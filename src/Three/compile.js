var DracoEncoderModule = function (DracoEncoderModule) {
  DracoEncoderModule = DracoEncoderModule || {};

  var Module = typeof DracoEncoderModule !== "undefined" ? DracoEncoderModule : {}; var isRuntimeInitialized = false; var isModuleParsed = false; Module["onRuntimeInitialized"] = (function () { isRuntimeInitialized = true; if (isModuleParsed) { if (typeof Module["onModuleLoaded"] === "function") { Module["onModuleLoaded"](Module) } } }); Module["onModuleParsed"] = (function () { isModuleParsed = true; if (isRuntimeInitialized) { if (typeof Module["onModuleLoaded"] === "function") { Module["onModuleLoaded"](Module) } } }); function isVersionSupported(versionString) { if (typeof versionString !== "string") return false; const version = versionString.split("."); if (version.length < 2 || version.length > 3) return false; if (version[0] == 1 && version[1] >= 0 && version[1] <= 3) return true; if (version[0] != 0 || version[1] > 10) return false; return true } Module["isVersionSupported"] = isVersionSupported; var moduleOverrides = {}; var key; for (key in Module) { if (Module.hasOwnProperty(key)) { moduleOverrides[key] = Module[key] } } Module["arguments"] = []; Module["thisProgram"] = "./this.program"; Module["quit"] = (function (status, toThrow) { throw toThrow }); Module["preRun"] = []; Module["postRun"] = []; var ENVIRONMENT_IS_WEB = false; var ENVIRONMENT_IS_WORKER = false; var ENVIRONMENT_IS_NODE = false; var ENVIRONMENT_IS_SHELL = false; if (Module["ENVIRONMENT"]) { if (Module["ENVIRONMENT"] === "WEB") { ENVIRONMENT_IS_WEB = true } else if (Module["ENVIRONMENT"] === "WORKER") { ENVIRONMENT_IS_WORKER = true } else if (Module["ENVIRONMENT"] === "NODE") { ENVIRONMENT_IS_NODE = true } else if (Module["ENVIRONMENT"] === "SHELL") { ENVIRONMENT_IS_SHELL = true } else { throw new Error("Module['ENVIRONMENT'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.") } } else { ENVIRONMENT_IS_WEB = typeof window === "object"; ENVIRONMENT_IS_WORKER = typeof importScripts === "function"; ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER; ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER } if (ENVIRONMENT_IS_NODE) { var nodeFS; var nodePath; Module["read"] = function shell_read(filename, binary) { var ret; ret = tryParseAsDataURI(filename); if (!ret) { if (!nodeFS) nodeFS = require("fs"); if (!nodePath) nodePath = require("path"); filename = nodePath["normalize"](filename); ret = nodeFS["readFileSync"](filename) } return binary ? ret : ret.toString() }; Module["readBinary"] = function readBinary(filename) { var ret = Module["read"](filename, true); if (!ret.buffer) { ret = new Uint8Array(ret) } assert(ret.buffer); return ret }; if (process["argv"].length > 1) { Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/") } Module["arguments"] = process["argv"].slice(2); process["on"]("uncaughtException", (function (ex) { if (!(ex instanceof ExitStatus)) { throw ex } })); process["on"]("unhandledRejection", (function (reason, p) { process["exit"](1) })); Module["inspect"] = (function () { return "[Emscripten Module object]" }) } else if (ENVIRONMENT_IS_SHELL) { if (typeof read != "undefined") { Module["read"] = function shell_read(f) { var data = tryParseAsDataURI(f); if (data) { return intArrayToString(data) } return read(f) } } Module["readBinary"] = function readBinary(f) { var data; data = tryParseAsDataURI(f); if (data) { return data } if (typeof readbuffer === "function") { return new Uint8Array(readbuffer(f)) } data = read(f, "binary"); assert(typeof data === "object"); return data }; if (typeof scriptArgs != "undefined") { Module["arguments"] = scriptArgs } else if (typeof arguments != "undefined") { Module["arguments"] = arguments } if (typeof quit === "function") { Module["quit"] = (function (status, toThrow) { quit(status) }) } } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { Module["read"] = function shell_read(url) { try { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.send(null); return xhr.responseText } catch (err) { var data = tryParseAsDataURI(url); if (data) { return intArrayToString(data) } throw err } }; if (ENVIRONMENT_IS_WORKER) { Module["readBinary"] = function readBinary(url) { try { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.responseType = "arraybuffer"; xhr.send(null); return new Uint8Array(xhr.response) } catch (err) { var data = tryParseAsDataURI(url); if (data) { return data } throw err } } } Module["readAsync"] = function readAsync(url, onload, onerror) { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.responseType = "arraybuffer"; xhr.onload = function xhr_onload() { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return } var data = tryParseAsDataURI(url); if (data) { onload(data.buffer); return } onerror() }; xhr.onerror = onerror; xhr.send(null) }; Module["setWindowTitle"] = (function (title) { document.title = title }) } Module["print"] = typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null; Module["printErr"] = typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || Module["print"]; Module.print = Module["print"]; Module.printErr = Module["printErr"]; for (key in moduleOverrides) { if (moduleOverrides.hasOwnProperty(key)) { Module[key] = moduleOverrides[key] } } moduleOverrides = undefined; var STACK_ALIGN = 16; function staticAlloc(size) { assert(!staticSealed); var ret = STATICTOP; STATICTOP = STATICTOP + size + 15 & -16; return ret } function dynamicAlloc(size) { assert(DYNAMICTOP_PTR); var ret = HEAP32[DYNAMICTOP_PTR >> 2]; var end = ret + size + 15 & -16; HEAP32[DYNAMICTOP_PTR >> 2] = end; if (end >= TOTAL_MEMORY) { var success = enlargeMemory(); if (!success) { HEAP32[DYNAMICTOP_PTR >> 2] = ret; return 0 } } return ret } function alignMemory(size, factor) { if (!factor) factor = STACK_ALIGN; var ret = size = Math.ceil(size / factor) * factor; return ret } function getNativeTypeSize(type) { switch (type) { case "i1": case "i8": return 1; case "i16": return 2; case "i32": return 4; case "i64": return 8; case "float": return 4; case "double": return 8; default: { if (type[type.length - 1] === "*") { return 4 } else if (type[0] === "i") { var bits = parseInt(type.substr(1)); assert(bits % 8 === 0); return bits / 8 } else { return 0 } } } } function warnOnce(text) { if (!warnOnce.shown) warnOnce.shown = {}; if (!warnOnce.shown[text]) { warnOnce.shown[text] = 1; Module.printErr(text) } } var jsCallStartIndex = 1; var functionPointers = new Array(0); var funcWrappers = {}; function dynCall(sig, ptr, args) { if (args && args.length) { return Module["dynCall_" + sig].apply(null, [ptr].concat(args)) } else { return Module["dynCall_" + sig].call(null, ptr) } } var GLOBAL_BASE = 8; var ABORT = 0; var EXITSTATUS = 0; function assert(condition, text) { if (!condition) { abort("Assertion failed: " + text) } } function getCFunc(ident) { var func = Module["_" + ident]; assert(func, "Cannot call unknown function " + ident + ", make sure it is exported"); return func } var JSfuncs = { "stackSave": (function () { stackSave() }), "stackRestore": (function () { stackRestore() }), "arrayToC": (function (arr) { var ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret }), "stringToC": (function (str) { var ret = 0; if (str !== null && str !== undefined && str !== 0) { var len = (str.length << 2) + 1; ret = stackAlloc(len); stringToUTF8(str, ret, len) } return ret }) }; var toC = { "string": JSfuncs["stringToC"], "array": JSfuncs["arrayToC"] }; function ccall(ident, returnType, argTypes, args, opts) { var func = getCFunc(ident); var cArgs = []; var stack = 0; if (args) { for (var i = 0; i < args.length; i++) { var converter = toC[argTypes[i]]; if (converter) { if (stack === 0) stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } var ret = func.apply(null, cArgs); if (returnType === "string") ret = Pointer_stringify(ret); if (returnType === "boolean") ret = Boolean(ret); if (stack !== 0) { stackRestore(stack) } return ret } function setValue(ptr, value, type, noSafe) { type = type || "i8"; if (type.charAt(type.length - 1) === "*") type = "i32"; switch (type) { case "i1": HEAP8[ptr >> 0] = value; break; case "i8": HEAP8[ptr >> 0] = value; break; case "i16": HEAP16[ptr >> 1] = value; break; case "i32": HEAP32[ptr >> 2] = value; break; case "i64": tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= +1 ? tempDouble > +0 ? (Math_min(+Math_floor(tempDouble / +4294967296), +4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / +4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1]; break; case "float": HEAPF32[ptr >> 2] = value; break; case "double": HEAPF64[ptr >> 3] = value; break; default: abort("invalid type for setValue: " + type) } } var ALLOC_STATIC = 2; var ALLOC_NONE = 4; function allocate(slab, types, allocator, ptr) { var zeroinit, size; if (typeof slab === "number") { zeroinit = true; size = slab } else { zeroinit = false; size = slab.length } var singleType = typeof types === "string" ? types : null; var ret; if (allocator == ALLOC_NONE) { ret = ptr } else { ret = [typeof _malloc === "function" ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length)) } if (zeroinit) { var stop; ptr = ret; assert((ret & 3) == 0); stop = ret + (size & ~3); for (; ptr < stop; ptr += 4) { HEAP32[ptr >> 2] = 0 } stop = ret + size; while (ptr < stop) { HEAP8[ptr++ >> 0] = 0 } return ret } if (singleType === "i8") { if (slab.subarray || slab.slice) { HEAPU8.set(slab, ret) } else { HEAPU8.set(new Uint8Array(slab), ret) } return ret } var i = 0, type, typeSize, previousType; while (i < size) { var curr = slab[i]; type = singleType || types[i]; if (type === 0) { i++; continue } if (type == "i64") type = "i32"; setValue(ret + i, curr, type); if (previousType !== type) { typeSize = getNativeTypeSize(type); previousType = type } i += typeSize } return ret } function Pointer_stringify(ptr, length) { if (length === 0 || !ptr) return ""; var hasUtf = 0; var t; var i = 0; while (1) { t = HEAPU8[ptr + i >> 0]; hasUtf |= t; if (t == 0 && !length) break; i++; if (length && i == length) break } if (!length) length = i; var ret = ""; if (hasUtf < 128) { var MAX_CHUNK = 1024; var curr; while (length > 0) { curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK))); ret = ret ? ret + curr : curr; ptr += MAX_CHUNK; length -= MAX_CHUNK } return ret } return UTF8ToString(ptr) } var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined; function UTF8ArrayToString(u8Array, idx) { var endPtr = idx; while (u8Array[endPtr]) ++endPtr; if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) { return UTF8Decoder.decode(u8Array.subarray(idx, endPtr)) } else { var u0, u1, u2, u3, u4, u5; var str = ""; while (1) { u0 = u8Array[idx++]; if (!u0) return str; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } u1 = u8Array[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } u2 = u8Array[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u3 = u8Array[idx++] & 63; if ((u0 & 248) == 240) { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3 } else { u4 = u8Array[idx++] & 63; if ((u0 & 252) == 248) { u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4 } else { u5 = u8Array[idx++] & 63; u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5 } } } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } } function UTF8ToString(ptr) { return UTF8ArrayToString(HEAPU8, ptr) } function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127) { if (outIdx >= endIdx) break; outU8Array[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; outU8Array[outIdx++] = 192 | u >> 6; outU8Array[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; outU8Array[outIdx++] = 224 | u >> 12; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } else if (u <= 2097151) { if (outIdx + 3 >= endIdx) break; outU8Array[outIdx++] = 240 | u >> 18; outU8Array[outIdx++] = 128 | u >> 12 & 63; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } else if (u <= 67108863) { if (outIdx + 4 >= endIdx) break; outU8Array[outIdx++] = 248 | u >> 24; outU8Array[outIdx++] = 128 | u >> 18 & 63; outU8Array[outIdx++] = 128 | u >> 12 & 63; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } else { if (outIdx + 5 >= endIdx) break; outU8Array[outIdx++] = 252 | u >> 30; outU8Array[outIdx++] = 128 | u >> 24 & 63; outU8Array[outIdx++] = 128 | u >> 18 & 63; outU8Array[outIdx++] = 128 | u >> 12 & 63; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } } outU8Array[outIdx] = 0; return outIdx - startIdx } function stringToUTF8(str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8(str) { var len = 0; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127) { ++len } else if (u <= 2047) { len += 2 } else if (u <= 65535) { len += 3 } else if (u <= 2097151) { len += 4 } else if (u <= 67108863) { len += 5 } else { len += 6 } } return len } var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined; function demangle(func) { return func } function demangleAll(text) { var regex = /__Z[\w\d_]+/g; return text.replace(regex, (function (x) { var y = demangle(x); return x === y ? x : x + " [" + y + "]" })) } function jsStackTrace() { var err = new Error; if (!err.stack) { try { throw new Error(0) } catch (e) { err = e } if (!err.stack) { return "(no stack trace available)" } } return err.stack.toString() } var WASM_PAGE_SIZE = 65536; var ASMJS_PAGE_SIZE = 16777216; var MIN_TOTAL_MEMORY = 16777216; function alignUp(x, multiple) { if (x % multiple > 0) { x += multiple - x % multiple } return x } var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBuffer(buf) { Module["buffer"] = buffer = buf } function updateGlobalBufferViews() { Module["HEAP8"] = HEAP8 = new Int8Array(buffer); Module["HEAP16"] = HEAP16 = new Int16Array(buffer); Module["HEAP32"] = HEAP32 = new Int32Array(buffer); Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer); Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer); Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer); Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer); Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer) } var STATIC_BASE, STATICTOP, staticSealed; var STACK_BASE, STACKTOP, STACK_MAX; var DYNAMIC_BASE, DYNAMICTOP_PTR; STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0; staticSealed = false; function abortOnCannotGrowMemory() { abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ") } if (!Module["reallocBuffer"]) Module["reallocBuffer"] = (function (size) { var ret; try { if (ArrayBuffer.transfer) { ret = ArrayBuffer.transfer(buffer, size) } else { var oldHEAP8 = HEAP8; ret = new ArrayBuffer(size); var temp = new Int8Array(ret); temp.set(oldHEAP8) } } catch (e) { return false } var success = _emscripten_replace_memory(ret); if (!success) return false; return ret }); function enlargeMemory() { var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; var LIMIT = 2147483648 - PAGE_MULTIPLE; if (HEAP32[DYNAMICTOP_PTR >> 2] > LIMIT) { return false } var OLD_TOTAL_MEMORY = TOTAL_MEMORY; TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY); while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR >> 2]) { if (TOTAL_MEMORY <= 536870912) { TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE) } else { TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT) } } var replacement = Module["reallocBuffer"](TOTAL_MEMORY); if (!replacement || replacement.byteLength != TOTAL_MEMORY) { TOTAL_MEMORY = OLD_TOTAL_MEMORY; return false } updateGlobalBuffer(replacement); updateGlobalBufferViews(); return true } var byteLength; try { byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get); byteLength(new ArrayBuffer(4)) } catch (e) { byteLength = (function (buffer) { return buffer.byteLength }) } var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880; var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216; if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")"); if (Module["buffer"]) { buffer = Module["buffer"] } else { { buffer = new ArrayBuffer(TOTAL_MEMORY) } Module["buffer"] = buffer } updateGlobalBufferViews(); function getTotalMemory() { return TOTAL_MEMORY } HEAP32[0] = 1668509029; HEAP16[1] = 25459; if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw "Runtime error: expected the system to be little-endian!"; function callRuntimeCallbacks(callbacks) { while (callbacks.length > 0) { var callback = callbacks.shift(); if (typeof callback == "function") { callback(); continue } var func = callback.func; if (typeof func === "number") { if (callback.arg === undefined) { Module["dynCall_v"](func) } else { Module["dynCall_vi"](func, callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } var __ATPRERUN__ = []; var __ATINIT__ = []; var __ATMAIN__ = []; var __ATEXIT__ = []; var __ATPOSTRUN__ = []; var runtimeInitialized = false; var runtimeExited = false; function preRun() { if (Module["preRun"]) { if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]]; while (Module["preRun"].length) { addOnPreRun(Module["preRun"].shift()) } } callRuntimeCallbacks(__ATPRERUN__) } function ensureInitRuntime() { if (runtimeInitialized) return; runtimeInitialized = true; callRuntimeCallbacks(__ATINIT__) } function preMain() { callRuntimeCallbacks(__ATMAIN__) } function exitRuntime() { callRuntimeCallbacks(__ATEXIT__); runtimeExited = true } function postRun() { if (Module["postRun"]) { if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]]; while (Module["postRun"].length) { addOnPostRun(Module["postRun"].shift()) } } callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb) } function addOnPreMain(cb) { __ATMAIN__.unshift(cb) } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb) } function writeArrayToMemory(array, buffer) { HEAP8.set(array, buffer) } function writeAsciiToMemory(str, buffer, dontAddNull) { for (var i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull) HEAP8[buffer >> 0] = 0 } var Math_abs = Math.abs; var Math_cos = Math.cos; var Math_sin = Math.sin; var Math_tan = Math.tan; var Math_acos = Math.acos; var Math_asin = Math.asin; var Math_atan = Math.atan; var Math_atan2 = Math.atan2; var Math_exp = Math.exp; var Math_log = Math.log; var Math_sqrt = Math.sqrt; var Math_ceil = Math.ceil; var Math_floor = Math.floor; var Math_pow = Math.pow; var Math_imul = Math.imul; var Math_fround = Math.fround; var Math_round = Math.round; var Math_min = Math.min; var Math_max = Math.max; var Math_clz32 = Math.clz32; var Math_trunc = Math.trunc; var runDependencies = 0; var runDependencyWatcher = null; var dependenciesFulfilled = null; function addRunDependency(id) { runDependencies++; if (Module["monitorRunDependencies"]) { Module["monitorRunDependencies"](runDependencies) } } function removeRunDependency(id) { runDependencies--; if (Module["monitorRunDependencies"]) { Module["monitorRunDependencies"](runDependencies) } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } Module["preloadedImages"] = {}; Module["preloadedAudios"] = {}; var memoryInitializer = null; var dataURIPrefix = "data:application/octet-stream;base64,"; function isDataURI(filename) { return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0 } STATIC_BASE = GLOBAL_BASE; STATICTOP = STATIC_BASE + 18640; __ATINIT__.push(); memoryInitializer = "data:application/octet-stream;base64,vBoAACwbAADkGgAAehsAACAAAAAAAAAAvBoAAKEbAADkGgAAvhsAACAAAAAAAAAAvBoAAOcbAADkGgAAAxwAADgAAAAAAAAAvBoAACUcAADkGgAAShwAADgAAAAAAAAA5BoAAI4mAABQAAAAAAAAAOQaAAB6HAAAiAAAAAAAAADkGgAA0xwAAJgAAAAAAAAA5BoAACcdAACoAAAAAAAAAOQaAABbHQAAuAAAAAAAAAC8GgAAhh0AAOQaAACqHQAA0AAAAAAAAAC8GgAASB4AAOQaAADmHgAA6AAAAAAAAADkGgAAfh8AAIgAAAAAAAAA5BoAAAcgAADoAAAAAAAAAOQaAAChIAAA6AAAAAAAAADkGgAARyEAAOgAAAAAAAAA5BoAAN0hAAA4AQAAAAAAALwaAACIIgAA5BoAADMjAABQAQAAAAAAAOQaAADYIwAAiAAAAAAAAADkGgAAbiQAAFABAAAAAAAA5BoAABUlAABQAQAAAAAAAOQaAADIJQAAUAEAAAAAAADkGgAAqDEAAGgAAAAAAAAA5BoAALomAACwAQAAAAAAAOQaAAArJwAAmAAAAAAAAADkGgAAlycAANABAAAAAAAAvBoAAE0oAADkGgAAAykAAOgBAAAAAAAA5BoAALMpAACwAQAAAAAAAOQaAABUKgAA6AEAAAAAAADkGgAABisAAOgBAAAAAAAA5BoAAMQrAADoAQAAAAAAAOQaAAByLAAAOAIAAAAAAAC8GgAANS0AAOQaAAD4LQAAUAIAAAAAAADkGgAAtS4AALABAAAAAAAA5BoAAGMvAABQAgAAAAAAAOQaAAAiMAAAUAIAAAAAAADkGgAA7TAAAFACAAAAAAAA5BoAANMxAABoAAAAAAAAAOQaAABJMgAACAAAAAAAAAC8GgAAFjIAAOQaAABcMgAAsAIAAAAAAADkGgAAbDMAAHgDAAAAAAAA5BoAAOE3AABgAwAAAAAAALwaAAAsNAAA5BoAAJM0AADoAgAAAAAAAOQaAAAANQAAEAMAAAAAAAC8GgAAizUAALwaAAClNQAA5BoAAP81AAAYAwAAAAAAAOQaAABfNgAAEAMAAAAAAADkGgAA3TYAABgDAAAAAAAA5BoAAEY3AAAQAwAAAAAAALwaAAAtOAAA5BoAAFs4AABgAwAAAAAAAOQaAADMOAAAqAMAAAAAAADkGgAAEjkAAHgDAAAAAAAA5BoAAPg4AAAQAwAAAAAAALwaAAAyOQAA5BoAAAc6AACoAwAAAAAAAOQaAAApOgAAqAMAAAAAAADkGgAATzoAAOADAAAAAAAAvBoAAKE6AAC8GgAA0EQAAOQaAAAwRQAAAAQAAAAAAADkGgAA3UQAABAEAAAAAAAAvBoAAP5EAADkGgAAC0UAAPADAAAAAAAA5BoAABJGAADoAwAAAAAAAOQaAAAiRgAAKAQAAAAAAADkGgAAV0YAAAAEAAAAAAAA5BoAADNGAABIBAAAAAAAAAAAAAAIAAAAAQAAAAIAAAAAAAAAEAAAAAMAAAAEAAAAAQAAAAEAAAABAAAAAAAAACgAAAAFAAAABgAAAAIAAAACAAAAAgAAAP//////////AAAAADgAAAAHAAAACAAAAAEAAAADAAAAAQAAAAQAAAAFAAAAAgAAAAYAAAAHAAAAAwAAAAEAAAAIAAAAAAAAAEAAAAAJAAAACgAAAAEAAAADAAAABAAAAAQAAAAFAAAAAgAAAAYAAAAHAAAABQAAAAkAAAAKAAAAAAAAAFAAAAALAAAADAAAAAMAAAALAAAADAAAAAQAAAANAAAABgAAAAcAAAAOAAAADwAAAAUAAAAAAAAAWAAAAA0AAAAOAAAABgAAABAAAAAIAAAAEQAAABIAAAAHAAAAEwAAABQAAAAJAAAAFQAAABYAAAAKAAAAAQAAAAAAAABoAAAADwAAABAAAAAIAAAACwAAABcAAAAEAAAADQAAAAYAAAALAAAADgAAAA8AAAAJAAAAAgAAAAoAAAD/////AAAAAIgAAAARAAAAEgAAAAEAAAAMAAAAAQAAAA0AAAAYAAAAGQAAAA4AAAAPAAAAGgAAAAEAAAAAAAAAeAAAABEAAAATAAAAEAAAAAwAAAARAAAADQAAABgAAAAZAAAADgAAAA8AAAAaAAAAAQAAAAAAAAAYAQAAEQAAABQAAAASAAAADAAAABMAAAANAAAAGAAAABkAAAAOAAAADwAAABoAAAACAAAAAAAAAPgAAAAVAAAAFgAAABQAAAAMAAAAFQAAABYAAAAbAAAAHAAAAA4AAAAPAAAAHQAAAAMAAAAAAAAA2AAAABcAAAAYAAAAFwAAAAwAAAAYAAAAGQAAAB4AAAAfAAAADgAAAA8AAAAgAAAABAAAAAAAAADAAAAAGQAAABoAAAAhAAAAGgAAAAMAAAAAAAAA6AAAABEAAAAbAAAAAQAAAAwAAAABAAAADQAAABgAAAAZAAAADgAAAA8AAAAaAAAAAQAAAAAAAAAIAQAAHAAAAB0AAAAbAAAADAAAABwAAAANAAAAGAAAABkAAAAOAAAADwAAACIAAAAFAAAAAAAAAIABAAARAAAAHgAAAB0AAAAMAAAAHgAAAA0AAAAYAAAAGQAAAA4AAAAPAAAAGgAAAAYAAAAAAAAAYAEAAB8AAAAgAAAAHwAAAAwAAAAgAAAAIQAAACMAAAAkAAAADgAAAA8AAAAlAAAABwAAAAAAAABAAQAAIQAAACIAAAAiAAAADAAAACMAAAAkAAAAJgAAACcAAAAOAAAADwAAACgAAAAIAAAAAAAAACgBAAAjAAAAJAAAACkAAAAlAAAABAAAAAAAAABQAQAAEQAAACUAAAABAAAADAAAAAEAAAANAAAAGAAAABkAAAAOAAAADwAAABoAAAABAAAAAAAAAHABAAAmAAAAJwAAACYAAAAMAAAAJwAAAA0AAAAYAAAAGQAAAA4AAAAPAAAAKgAAAAkAAAAAAAAAkAEAACgAAAApAAAACwAAAAsAAAAXAAAABAAAACsAAAAoAAAAKQAAAA4AAAAPAAAACQAAAAUAAAAMAAAAAAAAAKABAAAqAAAAKwAAACoAAAArAAAALAAAAC0AAAAsAAAALQAAAC4AAAAvAAAALgAAAAoAAAAAAAAAGAIAACoAAAAsAAAAMAAAACsAAAAxAAAALQAAACwAAAAtAAAALgAAAC8AAAAuAAAACwAAAAAAAAAIAgAALQAAAC4AAAAyAAAAKwAAADMAAAAtAAAALAAAAC0AAAAuAAAALwAAAC8AAAAMAAAAAAAAAPgBAAAvAAAAMAAAADQAAAArAAAANQAAADYAAAAwAAAAMQAAAC4AAAAvAAAAMgAAAA0AAAAAAAAA2AEAADEAAAAyAAAANwAAACsAAAA4AAAAOQAAADMAAAA0AAAALgAAAC8AAAA1AAAADgAAAAAAAADAAQAAMwAAADQAAAA2AAAAOgAAAAYAAAAAAAAAgAIAACoAAAA1AAAAOwAAACsAAAA8AAAALQAAACwAAAAtAAAALgAAAC8AAAAuAAAADwAAAAAAAABwAgAANgAAADcAAAA9AAAAKwAAAD4AAAAtAAAALAAAAC0AAAAuAAAALwAAADcAAAAQAAAAAAAAAGACAAA4AAAAOQAAAD8AAAArAAAAQAAAAEEAAAA4AAAAOQAAAC4AAAAvAAAAOgAAABEAAAAAAAAAQAIAADoAAAA7AAAAQgAAACsAAABDAAAARAAAADsAAAA8AAAALgAAAC8AAAA9AAAAEgAAAAAAAAAoAgAAPAAAAD0AAAA+AAAARQAAAAcAAAAAAAAAkAIAAD4AAAA/AAAADQAAAAsAAAAXAAAABAAAAD8AAABGAAAARwAAAA4AAAAPAAAACQAAAAIAAAAOAAAAAAAAAKACAAABAAAAQAAAAAEAAAACAAAAAAAAALACAABBAAAAQgAAAAAAAAC4AgAAQQAAAEMAAAAAAAAAyAIAAEQAAABFAAAASAAAAEkAAABKAAAASwAAAAMAAABMAAAATQAAAEAAAABBAAAATgAAAEYAAABPAAAAQgAAAEMAAAAEAAAARwAAAAAAAADYAgAASAAAAEkAAABEAAAARQAAAEYAAABHAAAASAAAAAUAAABQAAAASQAAAFEAAAABAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAwAASgAAAEsAAABKAAAAUgAAAAAAAADwAgAATAAAAE0AAAAIAAAAAAAAAOgCAABOAAAATwAAAAgAAAD/////AAAAADADAABQAAAAUQAAAEsAAABTAAAAAAAAACADAABSAAAAUwAAAAkAAAAAAAAAGAMAAFQAAABVAAAACQAAAAAAAABQAwAAVgAAAFcAAABMAAAAVAAAAAAAAABAAwAAWAAAAFkAAAAJAAAAAAAAAGgDAABaAAAAWwAAAE0AAABOAAAATwAAAFAAAABRAAAABgAAAFUAAABSAAAAVgAAAAAAAAABAAAABQAAAAIAAAAFAAAAAwAAAAUAAAAEAAAAAAAAAHgDAABcAAAAXQAAAEgAAAABAAAAVwAAAEsAAAADAAAATAAAAE0AAAABAAAAUwAAAE4AAAABAAAAWAAAAFQAAABVAAAAAQAAAAEAAAAAAAAAiAMAAFwAAABeAAAASAAAAFkAAABXAAAASwAAAAMAAABMAAAATQAAAFYAAABTAAAATgAAAF8AAABYAAAAVAAAAFUAAAAHAAAAYAAAAAAAAACYAwAAYQAAAGIAAABXAAAAWgAAAAAAAACoAwAAXAAAAGMAAABbAAAAAQAAAFcAAABLAAAACAAAAEwAAABNAAAAAQAAAFMAAABOAAAAAQAAAAAAAACwAwAAXAAAAGQAAABbAAAAXAAAAFcAAABLAAAACQAAAEwAAABNAAAAWAAAAFMAAABOAAAAZQAAAAAAAADAAwAAXAAAAGYAAABbAAAAXQAAAFcAAABLAAAACgAAAEwAAABNAAAAWQAAAFMAAABOAAAAZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAFZVVVUCAAAAAAAAAAIAAACamZmZAwAAAFZVVVUDAAAAJUmSJAMAAAAAAAAAAwAAAMhxHMcEAAAAmpmZmQQAAABGF110BAAAAFZVVVUEAAAAPLETOwQAAAAlSZIkBAAAABIREREEAAAAAAAAAAQAAADi4eHhBQAAAMhxHMcFAAAAy2sorwUAAACamZmZBQAAAIdhGIYFAAAARhdddAUAAACRhSxkBQAAAFZVVVUFAAAAexSuRwUAAAA8sRM7BQAAANtLaC8FAAAAJUmSJAUAAAASlnsaBQAAABIREREFAAAAhRBCCAUAAAAAAAAABQAAAAgffPAGAAAA4uHh4QYAAADVQR3UBgAAAMhxHMcGAAAATZHPugYAAADLayivBgAAAKVBGqQGAAAAmpmZmQYAAAD6GJyPBgAAAIdhGIYGAAAAGPQFfQYAAABGF110BgAAAG3BFmwGAAAAkYUsZAYAAAC6gphcBgAAAFZVVVUGAAAAcwpeTgYAAAB7FK5HBgAAAEJBQUEGAAAAPLETOwYAAACzzyE1BgAAANtLaC8GAAAAnxLkKQYAAAAlSZIkBgAAAN1HcB8GAAAAEpZ7GgYAAAD45bEVBgAAABIREREGAAAA/BSXDAYAAACFEEIIBgAAAAVBEAQGAAAAAAAAAAYAAAD5gR/4BwAAAAgffPAHAAAAwBoT6QcAAADi4eHhBwAAAGwH5toHAAAA1UEd1AcAAACRaIXNBwAAAMhxHMcHAAAAOXDgwAcAAABNkc+6BwAAAE8b6LQHAAAAy2sorwcAAAAH9o6pBwAAAKVBGqQHAAAAUunIngcAAACamZmZBwAAAM4Pi5QHAAAA+hicjwcAAAD3kMuKBwAAAIdhGIYHAAAAgoGBgQcAAAAY9AV9BwAAABjIpHgHAAAARhdddAcAAADBBS5wBwAAAG3BFmwHAAAAaYEWaAcAAACRhSxkBwAAAAYWWGAHAAAAuoKYXAcAAAAJI+1YBwAAAFZVVVUHAAAAr37QUQcAAABzCl5OBwAAAAZq/UoHAAAAexSuRwcAAABXhm9EBwAAAEJBQUEHAAAAz8siPgcAAAA8sRM7BwAAADmBEzgHAAAAs88hNQcAAACjND4yBwAAANtLaC8HAAAA2bSfLAcAAACfEuQpBwAAAIkLNScHAAAAJUmSJAcAAAATePshBwAAAN1HcB8HAAAA22rwHAcAAAASlnsaBwAAABmBERgHAAAA+OWxFQcAAAAUgVwTBwAAABIREREHAAAAv1bPDgcAAAD8FJcMBwAAAKcQaAoHAAAAhRBCCAcAAAAw3SQGBwAAAAVBEAQHAAAAEQgEAgcAAAAAAAAABwAAACDwB/wIAAAA+YEf+AgAAADlWUb0CAAAAAgffPAIAAAAMXvA7AgAAADAGhPpCAAAAJGsc+UIAAAA4uHh4QgAAABAbl3eCAAAAGwH5toIAAAATGV71wgAAADVQR3UCAAAAPdYy9AIAAAAkWiFzQgAAABWMEvKCAAAAMhxHMcIAAAAHfD4wwgAAAA5cODACAAAAJq40r0IAAAATZHPuggAAADew9a3CAAAAE8b6LQIAAAAB2QDsggAAADLayivCAAAAK0BV6wIAAAAB/aOqQgAAABuGtCmCAAAAKVBGqQIAAAAmD9toQgAAABS6cieCAAAAO8ULZwIAAAAmpmZmQgAAACBTw6XCAAAAM4Pi5QIAAAAnrQPkggAAAD6GJyPCAAAANQYMI0IAAAA95DLiggAAAALX26ICAAAAIdhGIYIAAAArHfJgwgAAACCgYGBCAAAANFfQH8IAAAAGPQFfQgAAACPINJ6CAAAABjIpHgIAAAARM59dggAAABGF110CAAAAPWHQnIIAAAAwQUucAgAAAC1dh9uCAAAAG3BFmwIAAAAFs0TaggAAABpgRZoCAAAAKbGHmYIAAAAkYUsZAgAAABxpz9iCAAAAAYWWGAIAAAAjrt1XggAAAC6gphcCAAAALFWwFoIAAAACSPtWAgAAADG0x5XCAAAAFZVVVUIAAAAkJSQUwgAAACvftBRCAAAAFEBFVAIAAAAcwpeTggAAABziKtMCAAAAAZq/UoIAAAAPJ5TSQgAAAB7FK5HCAAAAIC8DEYIAAAAV4ZvRAgAAABeYtZCCAAAAEJBQUEIAAAA/BOwPwgAAADPyyI+CAAAAEhamTwIAAAAPLETOwgAAADCwpE5CAAAADmBEzgIAAAAPt+YNggAAACzzyE1CAAAALZFrjMIAAAAozQ+MggAAAAUkNEwCAAAANtLaC8IAAAABVwCLggAAADZtJ8sCAAAANFKQCsIAAAAnxLkKQgAAAApAYsoCAAAAIkLNScIAAAACSfiJQgAAAAlSZIkCAAAAIpnRSMIAAAAE3j7IQgAAADHcLQgCAAAAN1HcB8IAAAAtPMuHggAAADbavAcCAAAAAWktBsIAAAAEpZ7GggAAAAJOEUZCAAAABmBERgIAAAAlWjgFggAAAD45bEVCAAAAOHwhRQIAAAAFIFcEwgAAAB2jjUSCAAAABIREREIAAAAEAHvDwgAAAC/Vs8OCAAAAIkKsg0IAAAA/BSXDAgAAADDbn4LCAAAAKcQaAoIAAAAkfNTCQgAAACFEEIICAAAAKVgMgcIAAAAMN0kBggAAAB+fxkFCAAAAAVBEAQIAAAAUhsJAwgAAAARCAQCCAAAAAIBAQEIAAAA/////wAAAADQAwAAaAAAAGkAAAAKAAAACwAAAF4AAABqAAAACwAAAP////8AAAAA4AMAAGsAAABsAAAADAAAAAwAAABeAAAAagAAAA0AAAD/////HBcAAAUAAAAAAAAAAAAAAF8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAQAAAAyEgAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAP//////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJxIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFX3CJAP8JLw8AAAAAAgAAAAMAAAAFAAAABwAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAfwAAAIMAAACJAAAAiwAAAJUAAACXAAAAnQAAAKMAAACnAAAArQAAALMAAAC1AAAAvwAAAMEAAADFAAAAxwAAANMAAAABAAAACwAAAA0AAAARAAAAEwAAABcAAAAdAAAAHwAAACUAAAApAAAAKwAAAC8AAAA1AAAAOwAAAD0AAABDAAAARwAAAEkAAABPAAAAUwAAAFkAAABhAAAAZQAAAGcAAABrAAAAbQAAAHEAAAB5AAAAfwAAAIMAAACJAAAAiwAAAI8AAACVAAAAlwAAAJ0AAACjAAAApwAAAKkAAACtAAAAswAAALUAAAC7AAAAvwAAAMEAAADFAAAAxwAAANEAAAACAAAAAAAAAPADAABtAAAAbgAAAG8AAABwAAAAEgAAAAEAAAABAAAAAwAAAAAAAAAYBAAAbQAAAHEAAABvAAAAcAAAABIAAAACAAAAAgAAAAQAAAAAAAAAKAQAAHIAAABzAAAAYAAAAAAAAAA4BAAAcgAAAHQAAABgAAAATjVkcmFjbzExRW5jb2RlckJhc2VJTlNfMThFbmNvZGVyT3B0aW9uc0Jhc2VJTlNfMTdHZW9tZXRyeUF0dHJpYnV0ZTRUeXBlRUVFRUUATjVkcmFjbzI4QXR0cmlidXRlT2N0YWhlZHJvblRyYW5zZm9ybUUATjVkcmFjbzE4QXR0cmlidXRlVHJhbnNmb3JtRQBONWRyYWNvMzBBdHRyaWJ1dGVRdWFudGl6YXRpb25UcmFuc2Zvcm1FAE41ZHJhY28xN0F0dHJpYnV0ZXNFbmNvZGVyRQBONWRyYWNvMjNLZFRyZWVBdHRyaWJ1dGVzRW5jb2RlckUATjVkcmFjbzI2U2VxdWVudGlhbEF0dHJpYnV0ZUVuY29kZXJFAE41ZHJhY28zN1NlcXVlbnRpYWxBdHRyaWJ1dGVFbmNvZGVyc0NvbnRyb2xsZXJFAE41ZHJhY28yOFByZWRpY3Rpb25TY2hlbWVEZWx0YUVuY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFRUUATjVkcmFjbzIzUHJlZGljdGlvblNjaGVtZUVuY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFRUUATjVkcmFjbzM3UHJlZGljdGlvblNjaGVtZVR5cGVkRW5jb2RlckludGVyZmFjZUlpaUVFAE41ZHJhY28zMlByZWRpY3Rpb25TY2hlbWVFbmNvZGVySW50ZXJmYWNlRQBONWRyYWNvMjVQcmVkaWN0aW9uU2NoZW1lSW50ZXJmYWNlRQBONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckFyZWFJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQmFzZUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcEVuY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxFbmNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZUVuY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280NE1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzUG9ydGFibGVFbmNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcEVuY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQwTWVzaFByZWRpY3Rpb25TY2hlbWVQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcEVuY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JBcmVhSWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxFbmNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzI3TWVzaFByZWRpY3Rpb25TY2hlbWVFbmNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRW5jb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ0TWVzaFByZWRpY3Rpb25TY2hlbWVUZXhDb29yZHNQb3J0YWJsZUVuY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcEVuY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280ME1lc2hQcmVkaWN0aW9uU2NoZW1lUGFyYWxsZWxvZ3JhbUVuY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBFbmNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQB1c2VfYnVpbHRfaW5fYXR0cmlidXRlX2NvbXByZXNzaW9uAE41ZHJhY28zM1NlcXVlbnRpYWxJbnRlZ2VyQXR0cmlidXRlRW5jb2RlckUATjVkcmFjbzI4UHJlZGljdGlvblNjaGVtZURlbHRhRW5jb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVFRQBONWRyYWNvMjNQcmVkaWN0aW9uU2NoZW1lRW5jb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVFRQBONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckFyZWFJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRW5jb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQmFzZUlpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxFbmNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZUVuY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRW5jb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280NE1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzUG9ydGFibGVFbmNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQwTWVzaFByZWRpY3Rpb25TY2hlbWVQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JBcmVhSWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxFbmNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzI3TWVzaFByZWRpY3Rpb25TY2hlbWVFbmNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZEVuY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ0TWVzaFByZWRpY3Rpb25TY2hlbWVUZXhDb29yZHNQb3J0YWJsZUVuY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRW5jb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRW5jb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWRFbmNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280ME1lc2hQcmVkaWN0aW9uU2NoZW1lUGFyYWxsZWxvZ3JhbUVuY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRW5jb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMzJTZXF1ZW50aWFsTm9ybWFsQXR0cmlidXRlRW5jb2RlckUATjVkcmFjbzM4U2VxdWVudGlhbFF1YW50aXphdGlvbkF0dHJpYnV0ZUVuY29kZXJFAHByZWRpY3Rpb25fc2NoZW1lAE41ZHJhY28xMUVuY29kZXJCYXNlSU5TXzE4RW5jb2Rlck9wdGlvbnNCYXNlSWlFRUVFAE41ZHJhY283RW5jb2RlckUAIABONWRyYWNvMTNFeHBlcnRFbmNvZGVyRQBlbmNvZGluZ19tZXRob2QAcXVhbnRpemF0aW9uX2JpdHMASW52YWxpZCBlbmNvZGluZyBtZXRob2QuAGVuY29kaW5nX3NwZWVkAGRlY29kaW5nX3NwZWVkAHF1YW50aXphdGlvbl9vcmlnaW4AcXVhbnRpemF0aW9uX3JhbmdlAHN5bWJvbF9lbmNvZGluZ19tZXRob2QAc3ltYm9sX2VuY29kaW5nX2NvbXByZXNzaW9uX2xldmVsAHN0YW5kYXJkX2VkZ2VicmVha2VyAHByZWRpY3RpdmVfZWRnZWJyZWFrZXIAZWRnZWJyZWFrZXJfbWV0aG9kAE41ZHJhY28yMk1lc2hFZGdlYnJlYWtlckVuY29kZXJFAEFsbCB0cmlhbmdsZXMgYXJlIGRlZ2VuZXJhdGUuAEZhaWxlZCB0byBwcm9jZXNzIG1lc2ggaG9sZXMuAEZhaWxlZCB0byBpbml0aWFsaXplIGF0dHJpYnV0ZSBkYXRhLgBGYWlsZWQgdG8gZW5jb2RlIG1lc2ggY29tcG9uZW50LgBGYWlsZWQgdG8gZW5jb2RlIHNwbGl0IGRhdGEuAE41ZHJhY28xM1RyYXZlcnNlckJhc2VJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQBONWRyYWNvMTlEZXB0aEZpcnN0VHJhdmVyc2VySU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUATjVkcmFjbzIyTWVzaFRyYXZlcnNhbFNlcXVlbmNlcklOU18xOURlcHRoRmlyc3RUcmF2ZXJzZXJJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzJfRUVFRUVFAE41ZHJhY28xNVBvaW50c1NlcXVlbmNlckUATjVkcmFjbzEzVHJhdmVyc2VyQmFzZUlOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUATjVkcmFjbzE5RGVwdGhGaXJzdFRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUATjVkcmFjbzIyTWVzaFRyYXZlcnNhbFNlcXVlbmNlcklOU18xOURlcHRoRmlyc3RUcmF2ZXJzZXJJTlNfMTFDb3JuZXJUYWJsZUVOU18zNk1lc2hBdHRyaWJ1dGVJbmRpY2VzRW5jb2RpbmdPYnNlcnZlcklTMl9FRUVFRUUATjVkcmFjbzI4TWF4UHJlZGljdGlvbkRlZ3JlZVRyYXZlcnNlcklOU18xMUNvcm5lclRhYmxlRU5TXzM2TWVzaEF0dHJpYnV0ZUluZGljZXNFbmNvZGluZ09ic2VydmVySVMxX0VFRUUATjVkcmFjbzIyTWVzaFRyYXZlcnNhbFNlcXVlbmNlcklOU18yOE1heFByZWRpY3Rpb25EZWdyZWVUcmF2ZXJzZXJJTlNfMTFDb3JuZXJUYWJsZUVOU18zNk1lc2hBdHRyaWJ1dGVJbmRpY2VzRW5jb2RpbmdPYnNlcnZlcklTMl9FRUVFRUUAc3BsaXRfbWVzaF9vbl9zZWFtcwBONWRyYWNvMjZNZXNoRWRnZWJyZWFrZXJFbmNvZGVySW1wbElOU18zMU1lc2hFZGdlYnJlYWtlclRyYXZlcnNhbEVuY29kZXJFRUUATjVkcmFjbzM1TWVzaEVkZ2VicmVha2VyRW5jb2RlckltcGxJbnRlcmZhY2VFAE41ZHJhY28yNk1lc2hFZGdlYnJlYWtlckVuY29kZXJJbXBsSU5TXzM4TWVzaEVkZ2VicmVha2VyVHJhdmVyc2FsVmFsZW5jZUVuY29kZXJFRUUAc3RvcmVfbnVtYmVyX29mX2VuY29kZWRfZmFjZXMATjVkcmFjbzExTWVzaEVuY29kZXJFAGNvbXByZXNzX2Nvbm5lY3Rpdml0eQBONWRyYWNvMTVMaW5lYXJTZXF1ZW5jZXJFAE41ZHJhY28yMU1lc2hTZXF1ZW50aWFsRW5jb2RlckUATjVkcmFjbzE3UG9pbnRDbG91ZEVuY29kZXJFAEludmFsaWQgaW5wdXQgZ2VvbWV0cnkuAEZhaWxlZCB0byBpbml0aWFsaXplIGVuY29kZXIuAEZhaWxlZCB0byBlbmNvZGUgaW50ZXJuYWwgZGF0YS4ARmFpbGVkIHRvIGVuY29kZSBwb2ludCBhdHRyaWJ1dGVzLgBzdG9yZV9udW1iZXJfb2ZfZW5jb2RlZF9wb2ludHMARmFpbGVkIHRvIGVuY29kZSBtZXRhZGF0YS4ARFJBQ08ATjVkcmFjbzIzUG9pbnRDbG91ZEtkVHJlZUVuY29kZXJFAE41ZHJhY28yN1BvaW50Q2xvdWRTZXF1ZW50aWFsRW5jb2RlckUATjVkcmFjbzRNZXNoRQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAE41ZHJhY28xMFBvaW50Q2xvdWRFABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAwAAAAACQwAAAAAAAwAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAADQAAAAQNAAAAAAkOAAAAAAAOAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAEhISAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAACgAAAAAKAAAAAAkLAAAAAAALAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBOQU4AMDEyMzQ1Njc4OUFCQ0RFRi4AVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAABpbmZpbml0eQBuYW4AJWQAJWYAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlczogJXMAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0aW5nAHVuY2F1Z2h0AFN0OWV4Y2VwdGlvbgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBwdGhyZWFkX29uY2UgZmFpbHVyZSBpbiBfX2N4YV9nZXRfZ2xvYmFsc19mYXN0KCkAY2Fubm90IGNyZWF0ZSBwdGhyZWFkIGtleSBmb3IgX19jeGFfZ2V0X2dsb2JhbHMoKQBjYW5ub3QgemVybyBvdXQgdGhyZWFkIHZhbHVlIGZvciBfX2N4YV9nZXRfZ2xvYmFscygpAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0U="; var tempDoublePtr = STATICTOP; STATICTOP += 16; function ___cxa_allocate_exception(size) { return _malloc(size) } function __ZSt18uncaught_exceptionv() { return !!__ZSt18uncaught_exceptionv.uncaught_exception } var EXCEPTIONS = { last: 0, caught: [], infos: {}, deAdjust: (function (adjusted) { if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted; for (var ptr in EXCEPTIONS.infos) { var info = EXCEPTIONS.infos[ptr]; if (info.adjusted === adjusted) { return ptr } } return adjusted }), addRef: (function (ptr) { if (!ptr) return; var info = EXCEPTIONS.infos[ptr]; info.refcount++ }), decRef: (function (ptr) { if (!ptr) return; var info = EXCEPTIONS.infos[ptr]; assert(info.refcount > 0); info.refcount--; if (info.refcount === 0 && !info.rethrown) { if (info.destructor) { Module["dynCall_vi"](info.destructor, ptr) } delete EXCEPTIONS.infos[ptr]; ___cxa_free_exception(ptr) } }), clearRef: (function (ptr) { if (!ptr) return; var info = EXCEPTIONS.infos[ptr]; info.refcount = 0 }) }; function ___cxa_begin_catch(ptr) { var info = EXCEPTIONS.infos[ptr]; if (info && !info.caught) { info.caught = true; __ZSt18uncaught_exceptionv.uncaught_exception-- } if (info) info.rethrown = false; EXCEPTIONS.caught.push(ptr); EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr)); return ptr } function ___cxa_pure_virtual() { ABORT = true; throw "Pure virtual function called!" } function ___resumeException(ptr) { if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr } throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch." } function ___cxa_find_matching_catch() { var thrown = EXCEPTIONS.last; if (!thrown) { return (setTempRet0(0), 0) | 0 } var info = EXCEPTIONS.infos[thrown]; var throwntype = info.type; if (!throwntype) { return (setTempRet0(0), thrown) | 0 } var typeArray = Array.prototype.slice.call(arguments); var pointer = Module["___cxa_is_pointer_type"](throwntype); if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4); HEAP32[___cxa_find_matching_catch.buffer >> 2] = thrown; thrown = ___cxa_find_matching_catch.buffer; for (var i = 0; i < typeArray.length; i++) { if (typeArray[i] && Module["___cxa_can_catch"](typeArray[i], throwntype, thrown)) { thrown = HEAP32[thrown >> 2]; info.adjusted = thrown; return (setTempRet0(typeArray[i]), thrown) | 0 } } thrown = HEAP32[thrown >> 2]; return (setTempRet0(throwntype), thrown) | 0 } function ___cxa_throw(ptr, type, destructor) { EXCEPTIONS.infos[ptr] = { ptr: ptr, adjusted: ptr, type: type, destructor: destructor, refcount: 0, caught: false, rethrown: false }; EXCEPTIONS.last = ptr; if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) { __ZSt18uncaught_exceptionv.uncaught_exception = 1 } else { __ZSt18uncaught_exceptionv.uncaught_exception++ } throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch." } var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], "i8", ALLOC_STATIC); function ___gxx_personality_v0() { } var SYSCALLS = { varargs: 0, get: (function (varargs) { SYSCALLS.varargs += 4; var ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }), getStr: (function () { var ret = Pointer_stringify(SYSCALLS.get()); return ret }), get64: (function () { var low = SYSCALLS.get(), high = SYSCALLS.get(); if (low >= 0) assert(high === 0); else assert(high === -1); return low }), getZero: (function () { assert(SYSCALLS.get() === 0) }) }; function ___syscall140(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get(); var offset = offset_low; FS.llseek(stream, offset, whence); HEAP32[result >> 2] = stream.position; if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function flush_NO_FILESYSTEM() { var fflush = Module["_fflush"]; if (fflush) fflush(0); var printChar = ___syscall146.printChar; if (!printChar) return; var buffers = ___syscall146.buffers; if (buffers[1].length) printChar(1, 10); if (buffers[2].length) printChar(2, 10) } function ___syscall146(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get(); var ret = 0; if (!___syscall146.buffers) { ___syscall146.buffers = [null, [], []]; ___syscall146.printChar = (function (stream, curr) { var buffer = ___syscall146.buffers[stream]; assert(buffer); if (curr === 0 || curr === 10) { (stream === 1 ? Module["print"] : Module["printErr"])(UTF8ArrayToString(buffer, 0)); buffer.length = 0 } else { buffer.push(curr) } }) } for (var i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + i * 8 >> 2]; var len = HEAP32[iov + (i * 8 + 4) >> 2]; for (var j = 0; j < len; j++) { ___syscall146.printChar(stream, HEAPU8[ptr + j]) } ret += len } return ret } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function ___syscall6(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); FS.close(stream); return 0 } catch (e) { if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e); return -e.errno } } function _abort() { Module["abort"]() } var _llvm_ceil_f64 = Math_ceil; var _llvm_fabs_f64 = Math_abs; var _llvm_floor_f64 = Math_floor; function _llvm_trap() { abort("trap!") } function _emscripten_memcpy_big(dest, src, num) { HEAPU8.set(HEAPU8.subarray(src, src + num), dest); return dest } var PTHREAD_SPECIFIC = {}; function _pthread_getspecific(key) { return PTHREAD_SPECIFIC[key] || 0 } var PTHREAD_SPECIFIC_NEXT_KEY = 1; var ERRNO_CODES = { EPERM: 1, ENOENT: 2, ESRCH: 3, EINTR: 4, EIO: 5, ENXIO: 6, E2BIG: 7, ENOEXEC: 8, EBADF: 9, ECHILD: 10, EAGAIN: 11, EWOULDBLOCK: 11, ENOMEM: 12, EACCES: 13, EFAULT: 14, ENOTBLK: 15, EBUSY: 16, EEXIST: 17, EXDEV: 18, ENODEV: 19, ENOTDIR: 20, EISDIR: 21, EINVAL: 22, ENFILE: 23, EMFILE: 24, ENOTTY: 25, ETXTBSY: 26, EFBIG: 27, ENOSPC: 28, ESPIPE: 29, EROFS: 30, EMLINK: 31, EPIPE: 32, EDOM: 33, ERANGE: 34, ENOMSG: 42, EIDRM: 43, ECHRNG: 44, EL2NSYNC: 45, EL3HLT: 46, EL3RST: 47, ELNRNG: 48, EUNATCH: 49, ENOCSI: 50, EL2HLT: 51, EDEADLK: 35, ENOLCK: 37, EBADE: 52, EBADR: 53, EXFULL: 54, ENOANO: 55, EBADRQC: 56, EBADSLT: 57, EDEADLOCK: 35, EBFONT: 59, ENOSTR: 60, ENODATA: 61, ETIME: 62, ENOSR: 63, ENONET: 64, ENOPKG: 65, EREMOTE: 66, ENOLINK: 67, EADV: 68, ESRMNT: 69, ECOMM: 70, EPROTO: 71, EMULTIHOP: 72, EDOTDOT: 73, EBADMSG: 74, ENOTUNIQ: 76, EBADFD: 77, EREMCHG: 78, ELIBACC: 79, ELIBBAD: 80, ELIBSCN: 81, ELIBMAX: 82, ELIBEXEC: 83, ENOSYS: 38, ENOTEMPTY: 39, ENAMETOOLONG: 36, ELOOP: 40, EOPNOTSUPP: 95, EPFNOSUPPORT: 96, ECONNRESET: 104, ENOBUFS: 105, EAFNOSUPPORT: 97, EPROTOTYPE: 91, ENOTSOCK: 88, ENOPROTOOPT: 92, ESHUTDOWN: 108, ECONNREFUSED: 111, EADDRINUSE: 98, ECONNABORTED: 103, ENETUNREACH: 101, ENETDOWN: 100, ETIMEDOUT: 110, EHOSTDOWN: 112, EHOSTUNREACH: 113, EINPROGRESS: 115, EALREADY: 114, EDESTADDRREQ: 89, EMSGSIZE: 90, EPROTONOSUPPORT: 93, ESOCKTNOSUPPORT: 94, EADDRNOTAVAIL: 99, ENETRESET: 102, EISCONN: 106, ENOTCONN: 107, ETOOMANYREFS: 109, EUSERS: 87, EDQUOT: 122, ESTALE: 116, ENOTSUP: 95, ENOMEDIUM: 123, EILSEQ: 84, EOVERFLOW: 75, ECANCELED: 125, ENOTRECOVERABLE: 131, EOWNERDEAD: 130, ESTRPIPE: 86 }; function _pthread_key_create(key, destructor) { if (key == 0) { return ERRNO_CODES.EINVAL } HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY; PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0; PTHREAD_SPECIFIC_NEXT_KEY++; return 0 } function _pthread_once(ptr, func) { if (!_pthread_once.seen) _pthread_once.seen = {}; if (ptr in _pthread_once.seen) return; Module["dynCall_v"](func); _pthread_once.seen[ptr] = 1 } function _pthread_setspecific(key, value) { if (!(key in PTHREAD_SPECIFIC)) { return ERRNO_CODES.EINVAL } PTHREAD_SPECIFIC[key] = value; return 0 } function ___setErrNo(value) { if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value; return value } DYNAMICTOP_PTR = staticAlloc(4); STACK_BASE = STACKTOP = alignMemory(STATICTOP); STACK_MAX = STACK_BASE + TOTAL_STACK; DYNAMIC_BASE = alignMemory(STACK_MAX); HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; staticSealed = true; var ASSERTIONS = false; function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull) u8array.length = numBytesWritten; return u8array } function intArrayToString(array) { var ret = []; for (var i = 0; i < array.length; i++) { var chr = array[i]; if (chr > 255) { if (ASSERTIONS) { assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.") } chr &= 255 } ret.push(String.fromCharCode(chr)) } return ret.join("") } var decodeBase64 = typeof atob === "function" ? atob : (function (input) { var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; var output = ""; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""); do { enc1 = keyStr.indexOf(input.charAt(i++)); enc2 = keyStr.indexOf(input.charAt(i++)); enc3 = keyStr.indexOf(input.charAt(i++)); enc4 = keyStr.indexOf(input.charAt(i++)); chr1 = enc1 << 2 | enc2 >> 4; chr2 = (enc2 & 15) << 4 | enc3 >> 2; chr3 = (enc3 & 3) << 6 | enc4; output = output + String.fromCharCode(chr1); if (enc3 !== 64) { output = output + String.fromCharCode(chr2) } if (enc4 !== 64) { output = output + String.fromCharCode(chr3) } } while (i < input.length); return output }); function intArrayFromBase64(s) { if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) { var buf; try { buf = Buffer.from(s, "base64") } catch (_) { buf = new Buffer(s, "base64") } return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) } try { var decoded = decodeBase64(s); var bytes = new Uint8Array(decoded.length); for (var i = 0; i < decoded.length; ++i) { bytes[i] = decoded.charCodeAt(i) } return bytes } catch (_) { throw new Error("Converting base64 string to bytes failed.") } } function tryParseAsDataURI(filename) { if (!isDataURI(filename)) { return } return intArrayFromBase64(filename.slice(dataURIPrefix.length)) } function invoke_ii(index, a1) { try { return Module["dynCall_ii"](index, a1) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_iii(index, a1, a2) { try { return Module["dynCall_iii"](index, a1, a2) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_iiii(index, a1, a2, a3) { try { return Module["dynCall_iiii"](index, a1, a2, a3) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) { try { return Module["dynCall_iiiiiii"](index, a1, a2, a3, a4, a5, a6) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_v(index) { try { Module["dynCall_v"](index) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_vi(index, a1) { try { Module["dynCall_vi"](index, a1) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_vii(index, a1, a2) { try { Module["dynCall_vii"](index, a1, a2) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_viii(index, a1, a2, a3) { try { Module["dynCall_viii"](index, a1, a2, a3) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_viiii(index, a1, a2, a3, a4) { try { Module["dynCall_viiii"](index, a1, a2, a3, a4) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_viiiii(index, a1, a2, a3, a4, a5) { try { Module["dynCall_viiiii"](index, a1, a2, a3, a4, a5) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) { try { Module["dynCall_viiiiii"](index, a1, a2, a3, a4, a5, a6) } catch (e) { if (typeof e !== "number" && e !== "longjmp") throw e; Module["setThrew"](1, 0) } } Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity, "byteLength": byteLength }; Module.asmLibraryArg = { "abort": abort, "assert": assert, "enlargeMemory": enlargeMemory, "getTotalMemory": getTotalMemory, "abortOnCannotGrowMemory": abortOnCannotGrowMemory, "invoke_ii": invoke_ii, "invoke_iii": invoke_iii, "invoke_iiii": invoke_iiii, "invoke_iiiiiii": invoke_iiiiiii, "invoke_v": invoke_v, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_viii": invoke_viii, "invoke_viiii": invoke_viiii, "invoke_viiiii": invoke_viiiii, "invoke_viiiiii": invoke_viiiiii, "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv, "___cxa_allocate_exception": ___cxa_allocate_exception, "___cxa_begin_catch": ___cxa_begin_catch, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "___cxa_pure_virtual": ___cxa_pure_virtual, "___cxa_throw": ___cxa_throw, "___gxx_personality_v0": ___gxx_personality_v0, "___resumeException": ___resumeException, "___setErrNo": ___setErrNo, "___syscall140": ___syscall140, "___syscall146": ___syscall146, "___syscall6": ___syscall6, "_abort": _abort, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_llvm_ceil_f64": _llvm_ceil_f64, "_llvm_fabs_f64": _llvm_fabs_f64, "_llvm_floor_f64": _llvm_floor_f64, "_llvm_trap": _llvm_trap, "_pthread_getspecific": _pthread_getspecific, "_pthread_key_create": _pthread_key_create, "_pthread_once": _pthread_once, "_pthread_setspecific": _pthread_setspecific, "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM, "DYNAMICTOP_PTR": DYNAMICTOP_PTR, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "cttz_i8": cttz_i8 };// EMSCRIPTEN_START_ASM
  var asm = (/** @suppress {uselessCode} */ function (global, env, buffer) {
    "almost asm"; var a = global.Int8Array; var b = new a(buffer); var c = global.Int16Array; var d = new c(buffer); var e = global.Int32Array; var f = new e(buffer); var g = global.Uint8Array; var h = new g(buffer); var i = global.Uint16Array; var j = new i(buffer); var k = global.Uint32Array; var l = new k(buffer); var m = global.Float32Array; var n = new m(buffer); var o = global.Float64Array; var p = new o(buffer); var q = global.byteLength; var r = env.DYNAMICTOP_PTR | 0; var s = env.tempDoublePtr | 0; var t = env.ABORT | 0; var u = env.STACKTOP | 0; var v = env.STACK_MAX | 0; var w = env.cttz_i8 | 0; var x = 0; var y = 0; var z = 0; var A = 0; var B = global.NaN, C = global.Infinity; var D = 0, E = 0, F = 0, G = 0, H = 0.0; var I = 0; var J = global.Math.floor; var K = global.Math.abs; var L = global.Math.sqrt; var M = global.Math.pow; var N = global.Math.cos; var O = global.Math.sin; var P = global.Math.tan; var Q = global.Math.acos; var R = global.Math.asin; var S = global.Math.atan; var T = global.Math.atan2; var U = global.Math.exp; var V = global.Math.log; var W = global.Math.ceil; var X = global.Math.imul; var Y = global.Math.min; var Z = global.Math.max; var _ = global.Math.clz32; var $ = global.Math.fround; var aa = env.abort; var ba = env.assert; var ca = env.enlargeMemory; var da = env.getTotalMemory; var ea = env.abortOnCannotGrowMemory; var fa = env.invoke_ii; var ga = env.invoke_iii; var ha = env.invoke_iiii; var ia = env.invoke_iiiiiii; var ja = env.invoke_v; var ka = env.invoke_vi; var la = env.invoke_vii; var ma = env.invoke_viii; var na = env.invoke_viiii; var oa = env.invoke_viiiii; var pa = env.invoke_viiiiii; var qa = env.__ZSt18uncaught_exceptionv; var ra = env.___cxa_allocate_exception; var sa = env.___cxa_begin_catch; var ta = env.___cxa_find_matching_catch; var ua = env.___cxa_pure_virtual; var va = env.___cxa_throw; var wa = env.___gxx_personality_v0; var xa = env.___resumeException; var ya = env.___setErrNo; var za = env.___syscall140; var Aa = env.___syscall146; var Ba = env.___syscall6; var Ca = env._abort; var Da = env._emscripten_memcpy_big; var Ea = env._llvm_ceil_f64; var Fa = env._llvm_fabs_f64; var Ga = env._llvm_floor_f64; var Ha = env._llvm_trap; var Ia = env._pthread_getspecific; var Ja = env._pthread_key_create; var Ka = env._pthread_once; var La = env._pthread_setspecific; var Ma = env.flush_NO_FILESYSTEM; var Na = $(0); const Oa = $(0); function Pa(newBuffer) { if (q(newBuffer) & 16777215 || q(newBuffer) <= 16777215 || q(newBuffer) > 2147483648) return false; b = new a(newBuffer); d = new c(newBuffer); f = new e(newBuffer); h = new g(newBuffer); j = new i(newBuffer); l = new k(newBuffer); n = new m(newBuffer); p = new o(newBuffer); buffer = newBuffer; return true }
    // EMSCRIPTEN_START_FUNCS
    function wc(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; if (!a) return; b = a + -8 | 0; c = f[4516] | 0; d = f[a + -4 >> 2] | 0; a = d & -8; e = b + a | 0; do if (!(d & 1)) { g = f[b >> 2] | 0; if (!(d & 3)) return; h = b + (0 - g) | 0; i = g + a | 0; if (h >>> 0 < c >>> 0) return; if ((f[4517] | 0) == (h | 0)) { j = e + 4 | 0; k = f[j >> 2] | 0; if ((k & 3 | 0) != 3) { l = h; m = i; n = h; break } f[4514] = i; f[j >> 2] = k & -2; f[h + 4 >> 2] = i | 1; f[h + i >> 2] = i; return } k = g >>> 3; if (g >>> 0 < 256) { g = f[h + 8 >> 2] | 0; j = f[h + 12 >> 2] | 0; if ((j | 0) == (g | 0)) { f[4512] = f[4512] & ~(1 << k); l = h; m = i; n = h; break } else { f[g + 12 >> 2] = j; f[j + 8 >> 2] = g; l = h; m = i; n = h; break } } g = f[h + 24 >> 2] | 0; j = f[h + 12 >> 2] | 0; do if ((j | 0) == (h | 0)) { k = h + 16 | 0; o = k + 4 | 0; p = f[o >> 2] | 0; if (!p) { q = f[k >> 2] | 0; if (!q) { r = 0; break } else { s = q; t = k } } else { s = p; t = o } while (1) { o = s + 20 | 0; p = f[o >> 2] | 0; if (p | 0) { s = p; t = o; continue } o = s + 16 | 0; p = f[o >> 2] | 0; if (!p) break; else { s = p; t = o } } f[t >> 2] = 0; r = s } else { o = f[h + 8 >> 2] | 0; f[o + 12 >> 2] = j; f[j + 8 >> 2] = o; r = j } while (0); if (g) { j = f[h + 28 >> 2] | 0; o = 18352 + (j << 2) | 0; if ((f[o >> 2] | 0) == (h | 0)) { f[o >> 2] = r; if (!r) { f[4513] = f[4513] & ~(1 << j); l = h; m = i; n = h; break } } else { f[g + 16 + (((f[g + 16 >> 2] | 0) != (h | 0) & 1) << 2) >> 2] = r; if (!r) { l = h; m = i; n = h; break } } f[r + 24 >> 2] = g; j = h + 16 | 0; o = f[j >> 2] | 0; if (o | 0) { f[r + 16 >> 2] = o; f[o + 24 >> 2] = r } o = f[j + 4 >> 2] | 0; if (o) { f[r + 20 >> 2] = o; f[o + 24 >> 2] = r; l = h; m = i; n = h } else { l = h; m = i; n = h } } else { l = h; m = i; n = h } } else { l = b; m = a; n = b } while (0); if (n >>> 0 >= e >>> 0) return; b = e + 4 | 0; a = f[b >> 2] | 0; if (!(a & 1)) return; if (!(a & 2)) { if ((f[4518] | 0) == (e | 0)) { r = (f[4515] | 0) + m | 0; f[4515] = r; f[4518] = l; f[l + 4 >> 2] = r | 1; if ((l | 0) != (f[4517] | 0)) return; f[4517] = 0; f[4514] = 0; return } if ((f[4517] | 0) == (e | 0)) { r = (f[4514] | 0) + m | 0; f[4514] = r; f[4517] = n; f[l + 4 >> 2] = r | 1; f[n + r >> 2] = r; return } r = (a & -8) + m | 0; s = a >>> 3; do if (a >>> 0 < 256) { t = f[e + 8 >> 2] | 0; c = f[e + 12 >> 2] | 0; if ((c | 0) == (t | 0)) { f[4512] = f[4512] & ~(1 << s); break } else { f[t + 12 >> 2] = c; f[c + 8 >> 2] = t; break } } else { t = f[e + 24 >> 2] | 0; c = f[e + 12 >> 2] | 0; do if ((c | 0) == (e | 0)) { d = e + 16 | 0; o = d + 4 | 0; j = f[o >> 2] | 0; if (!j) { p = f[d >> 2] | 0; if (!p) { u = 0; break } else { v = p; w = d } } else { v = j; w = o } while (1) { o = v + 20 | 0; j = f[o >> 2] | 0; if (j | 0) { v = j; w = o; continue } o = v + 16 | 0; j = f[o >> 2] | 0; if (!j) break; else { v = j; w = o } } f[w >> 2] = 0; u = v } else { o = f[e + 8 >> 2] | 0; f[o + 12 >> 2] = c; f[c + 8 >> 2] = o; u = c } while (0); if (t | 0) { c = f[e + 28 >> 2] | 0; h = 18352 + (c << 2) | 0; if ((f[h >> 2] | 0) == (e | 0)) { f[h >> 2] = u; if (!u) { f[4513] = f[4513] & ~(1 << c); break } } else { f[t + 16 + (((f[t + 16 >> 2] | 0) != (e | 0) & 1) << 2) >> 2] = u; if (!u) break } f[u + 24 >> 2] = t; c = e + 16 | 0; h = f[c >> 2] | 0; if (h | 0) { f[u + 16 >> 2] = h; f[h + 24 >> 2] = u } h = f[c + 4 >> 2] | 0; if (h | 0) { f[u + 20 >> 2] = h; f[h + 24 >> 2] = u } } } while (0); f[l + 4 >> 2] = r | 1; f[n + r >> 2] = r; if ((l | 0) == (f[4517] | 0)) { f[4514] = r; return } else x = r } else { f[b >> 2] = a & -2; f[l + 4 >> 2] = m | 1; f[n + m >> 2] = m; x = m } m = x >>> 3; if (x >>> 0 < 256) { n = 18088 + (m << 1 << 2) | 0; a = f[4512] | 0; b = 1 << m; if (!(a & b)) { f[4512] = a | b; y = n; z = n + 8 | 0 } else { b = n + 8 | 0; y = f[b >> 2] | 0; z = b } f[z >> 2] = l; f[y + 12 >> 2] = l; f[l + 8 >> 2] = y; f[l + 12 >> 2] = n; return } n = x >>> 8; if (n) if (x >>> 0 > 16777215) A = 31; else { y = (n + 1048320 | 0) >>> 16 & 8; z = n << y; n = (z + 520192 | 0) >>> 16 & 4; b = z << n; z = (b + 245760 | 0) >>> 16 & 2; a = 14 - (n | y | z) + (b << z >>> 15) | 0; A = x >>> (a + 7 | 0) & 1 | a << 1 } else A = 0; a = 18352 + (A << 2) | 0; f[l + 28 >> 2] = A; f[l + 20 >> 2] = 0; f[l + 16 >> 2] = 0; z = f[4513] | 0; b = 1 << A; do if (z & b) { y = x << ((A | 0) == 31 ? 0 : 25 - (A >>> 1) | 0); n = f[a >> 2] | 0; while (1) { if ((f[n + 4 >> 2] & -8 | 0) == (x | 0)) { B = 73; break } C = n + 16 + (y >>> 31 << 2) | 0; m = f[C >> 2] | 0; if (!m) { B = 72; break } else { y = y << 1; n = m } } if ((B | 0) == 72) { f[C >> 2] = l; f[l + 24 >> 2] = n; f[l + 12 >> 2] = l; f[l + 8 >> 2] = l; break } else if ((B | 0) == 73) { y = n + 8 | 0; t = f[y >> 2] | 0; f[t + 12 >> 2] = l; f[y >> 2] = l; f[l + 8 >> 2] = t; f[l + 12 >> 2] = n; f[l + 24 >> 2] = 0; break } } else { f[4513] = z | b; f[a >> 2] = l; f[l + 24 >> 2] = a; f[l + 12 >> 2] = l; f[l + 8 >> 2] = l } while (0); l = (f[4520] | 0) + -1 | 0; f[4520] = l; if (!l) D = 18504; else return; while (1) { l = f[D >> 2] | 0; if (!l) break; else D = l + 8 | 0 } f[4520] = -1; return } function xc(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = Oa, F = Oa, G = Oa, H = 0, I = 0, J = 0, K = 0; d = b[c + 11 >> 0] | 0; e = d << 24 >> 24 < 0; g = e ? f[c >> 2] | 0 : c; i = e ? f[c + 4 >> 2] | 0 : d & 255; if (i >>> 0 > 3) { d = g; e = i; j = i; while (1) { k = X(h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24, 1540483477) | 0; e = (X(k >>> 24 ^ k, 1540483477) | 0) ^ (X(e, 1540483477) | 0); j = j + -4 | 0; if (j >>> 0 <= 3) break; else d = d + 4 | 0 } d = i + -4 | 0; j = d & -4; l = d - j | 0; m = g + (j + 4) | 0; o = e } else { l = i; m = g; o = i } switch (l | 0) { case 3: { p = h[m + 2 >> 0] << 16 ^ o; q = 6; break } case 2: { p = o; q = 6; break } case 1: { r = o; q = 7; break } default: s = o }if ((q | 0) == 6) { r = h[m + 1 >> 0] << 8 ^ p; q = 7 } if ((q | 0) == 7) s = X(r ^ h[m >> 0], 1540483477) | 0; m = X(s >>> 13 ^ s, 1540483477) | 0; s = m >>> 15 ^ m; m = a + 4 | 0; r = f[m >> 2] | 0; p = (r | 0) == 0; a: do if (!p) { o = r + -1 | 0; l = (o & r | 0) == 0; if (!l) if (s >>> 0 < r >>> 0) t = s; else t = (s >>> 0) % (r >>> 0) | 0; else t = s & o; e = f[(f[a >> 2] | 0) + (t << 2) >> 2] | 0; if ((e | 0) != 0 ? (j = f[e >> 2] | 0, (j | 0) != 0) : 0) { e = (i | 0) == 0; if (l) { if (e) { l = j; while (1) { d = f[l + 4 >> 2] | 0; if (!((d | 0) == (s | 0) | (d & o | 0) == (t | 0))) { u = t; break a } d = b[l + 8 + 11 >> 0] | 0; if (!((d << 24 >> 24 < 0 ? f[l + 12 >> 2] | 0 : d & 255) | 0)) { v = l; break } l = f[l >> 2] | 0; if (!l) { u = t; break a } } w = v + 20 | 0; return w | 0 } else x = j; b: while (1) { l = f[x + 4 >> 2] | 0; if (!((l | 0) == (s | 0) | (l & o | 0) == (t | 0))) { u = t; break a } l = x + 8 | 0; d = b[l + 11 >> 0] | 0; k = d << 24 >> 24 < 0; y = d & 255; do if (((k ? f[x + 12 >> 2] | 0 : y) | 0) == (i | 0)) { d = f[l >> 2] | 0; if (k) if (!(Pk(d, g, i) | 0)) { v = x; q = 63; break b } else break; if ((b[g >> 0] | 0) == (d & 255) << 24 >> 24) { d = l; z = y; A = g; do { z = z + -1 | 0; d = d + 1 | 0; if (!z) { v = x; q = 63; break b } A = A + 1 | 0 } while ((b[d >> 0] | 0) == (b[A >> 0] | 0)) } } while (0); x = f[x >> 2] | 0; if (!x) { u = t; break a } } if ((q | 0) == 63) { w = v + 20 | 0; return w | 0 } } if (e) { o = j; while (1) { y = f[o + 4 >> 2] | 0; if ((y | 0) != (s | 0)) { if (y >>> 0 < r >>> 0) B = y; else B = (y >>> 0) % (r >>> 0) | 0; if ((B | 0) != (t | 0)) { u = t; break a } } y = b[o + 8 + 11 >> 0] | 0; if (!((y << 24 >> 24 < 0 ? f[o + 12 >> 2] | 0 : y & 255) | 0)) { v = o; break } o = f[o >> 2] | 0; if (!o) { u = t; break a } } w = v + 20 | 0; return w | 0 } else C = j; c: while (1) { o = f[C + 4 >> 2] | 0; if ((o | 0) != (s | 0)) { if (o >>> 0 < r >>> 0) D = o; else D = (o >>> 0) % (r >>> 0) | 0; if ((D | 0) != (t | 0)) { u = t; break a } } o = C + 8 | 0; e = b[o + 11 >> 0] | 0; y = e << 24 >> 24 < 0; l = e & 255; do if (((y ? f[C + 12 >> 2] | 0 : l) | 0) == (i | 0)) { e = f[o >> 2] | 0; if (y) if (!(Pk(e, g, i) | 0)) { v = C; q = 63; break c } else break; if ((b[g >> 0] | 0) == (e & 255) << 24 >> 24) { e = o; k = l; A = g; do { k = k + -1 | 0; e = e + 1 | 0; if (!k) { v = C; q = 63; break c } A = A + 1 | 0 } while ((b[e >> 0] | 0) == (b[A >> 0] | 0)) } } while (0); C = f[C >> 2] | 0; if (!C) { u = t; break a } } if ((q | 0) == 63) { w = v + 20 | 0; return w | 0 } } else u = t } else u = 0; while (0); t = dn(24) | 0; dj(t + 8 | 0, c); f[t + 20 >> 2] = 0; f[t + 4 >> 2] = s; f[t >> 2] = 0; c = a + 12 | 0; E = $(((f[c >> 2] | 0) + 1 | 0) >>> 0); F = $(r >>> 0); G = $(n[a + 16 >> 2]); do if (p | $(G * F) < E) { C = r << 1 | (r >>> 0 < 3 | (r + -1 & r | 0) != 0) & 1; g = ~~$(W($(E / G))) >>> 0; Ph(a, C >>> 0 < g >>> 0 ? g : C); C = f[m >> 2] | 0; g = C + -1 | 0; if (!(g & C)) { H = C; I = g & s; break } if (s >>> 0 < C >>> 0) { H = C; I = s } else { H = C; I = (s >>> 0) % (C >>> 0) | 0 } } else { H = r; I = u } while (0); u = (f[a >> 2] | 0) + (I << 2) | 0; I = f[u >> 2] | 0; if (!I) { r = a + 8 | 0; f[t >> 2] = f[r >> 2]; f[r >> 2] = t; f[u >> 2] = r; r = f[t >> 2] | 0; if (r | 0) { u = f[r + 4 >> 2] | 0; r = H + -1 | 0; if (r & H) if (u >>> 0 < H >>> 0) J = u; else J = (u >>> 0) % (H >>> 0) | 0; else J = u & r; K = (f[a >> 2] | 0) + (J << 2) | 0; q = 61 } } else { f[t >> 2] = f[I >> 2]; K = I; q = 61 } if ((q | 0) == 61) f[K >> 2] = t; f[c >> 2] = (f[c >> 2] | 0) + 1; v = t; w = v + 20 | 0; return w | 0 } function yc(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0.0, q = 0.0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0.0, G = 0.0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0.0, P = 0, Q = 0.0, R = 0.0, S = 0, T = 0.0, U = 0, V = 0, W = 0, X = 0.0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0.0, da = 0, ea = 0.0; g = a + 4 | 0; i = f[g >> 2] | 0; j = a + 100 | 0; if (i >>> 0 < (f[j >> 2] | 0) >>> 0) { f[g >> 2] = i + 1; k = h[i >> 0] | 0; l = 0 } else { k = Di(a) | 0; l = 0 } a: while (1) { switch (k | 0) { case 46: { m = 8; break a; break } case 48: break; default: { n = 0; o = 0; p = 1.0; q = 0.0; r = 0; s = k; t = l; u = 0; v = 0; w = 0; x = 0; break a } }i = f[g >> 2] | 0; if (i >>> 0 < (f[j >> 2] | 0) >>> 0) { f[g >> 2] = i + 1; k = h[i >> 0] | 0; l = 1; continue } else { k = Di(a) | 0; l = 1; continue } } if ((m | 0) == 8) { k = f[g >> 2] | 0; if (k >>> 0 < (f[j >> 2] | 0) >>> 0) { f[g >> 2] = k + 1; y = h[k >> 0] | 0 } else y = Di(a) | 0; if ((y | 0) == 48) { k = 0; i = 0; while (1) { z = f[g >> 2] | 0; if (z >>> 0 < (f[j >> 2] | 0) >>> 0) { f[g >> 2] = z + 1; A = h[z >> 0] | 0 } else A = Di(a) | 0; z = Tn(k | 0, i | 0, -1, -1) | 0; B = I; if ((A | 0) == 48) { k = z; i = B } else { n = 1; o = 0; p = 1.0; q = 0.0; r = 0; s = A; t = 1; u = 0; v = 0; w = z; x = B; break } } } else { n = 1; o = 0; p = 1.0; q = 0.0; r = 0; s = y; t = l; u = 0; v = 0; w = 0; x = 0 } } while (1) { l = s + -48 | 0; y = s | 32; if (l >>> 0 >= 10) { A = (s | 0) == 46; if (!(A | (y + -97 | 0) >>> 0 < 6)) { C = s; break } if (A) if (!n) { D = 1; E = o; F = p; G = q; H = r; J = t; K = v; L = u; M = v; N = u } else { C = 46; break } else m = 20 } else m = 20; if ((m | 0) == 20) { m = 0; A = (s | 0) > 57 ? y + -87 | 0 : l; do if (!((u | 0) < 0 | (u | 0) == 0 & v >>> 0 < 8)) if ((u | 0) < 0 | (u | 0) == 0 & v >>> 0 < 14) { O = p * .0625; P = o; Q = O; R = q + O * +(A | 0); S = r; break } else { l = (o | 0) != 0 | (A | 0) == 0; P = l ? o : 1; Q = p; R = l ? q : q + p * .5; S = r; break } else { P = o; Q = p; R = q; S = A + (r << 4) | 0 } while (0); A = Tn(v | 0, u | 0, 1, 0) | 0; D = n; E = P; F = Q; G = R; H = S; J = 1; K = w; L = x; M = A; N = I } A = f[g >> 2] | 0; if (A >>> 0 < (f[j >> 2] | 0) >>> 0) { f[g >> 2] = A + 1; n = D; o = E; p = F; q = G; r = H; s = h[A >> 0] | 0; t = J; u = N; v = M; w = K; x = L; continue } else { n = D; o = E; p = F; q = G; r = H; s = Di(a) | 0; t = J; u = N; v = M; w = K; x = L; continue } } do if (!t) { L = (f[j >> 2] | 0) == 0; if (!L) f[g >> 2] = (f[g >> 2] | 0) + -1; if (e) { if (!L) f[g >> 2] = (f[g >> 2] | 0) + -1; if (!((n | 0) == 0 | L)) f[g >> 2] = (f[g >> 2] | 0) + -1 } else Rm(a, 0); T = +(d | 0) * 0.0 } else { L = (n | 0) == 0; K = L ? v : w; M = L ? u : x; if ((u | 0) < 0 | (u | 0) == 0 & v >>> 0 < 8) { L = r; N = v; J = u; while (1) { s = L << 4; H = N; N = Tn(N | 0, J | 0, 1, 0) | 0; if (!((J | 0) < 0 | (J | 0) == 0 & H >>> 0 < 7)) { U = s; break } else { L = s; J = I } } } else U = r; if ((C | 32 | 0) == 112) { J = De(a, e) | 0; L = I; if ((J | 0) == 0 & (L | 0) == -2147483648) { if (!e) { Rm(a, 0); T = 0.0; break } if (!(f[j >> 2] | 0)) { V = 0; W = 0 } else { f[g >> 2] = (f[g >> 2] | 0) + -1; V = 0; W = 0 } } else { V = J; W = L } } else if (!(f[j >> 2] | 0)) { V = 0; W = 0 } else { f[g >> 2] = (f[g >> 2] | 0) + -1; V = 0; W = 0 } L = Rn(K | 0, M | 0, 2) | 0; J = Tn(L | 0, I | 0, -32, -1) | 0; L = Tn(J | 0, I | 0, V | 0, W | 0) | 0; J = I; if (!U) { T = +(d | 0) * 0.0; break } N = 0 - c | 0; s = ((N | 0) < 0) << 31 >> 31; if ((J | 0) > (s | 0) | (J | 0) == (s | 0) & L >>> 0 > N >>> 0) { N = ir() | 0; f[N >> 2] = 34; T = +(d | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284; break } N = c + -106 | 0; s = ((N | 0) < 0) << 31 >> 31; if ((J | 0) < (s | 0) | (J | 0) == (s | 0) & L >>> 0 < N >>> 0) { N = ir() | 0; f[N >> 2] = 34; T = +(d | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308; break } if ((U | 0) > -1) { G = q; N = U; s = L; H = J; while (1) { E = !(G >= .5); o = N << 1 | (E ^ 1) & 1; F = G + (E ? G : G + -1.0); E = Tn(s | 0, H | 0, -1, -1) | 0; D = I; if ((o | 0) > -1) { G = F; N = o; s = E; H = D } else { X = F; Y = o; Z = E; _ = D; break } } } else { X = q; Y = U; Z = L; _ = J } H = ((b | 0) < 0) << 31 >> 31; s = Vn(32, 0, c | 0, ((c | 0) < 0) << 31 >> 31 | 0) | 0; N = Tn(s | 0, I | 0, Z | 0, _ | 0) | 0; s = I; if ((s | 0) < (H | 0) | (s | 0) == (H | 0) & N >>> 0 < b >>> 0) if ((N | 0) > 0) { $ = N; m = 59 } else { aa = 0; ba = 84; m = 61 } else { $ = b; m = 59 } if ((m | 0) == 59) if (($ | 0) < 53) { aa = $; ba = 84 - $ | 0; m = 61 } else { ca = 0.0; da = $; ea = +(d | 0) } if ((m | 0) == 61) { G = +(d | 0); ca = +Gq(+Wj(1.0, ba), G); da = aa; ea = G } N = (Y & 1 | 0) == 0 & (X != 0.0 & (da | 0) < 32); G = (N ? 0.0 : X) * ea + (ca + ea * +((Y + (N & 1) | 0) >>> 0)) - ca; if (!(G != 0.0)) { N = ir() | 0; f[N >> 2] = 34 } T = +Hq(G, Z) } while (0); return +T } function zc(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0; g = u; u = u + 16 | 0; h = g + 4 | 0; i = g; if (!(oh(a, d) | 0)) { j = 0; u = g; return j | 0 } d = a + 84 | 0; k = f[d >> 2] | 0; l = a + 88 | 0; m = f[l >> 2] | 0; if ((m | 0) != (k | 0)) f[l >> 2] = m + (~((m + -4 - k | 0) >>> 2) << 2); f[d >> 2] = 0; f[l >> 2] = 0; f[a + 92 >> 2] = 0; if (k | 0) br(k); k = a + 72 | 0; l = f[k >> 2] | 0; d = a + 76 | 0; if ((f[d >> 2] | 0) != (l | 0)) f[d >> 2] = l; f[k >> 2] = 0; f[d >> 2] = 0; f[a + 80 >> 2] = 0; if (l | 0) br(l); l = a + 64 | 0; d = f[l >> 2] | 0; if ((f[d + 4 >> 2] | 0) != (f[d >> 2] | 0)) { k = a + 12 | 0; m = e + 84 | 0; n = e + 68 | 0; o = c + 96 | 0; p = a + 24 | 0; q = 0; r = d; do { f[i >> 2] = (q >>> 0) / 3 | 0; f[h >> 2] = f[i >> 2]; d = Rj(r, h) | 0; r = f[l >> 2] | 0; do if (!d) { s = f[(f[r + 12 >> 2] | 0) + (q << 2) >> 2] | 0; if ((s | 0) == -1) { t = (f[a >> 2] | 0) + (q >>> 5 << 2) | 0; f[t >> 2] = f[t >> 2] | 1 << (q & 31); t = q + 1 | 0; v = ((t >>> 0) % 3 | 0 | 0) == 0 ? q + -2 | 0 : t; if ((v | 0) == -1) w = -1; else w = f[(f[r >> 2] | 0) + (v << 2) >> 2] | 0; v = (f[k >> 2] | 0) + (w >>> 5 << 2) | 0; f[v >> 2] = f[v >> 2] | 1 << (w & 31); v = (((q >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + q | 0; if ((v | 0) == -1) x = -1; else x = f[(f[r >> 2] | 0) + (v << 2) >> 2] | 0; v = (f[k >> 2] | 0) + (x >>> 5 << 2) | 0; f[v >> 2] = f[v >> 2] | 1 << (x & 31); break } if (s >>> 0 >= q >>> 0) { v = q + 1 | 0; t = ((v >>> 0) % 3 | 0 | 0) == 0 ? q + -2 | 0 : v; y = s + (((s >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; z = (t | 0) == -1; if (!(b[m >> 0] | 0)) { if (z) A = -1; else A = f[(f[o >> 2] | 0) + (((t | 0) / 3 | 0) * 12 | 0) + (((t | 0) % 3 | 0) << 2) >> 2] | 0; B = (y | 0) == -1; if (B) C = -1; else C = f[(f[o >> 2] | 0) + (((y | 0) / 3 | 0) * 12 | 0) + (((y | 0) % 3 | 0) << 2) >> 2] | 0; D = f[n >> 2] | 0; if ((f[D + (A << 2) >> 2] | 0) == (f[D + (C << 2) >> 2] | 0)) { E = t + 1 | 0; if (z) F = -1; else F = ((E >>> 0) % 3 | 0 | 0) == 0 ? t + -2 | 0 : E; do if (!B) if (!((y >>> 0) % 3 | 0)) { G = y + 2 | 0; break } else { G = y + -1 | 0; break } else G = -1; while (0); if ((F | 0) == -1) H = -1; else H = f[(f[o >> 2] | 0) + (((F | 0) / 3 | 0) * 12 | 0) + (((F | 0) % 3 | 0) << 2) >> 2] | 0; if ((G | 0) == -1) I = -1; else I = f[(f[o >> 2] | 0) + (((G | 0) / 3 | 0) * 12 | 0) + (((G | 0) % 3 | 0) << 2) >> 2] | 0; if ((f[D + (H << 2) >> 2] | 0) == (f[D + (I << 2) >> 2] | 0)) break } } else { if (z) J = -1; else J = f[(f[o >> 2] | 0) + (((t | 0) / 3 | 0) * 12 | 0) + (((t | 0) % 3 | 0) << 2) >> 2] | 0; B = (y | 0) == -1; if (B) K = -1; else K = f[(f[o >> 2] | 0) + (((y | 0) / 3 | 0) * 12 | 0) + (((y | 0) % 3 | 0) << 2) >> 2] | 0; if ((J | 0) == (K | 0)) { E = t + 1 | 0; if (z) L = -1; else L = ((E >>> 0) % 3 | 0 | 0) == 0 ? t + -2 | 0 : E; do if (!B) if (!((y >>> 0) % 3 | 0)) { M = y + 2 | 0; break } else { M = y + -1 | 0; break } else M = -1; while (0); if ((L | 0) == -1) N = -1; else N = f[(f[o >> 2] | 0) + (((L | 0) / 3 | 0) * 12 | 0) + (((L | 0) % 3 | 0) << 2) >> 2] | 0; if ((M | 0) == -1) O = -1; else O = f[(f[o >> 2] | 0) + (((M | 0) / 3 | 0) * 12 | 0) + (((M | 0) % 3 | 0) << 2) >> 2] | 0; if ((N | 0) == (O | 0)) break } } b[p >> 0] = 0; y = f[a >> 2] | 0; B = y + (q >>> 5 << 2) | 0; f[B >> 2] = f[B >> 2] | 1 << (q & 31); B = y + (s >>> 5 << 2) | 0; f[B >> 2] = f[B >> 2] | 1 << (s & 31); B = ((v >>> 0) % 3 | 0 | 0) == 0 ? q + -2 | 0 : v; if ((B | 0) == -1) P = -1; else P = f[(f[r >> 2] | 0) + (B << 2) >> 2] | 0; B = (f[k >> 2] | 0) + (P >>> 5 << 2) | 0; f[B >> 2] = f[B >> 2] | 1 << (P & 31); B = (((q >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + q | 0; if ((B | 0) == -1) Q = -1; else Q = f[(f[r >> 2] | 0) + (B << 2) >> 2] | 0; B = (f[k >> 2] | 0) + (Q >>> 5 << 2) | 0; f[B >> 2] = f[B >> 2] | 1 << (Q & 31); B = s + 1 | 0; y = ((B >>> 0) % 3 | 0 | 0) == 0 ? s + -2 | 0 : B; if ((y | 0) == -1) R = -1; else R = f[(f[r >> 2] | 0) + (y << 2) >> 2] | 0; y = (f[k >> 2] | 0) + (R >>> 5 << 2) | 0; f[y >> 2] = f[y >> 2] | 1 << (R & 31); y = (((s >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + s | 0; if ((y | 0) == -1) S = -1; else S = f[(f[r >> 2] | 0) + (y << 2) >> 2] | 0; y = (f[k >> 2] | 0) + (S >>> 5 << 2) | 0; f[y >> 2] = f[y >> 2] | 1 << (S & 31) } } while (0); q = q + 1 | 0 } while (q >>> 0 < (f[r + 4 >> 2] | 0) - (f[r >> 2] | 0) >> 2 >>> 0) } if ((c | 0) != 0 & (e | 0) != 0) { Kc(a, c, e); j = 1; u = g; return j | 0 } else { gd(a, 0, 0); j = 1; u = g; return j | 0 } return 0 } function Ac(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0; d = u; u = u + 32 | 0; e = d + 12 | 0; g = d + 8 | 0; h = d + 4 | 0; i = d; j = a + 8 | 0; a: do if (f[j >> 2] | 0 ? (k = f[a >> 2] | 0, l = a + 4 | 0, f[a >> 2] = l, f[(f[l >> 2] | 0) + 8 >> 2] = 0, f[l >> 2] = 0, f[j >> 2] = 0, m = f[k + 4 >> 2] | 0, n = (m | 0) == 0 ? k : m, n | 0) : 0) { m = a + 4 | 0; k = n; n = f[b >> 2] | 0; while (1) { if ((n | 0) == (f[c >> 2] | 0)) break; o = k + 16 | 0; f[o >> 2] = f[n + 16 >> 2]; if ((k | 0) != (n | 0)) { f[h >> 2] = f[n + 20 >> 2]; f[i >> 2] = n + 24; f[g >> 2] = f[h >> 2]; f[e >> 2] = f[i >> 2]; Hc(k + 20 | 0, g, e) } p = k + 8 | 0; q = f[p >> 2] | 0; do if (q) { r = f[q >> 2] | 0; if ((r | 0) == (k | 0)) { f[q >> 2] = 0; s = f[q + 4 >> 2] | 0; if (!s) { t = q; break } else v = s; while (1) { s = f[v >> 2] | 0; if (s | 0) { v = s; continue } s = f[v + 4 >> 2] | 0; if (!s) break; else v = s } t = v; break } else { f[q + 4 >> 2] = 0; if (!r) { t = q; break } else w = r; while (1) { s = f[w >> 2] | 0; if (s | 0) { w = s; continue } s = f[w + 4 >> 2] | 0; if (!s) break; else w = s } t = w; break } } else t = 0; while (0); q = f[l >> 2] | 0; do if (q) { r = f[o >> 2] | 0; s = q; while (1) { if ((r | 0) < (f[s + 16 >> 2] | 0)) { x = f[s >> 2] | 0; if (!x) { y = 22; break } else z = x } else { A = s + 4 | 0; x = f[A >> 2] | 0; if (!x) { y = 25; break } else z = x } s = z } if ((y | 0) == 22) { y = 0; B = s; C = s; break } else if ((y | 0) == 25) { y = 0; B = s; C = A; break } } else { B = l; C = l } while (0); f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[p >> 2] = B; f[C >> 2] = k; q = f[f[a >> 2] >> 2] | 0; if (!q) D = k; else { f[a >> 2] = q; D = f[C >> 2] | 0 } Ae(f[m >> 2] | 0, D); f[j >> 2] = (f[j >> 2] | 0) + 1; q = f[n + 4 >> 2] | 0; if (!q) { o = n + 8 | 0; r = f[o >> 2] | 0; if ((f[r >> 2] | 0) == (n | 0)) E = r; else { r = o; do { o = f[r >> 2] | 0; r = o + 8 | 0; x = f[r >> 2] | 0 } while ((f[x >> 2] | 0) != (o | 0)); E = x } } else { r = q; while (1) { p = f[r >> 2] | 0; if (!p) break; else r = p } E = r } f[b >> 2] = E; if (!t) break a; else { k = t; n = E } } n = f[k + 8 >> 2] | 0; if (!n) F = k; else { m = n; while (1) { n = f[m + 8 >> 2] | 0; if (!n) break; else m = n } F = m } Dj(a, F) } while (0); F = f[b >> 2] | 0; E = f[c >> 2] | 0; if ((F | 0) == (E | 0)) { u = d; return } c = a + 4 | 0; t = a + 4 | 0; D = F; while (1) { tg(e, a, D + 16 | 0); F = f[c >> 2] | 0; do if (F) { C = f[e >> 2] | 0; B = f[C + 16 >> 2] | 0; A = F; while (1) { if ((B | 0) < (f[A + 16 >> 2] | 0)) { z = f[A >> 2] | 0; if (!z) { y = 43; break } else G = z } else { H = A + 4 | 0; z = f[H >> 2] | 0; if (!z) { y = 46; break } else G = z } A = G } if ((y | 0) == 43) { y = 0; I = A; J = A; K = C; break } else if ((y | 0) == 46) { y = 0; I = A; J = H; K = C; break } } else { I = c; J = c; K = f[e >> 2] | 0 } while (0); f[K >> 2] = 0; f[K + 4 >> 2] = 0; f[K + 8 >> 2] = I; f[J >> 2] = K; F = f[f[a >> 2] >> 2] | 0; if (!F) L = K; else { f[a >> 2] = F; L = f[J >> 2] | 0 } Ae(f[t >> 2] | 0, L); f[j >> 2] = (f[j >> 2] | 0) + 1; F = f[D + 4 >> 2] | 0; if (!F) { m = D + 8 | 0; B = f[m >> 2] | 0; if ((f[B >> 2] | 0) == (D | 0)) M = B; else { B = m; do { m = f[B >> 2] | 0; B = m + 8 | 0; r = f[B >> 2] | 0 } while ((f[r >> 2] | 0) != (m | 0)); M = r } } else { B = F; while (1) { r = f[B >> 2] | 0; if (!r) break; else B = r } M = B } f[b >> 2] = M; if ((M | 0) == (E | 0)) break; else D = M } u = d; return } function Bc(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0; g = a + 8 | 0; Ah(g, b, d, e); d = e >>> 0 > 1073741823 ? -1 : e << 2; h = _q(d) | 0; hj(h | 0, 0, d | 0) | 0; d = f[a + 48 >> 2] | 0; i = f[a + 56 >> 2] | 0; j = f[i >> 2] | 0; k = (f[i + 4 >> 2] | 0) - j | 0; l = k >> 2; a: do if ((k | 0) > 4) { m = f[a + 52 >> 2] | 0; n = a + 16 | 0; o = a + 32 | 0; p = a + 12 | 0; q = a + 28 | 0; r = a + 20 | 0; s = a + 24 | 0; t = d + 12 | 0; u = (e | 0) > 0; v = j; w = l; while (1) { x = w; w = w + -1 | 0; if (l >>> 0 <= w >>> 0) break; y = f[v + (w << 2) >> 2] | 0; z = X(w, e) | 0; if ((y | 0) != -1 ? (A = f[(f[t >> 2] | 0) + (y << 2) >> 2] | 0, (A | 0) != -1) : 0) { y = f[d >> 2] | 0; B = f[m >> 2] | 0; C = f[B + (f[y + (A << 2) >> 2] << 2) >> 2] | 0; D = A + 1 | 0; E = ((D >>> 0) % 3 | 0 | 0) == 0 ? A + -2 | 0 : D; if ((E | 0) == -1) F = -1; else F = f[y + (E << 2) >> 2] | 0; E = f[B + (F << 2) >> 2] | 0; D = (((A >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + A | 0; if ((D | 0) == -1) G = -1; else G = f[y + (D << 2) >> 2] | 0; D = f[B + (G << 2) >> 2] | 0; if ((C | 0) < (w | 0) & (E | 0) < (w | 0) & (D | 0) < (w | 0)) { B = X(C, e) | 0; C = X(E, e) | 0; E = X(D, e) | 0; if (u) { D = 0; do { f[h + (D << 2) >> 2] = (f[b + (D + E << 2) >> 2] | 0) + (f[b + (D + C << 2) >> 2] | 0) - (f[b + (D + B << 2) >> 2] | 0); D = D + 1 | 0 } while ((D | 0) != (e | 0)) } D = b + (z << 2) | 0; B = c + (z << 2) | 0; C = f[g >> 2] | 0; if ((C | 0) > 0) { E = 0; y = h; A = C; while (1) { if ((A | 0) > 0) { C = 0; do { H = f[y + (C << 2) >> 2] | 0; I = f[n >> 2] | 0; if ((H | 0) > (I | 0)) { J = f[o >> 2] | 0; f[J + (C << 2) >> 2] = I; K = J } else { J = f[p >> 2] | 0; I = f[o >> 2] | 0; f[I + (C << 2) >> 2] = (H | 0) < (J | 0) ? J : H; K = I } C = C + 1 | 0 } while ((C | 0) < (f[g >> 2] | 0)); L = K } else L = f[o >> 2] | 0; C = (f[D + (E << 2) >> 2] | 0) - (f[L + (E << 2) >> 2] | 0) | 0; I = B + (E << 2) | 0; f[I >> 2] = C; if ((C | 0) >= (f[q >> 2] | 0)) { if ((C | 0) > (f[s >> 2] | 0)) { M = C - (f[r >> 2] | 0) | 0; N = 42 } } else { M = (f[r >> 2] | 0) + C | 0; N = 42 } if ((N | 0) == 42) { N = 0; f[I >> 2] = M } E = E + 1 | 0; A = f[g >> 2] | 0; if ((E | 0) >= (A | 0)) break; else y = L } } } else N = 16 } else N = 16; if ((N | 0) == 16 ? (N = 0, y = b + (z << 2) | 0, A = c + (z << 2) | 0, E = f[g >> 2] | 0, (E | 0) > 0) : 0) { B = 0; D = b + ((X(x + -2 | 0, e) | 0) << 2) | 0; I = E; while (1) { if ((I | 0) > 0) { E = 0; do { C = f[D + (E << 2) >> 2] | 0; H = f[n >> 2] | 0; if ((C | 0) > (H | 0)) { J = f[o >> 2] | 0; f[J + (E << 2) >> 2] = H; O = J } else { J = f[p >> 2] | 0; H = f[o >> 2] | 0; f[H + (E << 2) >> 2] = (C | 0) < (J | 0) ? J : C; O = H } E = E + 1 | 0 } while ((E | 0) < (f[g >> 2] | 0)); P = O } else P = f[o >> 2] | 0; E = (f[y + (B << 2) >> 2] | 0) - (f[P + (B << 2) >> 2] | 0) | 0; H = A + (B << 2) | 0; f[H >> 2] = E; if ((E | 0) >= (f[q >> 2] | 0)) { if ((E | 0) > (f[s >> 2] | 0)) { Q = E - (f[r >> 2] | 0) | 0; N = 29 } } else { Q = (f[r >> 2] | 0) + E | 0; N = 29 } if ((N | 0) == 29) { N = 0; f[H >> 2] = Q } B = B + 1 | 0; I = f[g >> 2] | 0; if ((B | 0) >= (I | 0)) break; else D = P } } if ((x | 0) <= 2) break a } mq(i) } while (0); if ((e | 0) > 0) hj(h | 0, 0, e << 2 | 0) | 0; e = f[g >> 2] | 0; if ((e | 0) <= 0) { $q(h); return 1 } i = a + 16 | 0; P = a + 32 | 0; Q = a + 12 | 0; O = a + 28 | 0; L = a + 20 | 0; M = a + 24 | 0; a = 0; K = h; G = e; while (1) { if ((G | 0) > 0) { e = 0; do { F = f[K + (e << 2) >> 2] | 0; d = f[i >> 2] | 0; if ((F | 0) > (d | 0)) { l = f[P >> 2] | 0; f[l + (e << 2) >> 2] = d; R = l } else { l = f[Q >> 2] | 0; d = f[P >> 2] | 0; f[d + (e << 2) >> 2] = (F | 0) < (l | 0) ? l : F; R = d } e = e + 1 | 0 } while ((e | 0) < (f[g >> 2] | 0)); S = R } else S = f[P >> 2] | 0; e = (f[b + (a << 2) >> 2] | 0) - (f[S + (a << 2) >> 2] | 0) | 0; d = c + (a << 2) | 0; f[d >> 2] = e; if ((e | 0) >= (f[O >> 2] | 0)) { if ((e | 0) > (f[M >> 2] | 0)) { T = e - (f[L >> 2] | 0) | 0; N = 56 } } else { T = (f[L >> 2] | 0) + e | 0; N = 56 } if ((N | 0) == 56) { N = 0; f[d >> 2] = T } a = a + 1 | 0; G = f[g >> 2] | 0; if ((a | 0) >= (G | 0)) break; else K = S } $q(h); return 1 } function Cc(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0; g = a + 8 | 0; Ah(g, b, d, e); d = e >>> 0 > 1073741823 ? -1 : e << 2; h = _q(d) | 0; hj(h | 0, 0, d | 0) | 0; d = f[a + 48 >> 2] | 0; i = f[a + 56 >> 2] | 0; j = f[i >> 2] | 0; k = (f[i + 4 >> 2] | 0) - j | 0; l = k >> 2; a: do if ((k | 0) > 4) { m = f[a + 52 >> 2] | 0; n = a + 16 | 0; o = a + 32 | 0; p = a + 12 | 0; q = a + 28 | 0; r = a + 20 | 0; s = a + 24 | 0; t = d + 64 | 0; u = d + 28 | 0; v = (e | 0) > 0; w = j; x = l; while (1) { y = x; x = x + -1 | 0; if (l >>> 0 <= x >>> 0) break; z = f[w + (x << 2) >> 2] | 0; A = X(x, e) | 0; if ((((z | 0) != -1 ? (f[(f[d >> 2] | 0) + (z >>> 5 << 2) >> 2] & 1 << (z & 31) | 0) == 0 : 0) ? (B = f[(f[(f[t >> 2] | 0) + 12 >> 2] | 0) + (z << 2) >> 2] | 0, (B | 0) != -1) : 0) ? (z = f[u >> 2] | 0, C = f[m >> 2] | 0, D = f[C + (f[z + (B << 2) >> 2] << 2) >> 2] | 0, E = B + 1 | 0, F = f[C + (f[z + ((((E >>> 0) % 3 | 0 | 0) == 0 ? B + -2 | 0 : E) << 2) >> 2] << 2) >> 2] | 0, E = f[C + (f[z + ((((B >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + B << 2) >> 2] << 2) >> 2] | 0, (D | 0) < (x | 0) & (F | 0) < (x | 0) & (E | 0) < (x | 0)) : 0) { B = X(D, e) | 0; D = X(F, e) | 0; F = X(E, e) | 0; if (v) { E = 0; do { f[h + (E << 2) >> 2] = (f[b + (E + F << 2) >> 2] | 0) + (f[b + (E + D << 2) >> 2] | 0) - (f[b + (E + B << 2) >> 2] | 0); E = E + 1 | 0 } while ((E | 0) != (e | 0)) } E = b + (A << 2) | 0; B = c + (A << 2) | 0; D = f[g >> 2] | 0; if ((D | 0) > 0) { F = 0; z = h; C = D; while (1) { if ((C | 0) > 0) { D = 0; do { G = f[z + (D << 2) >> 2] | 0; H = f[n >> 2] | 0; if ((G | 0) > (H | 0)) { I = f[o >> 2] | 0; f[I + (D << 2) >> 2] = H; J = I } else { I = f[p >> 2] | 0; H = f[o >> 2] | 0; f[H + (D << 2) >> 2] = (G | 0) < (I | 0) ? I : G; J = H } D = D + 1 | 0 } while ((D | 0) < (f[g >> 2] | 0)); K = J } else K = f[o >> 2] | 0; D = (f[E + (F << 2) >> 2] | 0) - (f[K + (F << 2) >> 2] | 0) | 0; H = B + (F << 2) | 0; f[H >> 2] = D; if ((D | 0) >= (f[q >> 2] | 0)) { if ((D | 0) > (f[s >> 2] | 0)) { L = D - (f[r >> 2] | 0) | 0; M = 39 } } else { L = (f[r >> 2] | 0) + D | 0; M = 39 } if ((M | 0) == 39) { M = 0; f[H >> 2] = L } F = F + 1 | 0; C = f[g >> 2] | 0; if ((F | 0) >= (C | 0)) break; else z = K } } } else M = 13; if ((M | 0) == 13 ? (M = 0, z = b + (A << 2) | 0, C = c + (A << 2) | 0, F = f[g >> 2] | 0, (F | 0) > 0) : 0) { B = 0; E = b + ((X(y + -2 | 0, e) | 0) << 2) | 0; H = F; while (1) { if ((H | 0) > 0) { F = 0; do { D = f[E + (F << 2) >> 2] | 0; G = f[n >> 2] | 0; if ((D | 0) > (G | 0)) { I = f[o >> 2] | 0; f[I + (F << 2) >> 2] = G; N = I } else { I = f[p >> 2] | 0; G = f[o >> 2] | 0; f[G + (F << 2) >> 2] = (D | 0) < (I | 0) ? I : D; N = G } F = F + 1 | 0 } while ((F | 0) < (f[g >> 2] | 0)); O = N } else O = f[o >> 2] | 0; F = (f[z + (B << 2) >> 2] | 0) - (f[O + (B << 2) >> 2] | 0) | 0; G = C + (B << 2) | 0; f[G >> 2] = F; if ((F | 0) >= (f[q >> 2] | 0)) { if ((F | 0) > (f[s >> 2] | 0)) { P = F - (f[r >> 2] | 0) | 0; M = 26 } } else { P = (f[r >> 2] | 0) + F | 0; M = 26 } if ((M | 0) == 26) { M = 0; f[G >> 2] = P } B = B + 1 | 0; H = f[g >> 2] | 0; if ((B | 0) >= (H | 0)) break; else E = O } } if ((y | 0) <= 2) break a } mq(i) } while (0); if ((e | 0) > 0) hj(h | 0, 0, e << 2 | 0) | 0; e = f[g >> 2] | 0; if ((e | 0) <= 0) { $q(h); return 1 } i = a + 16 | 0; O = a + 32 | 0; P = a + 12 | 0; N = a + 28 | 0; K = a + 20 | 0; L = a + 24 | 0; a = 0; J = h; d = e; while (1) { if ((d | 0) > 0) { e = 0; do { l = f[J + (e << 2) >> 2] | 0; j = f[i >> 2] | 0; if ((l | 0) > (j | 0)) { k = f[O >> 2] | 0; f[k + (e << 2) >> 2] = j; Q = k } else { k = f[P >> 2] | 0; j = f[O >> 2] | 0; f[j + (e << 2) >> 2] = (l | 0) < (k | 0) ? k : l; Q = j } e = e + 1 | 0 } while ((e | 0) < (f[g >> 2] | 0)); R = Q } else R = f[O >> 2] | 0; e = (f[b + (a << 2) >> 2] | 0) - (f[R + (a << 2) >> 2] | 0) | 0; j = c + (a << 2) | 0; f[j >> 2] = e; if ((e | 0) >= (f[N >> 2] | 0)) { if ((e | 0) > (f[L >> 2] | 0)) { S = e - (f[K >> 2] | 0) | 0; M = 53 } } else { S = (f[K >> 2] | 0) + e | 0; M = 53 } if ((M | 0) == 53) { M = 0; f[j >> 2] = S } a = a + 1 | 0; d = f[g >> 2] | 0; if ((a | 0) >= (d | 0)) break; else J = R } $q(h); return 1 } function Dc(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0; h = u; u = u + 48 | 0; i = h + 28 | 0; j = h + 24 | 0; k = h; l = h + 12 | 0; m = h + 40 | 0; if ((c | 0) < 0) { n = 0; u = h; return n | 0 } if (!c) { n = 1; u = h; return n | 0 } o = (d | 0) > 1; p = o ? d : 1; f[k >> 2] = 0; d = k + 4 | 0; f[d >> 2] = 0; f[k + 8 >> 2] = 0; $j(k, c); q = k + 8 | 0; if (o) { o = 0; r = 0; while (1) { s = 1; t = f[a + (r << 2) >> 2] | 0; do { v = f[a + (s + r << 2) >> 2] | 0; t = t >>> 0 < v >>> 0 ? v : t; s = s + 1 | 0 } while ((s | 0) != (p | 0)); s = (_(t | 0) | 0) ^ 31; v = t >>> 0 > o >>> 0 ? t : o; w = (t | 0) == 0 ? 1 : s + 1 | 0; f[i >> 2] = w; s = f[d >> 2] | 0; if (s >>> 0 < (f[q >> 2] | 0) >>> 0) { f[s >> 2] = w; f[d >> 2] = s + 4 } else Ci(k, i); r = r + p | 0; if ((r | 0) >= (c | 0)) { x = v; break } else o = v } } else { o = 0; r = 0; while (1) { v = f[a + (o << 2) >> 2] | 0; s = (_(v | 0) | 0) ^ 31; w = v >>> 0 > r >>> 0 ? v : r; y = (v | 0) == 0 ? 1 : s + 1 | 0; f[i >> 2] = y; s = f[d >> 2] | 0; if (s >>> 0 < (f[q >> 2] | 0) >>> 0) { f[s >> 2] = y; f[d >> 2] = s + 4 } else Ci(k, i); o = o + p | 0; if ((o | 0) >= (c | 0)) { x = w; break } else r = w } } f[l >> 2] = 0; r = l + 4 | 0; f[r >> 2] = 0; f[l + 8 >> 2] = 0; o = f[k >> 2] | 0; q = (f[d >> 2] | 0) - o | 0; w = q >> 2; if (w) { if (w >>> 0 > 1073741823) mq(l); s = dn(q) | 0; f[r >> 2] = s; f[l >> 2] = s; f[l + 8 >> 2] = s + (w << 2); w = s; if ((q | 0) > 0) { y = s + (q >>> 2 << 2) | 0; Rg(s | 0, o | 0, q | 0) | 0; f[r >> 2] = y; q = y - w >> 2; if ((y | 0) == (s | 0)) { z = q; A = s; B = 0; C = 0 } else { y = 0; o = 0; v = 0; while (1) { D = Tn(o | 0, v | 0, f[s + (y << 2) >> 2] | 0, 0) | 0; E = I; y = y + 1 | 0; if (y >>> 0 >= q >>> 0) { z = q; A = s; B = D; C = E; break } else { o = D; v = E } } } } else { F = w; G = 18 } } else { F = 0; G = 18 } if ((G | 0) == 18) { z = 0; A = F; B = 0; C = 0 } F = rg(A, z, 32, i) | 0; z = I; A = f[i >> 2] << 3; w = Rn(A | 0, ((A | 0) < 0) << 31 >> 31 | 0, 1) | 0; A = I; v = on(B | 0, C | 0, p | 0, 0) | 0; C = Tn(F | 0, z | 0, v | 0, I | 0) | 0; v = Tn(C | 0, I | 0, w | 0, A | 0) | 0; A = I; w = f[l >> 2] | 0; if (w | 0) { l = f[r >> 2] | 0; if ((l | 0) != (w | 0)) f[r >> 2] = l + (~((l + -4 - w | 0) >>> 2) << 2); br(w) } w = rg(a, c, x, i) | 0; l = f[i >> 2] | 0; r = ((x - l | 0) / 64 | 0) + l << 3; C = l << 3; z = Tn(w | 0, I | 0, C | 0, ((C | 0) < 0) << 31 >> 31 | 0) | 0; C = Tn(z | 0, I | 0, r | 0, ((r | 0) < 0) << 31 >> 31 | 0) | 0; r = I; z = (_((x >>> 0 > 1 ? x : 1) | 0) | 0) ^ 30; if (e) { f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; w = dn(32) | 0; f[i >> 2] = w; f[i + 8 >> 2] = -2147483616; f[i + 4 >> 2] = 22; F = w; B = 13044; o = F + 22 | 0; do { b[F >> 0] = b[B >> 0] | 0; F = F + 1 | 0; B = B + 1 | 0 } while ((F | 0) < (o | 0)); b[w + 22 >> 0] = 0; w = (sh(e, i) | 0) == 0; if ((b[i + 11 >> 0] | 0) < 0) br(f[i >> 2] | 0); if (!w) { f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; w = dn(32) | 0; f[i >> 2] = w; f[i + 8 >> 2] = -2147483616; f[i + 4 >> 2] = 22; F = w; B = 13044; o = F + 22 | 0; do { b[F >> 0] = b[B >> 0] | 0; F = F + 1 | 0; B = B + 1 | 0 } while ((F | 0) < (o | 0)); b[w + 22 >> 0] = 0; w = Ck(e, i) | 0; if ((b[i + 11 >> 0] | 0) < 0) br(f[i >> 2] | 0); H = w } else G = 32 } else G = 32; if ((G | 0) == 32) H = z >>> 0 < 18 & ((A | 0) > (r | 0) | (A | 0) == (r | 0) & v >>> 0 >= C >>> 0) & 1; b[m >> 0] = H; C = g + 16 | 0; v = f[C + 4 >> 2] | 0; if (!((v | 0) > 0 | (v | 0) == 0 & (f[C >> 2] | 0) >>> 0 > 0)) { f[j >> 2] = f[g + 4 >> 2]; f[i >> 2] = f[j >> 2]; ye(g, i, m, m + 1 | 0) | 0 } switch (H | 0) { case 0: { J = md(a, c, p, k, g) | 0; break } case 1: { J = Nc(a, c, x, l, e, g) | 0; break } default: J = 0 }g = f[k >> 2] | 0; if (g | 0) { k = f[d >> 2] | 0; if ((k | 0) != (g | 0)) f[d >> 2] = k + (~((k + -4 - g | 0) >>> 2) << 2); br(g) } n = J; u = h; return n | 0 } function Ec(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0; if ((b | 0) < 0) return; c = a + 12 | 0; d = f[c >> 2] | 0; e = f[a + 8 >> 2] | 0; g = e; h = d; if (d - e >> 2 >>> 0 <= b >>> 0) return; e = g + (b << 2) | 0; d = f[(f[e >> 2] | 0) + 56 >> 2] | 0; i = f[(f[g + (b << 2) >> 2] | 0) + 60 >> 2] | 0; g = e + 4 | 0; if ((g | 0) != (h | 0)) { j = g; g = e; do { k = f[j >> 2] | 0; f[j >> 2] = 0; l = f[g >> 2] | 0; f[g >> 2] = k; if (l | 0) { k = l + 88 | 0; m = f[k >> 2] | 0; f[k >> 2] = 0; if (m | 0) { k = f[m + 8 >> 2] | 0; if (k | 0) { n = m + 12 | 0; if ((f[n >> 2] | 0) != (k | 0)) f[n >> 2] = k; br(k) } br(m) } m = f[l + 68 >> 2] | 0; if (m | 0) { k = l + 72 | 0; n = f[k >> 2] | 0; if ((n | 0) != (m | 0)) f[k >> 2] = n + (~((n + -4 - m | 0) >>> 2) << 2); br(m) } m = l + 64 | 0; n = f[m >> 2] | 0; f[m >> 2] = 0; if (n | 0) { m = f[n >> 2] | 0; if (m | 0) { k = n + 4 | 0; if ((f[k >> 2] | 0) != (m | 0)) f[k >> 2] = m; br(m) } br(n) } br(l) } j = j + 4 | 0; g = g + 4 | 0 } while ((j | 0) != (h | 0)); j = f[c >> 2] | 0; if ((j | 0) != (g | 0)) { o = g; p = j; q = 24 } } else { o = e; p = h; q = 24 } if ((q | 0) == 24) { q = p; do { p = q + -4 | 0; f[c >> 2] = p; h = f[p >> 2] | 0; f[p >> 2] = 0; if (h | 0) { p = h + 88 | 0; e = f[p >> 2] | 0; f[p >> 2] = 0; if (e | 0) { p = f[e + 8 >> 2] | 0; if (p | 0) { j = e + 12 | 0; if ((f[j >> 2] | 0) != (p | 0)) f[j >> 2] = p; br(p) } br(e) } e = f[h + 68 >> 2] | 0; if (e | 0) { p = h + 72 | 0; j = f[p >> 2] | 0; if ((j | 0) != (e | 0)) f[p >> 2] = j + (~((j + -4 - e | 0) >>> 2) << 2); br(e) } e = h + 64 | 0; j = f[e >> 2] | 0; f[e >> 2] = 0; if (j | 0) { e = f[j >> 2] | 0; if (e | 0) { p = j + 4 | 0; if ((f[p >> 2] | 0) != (e | 0)) f[p >> 2] = e; br(e) } br(j) } br(h) } q = f[c >> 2] | 0 } while ((q | 0) != (o | 0)) } o = f[a + 4 >> 2] | 0; a: do if (o | 0) { q = o + 44 | 0; c = f[q >> 2] | 0; h = f[o + 40 >> 2] | 0; while (1) { if ((h | 0) == (c | 0)) break a; r = h + 4 | 0; if ((f[(f[h >> 2] | 0) + 40 >> 2] | 0) == (i | 0)) break; else h = r } if ((r | 0) != (c | 0)) { j = r; e = h; do { p = f[j >> 2] | 0; f[j >> 2] = 0; g = f[e >> 2] | 0; f[e >> 2] = p; if (g | 0) { Qi(g); br(g) } j = j + 4 | 0; e = e + 4 | 0 } while ((j | 0) != (c | 0)); j = f[q >> 2] | 0; if ((j | 0) == (e | 0)) break; else { s = e; t = j } } else { s = h; t = c } j = t; do { g = j + -4 | 0; f[q >> 2] = g; p = f[g >> 2] | 0; f[g >> 2] = 0; if (p | 0) { Qi(p); br(p) } j = f[q >> 2] | 0 } while ((j | 0) != (s | 0)) } while (0); b: do if ((d | 0) < 5) { s = f[a + 20 + (d * 12 | 0) >> 2] | 0; t = a + 20 + (d * 12 | 0) + 4 | 0; r = f[t >> 2] | 0; i = r; c: do if ((s | 0) == (r | 0)) u = s; else { o = s; while (1) { if ((f[o >> 2] | 0) == (b | 0)) { u = o; break c } o = o + 4 | 0; if ((o | 0) == (r | 0)) break b } } while (0); if ((u | 0) != (r | 0)) { s = u + 4 | 0; o = i - s | 0; j = o >> 2; if (!j) v = r; else { Xl(u | 0, s | 0, o | 0) | 0; v = f[t >> 2] | 0 } o = u + (j << 2) | 0; if ((v | 0) != (o | 0)) f[t >> 2] = v + (~((v + -4 - o | 0) >>> 2) << 2) } } while (0); v = f[a + 24 >> 2] | 0; u = f[a + 20 >> 2] | 0; d = u; if ((v | 0) != (u | 0)) { o = v - u >> 2; u = 0; do { v = d + (u << 2) | 0; j = f[v >> 2] | 0; if ((j | 0) > (b | 0)) f[v >> 2] = j + -1; u = u + 1 | 0 } while (u >>> 0 < o >>> 0) } o = f[a + 36 >> 2] | 0; u = f[a + 32 >> 2] | 0; d = u; if ((o | 0) != (u | 0)) { j = o - u >> 2; u = 0; do { o = d + (u << 2) | 0; v = f[o >> 2] | 0; if ((v | 0) > (b | 0)) f[o >> 2] = v + -1; u = u + 1 | 0 } while (u >>> 0 < j >>> 0) } j = f[a + 48 >> 2] | 0; u = f[a + 44 >> 2] | 0; d = u; if ((j | 0) != (u | 0)) { v = j - u >> 2; u = 0; do { j = d + (u << 2) | 0; o = f[j >> 2] | 0; if ((o | 0) > (b | 0)) f[j >> 2] = o + -1; u = u + 1 | 0 } while (u >>> 0 < v >>> 0) } v = f[a + 60 >> 2] | 0; u = f[a + 56 >> 2] | 0; d = u; if ((v | 0) != (u | 0)) { o = v - u >> 2; u = 0; do { v = d + (u << 2) | 0; j = f[v >> 2] | 0; if ((j | 0) > (b | 0)) f[v >> 2] = j + -1; u = u + 1 | 0 } while (u >>> 0 < o >>> 0) } o = f[a + 72 >> 2] | 0; u = f[a + 68 >> 2] | 0; a = u; if ((o | 0) == (u | 0)) return; d = o - u >> 2; u = 0; do { o = a + (u << 2) | 0; j = f[o >> 2] | 0; if ((j | 0) > (b | 0)) f[o >> 2] = j + -1; u = u + 1 | 0 } while (u >>> 0 < d >>> 0); return } function Fc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; d = u; u = u + 32 | 0; e = d + 16 | 0; g = d; h = c + 4 | 0; i = f[(f[h >> 2] | 0) + 48 >> 2] | 0; j = c + 12 | 0; c = f[j >> 2] | 0; k = dn(32) | 0; f[e >> 2] = k; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 17; l = k; m = 12932; n = l + 17 | 0; do { b[l >> 0] = b[m >> 0] | 0; l = l + 1 | 0; m = m + 1 | 0 } while ((l | 0) < (n | 0)); b[k + 17 >> 0] = 0; k = i + 16 | 0; o = f[k >> 2] | 0; if (o) { p = k; q = o; a: while (1) { o = q; while (1) { if ((f[o + 16 >> 2] | 0) >= (c | 0)) break; r = f[o + 4 >> 2] | 0; if (!r) { s = p; break a } else o = r } q = f[o >> 2] | 0; if (!q) { s = o; break } else p = o } if (((s | 0) != (k | 0) ? (c | 0) >= (f[s + 16 >> 2] | 0) : 0) ? (c = s + 20 | 0, (sh(c, e) | 0) != 0) : 0) t = yk(c, e, -1) | 0; else v = 10 } else v = 10; if ((v | 0) == 10) t = yk(i, e, -1) | 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); i = (1 << t) + -1 | 0; f[e >> 2] = -1; f[e + 4 >> 2] = -1; f[e + 8 >> 2] = -1; f[e + 12 >> 2] = -1; if (i & 1 | 0 ? (t = (_(i | 0) | 0) ^ 31, (t + -1 | 0) >>> 0 <= 28) : 0) { f[e >> 2] = t + 1; i = 2 << t; f[e + 4 >> 2] = i + -1; t = i + -2 | 0; f[e + 8 >> 2] = t; f[e + 12 >> 2] = (t | 0) / 2 | 0 } t = Ki(f[j >> 2] | 0, f[h >> 2] | 0) | 0; i = f[(f[h >> 2] | 0) + 48 >> 2] | 0; c = f[j >> 2] | 0; s = dn(32) | 0; f[g >> 2] = s; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 17; l = s; m = 12804; n = l + 17 | 0; do { b[l >> 0] = b[m >> 0] | 0; l = l + 1 | 0; m = m + 1 | 0 } while ((l | 0) < (n | 0)); b[s + 17 >> 0] = 0; s = i + 16 | 0; m = f[s >> 2] | 0; if (m) { l = s; n = m; b: while (1) { m = n; while (1) { if ((f[m + 16 >> 2] | 0) >= (c | 0)) break; k = f[m + 4 >> 2] | 0; if (!k) { w = l; break b } else m = k } n = f[m >> 2] | 0; if (!n) { w = m; break } else l = m } if (((w | 0) != (s | 0) ? (c | 0) >= (f[w + 16 >> 2] | 0) : 0) ? (c = w + 20 | 0, (sh(c, g) | 0) != 0) : 0) x = yk(c, g, t) | 0; else v = 25 } else v = 25; if ((v | 0) == 25) x = yk(i, g, t) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); switch (x | 0) { case 6: { x = f[j >> 2] | 0; t = f[h >> 2] | 0; i = f[(f[(f[t + 4 >> 2] | 0) + 8 >> 2] | 0) + (x << 2) >> 2] | 0; do if ((Qa[f[(f[t >> 2] | 0) + 8 >> 2] & 127](t) | 0) == 1) { rf(g, t, 6, x, e, 514); c = f[g >> 2] | 0; if (!c) { f[g >> 2] = 0; y = g; v = 34; break } else { z = g; A = c; break } } else { y = g; v = 34 } while (0); if ((v | 0) == 34) { x = dn(24) | 0; f[x + 4 >> 2] = i; i = x + 8 | 0; f[i >> 2] = f[e >> 2]; f[i + 4 >> 2] = f[e + 4 >> 2]; f[i + 8 >> 2] = f[e + 8 >> 2]; f[i + 12 >> 2] = f[e + 12 >> 2]; f[x >> 2] = 2320; i = x; f[g >> 2] = i; z = y; A = i } f[a >> 2] = A; f[z >> 2] = 0; u = d; return } case 0: { z = f[j >> 2] | 0; j = f[h >> 2] | 0; h = f[(f[(f[j + 4 >> 2] | 0) + 8 >> 2] | 0) + (z << 2) >> 2] | 0; do if ((Qa[f[(f[j >> 2] | 0) + 8 >> 2] & 127](j) | 0) == 1) { rf(g, j, 0, z, e, 514); A = f[g >> 2] | 0; if (!A) { f[g >> 2] = 0; B = g; v = 41; break } else { C = g; D = A; break } } else { B = g; v = 41 } while (0); if ((v | 0) == 41) { v = dn(24) | 0; f[v + 4 >> 2] = h; h = v + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; f[v >> 2] = 2320; e = v; f[g >> 2] = e; C = B; D = e } f[a >> 2] = D; f[C >> 2] = 0; u = d; return } default: { f[a >> 2] = 0; u = d; return } } } function Gc(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0; b = u; u = u + 32 | 0; c = b + 20 | 0; d = b + 8 | 0; e = b; g = a + 4 | 0; h = f[g >> 2] | 0; i = f[a >> 2] | 0; j = h - i | 0; k = j >> 2; f[c >> 2] = 0; l = c + 4 | 0; f[l >> 2] = 0; m = c + 8 | 0; f[m >> 2] = 0; n = i; if (k | 0) { if ((j | 0) < 0) mq(c); j = ((k + -1 | 0) >>> 5) + 1 | 0; o = dn(j << 2) | 0; f[c >> 2] = o; f[m >> 2] = j; f[l >> 2] = k; l = k >>> 5; hj(o | 0, 0, l << 2 | 0) | 0; j = k & 31; k = o + (l << 2) | 0; if (j | 0) f[k >> 2] = f[k >> 2] & ~(-1 >>> (32 - j | 0)) } f[d >> 2] = 0; j = d + 4 | 0; f[j >> 2] = 0; f[d + 8 >> 2] = 0; k = a + 12 | 0; l = e + 4 | 0; o = d + 8 | 0; m = n; n = h; h = i; while (1) { if ((n | 0) == (h | 0)) break; else { p = 0; q = 0; r = h; s = m } while (1) { i = f[c >> 2] | 0; do if (!(f[i + (q >>> 5 << 2) >> 2] & 1 << (q & 31))) { t = f[d >> 2] | 0; v = f[j >> 2] | 0; if ((v | 0) == (t | 0)) w = t; else { x = v + (~((v + -8 - t | 0) >>> 3) << 3) | 0; f[j >> 2] = x; w = x } x = q; while (1) { v = x + 1 | 0; y = ((v >>> 0) % 3 | 0 | 0) == 0 ? x + -2 | 0 : v; if ((y | 0) == -1) { z = x; A = r; B = i; C = s; D = t; E = w; break } v = f[(f[k >> 2] | 0) + (y << 2) >> 2] | 0; y = v + 1 | 0; if ((v | 0) == -1) { z = x; A = r; B = i; C = s; D = t; E = w; break } F = ((y >>> 0) % 3 | 0 | 0) == 0 ? v + -2 | 0 : y; if (!((F | 0) != (q | 0) & (F | 0) != -1)) { z = x; A = r; B = i; C = s; D = t; E = w; break } if (!(f[i + (F >>> 5 << 2) >> 2] & 1 << (F & 31))) x = F; else { z = x; A = r; B = i; C = s; D = t; E = w; break } } a: while (1) { t = B + (z >>> 5 << 2) | 0; f[t >> 2] = f[t >> 2] | 1 << (z & 31); t = z + 1 | 0; F = ((t >>> 0) % 3 | 0 | 0) == 0 ? z + -2 | 0 : t; t = f[C + (F << 2) >> 2] | 0; G = (((z >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + z | 0; if ((D | 0) != (E | 0)) if ((G | 0) == -1) { y = D; do { if ((f[y >> 2] | 0) == (t | 0) ? (v = f[y + 4 >> 2] | 0, (v | 0) != -1) : 0) { H = v; I = -1; J = -1; K = 25; break a } y = y + 8 | 0 } while ((y | 0) != (E | 0)) } else { y = D; do { if ((f[y >> 2] | 0) == (t | 0) ? (L = f[y + 4 >> 2] | 0, M = f[(f[k >> 2] | 0) + (G << 2) >> 2] | 0, (M | 0) != (L | 0)) : 0) { K = 24; break a } y = y + 8 | 0 } while ((y | 0) != (E | 0)) } f[e >> 2] = 0; f[e >> 2] = f[C + (G << 2) >> 2]; f[l >> 2] = F; if ((E | 0) == (f[o >> 2] | 0)) ei(d, e); else { y = e; t = f[y + 4 >> 2] | 0; v = E; f[v >> 2] = f[y >> 2]; f[v + 4 >> 2] = t; f[j >> 2] = (f[j >> 2] | 0) + 8 } if ((G | 0) == -1) { K = 38; break } t = f[(f[k >> 2] | 0) + (G << 2) >> 2] | 0; if ((t | 0) == -1) { K = 38; break } v = t + (((t >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if (!((v | 0) != (x | 0) & (v | 0) != -1)) { K = 40; break } t = f[a >> 2] | 0; z = v; A = t; B = f[c >> 2] | 0; C = t; D = f[d >> 2] | 0; E = f[j >> 2] | 0 } if ((K | 0) == 24) { K = 0; if ((L | 0) == -1) { N = -1; O = -1; P = M; Q = G } else { H = L; I = M; J = G; K = 25 } } else if ((K | 0) == 38) { K = 0; K = 40 } if ((K | 0) == 25) { K = 0; N = H; O = f[(f[k >> 2] | 0) + (H << 2) >> 2] | 0; P = I; Q = J } else if ((K | 0) == 40) { K = 0; R = p; S = f[a >> 2] | 0; break } if ((P | 0) != -1) f[(f[k >> 2] | 0) + (P << 2) >> 2] = -1; x = f[k >> 2] | 0; if ((O | 0) != -1) f[x + (O << 2) >> 2] = -1; f[x + (Q << 2) >> 2] = -1; f[x + (N << 2) >> 2] = -1; R = 1; S = A } else { R = p; S = r } while (0); q = q + 1 | 0; T = f[g >> 2] | 0; s = S; if (q >>> 0 >= T - S >> 2 >>> 0) break; else { p = R; r = S } } if (R) { m = s; n = T; h = S } else break } S = f[d >> 2] | 0; if (S | 0) { d = f[j >> 2] | 0; if ((d | 0) != (S | 0)) f[j >> 2] = d + (~((d + -8 - S | 0) >>> 3) << 3); br(S) } S = f[c >> 2] | 0; if (!S) { u = b; return 1 } br(S); u = b; return 1 } function Hc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0; e = a + 8 | 0; a: do if (f[e >> 2] | 0 ? (g = f[a >> 2] | 0, h = a + 4 | 0, f[a >> 2] = h, f[(f[h >> 2] | 0) + 8 >> 2] = 0, f[h >> 2] = 0, f[e >> 2] = 0, i = f[g + 4 >> 2] | 0, j = (i | 0) == 0 ? g : i, j | 0) : 0) { i = a + 4 | 0; g = j; j = f[c >> 2] | 0; while (1) { if ((j | 0) == (f[d >> 2] | 0)) break; k = g + 16 | 0; Ql(k, j + 16 | 0) | 0; Ql(g + 28 | 0, j + 28 | 0) | 0; l = g + 8 | 0; m = f[l >> 2] | 0; do if (m) { n = f[m >> 2] | 0; if ((n | 0) == (g | 0)) { f[m >> 2] = 0; o = f[m + 4 >> 2] | 0; if (!o) { p = m; break } else q = o; while (1) { o = f[q >> 2] | 0; if (o | 0) { q = o; continue } o = f[q + 4 >> 2] | 0; if (!o) break; else q = o } p = q; break } else { f[m + 4 >> 2] = 0; if (!n) { p = m; break } else r = n; while (1) { o = f[r >> 2] | 0; if (o | 0) { r = o; continue } o = f[r + 4 >> 2] | 0; if (!o) break; else r = o } p = r; break } } else p = 0; while (0); m = f[h >> 2] | 0; do if (m) { n = b[k + 11 >> 0] | 0; o = n << 24 >> 24 < 0; s = o ? f[g + 20 >> 2] | 0 : n & 255; n = o ? f[k >> 2] | 0 : k; o = m; while (1) { t = o + 16 | 0; u = b[t + 11 >> 0] | 0; v = u << 24 >> 24 < 0; w = v ? f[o + 20 >> 2] | 0 : u & 255; u = w >>> 0 < s >>> 0 ? w : s; if ((u | 0) != 0 ? (x = Pk(n, v ? f[t >> 2] | 0 : t, u) | 0, (x | 0) != 0) : 0) if ((x | 0) < 0) y = 22; else y = 24; else if (s >>> 0 < w >>> 0) y = 22; else y = 24; if ((y | 0) == 22) { y = 0; w = f[o >> 2] | 0; if (!w) { y = 23; break } else z = w } else if ((y | 0) == 24) { y = 0; A = o + 4 | 0; w = f[A >> 2] | 0; if (!w) { y = 26; break } else z = w } o = z } if ((y | 0) == 23) { y = 0; B = o; C = o; break } else if ((y | 0) == 26) { y = 0; B = A; C = o; break } } else { B = h; C = h } while (0); f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[l >> 2] = C; f[B >> 2] = g; m = f[f[a >> 2] >> 2] | 0; if (!m) D = g; else { f[a >> 2] = m; D = f[B >> 2] | 0 } Ae(f[i >> 2] | 0, D); f[e >> 2] = (f[e >> 2] | 0) + 1; m = f[j + 4 >> 2] | 0; if (!m) { k = j + 8 | 0; s = f[k >> 2] | 0; if ((f[s >> 2] | 0) == (j | 0)) E = s; else { s = k; do { k = f[s >> 2] | 0; s = k + 8 | 0; n = f[s >> 2] | 0 } while ((f[n >> 2] | 0) != (k | 0)); E = n } } else { s = m; while (1) { l = f[s >> 2] | 0; if (!l) break; else s = l } E = s } f[c >> 2] = E; if (!p) break a; else { g = p; j = E } } j = f[g + 8 >> 2] | 0; if (!j) F = g; else { i = j; while (1) { j = f[i + 8 >> 2] | 0; if (!j) break; else i = j } F = i } sj(a, F) } while (0); F = f[c >> 2] | 0; E = f[d >> 2] | 0; if ((F | 0) == (E | 0)) return; else G = F; while (1) { Qe(a, G + 16 | 0) | 0; F = f[G + 4 >> 2] | 0; if (!F) { d = G + 8 | 0; p = f[d >> 2] | 0; if ((f[p >> 2] | 0) == (G | 0)) H = p; else { p = d; do { d = f[p >> 2] | 0; p = d + 8 | 0; e = f[p >> 2] | 0 } while ((f[e >> 2] | 0) != (d | 0)); H = e } } else { p = F; while (1) { i = f[p >> 2] | 0; if (!i) break; else p = i } H = p } f[c >> 2] = H; if ((H | 0) == (E | 0)) break; else G = H } return } function Ic(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0; g = u; u = u + 16 | 0; h = g; i = c + 4 | 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; j = dn(16) | 0; f[h >> 2] = j; f[h + 8 >> 2] = -2147483632; f[h + 4 >> 2] = 15; k = j; l = 12916; m = k + 15 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[j + 15 >> 0] = 0; j = yk(i, h, -1) | 0; if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); switch (j | 0) { case 0: { n = dn(56) | 0; k = n; m = k + 56 | 0; do { f[k >> 2] = 0; k = k + 4 | 0 } while ((k | 0) < (m | 0)); zn(n); o = 3728; p = n; break } case -1: { if ((Yh(i) | 0) == 10) { n = dn(56) | 0; k = n; m = k + 56 | 0; do { f[k >> 2] = 0; k = k + 4 | 0 } while ((k | 0) < (m | 0)); zn(n); o = 3728; p = n } else q = 6; break } default: q = 6 }a: do if ((q | 0) == 6) { n = d + 8 | 0; r = d + 12 | 0; s = f[r >> 2] | 0; t = f[n >> 2] | 0; b: do if ((s - t | 0) > 0) { v = h + 8 | 0; w = h + 4 | 0; x = c + 20 | 0; y = h + 11 | 0; z = 0; A = t; B = s; c: while (1) { C = f[(f[A + (z << 2) >> 2] | 0) + 28 >> 2] | 0; switch (C | 0) { case 9: { q = 12; break } case 6: case 5: case 4: case 2: { D = A; E = B; break } default: { if ((C | 2 | 0) != 3) break c; if ((C | 0) == 9) q = 12; else { D = A; E = B } } }if ((q | 0) == 12) { q = 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; C = dn(32) | 0; f[h >> 2] = C; f[v >> 2] = -2147483616; f[w >> 2] = 17; k = C; l = 12932; m = k + 17 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[C + 17 >> 0] = 0; F = f[x >> 2] | 0; if (F) { G = x; H = F; d: while (1) { F = H; while (1) { if ((f[F + 16 >> 2] | 0) >= 0) break; I = f[F + 4 >> 2] | 0; if (!I) { J = G; break d } else F = I } H = f[F >> 2] | 0; if (!H) { J = F; break } else G = F } if (((J | 0) != (x | 0) ? (f[J + 16 >> 2] | 0) <= 0 : 0) ? (G = J + 20 | 0, (sh(G, h) | 0) != 0) : 0) K = yk(G, h, -1) | 0; else q = 21 } else q = 21; if ((q | 0) == 21) { q = 0; K = yk(i, h, -1) | 0 } if ((b[y >> 0] | 0) < 0) br(f[h >> 2] | 0); if ((K | 0) < 1) break; D = f[n >> 2] | 0; E = f[r >> 2] | 0 } z = z + 1 | 0; if ((z | 0) >= (E - D >> 2 | 0)) break b; else { A = D; B = E } } if ((j | 0) != 1) { B = dn(56) | 0; k = B; m = k + 56 | 0; do { f[k >> 2] = 0; k = k + 4 | 0 } while ((k | 0) < (m | 0)); zn(B); o = 3728; p = B; break a } f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; A = dn(32) | 0; f[h >> 2] = A; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 24; k = A; l = 12950; m = k + 24 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[A + 24 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, h); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); u = g; return } while (0); r = dn(56) | 0; k = r; m = k + 56 | 0; do { f[k >> 2] = 0; k = k + 4 | 0 } while ((k | 0) < (m | 0)); zn(r); o = 3668; p = r } while (0); f[p >> 2] = o; tp(p, d); Ad(a, p, i, e); if (!(f[a >> 2] | 0)) { e = a + 4 | 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); f[c + 40 >> 2] = f[p + 52 >> 2]; f[c + 44 >> 2] = 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0 } Va[f[(f[p >> 2] | 0) + 4 >> 2] & 127](p); u = g; return } function Jc(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; b = u; u = u + 32 | 0; c = b + 4 | 0; d = b; e = a + 16 | 0; g = f[e >> 2] | 0; if (g >>> 0 > 112) { f[e >> 2] = g + -113; g = a + 4 | 0; e = f[g >> 2] | 0; h = f[e >> 2] | 0; i = e + 4 | 0; f[g >> 2] = i; e = a + 8 | 0; j = f[e >> 2] | 0; k = a + 12 | 0; l = f[k >> 2] | 0; m = l; do if ((j | 0) == (l | 0)) { n = f[a >> 2] | 0; o = n; if (i >>> 0 > n >>> 0) { p = i; q = ((p - o >> 2) + 1 | 0) / -2 | 0; r = i + (q << 2) | 0; s = j - p | 0; p = s >> 2; if (!p) t = i; else { Xl(r | 0, i | 0, s | 0) | 0; t = f[g >> 2] | 0 } s = r + (p << 2) | 0; f[e >> 2] = s; f[g >> 2] = t + (q << 2); v = s; break } s = m - o >> 1; o = (s | 0) == 0 ? 1 : s; if (o >>> 0 > 1073741823) { s = ra(8) | 0; Wo(s, 14941); f[s >> 2] = 6944; va(s | 0, 1080, 114) } s = dn(o << 2) | 0; q = s; p = s + (o >>> 2 << 2) | 0; r = p; w = s + (o << 2) | 0; if ((i | 0) == (j | 0)) { x = r; y = n } else { n = p; p = r; o = i; do { f[n >> 2] = f[o >> 2]; n = p + 4 | 0; p = n; o = o + 4 | 0 } while ((o | 0) != (j | 0)); x = p; y = f[a >> 2] | 0 } f[a >> 2] = q; f[g >> 2] = r; f[e >> 2] = x; f[k >> 2] = w; if (!y) v = x; else { br(y); v = f[e >> 2] | 0 } } else v = j; while (0); f[v >> 2] = h; f[e >> 2] = (f[e >> 2] | 0) + 4; u = b; return } e = a + 8 | 0; h = f[e >> 2] | 0; v = a + 4 | 0; j = h - (f[v >> 2] | 0) | 0; y = a + 12 | 0; x = f[y >> 2] | 0; k = x - (f[a >> 2] | 0) | 0; if (j >>> 0 >= k >>> 0) { g = k >> 1; k = (g | 0) == 0 ? 1 : g; f[c + 12 >> 2] = 0; f[c + 16 >> 2] = a + 12; if (k >>> 0 > 1073741823) { g = ra(8) | 0; Wo(g, 14941); f[g >> 2] = 6944; va(g | 0, 1080, 114) } g = dn(k << 2) | 0; f[c >> 2] = g; i = g + (j >> 2 << 2) | 0; j = c + 8 | 0; f[j >> 2] = i; m = c + 4 | 0; f[m >> 2] = i; i = c + 12 | 0; f[i >> 2] = g + (k << 2); k = dn(4068) | 0; f[d >> 2] = k; kg(c, d); d = f[e >> 2] | 0; while (1) { z = f[v >> 2] | 0; if ((d | 0) == (z | 0)) break; k = d + -4 | 0; dg(c, k); d = k } k = z; z = f[a >> 2] | 0; f[a >> 2] = f[c >> 2]; f[c >> 2] = z; f[v >> 2] = f[m >> 2]; f[m >> 2] = k; m = f[e >> 2] | 0; f[e >> 2] = f[j >> 2]; f[j >> 2] = m; g = f[y >> 2] | 0; f[y >> 2] = f[i >> 2]; f[i >> 2] = g; g = m; if ((d | 0) != (g | 0)) f[j >> 2] = g + (~((g + -4 - k | 0) >>> 2) << 2); if (z | 0) br(z); u = b; return } if ((x | 0) != (h | 0)) { h = dn(4068) | 0; f[c >> 2] = h; kg(a, c); u = b; return } h = dn(4068) | 0; f[c >> 2] = h; dg(a, c); c = f[v >> 2] | 0; h = f[c >> 2] | 0; x = c + 4 | 0; f[v >> 2] = x; c = f[e >> 2] | 0; z = f[y >> 2] | 0; k = z; do if ((c | 0) == (z | 0)) { g = f[a >> 2] | 0; j = g; if (x >>> 0 > g >>> 0) { d = x; m = ((d - j >> 2) + 1 | 0) / -2 | 0; i = x + (m << 2) | 0; t = c - d | 0; d = t >> 2; if (!d) A = x; else { Xl(i | 0, x | 0, t | 0) | 0; A = f[v >> 2] | 0 } t = i + (d << 2) | 0; f[e >> 2] = t; f[v >> 2] = A + (m << 2); B = t; break } t = k - j >> 1; j = (t | 0) == 0 ? 1 : t; if (j >>> 0 > 1073741823) { t = ra(8) | 0; Wo(t, 14941); f[t >> 2] = 6944; va(t | 0, 1080, 114) } t = dn(j << 2) | 0; m = t; d = t + (j >>> 2 << 2) | 0; i = d; l = t + (j << 2) | 0; if ((x | 0) == (c | 0)) { C = i; D = g } else { g = d; d = i; j = x; do { f[g >> 2] = f[j >> 2]; g = d + 4 | 0; d = g; j = j + 4 | 0 } while ((j | 0) != (c | 0)); C = d; D = f[a >> 2] | 0 } f[a >> 2] = m; f[v >> 2] = i; f[e >> 2] = C; f[y >> 2] = l; if (!D) B = C; else { br(D); B = f[e >> 2] | 0 } } else B = c; while (0); f[B >> 2] = h; f[e >> 2] = (f[e >> 2] | 0) + 4; u = b; return } function Kc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0; e = u; u = u + 16 | 0; g = e + 8 | 0; h = e + 4 | 0; i = e; j = a + 64 | 0; k = f[j >> 2] | 0; if ((f[k + 28 >> 2] | 0) == (f[k + 24 >> 2] | 0)) { u = e; return } l = c + 96 | 0; c = a + 52 | 0; m = d + 84 | 0; n = d + 68 | 0; d = a + 56 | 0; o = a + 60 | 0; p = a + 12 | 0; q = a + 28 | 0; r = a + 40 | 0; s = a + 44 | 0; t = a + 48 | 0; v = 0; w = 0; x = k; while (1) { k = f[(f[x + 24 >> 2] | 0) + (w << 2) >> 2] | 0; if ((k | 0) == -1) { y = v; z = x } else { A = v + 1 | 0; B = f[(f[l >> 2] | 0) + (((k | 0) / 3 | 0) * 12 | 0) + (((k | 0) % 3 | 0) << 2) >> 2] | 0; if (!(b[m >> 0] | 0)) C = f[(f[n >> 2] | 0) + (B << 2) >> 2] | 0; else C = B; f[g >> 2] = C; B = f[d >> 2] | 0; if (B >>> 0 < (f[o >> 2] | 0) >>> 0) { f[B >> 2] = C; f[d >> 2] = B + 4 } else Ci(c, g); f[g >> 2] = k; f[h >> 2] = 0; a: do if (!(f[(f[p >> 2] | 0) + (w >>> 5 << 2) >> 2] & 1 << (w & 31))) D = k; else { B = k + 1 | 0; E = ((B >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : B; if (((E | 0) != -1 ? (f[(f[a >> 2] | 0) + (E >>> 5 << 2) >> 2] & 1 << (E & 31) | 0) == 0 : 0) ? (B = f[(f[(f[j >> 2] | 0) + 12 >> 2] | 0) + (E << 2) >> 2] | 0, E = B + 1 | 0, (B | 0) != -1) : 0) { F = ((E >>> 0) % 3 | 0 | 0) == 0 ? B + -2 | 0 : E; f[h >> 2] = F; if ((F | 0) == -1) { D = k; break } else G = F; while (1) { f[g >> 2] = G; F = G + 1 | 0; E = ((F >>> 0) % 3 | 0 | 0) == 0 ? G + -2 | 0 : F; if ((E | 0) == -1) break; if (f[(f[a >> 2] | 0) + (E >>> 5 << 2) >> 2] & 1 << (E & 31) | 0) break; F = f[(f[(f[j >> 2] | 0) + 12 >> 2] | 0) + (E << 2) >> 2] | 0; E = F + 1 | 0; if ((F | 0) == -1) break; B = ((E >>> 0) % 3 | 0 | 0) == 0 ? F + -2 | 0 : E; f[h >> 2] = B; if ((B | 0) == -1) { D = G; break a } else G = B } f[h >> 2] = -1; D = G; break } f[h >> 2] = -1; D = k } while (0); f[(f[q >> 2] | 0) + (D << 2) >> 2] = v; k = f[s >> 2] | 0; if ((k | 0) == (f[t >> 2] | 0)) Ci(r, g); else { f[k >> 2] = f[g >> 2]; f[s >> 2] = k + 4 } k = f[j >> 2] | 0; B = f[g >> 2] | 0; b: do if (((B | 0) != -1 ? (E = (((B >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + B | 0, (E | 0) != -1) : 0) ? (F = f[(f[k + 12 >> 2] | 0) + (E << 2) >> 2] | 0, (F | 0) != -1) : 0) { E = F + (((F >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; f[h >> 2] = E; if ((E | 0) != -1 & (E | 0) != (B | 0)) { F = A; H = v; I = E; while (1) { E = I + 1 | 0; J = ((E >>> 0) % 3 | 0 | 0) == 0 ? I + -2 | 0 : E; do if (f[(f[a >> 2] | 0) + (J >>> 5 << 2) >> 2] & 1 << (J & 31)) { E = F + 1 | 0; K = f[(f[l >> 2] | 0) + (((I | 0) / 3 | 0) * 12 | 0) + (((I | 0) % 3 | 0) << 2) >> 2] | 0; if (!(b[m >> 0] | 0)) L = f[(f[n >> 2] | 0) + (K << 2) >> 2] | 0; else L = K; f[i >> 2] = L; K = f[d >> 2] | 0; if (K >>> 0 < (f[o >> 2] | 0) >>> 0) { f[K >> 2] = L; f[d >> 2] = K + 4 } else Ci(c, i); K = f[s >> 2] | 0; if ((K | 0) == (f[t >> 2] | 0)) { Ci(r, h); M = E; N = F; break } else { f[K >> 2] = f[h >> 2]; f[s >> 2] = K + 4; M = E; N = F; break } } else { M = F; N = H } while (0); f[(f[q >> 2] | 0) + (f[h >> 2] << 2) >> 2] = N; O = f[j >> 2] | 0; J = f[h >> 2] | 0; if ((J | 0) == -1) break; E = (((J >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + J | 0; if ((E | 0) == -1) break; J = f[(f[O + 12 >> 2] | 0) + (E << 2) >> 2] | 0; if ((J | 0) == -1) break; I = J + (((J >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; f[h >> 2] = I; if (!((I | 0) != -1 ? (I | 0) != (f[g >> 2] | 0) : 0)) { P = M; Q = O; break b } else { F = M; H = N } } f[h >> 2] = -1; P = M; Q = O } else { P = A; Q = k } } else R = 28; while (0); if ((R | 0) == 28) { R = 0; f[h >> 2] = -1; P = A; Q = k } y = P; z = Q } w = w + 1 | 0; if (w >>> 0 >= (f[z + 28 >> 2] | 0) - (f[z + 24 >> 2] | 0) >> 2 >>> 0) break; else { v = y; x = z } } u = e; return } function Lc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0.0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, D = 0, E = 0, F = 0; switch (c | 0) { case 0: { e = -149; g = 24; i = 4; break } case 1: { e = -1074; g = 53; i = 4; break } case 2: { e = -1074; g = 53; i = 4; break } default: j = 0.0 }a: do if ((i | 0) == 4) { c = a + 4 | 0; k = a + 100 | 0; do { l = f[c >> 2] | 0; if (l >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = l + 1; m = h[l >> 0] | 0 } else m = Di(a) | 0 } while ((tq(m) | 0) != 0); b: do switch (m | 0) { case 43: case 45: { l = 1 - (((m | 0) == 45 & 1) << 1) | 0; n = f[c >> 2] | 0; if (n >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = n + 1; o = h[n >> 0] | 0; p = l; break b } else { o = Di(a) | 0; p = l; break b } break } default: { o = m; p = 1 } } while (0); l = 0; n = o; while (1) { if ((n | 32 | 0) != (b[17452 + l >> 0] | 0)) { q = l; r = n; break } do if (l >>> 0 < 7) { s = f[c >> 2] | 0; if (s >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = s + 1; t = h[s >> 0] | 0; break } else { t = Di(a) | 0; break } } else t = n; while (0); s = l + 1 | 0; if (s >>> 0 < 8) { l = s; n = t } else { q = s; r = t; break } } c: do switch (q | 0) { case 8: break; case 3: { i = 23; break } default: { n = (d | 0) != 0; if (n & q >>> 0 > 3) if ((q | 0) == 8) break c; else { i = 23; break c } d: do if (!q) { l = 0; s = r; while (1) { if ((s | 32 | 0) != (b[17461 + l >> 0] | 0)) { u = l; v = s; break d } do if (l >>> 0 < 2) { w = f[c >> 2] | 0; if (w >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = w + 1; x = h[w >> 0] | 0; break } else { x = Di(a) | 0; break } } else x = s; while (0); w = l + 1 | 0; if (w >>> 0 < 3) { l = w; s = x } else { u = w; v = x; break } } } else { u = q; v = r } while (0); switch (u | 0) { case 3: { s = f[c >> 2] | 0; if (s >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = s + 1; y = h[s >> 0] | 0 } else y = Di(a) | 0; if ((y | 0) == 40) z = 1; else { if (!(f[k >> 2] | 0)) { j = B; break a } f[c >> 2] = (f[c >> 2] | 0) + -1; j = B; break a } while (1) { s = f[c >> 2] | 0; if (s >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = s + 1; A = h[s >> 0] | 0 } else A = Di(a) | 0; if (!((A + -48 | 0) >>> 0 < 10 | (A + -65 | 0) >>> 0 < 26) ? !((A | 0) == 95 | (A + -97 | 0) >>> 0 < 26) : 0) break; z = z + 1 | 0 } if ((A | 0) == 41) { j = B; break a } s = (f[k >> 2] | 0) == 0; if (!s) f[c >> 2] = (f[c >> 2] | 0) + -1; if (!n) { l = ir() | 0; f[l >> 2] = 22; Rm(a, 0); j = 0.0; break a } if (!z) { j = B; break a } else D = z; while (1) { D = D + -1 | 0; if (!s) f[c >> 2] = (f[c >> 2] | 0) + -1; if (!D) { j = B; break a } } break } case 0: { if ((v | 0) == 48) { s = f[c >> 2] | 0; if (s >>> 0 < (f[k >> 2] | 0) >>> 0) { f[c >> 2] = s + 1; E = h[s >> 0] | 0 } else E = Di(a) | 0; if ((E | 32 | 0) == 120) { j = +yc(a, g, e, p, d); break a } if (!(f[k >> 2] | 0)) F = 48; else { f[c >> 2] = (f[c >> 2] | 0) + -1; F = 48 } } else F = v; j = +ob(a, F, g, e, p, d); break a; break } default: { if (f[k >> 2] | 0) f[c >> 2] = (f[c >> 2] | 0) + -1; s = ir() | 0; f[s >> 2] = 22; Rm(a, 0); j = 0.0; break a } } } } while (0); if ((i | 0) == 23) { s = (f[k >> 2] | 0) == 0; if (!s) f[c >> 2] = (f[c >> 2] | 0) + -1; if ((d | 0) != 0 & q >>> 0 > 3) { n = q; do { if (!s) f[c >> 2] = (f[c >> 2] | 0) + -1; n = n + -1 | 0 } while (n >>> 0 > 3) } } j = +$($(p | 0) * $(C)) } while (0); return +j } function Mc(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; e = f[a + 64 >> 2] | 0; if (!e) { u = b; return } g = Qa[f[(f[e >> 2] | 0) + 32 >> 2] & 127](e) | 0; if (!g) { u = b; return } e = g + 24 | 0; h = g + 28 | 0; i = ((f[h >> 2] | 0) - (f[e >> 2] | 0) >> 2) - (f[g + 44 >> 2] | 0) | 0; j = a + 56 | 0; k = f[j >> 2] | 0; if (((f[k + 12 >> 2] | 0) - (f[k + 8 >> 2] | 0) | 0) > 4) { f[c >> 2] = 0; l = c + 4 | 0; f[l >> 2] = 0; f[c + 8 >> 2] = 0; m = c + 8 | 0; n = 0; o = k; while (1) { if (!(f[(f[(f[o + 8 >> 2] | 0) + (n << 2) >> 2] | 0) + 56 >> 2] | 0)) p = o; else { k = Ra[f[(f[a >> 2] | 0) + 56 >> 2] & 127](a, n) | 0; f[d >> 2] = k; q = k; do if (k | 0) { r = f[l >> 2] | 0; if ((r | 0) == (f[m >> 2] | 0)) { Ci(c, d); break } else { f[r >> 2] = q; f[l >> 2] = (f[l >> 2] | 0) + 4; break } } while (0); p = f[j >> 2] | 0 } n = n + 1 | 0; if ((n | 0) >= ((f[p + 12 >> 2] | 0) - (f[p + 8 >> 2] | 0) >> 2 | 0)) break; else o = p } o = f[h >> 2] | 0; h = f[e >> 2] | 0; e = h; if ((o | 0) == (h | 0)) { s = i; t = f[c >> 2] | 0 } else { n = o - h >> 2; h = g + 12 | 0; g = f[l >> 2] | 0; o = f[c >> 2] | 0; c = (g | 0) == (o | 0); j = o; d = g - o >> 2; o = p + 96 | 0; p = i; g = 0; while (1) { m = f[e + (g << 2) >> 2] | 0; if ((m | 0) == -1) v = p; else { q = f[o >> 2] | 0; k = f[q + (((m | 0) / 3 | 0) * 12 | 0) + (((m | 0) % 3 | 0) << 2) >> 2] | 0; r = (((m >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + m | 0; a: do if (((r | 0) != -1 ? (w = f[(f[h >> 2] | 0) + (r << 2) >> 2] | 0, (w | 0) != -1) : 0) ? (x = w + (((w >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0, (x | 0) != -1) : 0) { if (c) { w = 0; y = x; z = k; while (1) { A = z; z = f[q + (((y | 0) / 3 | 0) * 12 | 0) + (((y | 0) % 3 | 0) << 2) >> 2] | 0; B = w + ((z | 0) != (A | 0) & 1) | 0; if ((y | 0) == (m | 0)) { C = B; break a } A = (((y >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + y | 0; if ((A | 0) == -1) { C = B; break a } D = f[(f[h >> 2] | 0) + (A << 2) >> 2] | 0; if ((D | 0) == -1) { C = B; break a } y = D + (((D >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((y | 0) == -1) { C = B; break a } else w = B } } else { E = 0; F = x; G = m; H = k } while (1) { w = f[q + (((F | 0) / 3 | 0) * 12 | 0) + (((F | 0) % 3 | 0) << 2) >> 2] | 0; b: do if ((w | 0) == (H | 0)) { y = 0; while (1) { z = f[(f[j + (y << 2) >> 2] | 0) + 28 >> 2] | 0; y = y + 1 | 0; if ((f[z + (F << 2) >> 2] | 0) != (f[z + (G << 2) >> 2] | 0)) { I = H; J = 28; break b } if (y >>> 0 >= d >>> 0) { K = H; L = E; break } } } else { I = w; J = 28 } while (0); if ((J | 0) == 28) { J = 0; K = I; L = E + 1 | 0 } if ((F | 0) == (m | 0)) { C = L; break a } w = (((F >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + F | 0; if ((w | 0) == -1) { C = L; break a } y = f[(f[h >> 2] | 0) + (w << 2) >> 2] | 0; if ((y | 0) == -1) { C = L; break a } w = y + (((y >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((w | 0) == -1) { C = L; break } else { y = F; E = L; F = w; H = K; G = y } } } else C = 0; while (0); m = f[e + (g << 2) >> 2] | 0; q = m + 1 | 0; if (((m | 0) != -1 ? (k = ((q >>> 0) % 3 | 0 | 0) == 0 ? m + -2 | 0 : q, (k | 0) != -1) : 0) ? (q = f[(f[h >> 2] | 0) + (k << 2) >> 2] | 0, k = q + 1 | 0, (q | 0) != -1) : 0) M = ((((k >>> 0) % 3 | 0 | 0) == 0 ? q + -2 | 0 : k) | 0) == -1; else M = 1; v = C + p + (((C | 0) != 0 & (M ^ 1)) << 31 >> 31) | 0 } g = g + 1 | 0; if (g >>> 0 >= n >>> 0) { s = v; t = j; break } else p = v } } if (t | 0) { v = f[l >> 2] | 0; if ((v | 0) != (t | 0)) f[l >> 2] = v + (~((v + -4 - t | 0) >>> 2) << 2); br(t) } N = s } else N = i; f[a + 52 >> 2] = N; u = b; return } function Nc(a, c, d, e, g, h) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; i = u; u = u + 32 | 0; j = i + 4 | 0; k = i; l = i + 16 | 0; m = (_(e | 0) | 0) ^ 31; if ((e | 0) > 0) if (m >>> 0 > 17) { n = 0; u = i; return n | 0 } else o = m + 1 | 0; else o = 1; do if (g) { m = dn(48) | 0; f[j >> 2] = m; f[j + 8 >> 2] = -2147483600; f[j + 4 >> 2] = 33; e = m; p = 13067; q = e + 33 | 0; do { b[e >> 0] = b[p >> 0] | 0; e = e + 1 | 0; p = p + 1 | 0 } while ((e | 0) < (q | 0)); b[m + 33 >> 0] = 0; r = (sh(g, j) | 0) == 0; if ((b[j + 11 >> 0] | 0) < 0) br(f[j >> 2] | 0); if (!r) { r = dn(48) | 0; f[j >> 2] = r; f[j + 8 >> 2] = -2147483600; f[j + 4 >> 2] = 33; e = r; p = 13067; q = e + 33 | 0; do { b[e >> 0] = b[p >> 0] | 0; e = e + 1 | 0; p = p + 1 | 0 } while ((e | 0) < (q | 0)); b[r + 33 >> 0] = 0; p = Ck(g, j) | 0; if ((b[j + 11 >> 0] | 0) < 0) br(f[j >> 2] | 0); if ((p | 0) < 4) { s = o + -2 | 0; break } if ((p | 0) < 6) { s = o + -1 | 0; break } if ((p | 0) > 9) { s = o + 2 | 0; break } else { s = o + ((p | 0) > 7 & 1) | 0; break } } else s = o } else s = o; while (0); o = (s | 0) > 1 ? s : 1; s = (o | 0) < 18 ? o : 18; b[l >> 0] = s; o = h + 16 | 0; g = f[o + 4 >> 2] | 0; if (!((g | 0) > 0 | (g | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[k >> 2] = f[h + 4 >> 2]; f[j >> 2] = f[k >> 2]; ye(h, j, l, l + 1 | 0) | 0 } do switch (s & 31) { case 1: case 0: { n = je(a, c, d, h) | 0; u = i; return n | 0 } case 2: { n = ie(a, c, d, h) | 0; u = i; return n | 0 } case 3: { n = he(a, c, d, h) | 0; u = i; return n | 0 } case 4: { n = ge(a, c, d, h) | 0; u = i; return n | 0 } case 5: { n = fe(a, c, d, h) | 0; u = i; return n | 0 } case 6: { n = ee(a, c, d, h) | 0; u = i; return n | 0 } case 7: { n = de(a, c, d, h) | 0; u = i; return n | 0 } case 8: { n = ce(a, c, d, h) | 0; u = i; return n | 0 } case 9: { n = be(a, c, d, h) | 0; u = i; return n | 0 } case 10: { n = ae(a, c, d, h) | 0; u = i; return n | 0 } case 11: { n = $d(a, c, d, h) | 0; u = i; return n | 0 } case 12: { n = _d(a, c, d, h) | 0; u = i; return n | 0 } case 13: { n = Zd(a, c, d, h) | 0; u = i; return n | 0 } case 14: { n = Yd(a, c, d, h) | 0; u = i; return n | 0 } case 15: { n = Xd(a, c, d, h) | 0; u = i; return n | 0 } case 16: { n = Wd(a, c, d, h) | 0; u = i; return n | 0 } case 17: { n = Vd(a, c, d, h) | 0; u = i; return n | 0 } case 18: { n = Ud(a, c, d, h) | 0; u = i; return n | 0 } default: { n = 0; u = i; return n | 0 } } while (0); return 0 } function Oc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 1048576.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 1048576) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; wb(z, A, g); a: do if ((x | 0) < 1048576) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 1048576 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 1048576; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -1048576 | 0; m = x; while (1) { v = 1048576.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 1048576) { C = p; D = 1048576; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 1048576) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 9.5367431640625e-07) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Pc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 1048576.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 1048576) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; xb(z, A, g); a: do if ((x | 0) < 1048576) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 1048576 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 1048576; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -1048576 | 0; m = x; while (1) { v = 1048576.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 1048576) { C = p; D = 1048576; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 1048576) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 9.5367431640625e-07) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Qc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 1048576.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 1048576) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; yb(z, A, g); a: do if ((x | 0) < 1048576) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 1048576 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 1048576; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -1048576 | 0; m = x; while (1) { v = 1048576.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 1048576) { C = p; D = 1048576; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 1048576) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 9.5367431640625e-07) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Rc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 1048576.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 1048576) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; zb(z, A, g); a: do if ((x | 0) < 1048576) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 1048576 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 1048576; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -1048576 | 0; m = x; while (1) { v = 1048576.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 1048576) { C = p; D = 1048576; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 1048576) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 9.5367431640625e-07) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Sc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 1048576.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 1048576) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Ab(z, A, g); a: do if ((x | 0) < 1048576) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 1048576 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 1048576; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -1048576 | 0; m = x; while (1) { v = 1048576.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 1048576) { C = p; D = 1048576; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 1048576) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 9.5367431640625e-07) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Tc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 524288.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 524288) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Eb(z, A, g); a: do if ((x | 0) < 524288) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 524288 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 524288; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -524288 | 0; m = x; while (1) { v = 524288.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 524288) { C = p; D = 524288; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 524288) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 1.9073486328125e-06) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Uc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 262144.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 262144) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Bb(z, A, g); a: do if ((x | 0) < 262144) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 262144 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 262144; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -262144 | 0; m = x; while (1) { v = 262144.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 262144) { C = p; D = 262144; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 262144) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * 3.814697265625e-06) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Vc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 65536.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 65536) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Cb(z, A, g); a: do if ((x | 0) < 65536) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 65536 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 65536; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -65536 | 0; m = x; while (1) { v = 65536.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 65536) { C = p; D = 65536; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 65536) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .0000152587890625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Wc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 32768.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 32768) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Db(z, A, g); a: do if ((x | 0) < 32768) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 32768 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 32768; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -32768 | 0; m = x; while (1) { v = 32768.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 32768) { C = p; D = 32768; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 32768) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000030517578125) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Xc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 8192.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 8192) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Fb(z, A, g); a: do if ((x | 0) < 8192) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 8192 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 8192; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -8192 | 0; m = x; while (1) { v = 8192.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 8192) { C = p; D = 8192; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 8192) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .0001220703125) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Yc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Gb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function Zc(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Hb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function _c(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Ib(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function $c(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Jb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function ad(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Kb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function bd(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Lb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function cd(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Mb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function dd(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0.0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0.0, F = 0.0, G = 0.0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; if ((c | 0) > 0) { i = 0; j = 0; k = 0; l = 0; while (1) { m = b + (j << 3) | 0; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; m = Tn(n | 0, o | 0, k | 0, l | 0) | 0; p = I; q = (n | 0) == 0 & (o | 0) == 0 ? i : j; j = j + 1 | 0; if ((j | 0) == (c | 0)) { r = q; s = p; t = m; break } else { i = q; k = m; l = p } } } else { r = 0; s = 0; t = 0 } l = r + 1 | 0; f[a + 12 >> 2] = l; k = a + 4 | 0; i = f[k >> 2] | 0; c = f[a >> 2] | 0; j = i - c >> 3; p = c; c = i; if (l >>> 0 <= j >>> 0) { if (l >>> 0 < j >>> 0 ? (i = p + (l << 3) | 0, (i | 0) != (c | 0)) : 0) f[k >> 2] = c + (~((c + -8 - i | 0) >>> 3) << 3) } else dh(a, l - j | 0); v = +(t >>> 0) + 4294967296.0 * +(s >>> 0); s = (r | 0) < 0; if (!s) { t = f[a >> 2] | 0; j = 0; i = 0; do { c = b + (i << 3) | 0; k = f[c >> 2] | 0; p = f[c + 4 >> 2] | 0; c = ~~((+(k >>> 0) + 4294967296.0 * +(p >>> 0)) / v * 4096.0 + .5) >>> 0; m = ((k | 0) != 0 | (p | 0) != 0) & (c | 0) == 0 ? 1 : c; f[t + (i << 3) >> 2] = m; j = m + j | 0; i = i + 1 | 0 } while ((i | 0) != (l | 0)); if ((j | 0) == 4096) { if (s) { w = 0; u = e; return w | 0 } } else { x = j; y = 12 } } else { x = 0; y = 12 } if ((y | 0) == 12) { f[h >> 2] = 0; j = h + 4 | 0; f[j >> 2] = 0; f[h + 8 >> 2] = 0; do if (l) if (l >>> 0 > 1073741823) mq(h); else { i = l << 2; t = dn(i) | 0; f[h >> 2] = t; m = t + (l << 2) | 0; f[h + 8 >> 2] = m; hj(t | 0, 0, i | 0) | 0; f[j >> 2] = m; z = t; A = m; break } else { z = 0; A = 0 } while (0); if (!s ? (f[z >> 2] = 0, r | 0) : 0) { m = 1; do { f[z + (m << 2) >> 2] = m; m = m + 1 | 0 } while ((m | 0) != (l | 0)) } f[g >> 2] = a; Nb(z, A, g); a: do if ((x | 0) < 4096) { g = (f[a >> 2] | 0) + (f[(f[j >> 2] | 0) + -4 >> 2] << 3) | 0; f[g >> 2] = 4096 - x + (f[g >> 2] | 0); B = 0 } else { g = f[h >> 2] | 0; if ((r | 0) <= 0) { A = (x | 0) > 4096; while (1) if (!A) { B = 0; break a } } A = f[a >> 2] | 0; z = x + -4096 | 0; m = x; while (1) { v = 4096.0 / +(m | 0); t = r; i = z; c = m; while (1) { p = A + (f[g + (t << 2) >> 2] << 3) | 0; k = f[p >> 2] | 0; if (k >>> 0 < 2) { y = 28; break } q = k - ~~+J(+(v * +(k >>> 0))) | 0; o = (q | 0) == 0 ? 1 : q; q = (o | 0) < (k | 0) ? o : k + -1 | 0; o = (q | 0) > (i | 0) ? i : q; f[p >> 2] = k - o; k = c - o | 0; p = i - o | 0; if ((k | 0) == 4096) { C = p; D = 4096; break } if ((t | 0) > 1) { t = t + -1 | 0; i = p; c = k } else { C = p; D = k; break } } if ((y | 0) == 28) { y = 0; if ((t | 0) == (r | 0)) { B = 1; break a } else { C = i; D = c } } if ((C | 0) > 0) { z = C; m = D } else { B = 0; break } } } while (0); D = f[h >> 2] | 0; if (D | 0) { h = f[j >> 2] | 0; if ((h | 0) != (D | 0)) f[j >> 2] = h + (~((h + -4 - D | 0) >>> 2) << 2); br(D) } if ((B | 0) != 0 | s) { w = 0; u = e; return w | 0 } } B = f[a >> 2] | 0; D = 0; h = 0; do { f[B + (D << 3) + 4 >> 2] = h; h = (f[B + (D << 3) >> 2] | 0) + h | 0; D = D + 1 | 0 } while ((D | 0) != (l | 0)); if ((h | 0) != 4096) { w = 0; u = e; return w | 0 } if (s) E = 0.0; else { s = f[a >> 2] | 0; h = 0; v = 0.0; while (1) { D = f[s + (h << 3) >> 2] | 0; if (!D) F = v; else { B = b + (h << 3) | 0; G = +((f[B >> 2] | 0) >>> 0) + 4294967296.0 * +((f[B + 4 >> 2] | 0) >>> 0); F = v + +Fg(+(D >>> 0) * .000244140625) * G } h = h + 1 | 0; if ((h | 0) == (l | 0)) { E = F; break } else v = F } } F = +W(+-E); l = +K(F) >= 1.0 ? (F > 0.0 ? ~~+Y(+J(F / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((F - +(~~F >>> 0)) / 4294967296.0) >>> 0) : 0; h = a + 16 | 0; f[h >> 2] = ~~F >>> 0; f[h + 4 >> 2] = l; w = xe(a, d) | 0; u = e; return w | 0 } function ed(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0; g = u; u = u + 32 | 0; d = g + 16 | 0; h = g + 8 | 0; i = g; j = e >>> 0 > 1073741823 ? -1 : e << 2; k = _q(j) | 0; hj(k | 0, 0, j | 0) | 0; j = f[a + 28 >> 2] | 0; l = a + 36 | 0; m = f[l >> 2] | 0; n = f[m + 4 >> 2] | 0; o = f[m >> 2] | 0; p = n - o | 0; a: do if ((p | 0) > 4) { q = p >> 2; r = f[a + 32 >> 2] | 0; s = a + 8 | 0; t = h + 4 | 0; v = i + 4 | 0; w = d + 4 | 0; x = j + 12 | 0; y = (e | 0) > 0; z = k + 4 | 0; A = h + 4 | 0; B = i + 4 | 0; C = d + 4 | 0; D = q + -1 | 0; if (n - o >> 2 >>> 0 > D >>> 0) { E = q; F = D; G = o } else { H = m; mq(H) } while (1) { D = f[G + (F << 2) >> 2] | 0; q = X(F, e) | 0; if ((D | 0) != -1 ? (I = f[(f[x >> 2] | 0) + (D << 2) >> 2] | 0, (I | 0) != -1) : 0) { D = f[j >> 2] | 0; J = f[r >> 2] | 0; K = f[J + (f[D + (I << 2) >> 2] << 2) >> 2] | 0; L = I + 1 | 0; M = ((L >>> 0) % 3 | 0 | 0) == 0 ? I + -2 | 0 : L; if ((M | 0) == -1) N = -1; else N = f[D + (M << 2) >> 2] | 0; M = f[J + (N << 2) >> 2] | 0; L = (((I >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + I | 0; if ((L | 0) == -1) O = -1; else O = f[D + (L << 2) >> 2] | 0; L = f[J + (O << 2) >> 2] | 0; if ((K | 0) < (F | 0) & (M | 0) < (F | 0) & (L | 0) < (F | 0)) { J = X(K, e) | 0; K = X(M, e) | 0; M = X(L, e) | 0; if (y) { L = 0; do { f[k + (L << 2) >> 2] = (f[b + (L + M << 2) >> 2] | 0) + (f[b + (L + K << 2) >> 2] | 0) - (f[b + (L + J << 2) >> 2] | 0); L = L + 1 | 0 } while ((L | 0) != (e | 0)) } L = b + (q << 2) | 0; J = c + (q << 2) | 0; K = f[L + 4 >> 2] | 0; M = f[k >> 2] | 0; D = f[z >> 2] | 0; f[h >> 2] = f[L >> 2]; f[A >> 2] = K; f[i >> 2] = M; f[B >> 2] = D; Dd(d, s, h, i); f[J >> 2] = f[d >> 2]; f[J + 4 >> 2] = f[C >> 2] } else P = 15 } else P = 15; if ((P | 0) == 15) { P = 0; J = b + (q << 2) | 0; D = b + ((X(E + -2 | 0, e) | 0) << 2) | 0; M = c + (q << 2) | 0; K = f[J + 4 >> 2] | 0; L = f[D >> 2] | 0; I = f[D + 4 >> 2] | 0; f[h >> 2] = f[J >> 2]; f[t >> 2] = K; f[i >> 2] = L; f[v >> 2] = I; Dd(d, s, h, i); f[M >> 2] = f[d >> 2]; f[M + 4 >> 2] = f[w >> 2] } if ((E | 0) <= 2) break a; M = f[l >> 2] | 0; G = f[M >> 2] | 0; I = F + -1 | 0; if ((f[M + 4 >> 2] | 0) - G >> 2 >>> 0 <= I >>> 0) { H = M; break } else { M = F; F = I; E = M } } mq(H) } while (0); if ((e | 0) <= 0) { Q = a + 8 | 0; R = b + 4 | 0; S = f[b >> 2] | 0; T = f[R >> 2] | 0; U = k + 4 | 0; V = f[k >> 2] | 0; W = f[U >> 2] | 0; f[h >> 2] = S; Y = h + 4 | 0; f[Y >> 2] = T; f[i >> 2] = V; Z = i + 4 | 0; f[Z >> 2] = W; Dd(d, Q, h, i); _ = f[d >> 2] | 0; f[c >> 2] = _; $ = d + 4 | 0; aa = f[$ >> 2] | 0; ba = c + 4 | 0; f[ba >> 2] = aa; $q(k); u = g; return 1 } hj(k | 0, 0, e << 2 | 0) | 0; Q = a + 8 | 0; R = b + 4 | 0; S = f[b >> 2] | 0; T = f[R >> 2] | 0; U = k + 4 | 0; V = f[k >> 2] | 0; W = f[U >> 2] | 0; f[h >> 2] = S; Y = h + 4 | 0; f[Y >> 2] = T; f[i >> 2] = V; Z = i + 4 | 0; f[Z >> 2] = W; Dd(d, Q, h, i); _ = f[d >> 2] | 0; f[c >> 2] = _; $ = d + 4 | 0; aa = f[$ >> 2] | 0; ba = c + 4 | 0; f[ba >> 2] = aa; $q(k); u = g; return 1 } function fd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0; d = u; u = u + 32 | 0; e = d; g = d + 20 | 0; h = d + 24 | 0; i = d + 8 | 0; j = f[a >> 2] | 0; k = j + 8 | 0; l = j; j = f[l >> 2] | 0; m = f[l + 4 >> 2] | 0; l = Tn(j | 0, m | 0, f[k >> 2] | 0, f[k + 4 >> 2] | 0) | 0; k = I; n = Tn(l | 0, k | 0, (l | 0) == 0 & (k | 0) == 0 & 1 | 0, 0) | 0; k = ~~((+(j >>> 0) + 4294967296.0 * +(m >>> 0)) / (+(n >>> 0) + 4294967296.0 * +(I >>> 0)) * 256.0 + .5) >>> 0; n = k >>> 0 < 255 ? k : 255; k = n + ((n | 0) == 0 & 1) & 255; b[h >> 0] = k; n = a + 12 | 0; m = a + 16 | 0; j = ((f[m >> 2] | 0) - (f[n >> 2] | 0) << 1) + 64 | 0; f[i >> 2] = 0; l = i + 4 | 0; f[l >> 2] = 0; f[i + 8 >> 2] = 0; if (!j) o = 0; else { if ((j | 0) < 0) mq(i); p = dn(j) | 0; f[l >> 2] = p; f[i >> 2] = p; f[i + 8 >> 2] = p + j; q = j; j = p; do { b[j >> 0] = 0; j = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = j; q = q + -1 | 0 } while ((q | 0) != 0); o = f[i >> 2] | 0 } q = a + 28 | 0; j = (f[q >> 2] | 0) + -1 | 0; a: do if ((j | 0) > -1) { p = a + 24 | 0; r = j; s = 0; t = 4096; v = k; while (1) { w = (f[p >> 2] & 1 << r | 0) != 0; x = (w ? 0 - (v & 255) & 255 : v) & 255; if (t >>> 0 < x << 12 >>> 0) { y = s; z = t } else { b[o + s >> 0] = t; y = s + 1 | 0; z = t >>> 8 } on(f[3780 + (x << 3) >> 2] | 0, 0, z | 0, 0) | 0; A = z + (w ? 0 : 0 - v & 255) + (X((z + I | 0) >>> (f[3780 + (x << 3) + 4 >> 2] | 0), 256 - x | 0) | 0) | 0; x = r + -1 | 0; if ((x | 0) <= -1) { B = y; C = A; break a } r = x; s = y; t = A; v = b[h >> 0] | 0 } } else { B = 0; C = 4096 } while (0); y = f[m >> 2] | 0; if ((f[n >> 2] | 0) == (y | 0)) { D = B; E = C } else { z = B; B = C; C = y; while (1) { C = C + -4 | 0; y = f[C >> 2] | 0; k = 31; j = z; v = B; while (1) { t = b[h >> 0] | 0; s = (1 << k & y | 0) != 0; r = (s ? 0 - (t & 255) & 255 : t) & 255; if (v >>> 0 < r << 12 >>> 0) { F = j; G = v } else { b[o + j >> 0] = v; F = j + 1 | 0; G = v >>> 8 } on(f[3780 + (r << 3) >> 2] | 0, 0, G | 0, 0) | 0; v = G + (s ? 0 : 0 - t & 255) + (X((G + I | 0) >>> (f[3780 + (r << 3) + 4 >> 2] | 0), 256 - r | 0) | 0) | 0; if ((k | 0) <= 0) break; else { k = k + -1 | 0; j = F } } if ((f[n >> 2] | 0) == (C | 0)) { D = F; E = v; break } else { z = F; B = v } } } B = E + -4096 | 0; do if (B >>> 0 >= 64) { if (B >>> 0 < 16384) { F = o + D | 0; z = E + 12288 | 0; b[F >> 0] = z; H = 2; J = z >>> 8; K = F + 1 | 0; L = 25; break } if (B >>> 0 < 4194304) { F = o + D | 0; z = E + 8384512 | 0; b[F >> 0] = z; b[F + 1 >> 0] = z >>> 8; H = 3; J = z >>> 16; K = F + 2 | 0; L = 25 } else M = D } else { H = 1; J = B; K = o + D | 0; L = 25 } while (0); if ((L | 0) == 25) { b[K >> 0] = J; M = H + D | 0 } D = c + 16 | 0; H = D; J = f[H + 4 >> 2] | 0; if (!((J | 0) > 0 | (J | 0) == 0 & (f[H >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0 } Nh(M, c) | 0; h = f[i >> 2] | 0; H = D; D = f[H + 4 >> 2] | 0; if (!((D | 0) > 0 | (D | 0) == 0 & (f[H >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + M | 0) | 0 } M = e; f[M >> 2] = 0; f[M + 4 >> 2] = 0; cf(a, 2, e); e = f[a + 12 >> 2] | 0; M = f[m >> 2] | 0; if ((M | 0) != (e | 0)) f[m >> 2] = M + (~((M + -4 - e | 0) >>> 2) << 2); f[a + 24 >> 2] = 0; f[q >> 2] = 0; q = f[i >> 2] | 0; if (!q) { u = d; return } if ((f[l >> 2] | 0) != (q | 0)) f[l >> 2] = q; br(q); u = d; return } function gd(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0; c = u; u = u + 16 | 0; b = c + 8 | 0; d = c + 4 | 0; e = c; g = a + 64 | 0; h = f[g >> 2] | 0; if ((f[h + 28 >> 2] | 0) == (f[h + 24 >> 2] | 0)) { u = c; return } i = a + 52 | 0; j = a + 56 | 0; k = a + 60 | 0; l = a + 12 | 0; m = a + 28 | 0; n = a + 40 | 0; o = a + 44 | 0; p = a + 48 | 0; q = 0; r = 0; s = h; while (1) { h = f[(f[s + 24 >> 2] | 0) + (r << 2) >> 2] | 0; if ((h | 0) == -1) { t = q; v = s } else { w = q + 1 | 0; f[b >> 2] = q; x = f[j >> 2] | 0; if ((x | 0) == (f[k >> 2] | 0)) Ci(i, b); else { f[x >> 2] = q; f[j >> 2] = x + 4 } f[d >> 2] = h; f[e >> 2] = 0; a: do if (!(f[(f[l >> 2] | 0) + (r >>> 5 << 2) >> 2] & 1 << (r & 31))) y = h; else { x = h + 1 | 0; z = ((x >>> 0) % 3 | 0 | 0) == 0 ? h + -2 | 0 : x; if (((z | 0) != -1 ? (f[(f[a >> 2] | 0) + (z >>> 5 << 2) >> 2] & 1 << (z & 31) | 0) == 0 : 0) ? (x = f[(f[(f[g >> 2] | 0) + 12 >> 2] | 0) + (z << 2) >> 2] | 0, z = x + 1 | 0, (x | 0) != -1) : 0) { A = ((z >>> 0) % 3 | 0 | 0) == 0 ? x + -2 | 0 : z; f[e >> 2] = A; if ((A | 0) == -1) { y = h; break } else B = A; while (1) { f[d >> 2] = B; A = B + 1 | 0; z = ((A >>> 0) % 3 | 0 | 0) == 0 ? B + -2 | 0 : A; if ((z | 0) == -1) break; if (f[(f[a >> 2] | 0) + (z >>> 5 << 2) >> 2] & 1 << (z & 31) | 0) break; A = f[(f[(f[g >> 2] | 0) + 12 >> 2] | 0) + (z << 2) >> 2] | 0; z = A + 1 | 0; if ((A | 0) == -1) break; x = ((z >>> 0) % 3 | 0 | 0) == 0 ? A + -2 | 0 : z; f[e >> 2] = x; if ((x | 0) == -1) { y = B; break a } else B = x } f[e >> 2] = -1; y = B; break } f[e >> 2] = -1; y = h } while (0); f[(f[m >> 2] | 0) + (y << 2) >> 2] = f[b >> 2]; h = f[o >> 2] | 0; if ((h | 0) == (f[p >> 2] | 0)) Ci(n, d); else { f[h >> 2] = f[d >> 2]; f[o >> 2] = h + 4 } h = f[g >> 2] | 0; x = f[d >> 2] | 0; b: do if (((x | 0) != -1 ? (z = (((x >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + x | 0, (z | 0) != -1) : 0) ? (A = f[(f[h + 12 >> 2] | 0) + (z << 2) >> 2] | 0, (A | 0) != -1) : 0) { z = A + (((A >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; f[e >> 2] = z; if ((z | 0) != -1 & (z | 0) != (x | 0)) { A = w; C = z; while (1) { z = C + 1 | 0; D = ((z >>> 0) % 3 | 0 | 0) == 0 ? C + -2 | 0 : z; do if (f[(f[a >> 2] | 0) + (D >>> 5 << 2) >> 2] & 1 << (D & 31)) { z = A + 1 | 0; f[b >> 2] = A; E = f[j >> 2] | 0; if ((E | 0) == (f[k >> 2] | 0)) Ci(i, b); else { f[E >> 2] = A; f[j >> 2] = E + 4 } E = f[o >> 2] | 0; if ((E | 0) == (f[p >> 2] | 0)) { Ci(n, e); F = z; break } else { f[E >> 2] = f[e >> 2]; f[o >> 2] = E + 4; F = z; break } } else F = A; while (0); f[(f[m >> 2] | 0) + (f[e >> 2] << 2) >> 2] = f[b >> 2]; G = f[g >> 2] | 0; D = f[e >> 2] | 0; if ((D | 0) == -1) break; z = (((D >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + D | 0; if ((z | 0) == -1) break; D = f[(f[G + 12 >> 2] | 0) + (z << 2) >> 2] | 0; if ((D | 0) == -1) break; C = D + (((D >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; f[e >> 2] = C; if (!((C | 0) != -1 ? (C | 0) != (f[d >> 2] | 0) : 0)) { H = F; I = G; break b } else A = F } f[e >> 2] = -1; H = F; I = G } else { H = w; I = h } } else J = 26; while (0); if ((J | 0) == 26) { J = 0; f[e >> 2] = -1; H = w; I = h } t = H; v = I } r = r + 1 | 0; if (r >>> 0 >= (f[v + 28 >> 2] | 0) - (f[v + 24 >> 2] | 0) >> 2 >>> 0) break; else { q = t; s = v } } u = c; return } function hd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; h = a + 124 | 0; f[h >> 2] = (f[h >> 2] | 0) + 1; h = a + 88 | 0; i = a + 120 | 0; j = f[i >> 2] | 0; k = j + 1 | 0; do if ((j | 0) != -1) { l = ((k >>> 0) % 3 | 0 | 0) == 0 ? j + -2 | 0 : k; if (!((j >>> 0) % 3 | 0)) { m = j + 2 | 0; n = l; break } else { m = j + -1 | 0; n = l; break } } else { m = -1; n = -1 } while (0); k = a + 104 | 0; l = a + 92 | 0; o = f[l >> 2] | 0; p = o + (n << 2) | 0; q = f[k >> 2] | 0; r = q + (f[p >> 2] << 2) | 0; s = f[r >> 2] | 0; switch (b | 0) { case 1: case 0: { f[r >> 2] = s + -1; r = q + (f[o + (m << 2) >> 2] << 2) | 0; f[r >> 2] = (f[r >> 2] | 0) + -1; if ((b | 0) == 1) { if ((m | 0) != -1 ? (r = f[(f[(f[h >> 2] | 0) + 12 >> 2] | 0) + (m << 2) >> 2] | 0, (r | 0) != -1) : 0) { t = a + 64 | 0; v = 1; w = r; while (1) { r = f[t >> 2] | 0; x = f[(f[r >> 2] | 0) + 36 >> 2] | 0; f[e >> 2] = (w >>> 0) / 3 | 0; f[d >> 2] = f[e >> 2]; if (Ra[x & 127](r, d) | 0) { y = v; break } r = w + 1 | 0; x = ((r >>> 0) % 3 | 0 | 0) == 0 ? w + -2 | 0 : r; if ((x | 0) == -1) { z = 12; break } w = f[(f[(f[h >> 2] | 0) + 12 >> 2] | 0) + (x << 2) >> 2] | 0; x = v + 1 | 0; if ((w | 0) == -1) { y = x; break } else v = x } if ((z | 0) == 12) y = v + 1 | 0; A = y; B = f[k >> 2] | 0; C = f[l >> 2] | 0 } else { A = 1; B = q; C = o } f[B + (f[C + (f[i >> 2] << 2) >> 2] << 2) >> 2] = A; A = a + 108 | 0; i = f[A >> 2] | 0; C = i - B >> 2; B = i; if ((n | 0) != -1 ? (i = f[(f[(f[h >> 2] | 0) + 12 >> 2] | 0) + (n << 2) >> 2] | 0, (i | 0) != -1) : 0) { n = a + 64 | 0; y = 1; v = i; while (1) { i = f[n >> 2] | 0; w = f[(f[i >> 2] | 0) + 36 >> 2] | 0; f[g >> 2] = (v >>> 0) / 3 | 0; f[d >> 2] = f[g >> 2]; if (Ra[w & 127](i, d) | 0) { D = y; break } i = v + 1 | 0; f[(f[l >> 2] | 0) + ((((i >>> 0) % 3 | 0 | 0) == 0 ? v + -2 | 0 : i) << 2) >> 2] = C; i = (((v >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + v | 0; if ((i | 0) == -1) { z = 20; break } v = f[(f[(f[h >> 2] | 0) + 12 >> 2] | 0) + (i << 2) >> 2] | 0; i = y + 1 | 0; if ((v | 0) == -1) { D = i; break } else y = i } if ((z | 0) == 20) D = y + 1 | 0; E = D; F = f[A >> 2] | 0 } else { E = 1; F = B } f[d >> 2] = E; if (F >>> 0 < (f[a + 112 >> 2] | 0) >>> 0) { f[F >> 2] = E; f[A >> 2] = F + 4 } else Ci(k, d) } break } case 5: { k = q + (f[o + (j << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -1; k = q + (f[p >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -1; k = q + (f[o + (m << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -2; break } case 3: { k = q + (f[o + (j << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -1; k = q + (f[p >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -2; k = q + (f[o + (m << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -1; break } case 7: { k = q + (f[o + (j << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -2; k = q + (f[p >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -2; k = q + (f[o + (m << 2) >> 2] << 2) | 0; f[k >> 2] = (f[k >> 2] | 0) + -2; break } default: { } }k = a + 116 | 0; m = f[k >> 2] | 0; if ((m | 0) == -1) { f[k >> 2] = b; u = c; return } o = f[a + 128 >> 2] | 0; if ((s | 0) < (o | 0)) G = o; else { q = f[a + 132 >> 2] | 0; G = (s | 0) > (q | 0) ? q : s } s = G - o | 0; o = f[a + 136 >> 2] | 0; a = f[3384 + (m << 2) >> 2] | 0; f[d >> 2] = a; m = o + (s * 12 | 0) + 4 | 0; G = f[m >> 2] | 0; if (G >>> 0 < (f[o + (s * 12 | 0) + 8 >> 2] | 0) >>> 0) { f[G >> 2] = a; f[m >> 2] = G + 4 } else Ci(o + (s * 12 | 0) | 0, d); f[k >> 2] = b; u = c; return } function id(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, _ = 0, $ = 0; g = u; u = u + 32 | 0; d = g + 16 | 0; h = g + 8 | 0; i = g; j = e >>> 0 > 1073741823 ? -1 : e << 2; k = _q(j) | 0; hj(k | 0, 0, j | 0) | 0; j = f[a + 28 >> 2] | 0; l = a + 36 | 0; m = f[l >> 2] | 0; n = f[m + 4 >> 2] | 0; o = f[m >> 2] | 0; p = n - o | 0; a: do if ((p | 0) > 4) { q = p >> 2; r = f[a + 32 >> 2] | 0; s = a + 8 | 0; t = h + 4 | 0; v = i + 4 | 0; w = d + 4 | 0; x = j + 64 | 0; y = j + 28 | 0; z = (e | 0) > 0; A = k + 4 | 0; B = h + 4 | 0; C = i + 4 | 0; D = d + 4 | 0; E = q + -1 | 0; if (n - o >> 2 >>> 0 > E >>> 0) { F = q; G = E; H = o } else { I = m; mq(I) } while (1) { E = f[H + (G << 2) >> 2] | 0; q = X(G, e) | 0; if ((((E | 0) != -1 ? (f[(f[j >> 2] | 0) + (E >>> 5 << 2) >> 2] & 1 << (E & 31) | 0) == 0 : 0) ? (J = f[(f[(f[x >> 2] | 0) + 12 >> 2] | 0) + (E << 2) >> 2] | 0, (J | 0) != -1) : 0) ? (E = f[y >> 2] | 0, K = f[r >> 2] | 0, L = f[K + (f[E + (J << 2) >> 2] << 2) >> 2] | 0, M = J + 1 | 0, N = f[K + (f[E + ((((M >>> 0) % 3 | 0 | 0) == 0 ? J + -2 | 0 : M) << 2) >> 2] << 2) >> 2] | 0, M = f[K + (f[E + ((((J >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + J << 2) >> 2] << 2) >> 2] | 0, (L | 0) < (G | 0) & (N | 0) < (G | 0) & (M | 0) < (G | 0)) : 0) { J = X(L, e) | 0; L = X(N, e) | 0; N = X(M, e) | 0; if (z) { M = 0; do { f[k + (M << 2) >> 2] = (f[b + (M + N << 2) >> 2] | 0) + (f[b + (M + L << 2) >> 2] | 0) - (f[b + (M + J << 2) >> 2] | 0); M = M + 1 | 0 } while ((M | 0) != (e | 0)) } M = b + (q << 2) | 0; J = c + (q << 2) | 0; L = f[M + 4 >> 2] | 0; N = f[k >> 2] | 0; E = f[A >> 2] | 0; f[h >> 2] = f[M >> 2]; f[B >> 2] = L; f[i >> 2] = N; f[C >> 2] = E; Dd(d, s, h, i); f[J >> 2] = f[d >> 2]; f[J + 4 >> 2] = f[D >> 2] } else { J = b + (q << 2) | 0; E = b + ((X(F + -2 | 0, e) | 0) << 2) | 0; N = c + (q << 2) | 0; L = f[J + 4 >> 2] | 0; M = f[E >> 2] | 0; K = f[E + 4 >> 2] | 0; f[h >> 2] = f[J >> 2]; f[t >> 2] = L; f[i >> 2] = M; f[v >> 2] = K; Dd(d, s, h, i); f[N >> 2] = f[d >> 2]; f[N + 4 >> 2] = f[w >> 2] } if ((F | 0) <= 2) break a; N = f[l >> 2] | 0; H = f[N >> 2] | 0; K = G + -1 | 0; if ((f[N + 4 >> 2] | 0) - H >> 2 >>> 0 <= K >>> 0) { I = N; break } else { N = G; G = K; F = N } } mq(I) } while (0); if ((e | 0) <= 0) { O = a + 8 | 0; P = b + 4 | 0; Q = f[b >> 2] | 0; R = f[P >> 2] | 0; S = k + 4 | 0; T = f[k >> 2] | 0; U = f[S >> 2] | 0; f[h >> 2] = Q; V = h + 4 | 0; f[V >> 2] = R; f[i >> 2] = T; W = i + 4 | 0; f[W >> 2] = U; Dd(d, O, h, i); Y = f[d >> 2] | 0; f[c >> 2] = Y; Z = d + 4 | 0; _ = f[Z >> 2] | 0; $ = c + 4 | 0; f[$ >> 2] = _; $q(k); u = g; return 1 } hj(k | 0, 0, e << 2 | 0) | 0; O = a + 8 | 0; P = b + 4 | 0; Q = f[b >> 2] | 0; R = f[P >> 2] | 0; S = k + 4 | 0; T = f[k >> 2] | 0; U = f[S >> 2] | 0; f[h >> 2] = Q; V = h + 4 | 0; f[V >> 2] = R; f[i >> 2] = T; W = i + 4 | 0; f[W >> 2] = U; Dd(d, O, h, i); Y = f[d >> 2] | 0; f[c >> 2] = Y; Z = d + 4 | 0; _ = f[Z >> 2] | 0; $ = c + 4 | 0; f[$ >> 2] = _; $q(k); u = g; return 1 } function jd(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; c = a + 4 | 0; if (!b) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(b << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; g = f[c >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = b + -1 | 0; i = (h & b | 0) == 0; if (!i) if (e >>> 0 < b >>> 0) j = e; else j = (e >>> 0) % (b >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = c; c = f[g >> 2] | 0; if (!c) return; else { k = j; l = g; m = c; n = g } a: while (1) { g = l; c = m; j = n; b: while (1) { c: do if (i) { e = c; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = q + 2 | 0; v = e + 12 | 0; w = q + 6 | 0; x = f[e >> 2] | 0; d: do if (!x) y = e; else { z = d[q >> 1] | 0; A = e; B = x; while (1) { C = B + 8 | 0; if (z << 16 >> 16 != (d[C >> 1] | 0)) { y = A; break d } if ((d[u >> 1] | 0) != (d[C + 2 >> 1] | 0)) { y = A; break d } if ((d[v >> 1] | 0) != (d[B + 12 >> 1] | 0)) { y = A; break d } if ((d[w >> 1] | 0) != (d[C + 6 >> 1] | 0)) { y = A; break d } C = f[B >> 2] | 0; if (!C) { y = B; break } else { D = B; B = C; A = D } } } while (0); f[j >> 2] = f[y >> 2]; f[y >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { E = 43; break a } } } else { e = c; while (1) { w = f[e + 4 >> 2] | 0; if (w >>> 0 < b >>> 0) F = w; else F = (w >>> 0) % (b >>> 0) | 0; if ((F | 0) == (k | 0)) { p = e; break c } w = (f[a >> 2] | 0) + (F << 2) | 0; if (!(f[w >> 2] | 0)) { r = e; s = F; t = w; break b } w = e + 8 | 0; v = w + 2 | 0; u = e + 12 | 0; x = w + 6 | 0; q = f[e >> 2] | 0; e: do if (!q) G = e; else { A = d[w >> 1] | 0; B = e; z = q; while (1) { D = z + 8 | 0; if (A << 16 >> 16 != (d[D >> 1] | 0)) { G = B; break e } if ((d[v >> 1] | 0) != (d[D + 2 >> 1] | 0)) { G = B; break e } if ((d[u >> 1] | 0) != (d[z + 12 >> 1] | 0)) { G = B; break e } if ((d[x >> 1] | 0) != (d[D + 6 >> 1] | 0)) { G = B; break e } D = f[z >> 2] | 0; if (!D) { G = z; break } else { C = z; z = D; B = C } } } while (0); f[j >> 2] = f[G >> 2]; f[G >> 2] = f[f[(f[a >> 2] | 0) + (F << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (F << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { E = 43; break a } } } while (0); c = f[p >> 2] | 0; if (!c) { E = 43; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { E = 43; break } else { k = s; l = r; n = r } } if ((E | 0) == 43) return } function kd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; else { k = j; l = g; m = d; n = g } a: while (1) { g = l; d = m; j = n; b: while (1) { c: do if (i) { e = d; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = q + 1 | 0; v = q + 2 | 0; w = q + 3 | 0; x = f[e >> 2] | 0; d: do if (!x) y = e; else { z = b[q >> 0] | 0; A = e; B = x; while (1) { C = B + 8 | 0; if (z << 24 >> 24 != (b[C >> 0] | 0)) { y = A; break d } if ((b[u >> 0] | 0) != (b[C + 1 >> 0] | 0)) { y = A; break d } if ((b[v >> 0] | 0) != (b[C + 2 >> 0] | 0)) { y = A; break d } if ((b[w >> 0] | 0) != (b[C + 3 >> 0] | 0)) { y = A; break d } C = f[B >> 2] | 0; if (!C) { y = B; break } else { D = B; B = C; A = D } } } while (0); f[j >> 2] = f[y >> 2]; f[y >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { E = 43; break a } } } else { e = d; while (1) { w = f[e + 4 >> 2] | 0; if (w >>> 0 < c >>> 0) F = w; else F = (w >>> 0) % (c >>> 0) | 0; if ((F | 0) == (k | 0)) { p = e; break c } w = (f[a >> 2] | 0) + (F << 2) | 0; if (!(f[w >> 2] | 0)) { r = e; s = F; t = w; break b } w = e + 8 | 0; v = w + 1 | 0; u = w + 2 | 0; x = w + 3 | 0; q = f[e >> 2] | 0; e: do if (!q) G = e; else { A = b[w >> 0] | 0; B = e; z = q; while (1) { D = z + 8 | 0; if (A << 24 >> 24 != (b[D >> 0] | 0)) { G = B; break e } if ((b[v >> 0] | 0) != (b[D + 1 >> 0] | 0)) { G = B; break e } if ((b[u >> 0] | 0) != (b[D + 2 >> 0] | 0)) { G = B; break e } if ((b[x >> 0] | 0) != (b[D + 3 >> 0] | 0)) { G = B; break e } D = f[z >> 2] | 0; if (!D) { G = z; break } else { C = z; z = D; B = C } } } while (0); f[j >> 2] = f[G >> 2]; f[G >> 2] = f[f[(f[a >> 2] | 0) + (F << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (F << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { E = 43; break a } } } while (0); d = f[p >> 2] | 0; if (!d) { E = 43; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { E = 43; break } else { k = s; l = r; n = r } } if ((E | 0) == 43) return } function ld(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; c = a + 4 | 0; if (!b) { d = f[a >> 2] | 0; f[a >> 2] = 0; if (d | 0) br(d); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } d = dn(b << 2) | 0; e = f[a >> 2] | 0; f[a >> 2] = d; if (e | 0) br(e); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; e = f[c >> 2] | 0; if (!e) return; d = f[e + 4 >> 2] | 0; g = b + -1 | 0; h = (g & b | 0) == 0; if (!h) if (d >>> 0 < b >>> 0) i = d; else i = (d >>> 0) % (b >>> 0) | 0; else i = d & g; f[(f[a >> 2] | 0) + (i << 2) >> 2] = c; c = f[e >> 2] | 0; if (!c) return; else { j = i; k = e; l = c; m = e } a: while (1) { e = k; c = l; i = m; b: while (1) { c: do if (h) { d = c; while (1) { n = f[d + 4 >> 2] & g; if ((n | 0) == (j | 0)) { o = d; break c } p = (f[a >> 2] | 0) + (n << 2) | 0; if (!(f[p >> 2] | 0)) { q = d; r = n; s = p; break b } p = d + 12 | 0; t = d + 16 | 0; u = d + 20 | 0; v = f[d >> 2] | 0; d: do if (!v) w = d; else { x = f[d + 8 >> 2] | 0; y = d; z = v; while (1) { if ((x | 0) != (f[z + 8 >> 2] | 0)) { w = y; break d } if ((f[p >> 2] | 0) != (f[z + 12 >> 2] | 0)) { w = y; break d } if ((f[t >> 2] | 0) != (f[z + 16 >> 2] | 0)) { w = y; break d } if ((f[u >> 2] | 0) != (f[z + 20 >> 2] | 0)) { w = y; break d } A = f[z >> 2] | 0; if (!A) { w = z; break } else { B = z; z = A; y = B } } } while (0); f[i >> 2] = f[w >> 2]; f[w >> 2] = f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { C = 43; break a } } } else { d = c; while (1) { u = f[d + 4 >> 2] | 0; if (u >>> 0 < b >>> 0) D = u; else D = (u >>> 0) % (b >>> 0) | 0; if ((D | 0) == (j | 0)) { o = d; break c } u = (f[a >> 2] | 0) + (D << 2) | 0; if (!(f[u >> 2] | 0)) { q = d; r = D; s = u; break b } u = d + 12 | 0; t = d + 16 | 0; p = d + 20 | 0; v = f[d >> 2] | 0; e: do if (!v) E = d; else { y = f[d + 8 >> 2] | 0; z = d; x = v; while (1) { if ((y | 0) != (f[x + 8 >> 2] | 0)) { E = z; break e } if ((f[u >> 2] | 0) != (f[x + 12 >> 2] | 0)) { E = z; break e } if ((f[t >> 2] | 0) != (f[x + 16 >> 2] | 0)) { E = z; break e } if ((f[p >> 2] | 0) != (f[x + 20 >> 2] | 0)) { E = z; break e } B = f[x >> 2] | 0; if (!B) { E = x; break } else { A = x; x = B; z = A } } } while (0); f[i >> 2] = f[E >> 2]; f[E >> 2] = f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { C = 43; break a } } } while (0); c = f[o >> 2] | 0; if (!c) { C = 43; break a } else { e = o; i = o } } f[s >> 2] = i; l = f[q >> 2] | 0; if (!l) { C = 43; break } else { j = r; k = q; m = q } } if ((C | 0) == 43) return } function md(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0; i = u; u = u + 352 | 0; j = i + 340 | 0; k = i + 336 | 0; l = i + 80 | 0; m = i + 48 | 0; n = i; hj(l | 0, 0, 256) | 0; o = f[e + 4 >> 2] | 0; p = f[e >> 2] | 0; q = p; if ((o | 0) != (p | 0)) { r = o - p >> 2; p = 0; do { o = l + (f[q + (p << 2) >> 2] << 3) | 0; s = o; t = Tn(f[s >> 2] | 0, f[s + 4 >> 2] | 0, 1, 0) | 0; s = o; f[s >> 2] = t; f[s + 4 >> 2] = I; p = p + 1 | 0 } while (p >>> 0 < r >>> 0) } Cn(m); r = Rn(c | 0, ((c | 0) < 0) << 31 >> 31 | 0, 5) | 0; p = I; q = n + 40 | 0; s = q; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = n; t = s + 36 | 0; do { f[s >> 2] = 0; s = s + 4 | 0 } while ((s | 0) < (t | 0)); $c(n, l, 32, g) | 0; l = n + 16 | 0; s = Rn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1) | 0; l = g + 4 | 0; t = (f[l >> 2] | 0) - (f[g >> 2] | 0) | 0; o = q; f[o >> 2] = t; f[o + 4 >> 2] = 0; o = Tn(s | 0, I | 0, 39, 0) | 0; s = Wn(o | 0, I | 0, 3) | 0; o = Tn(s | 0, I | 0, 8, 0) | 0; s = Tn(o | 0, I | 0, t | 0, 0) | 0; vl(g, s, I); s = n + 24 | 0; f[s >> 2] = (f[g >> 2] | 0) + (f[q >> 2] | 0); q = n + 28 | 0; f[q >> 2] = 0; t = n + 32 | 0; f[t >> 2] = 16384; li(m, r, p, 0) | 0; p = c - d | 0; if ((p | 0) > -1) { c = (d | 0) > 0; r = m + 16 | 0; o = m + 12 | 0; v = p; do { w = f[e >> 2] | 0; x = f[w + (((v | 0) / (d | 0) | 0) << 2) >> 2] | 0; y = f[n >> 2] | 0; z = f[y + (x << 3) >> 2] | 0; A = f[t >> 2] | 0; B = z << 10; if (A >>> 0 < B >>> 0) { C = A; D = w } else { w = A; do { A = f[s >> 2] | 0; E = f[q >> 2] | 0; f[q >> 2] = E + 1; b[A + E >> 0] = w; w = (f[t >> 2] | 0) >>> 8; f[t >> 2] = w } while (w >>> 0 >= B >>> 0); C = w; D = f[e >> 2] | 0 } f[t >> 2] = (((C >>> 0) / (z >>> 0) | 0) << 12) + ((C >>> 0) % (z >>> 0) | 0) + (f[y + (x << 3) + 4 >> 2] | 0); B = p - v | 0; E = f[D + (((B | 0) / (d | 0) | 0) << 2) >> 2] | 0; if (c & (E | 0) > 0) { A = 0; do { F = f[a + (A + B << 2) >> 2] | 0; G = r; H = f[G + 4 >> 2] | 0; if ((H | 0) > 0 | (H | 0) == 0 & (f[G >> 2] | 0) >>> 0 > 0) { G = f[o >> 2] | 0; H = G + 4 | 0; J = 0; K = f[H >> 2] | 0; do { L = K >>> 3; M = K & 7; N = (f[G >> 2] | 0) + L | 0; b[N >> 0] = (1 << M ^ 255) & (h[N >> 0] | 0); N = (f[G >> 2] | 0) + L | 0; b[N >> 0] = (F >>> J & 1) << M | (h[N >> 0] | 0); K = (f[H >> 2] | 0) + 1 | 0; f[H >> 2] = K; J = J + 1 | 0 } while ((J | 0) != (E | 0)) } A = A + 1 | 0 } while ((A | 0) != (d | 0)) } v = v - d | 0 } while ((v | 0) > -1) } Lf(n, g); Qf(m); v = f[m >> 2] | 0; d = m + 4 | 0; o = g + 16 | 0; r = f[o + 4 >> 2] | 0; if (!((r | 0) > 0 | (r | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { o = (f[d >> 2] | 0) - v | 0; f[k >> 2] = f[l >> 2]; f[j >> 2] = f[k >> 2]; ye(g, j, v, v + o | 0) | 0 } o = f[n >> 2] | 0; if (o | 0) { v = n + 4 | 0; n = f[v >> 2] | 0; if ((n | 0) != (o | 0)) f[v >> 2] = n + (~((n + -8 - o | 0) >>> 3) << 3); br(o) } o = m + 12 | 0; n = f[o >> 2] | 0; f[o >> 2] = 0; if (n | 0) br(n); n = f[m >> 2] | 0; if (!n) { u = i; return 1 } if ((f[d >> 2] | 0) != (n | 0)) f[d >> 2] = n; br(n); u = i; return 1 } function nd(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0; c = a + 4 | 0; if (!b) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(b << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; g = f[c >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = b + -1 | 0; i = (h & b | 0) == 0; if (!i) if (e >>> 0 < b >>> 0) j = e; else j = (e >>> 0) % (b >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = c; c = f[g >> 2] | 0; if (!c) return; else { k = j; l = g; m = c; n = g } a: while (1) { g = l; c = m; j = n; b: while (1) { c: do if (i) { e = c; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = e + 12 | 0; v = f[e >> 2] | 0; d: do if (!v) w = e; else { x = d[q >> 1] | 0; y = q + 2 | 0; z = e; A = v; while (1) { B = A + 8 | 0; if (x << 16 >> 16 != (d[B >> 1] | 0)) { w = z; break d } if ((d[y >> 1] | 0) != (d[B + 2 >> 1] | 0)) { w = z; break d } if ((d[u >> 1] | 0) != (d[A + 12 >> 1] | 0)) { w = z; break d } B = f[A >> 2] | 0; if (!B) { w = A; break } else { C = A; A = B; z = C } } } while (0); f[j >> 2] = f[w >> 2]; f[w >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { D = 41; break a } } } else { e = c; while (1) { u = f[e + 4 >> 2] | 0; if (u >>> 0 < b >>> 0) E = u; else E = (u >>> 0) % (b >>> 0) | 0; if ((E | 0) == (k | 0)) { p = e; break c } u = (f[a >> 2] | 0) + (E << 2) | 0; if (!(f[u >> 2] | 0)) { r = e; s = E; t = u; break b } u = e + 8 | 0; v = e + 12 | 0; q = f[e >> 2] | 0; e: do if (!q) F = e; else { z = d[u >> 1] | 0; A = u + 2 | 0; y = e; x = q; while (1) { C = x + 8 | 0; if (z << 16 >> 16 != (d[C >> 1] | 0)) { F = y; break e } if ((d[A >> 1] | 0) != (d[C + 2 >> 1] | 0)) { F = y; break e } if ((d[v >> 1] | 0) != (d[x + 12 >> 1] | 0)) { F = y; break e } C = f[x >> 2] | 0; if (!C) { F = x; break } else { B = x; x = C; y = B } } } while (0); f[j >> 2] = f[F >> 2]; f[F >> 2] = f[f[(f[a >> 2] | 0) + (E << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (E << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { D = 41; break a } } } while (0); c = f[p >> 2] | 0; if (!c) { D = 41; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { D = 41; break } else { k = s; l = r; n = r } } if ((D | 0) == 41) return } function od(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; else { k = j; l = g; m = d; n = g } a: while (1) { g = l; d = m; j = n; b: while (1) { c: do if (i) { e = d; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = q + 1 | 0; v = q + 2 | 0; w = f[e >> 2] | 0; d: do if (!w) x = e; else { y = b[q >> 0] | 0; z = e; A = w; while (1) { B = A + 8 | 0; if (y << 24 >> 24 != (b[B >> 0] | 0)) { x = z; break d } if ((b[u >> 0] | 0) != (b[B + 1 >> 0] | 0)) { x = z; break d } if ((b[v >> 0] | 0) != (b[B + 2 >> 0] | 0)) { x = z; break d } B = f[A >> 2] | 0; if (!B) { x = A; break } else { C = A; A = B; z = C } } } while (0); f[j >> 2] = f[x >> 2]; f[x >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { D = 41; break a } } } else { e = d; while (1) { v = f[e + 4 >> 2] | 0; if (v >>> 0 < c >>> 0) E = v; else E = (v >>> 0) % (c >>> 0) | 0; if ((E | 0) == (k | 0)) { p = e; break c } v = (f[a >> 2] | 0) + (E << 2) | 0; if (!(f[v >> 2] | 0)) { r = e; s = E; t = v; break b } v = e + 8 | 0; u = v + 1 | 0; w = v + 2 | 0; q = f[e >> 2] | 0; e: do if (!q) F = e; else { z = b[v >> 0] | 0; A = e; y = q; while (1) { C = y + 8 | 0; if (z << 24 >> 24 != (b[C >> 0] | 0)) { F = A; break e } if ((b[u >> 0] | 0) != (b[C + 1 >> 0] | 0)) { F = A; break e } if ((b[w >> 0] | 0) != (b[C + 2 >> 0] | 0)) { F = A; break e } C = f[y >> 2] | 0; if (!C) { F = y; break } else { B = y; y = C; A = B } } } while (0); f[j >> 2] = f[F >> 2]; f[F >> 2] = f[f[(f[a >> 2] | 0) + (E << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (E << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { D = 41; break a } } } while (0); d = f[p >> 2] | 0; if (!d) { D = 41; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { D = 41; break } else { k = s; l = r; n = r } } if ((D | 0) == 41) return } function pd(a, b) { a = +a; b = +b; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, q = 0, r = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0.0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0.0; p[s >> 3] = a; c = f[s >> 2] | 0; d = f[s + 4 >> 2] | 0; p[s >> 3] = b; e = f[s >> 2] | 0; g = f[s + 4 >> 2] | 0; h = Wn(c | 0, d | 0, 52) | 0; i = h & 2047; h = Wn(e | 0, g | 0, 52) | 0; j = h & 2047; h = d & -2147483648; k = Rn(e | 0, g | 0, 1) | 0; l = I; a: do if (!((k | 0) == 0 & (l | 0) == 0) ? (m = xo(b) | 0, n = I & 2147483647, !((i | 0) == 2047 | (n >>> 0 > 2146435072 | (n | 0) == 2146435072 & m >>> 0 > 0))) : 0) { m = Rn(c | 0, d | 0, 1) | 0; n = I; if (!(n >>> 0 > l >>> 0 | (n | 0) == (l | 0) & m >>> 0 > k >>> 0)) return +((m | 0) == (k | 0) & (n | 0) == (l | 0) ? a * 0.0 : a); if (!i) { n = Rn(c | 0, d | 0, 12) | 0; m = I; if ((m | 0) > -1 | (m | 0) == -1 & n >>> 0 > 4294967295) { o = 0; q = n; n = m; while (1) { m = o + -1 | 0; q = Rn(q | 0, n | 0, 1) | 0; n = I; if (!((n | 0) > -1 | (n | 0) == -1 & q >>> 0 > 4294967295)) { r = m; break } else o = m } } else r = 0; o = Rn(c | 0, d | 0, 1 - r | 0) | 0; t = r; u = o; v = I } else { t = i; u = c; v = d & 1048575 | 1048576 } if (!j) { o = Rn(e | 0, g | 0, 12) | 0; q = I; if ((q | 0) > -1 | (q | 0) == -1 & o >>> 0 > 4294967295) { n = 0; m = o; o = q; while (1) { q = n + -1 | 0; m = Rn(m | 0, o | 0, 1) | 0; o = I; if (!((o | 0) > -1 | (o | 0) == -1 & m >>> 0 > 4294967295)) { w = q; break } else n = q } } else w = 0; n = Rn(e | 0, g | 0, 1 - w | 0) | 0; x = w; y = n; z = I } else { x = j; y = e; z = g & 1048575 | 1048576 } n = Vn(u | 0, v | 0, y | 0, z | 0) | 0; m = I; o = (m | 0) > -1 | (m | 0) == -1 & n >>> 0 > 4294967295; b: do if ((t | 0) > (x | 0)) { q = t; A = m; B = o; C = u; D = v; E = n; while (1) { if (B) if ((E | 0) == 0 & (A | 0) == 0) break; else { F = E; G = A } else { F = C; G = D } H = Rn(F | 0, G | 0, 1) | 0; J = I; K = q + -1 | 0; L = Vn(H | 0, J | 0, y | 0, z | 0) | 0; M = I; N = (M | 0) > -1 | (M | 0) == -1 & L >>> 0 > 4294967295; if ((K | 0) > (x | 0)) { q = K; A = M; B = N; C = H; D = J; E = L } else { O = K; P = N; Q = L; R = M; S = H; T = J; break b } } U = a * 0.0; break a } else { O = t; P = o; Q = n; R = m; S = u; T = v } while (0); if (P) if ((Q | 0) == 0 & (R | 0) == 0) { U = a * 0.0; break } else { V = R; W = Q } else { V = T; W = S } if (V >>> 0 < 1048576 | (V | 0) == 1048576 & W >>> 0 < 0) { m = O; n = W; o = V; while (1) { E = Rn(n | 0, o | 0, 1) | 0; D = I; C = m + -1 | 0; if (D >>> 0 < 1048576 | (D | 0) == 1048576 & E >>> 0 < 0) { m = C; n = E; o = D } else { X = C; Y = E; Z = D; break } } } else { X = O; Y = W; Z = V } if ((X | 0) > 0) { o = Tn(Y | 0, Z | 0, 0, -1048576) | 0; n = I; m = Rn(X | 0, 0, 52) | 0; _ = n | I; $ = o | m } else { m = Wn(Y | 0, Z | 0, 1 - X | 0) | 0; _ = I; $ = m } f[s >> 2] = $; f[s + 4 >> 2] = _ | h; U = +p[s >> 3] } else aa = 3; while (0); if ((aa | 0) == 3) { ba = a * b; U = ba / ba } return +U } function qd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; c = a + 4 | 0; if (!b) { d = f[a >> 2] | 0; f[a >> 2] = 0; if (d | 0) br(d); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } d = dn(b << 2) | 0; e = f[a >> 2] | 0; f[a >> 2] = d; if (e | 0) br(e); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; e = f[c >> 2] | 0; if (!e) return; d = f[e + 4 >> 2] | 0; g = b + -1 | 0; h = (g & b | 0) == 0; if (!h) if (d >>> 0 < b >>> 0) i = d; else i = (d >>> 0) % (b >>> 0) | 0; else i = d & g; f[(f[a >> 2] | 0) + (i << 2) >> 2] = c; c = f[e >> 2] | 0; if (!c) return; else { j = i; k = e; l = c; m = e } a: while (1) { e = k; c = l; i = m; b: while (1) { c: do if (h) { d = c; while (1) { n = f[d + 4 >> 2] & g; if ((n | 0) == (j | 0)) { o = d; break c } p = (f[a >> 2] | 0) + (n << 2) | 0; if (!(f[p >> 2] | 0)) { q = d; r = n; s = p; break b } p = d + 12 | 0; t = d + 16 | 0; u = f[d >> 2] | 0; d: do if (!u) v = d; else { w = f[d + 8 >> 2] | 0; x = d; y = u; while (1) { if ((w | 0) != (f[y + 8 >> 2] | 0)) { v = x; break d } if ((f[p >> 2] | 0) != (f[y + 12 >> 2] | 0)) { v = x; break d } if ((f[t >> 2] | 0) != (f[y + 16 >> 2] | 0)) { v = x; break d } z = f[y >> 2] | 0; if (!z) { v = y; break } else { A = y; y = z; x = A } } } while (0); f[i >> 2] = f[v >> 2]; f[v >> 2] = f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { B = 41; break a } } } else { d = c; while (1) { t = f[d + 4 >> 2] | 0; if (t >>> 0 < b >>> 0) C = t; else C = (t >>> 0) % (b >>> 0) | 0; if ((C | 0) == (j | 0)) { o = d; break c } t = (f[a >> 2] | 0) + (C << 2) | 0; if (!(f[t >> 2] | 0)) { q = d; r = C; s = t; break b } t = d + 12 | 0; p = d + 16 | 0; u = f[d >> 2] | 0; e: do if (!u) D = d; else { x = f[d + 8 >> 2] | 0; y = d; w = u; while (1) { if ((x | 0) != (f[w + 8 >> 2] | 0)) { D = y; break e } if ((f[t >> 2] | 0) != (f[w + 12 >> 2] | 0)) { D = y; break e } if ((f[p >> 2] | 0) != (f[w + 16 >> 2] | 0)) { D = y; break e } A = f[w >> 2] | 0; if (!A) { D = w; break } else { z = w; w = A; y = z } } } while (0); f[i >> 2] = f[D >> 2]; f[D >> 2] = f[f[(f[a >> 2] | 0) + (C << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (C << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { B = 41; break a } } } while (0); c = f[o >> 2] | 0; if (!c) { B = 41; break a } else { e = o; i = o } } f[s >> 2] = i; l = f[q >> 2] | 0; if (!l) { B = 41; break } else { j = r; k = q; m = q } } if ((B | 0) == 41) return } function rd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; else { k = j; l = g; m = d; n = g } a: while (1) { g = l; d = m; j = n; b: while (1) { o = d; while (1) { e = f[o + 4 >> 2] | 0; if (!i) if (e >>> 0 < c >>> 0) p = e; else p = (e >>> 0) % (c >>> 0) | 0; else p = e & h; if ((p | 0) == (k | 0)) break; q = (f[a >> 2] | 0) + (p << 2) | 0; if (!(f[q >> 2] | 0)) break b; e = f[o >> 2] | 0; c: do if (!e) r = o; else { s = o + 8 | 0; t = b[s + 11 >> 0] | 0; u = t << 24 >> 24 < 0; v = t & 255; t = u ? f[o + 12 >> 2] | 0 : v; w = (t | 0) == 0; if (u) { u = o; x = e; while (1) { y = x + 8 | 0; z = b[y + 11 >> 0] | 0; A = z << 24 >> 24 < 0; if ((t | 0) != ((A ? f[x + 12 >> 2] | 0 : z & 255) | 0)) { r = u; break c } if (!w ? Pk(f[s >> 2] | 0, A ? f[y >> 2] | 0 : y, t) | 0 : 0) { r = u; break c } y = f[x >> 2] | 0; if (!y) { r = x; break c } else { A = x; x = y; u = A } } } if (w) { u = o; x = e; while (1) { A = b[x + 8 + 11 >> 0] | 0; if ((A << 24 >> 24 < 0 ? f[x + 12 >> 2] | 0 : A & 255) | 0) { r = u; break c } A = f[x >> 2] | 0; if (!A) { r = x; break c } else { y = x; x = A; u = y } } } u = o; x = e; while (1) { w = x + 8 | 0; y = b[w + 11 >> 0] | 0; A = y << 24 >> 24 < 0; if ((t | 0) != ((A ? f[x + 12 >> 2] | 0 : y & 255) | 0)) { r = u; break c } y = A ? f[w >> 2] | 0 : w; if ((b[y >> 0] | 0) == (f[s >> 2] & 255) << 24 >> 24) { B = s; C = v; D = y } else { r = u; break c } while (1) { C = C + -1 | 0; B = B + 1 | 0; if (!C) break; D = D + 1 | 0; if ((b[B >> 0] | 0) != (b[D >> 0] | 0)) { r = u; break c } } y = f[x >> 2] | 0; if (!y) { r = x; break } else { w = x; x = y; u = w } } } while (0); f[j >> 2] = f[r >> 2]; f[r >> 2] = f[f[(f[a >> 2] | 0) + (p << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (p << 2) >> 2] >> 2] = o; e = f[g >> 2] | 0; if (!e) { E = 43; break a } else o = e } d = f[o >> 2] | 0; if (!d) { E = 43; break a } else { g = o; j = o } } f[q >> 2] = j; m = f[o >> 2] | 0; if (!m) { E = 43; break } else { k = p; l = o; n = o } } if ((E | 0) == 43) return } function sd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 48 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; h = a + 44 | 0; Nh(f[h >> 2] | 0, b) | 0; if (f[h >> 2] | 0) { rn(d); lk(d); i = f[h >> 2] | 0; if ((i | 0) > 0) { h = a + 40 | 0; j = i; do { i = j; j = j + -1 | 0; Vi(d, (f[(f[h >> 2] | 0) + (j >>> 5 << 2) >> 2] & 1 << (j & 31) | 0) != 0) } while ((i | 0) > 1) } fd(d, b); tj(d) } j = a + 56 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); h = f[j >> 2] | 0; if ((h | 0) > 1) { j = a + 52 | 0; i = h; do { h = i; i = i + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) != 0); k = h + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((h | 0) > 3) } fd(d, b); tj(d) } j = a + 68 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); i = f[j >> 2] | 0; if ((i | 0) > 2) { j = a + 64 | 0; h = i; do { i = h; h = h + -3 | 0; Vi(d, (f[(f[j >> 2] | 0) + (h >>> 5 << 2) >> 2] & 1 << (h & 31) | 0) != 0); k = i + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = i + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((i | 0) > 5) } fd(d, b); tj(d) } j = a + 80 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); h = f[j >> 2] | 0; if ((h | 0) > 3) { j = a + 76 | 0; i = h; do { h = i; i = i + -4 | 0; Vi(d, (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) != 0); k = h + -3 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = h + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = h + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((h | 0) > 7) } fd(d, b); tj(d) } f[g >> 2] = f[a + 12 >> 2]; j = b + 16 | 0; i = j; h = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & h >>> 0 > 0) { l = k; m = h } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; h = j; l = f[h + 4 >> 2] | 0; m = f[h >> 2] | 0 } f[g >> 2] = f[a + 20 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; u = c; return 1 } function td(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 48 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; h = a + 64 | 0; Nh(f[h >> 2] | 0, b) | 0; if (f[h >> 2] | 0) { rn(d); lk(d); i = f[h >> 2] | 0; if ((i | 0) > 0) { h = a + 60 | 0; j = i; do { i = j; j = j + -1 | 0; Vi(d, (f[(f[h >> 2] | 0) + (j >>> 5 << 2) >> 2] & 1 << (j & 31) | 0) != 0) } while ((i | 0) > 1) } fd(d, b); tj(d) } j = a + 76 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); h = f[j >> 2] | 0; if ((h | 0) > 1) { j = a + 72 | 0; i = h; do { h = i; i = i + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) != 0); k = h + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((h | 0) > 3) } fd(d, b); tj(d) } j = a + 88 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); i = f[j >> 2] | 0; if ((i | 0) > 2) { j = a + 84 | 0; h = i; do { i = h; h = h + -3 | 0; Vi(d, (f[(f[j >> 2] | 0) + (h >>> 5 << 2) >> 2] & 1 << (h & 31) | 0) != 0); k = i + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = i + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((i | 0) > 5) } fd(d, b); tj(d) } j = a + 100 | 0; Nh(f[j >> 2] | 0, b) | 0; if (f[j >> 2] | 0) { rn(d); lk(d); h = f[j >> 2] | 0; if ((h | 0) > 3) { j = a + 96 | 0; i = h; do { h = i; i = i + -4 | 0; Vi(d, (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) != 0); k = h + -3 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = h + -2 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0); k = h + -1 | 0; Vi(d, (f[(f[j >> 2] | 0) + (k >>> 5 << 2) >> 2] & 1 << (k & 31) | 0) != 0) } while ((h | 0) > 7) } fd(d, b); tj(d) } f[g >> 2] = f[a + 12 >> 2]; j = b + 16 | 0; i = j; h = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & h >>> 0 > 0) { l = k; m = h } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; h = j; l = f[h + 4 >> 2] | 0; m = f[h >> 2] | 0 } f[g >> 2] = f[a + 16 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; u = c; return 1 } function ud(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; c = a + 4 | 0; if (!b) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(b << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; g = f[c >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = b + -1 | 0; i = (h & b | 0) == 0; if (!i) if (e >>> 0 < b >>> 0) j = e; else j = (e >>> 0) % (b >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = c; c = f[g >> 2] | 0; if (!c) return; else { k = j; l = g; m = c; n = g } a: while (1) { g = l; c = m; j = n; b: while (1) { c: do if (i) { e = c; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = f[e >> 2] | 0; d: do if (!u) v = e; else { w = d[q >> 1] | 0; x = q + 2 | 0; y = e; z = u; while (1) { A = z + 8 | 0; if (w << 16 >> 16 != (d[A >> 1] | 0)) { v = y; break d } if ((d[x >> 1] | 0) != (d[A + 2 >> 1] | 0)) { v = y; break d } A = f[z >> 2] | 0; if (!A) { v = z; break } else { B = z; z = A; y = B } } } while (0); f[j >> 2] = f[v >> 2]; f[v >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { C = 39; break a } } } else { e = c; while (1) { u = f[e + 4 >> 2] | 0; if (u >>> 0 < b >>> 0) D = u; else D = (u >>> 0) % (b >>> 0) | 0; if ((D | 0) == (k | 0)) { p = e; break c } u = (f[a >> 2] | 0) + (D << 2) | 0; if (!(f[u >> 2] | 0)) { r = e; s = D; t = u; break b } u = e + 8 | 0; q = f[e >> 2] | 0; e: do if (!q) E = e; else { y = d[u >> 1] | 0; z = u + 2 | 0; x = e; w = q; while (1) { B = w + 8 | 0; if (y << 16 >> 16 != (d[B >> 1] | 0)) { E = x; break e } if ((d[z >> 1] | 0) != (d[B + 2 >> 1] | 0)) { E = x; break e } B = f[w >> 2] | 0; if (!B) { E = w; break } else { A = w; w = B; x = A } } } while (0); f[j >> 2] = f[E >> 2]; f[E >> 2] = f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { C = 39; break a } } } while (0); c = f[p >> 2] | 0; if (!c) { C = 39; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { C = 39; break } else { k = s; l = r; n = r } } if ((C | 0) == 39) return } function vd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; else { k = j; l = g; m = d; n = g } a: while (1) { g = l; d = m; j = n; b: while (1) { c: do if (i) { e = d; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) { p = e; break c } q = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[q >> 2] | 0)) { r = e; s = o; t = q; break b } q = e + 8 | 0; u = f[e >> 2] | 0; d: do if (!u) v = e; else { w = b[q >> 0] | 0; x = q + 1 | 0; y = e; z = u; while (1) { A = z + 8 | 0; if (w << 24 >> 24 != (b[A >> 0] | 0)) { v = y; break d } if ((b[x >> 0] | 0) != (b[A + 1 >> 0] | 0)) { v = y; break d } A = f[z >> 2] | 0; if (!A) { v = z; break } else { B = z; z = A; y = B } } } while (0); f[j >> 2] = f[v >> 2]; f[v >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { C = 39; break a } } } else { e = d; while (1) { u = f[e + 4 >> 2] | 0; if (u >>> 0 < c >>> 0) D = u; else D = (u >>> 0) % (c >>> 0) | 0; if ((D | 0) == (k | 0)) { p = e; break c } u = (f[a >> 2] | 0) + (D << 2) | 0; if (!(f[u >> 2] | 0)) { r = e; s = D; t = u; break b } u = e + 8 | 0; q = f[e >> 2] | 0; e: do if (!q) E = e; else { y = b[u >> 0] | 0; z = u + 1 | 0; x = e; w = q; while (1) { B = w + 8 | 0; if (y << 24 >> 24 != (b[B >> 0] | 0)) { E = x; break e } if ((b[z >> 0] | 0) != (b[B + 1 >> 0] | 0)) { E = x; break e } B = f[w >> 2] | 0; if (!B) { E = w; break } else { A = w; w = B; x = A } } } while (0); f[j >> 2] = f[E >> 2]; f[E >> 2] = f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (D << 2) >> 2] >> 2] = e; e = f[g >> 2] | 0; if (!e) { C = 39; break a } } } while (0); d = f[p >> 2] | 0; if (!d) { C = 39; break a } else { g = p; j = p } } f[t >> 2] = j; m = f[r >> 2] | 0; if (!m) { C = 39; break } else { k = s; l = r; n = r } } if ((C | 0) == 39) return } function wd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; c = u; u = u + 48 | 0; d = c + 32 | 0; e = c + 28 | 0; g = c + 16 | 0; h = c; i = a + 16 | 0; j = f[i >> 2] | 0; if (j | 0) { k = f[b >> 2] | 0; l = i; m = j; a: while (1) { j = m; while (1) { if ((f[j + 16 >> 2] | 0) >= (k | 0)) break; n = f[j + 4 >> 2] | 0; if (!n) { o = l; break a } else j = n } m = f[j >> 2] | 0; if (!m) { o = j; break } else l = j } if ((o | 0) != (i | 0) ? (k | 0) >= (f[o + 16 >> 2] | 0) : 0) { p = o; q = p + 20 | 0; u = c; return q | 0 } } wp(g); f[h >> 2] = f[b >> 2]; b = h + 4 | 0; f[h + 8 >> 2] = 0; o = h + 12 | 0; f[o >> 2] = 0; k = h + 8 | 0; f[b >> 2] = k; l = f[g >> 2] | 0; m = g + 4 | 0; if ((l | 0) != (m | 0)) { n = k; r = l; while (1) { l = r + 16 | 0; f[e >> 2] = n; f[d >> 2] = f[e >> 2]; Wg(b, d, l, l) | 0; l = f[r + 4 >> 2] | 0; if (!l) { s = r + 8 | 0; t = f[s >> 2] | 0; if ((f[t >> 2] | 0) == (r | 0)) v = t; else { t = s; do { s = f[t >> 2] | 0; t = s + 8 | 0; w = f[t >> 2] | 0 } while ((f[w >> 2] | 0) != (s | 0)); v = w } } else { t = l; while (1) { j = f[t >> 2] | 0; if (!j) break; else t = j } v = t } if ((v | 0) == (m | 0)) break; else r = v } } v = a + 12 | 0; r = f[i >> 2] | 0; do if (r) { d = f[h >> 2] | 0; e = a + 16 | 0; n = r; while (1) { l = f[n + 16 >> 2] | 0; if ((d | 0) < (l | 0)) { j = f[n >> 2] | 0; if (!j) { x = 23; break } else { y = n; z = j } } else { if ((l | 0) >= (d | 0)) { x = 27; break } A = n + 4 | 0; l = f[A >> 2] | 0; if (!l) { x = 26; break } else { y = A; z = l } } e = y; n = z } if ((x | 0) == 23) { B = n; C = n; break } else if ((x | 0) == 26) { B = n; C = A; break } else if ((x | 0) == 27) { B = n; C = e; break } } else { B = i; C = i } while (0); i = f[C >> 2] | 0; if (!i) { x = dn(32) | 0; f[x + 16 >> 2] = f[h >> 2]; A = x + 20 | 0; f[A >> 2] = f[b >> 2]; z = x + 24 | 0; y = f[h + 8 >> 2] | 0; f[z >> 2] = y; r = f[o >> 2] | 0; f[x + 28 >> 2] = r; if (!r) f[A >> 2] = z; else { f[y + 8 >> 2] = z; f[b >> 2] = k; f[k >> 2] = 0; f[o >> 2] = 0 } f[x >> 2] = 0; f[x + 4 >> 2] = 0; f[x + 8 >> 2] = B; f[C >> 2] = x; B = f[f[v >> 2] >> 2] | 0; if (!B) D = x; else { f[v >> 2] = B; D = f[C >> 2] | 0 } Ae(f[a + 16 >> 2] | 0, D); D = a + 20 | 0; f[D >> 2] = (f[D >> 2] | 0) + 1; E = x } else E = i; sj(h + 4 | 0, f[k >> 2] | 0); sj(g, f[m >> 2] | 0); p = E; q = p + 20 | 0; u = c; return q | 0 } function xd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0; d = b[c + 11 >> 0] | 0; e = d << 24 >> 24 < 0; g = e ? f[c >> 2] | 0 : c; i = e ? f[c + 4 >> 2] | 0 : d & 255; if (i >>> 0 > 3) { d = g; c = i; e = i; while (1) { j = X(h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24, 1540483477) | 0; c = (X(j >>> 24 ^ j, 1540483477) | 0) ^ (X(c, 1540483477) | 0); e = e + -4 | 0; if (e >>> 0 <= 3) break; else d = d + 4 | 0 } d = i + -4 | 0; e = d & -4; k = d - e | 0; l = g + (e + 4) | 0; m = c } else { k = i; l = g; m = i } switch (k | 0) { case 3: { n = h[l + 2 >> 0] << 16 ^ m; o = 6; break } case 2: { n = m; o = 6; break } case 1: { p = m; o = 7; break } default: q = m }if ((o | 0) == 6) { p = h[l + 1 >> 0] << 8 ^ n; o = 7 } if ((o | 0) == 7) q = X(p ^ h[l >> 0], 1540483477) | 0; l = X(q >>> 13 ^ q, 1540483477) | 0; q = l >>> 15 ^ l; l = f[a + 4 >> 2] | 0; if (!l) { r = 0; return r | 0 } p = l + -1 | 0; n = (p & l | 0) == 0; if (!n) if (q >>> 0 < l >>> 0) s = q; else s = (q >>> 0) % (l >>> 0) | 0; else s = q & p; m = f[(f[a >> 2] | 0) + (s << 2) >> 2] | 0; if (!m) { r = 0; return r | 0 } a = f[m >> 2] | 0; if (!a) { r = 0; return r | 0 } m = (i | 0) == 0; if (n) { n = a; a: while (1) { k = f[n + 4 >> 2] | 0; c = (k | 0) == (q | 0); if (!(c | (k & p | 0) == (s | 0))) { r = 0; o = 40; break } do if (c ? (k = n + 8 | 0, e = b[k + 11 >> 0] | 0, d = e << 24 >> 24 < 0, j = e & 255, ((d ? f[n + 12 >> 2] | 0 : j) | 0) == (i | 0)) : 0) { e = f[k >> 2] | 0; t = d ? e : k; if (d) { if (m) { r = n; o = 40; break a } if (!(Pk(t, g, i) | 0)) { r = n; o = 40; break a } else break } if (m) { r = n; o = 40; break a } if ((b[g >> 0] | 0) == (e & 255) << 24 >> 24) { e = k; k = j; j = g; do { k = k + -1 | 0; e = e + 1 | 0; if (!k) { r = n; o = 40; break a } j = j + 1 | 0 } while ((b[e >> 0] | 0) == (b[j >> 0] | 0)) } } while (0); n = f[n >> 2] | 0; if (!n) { r = 0; o = 40; break } } if ((o | 0) == 40) return r | 0 } else u = a; b: while (1) { a = f[u + 4 >> 2] | 0; do if ((a | 0) == (q | 0)) { n = u + 8 | 0; p = b[n + 11 >> 0] | 0; c = p << 24 >> 24 < 0; j = p & 255; if (((c ? f[u + 12 >> 2] | 0 : j) | 0) == (i | 0)) { p = f[n >> 2] | 0; e = c ? p : n; if (c) { if (m) { r = u; o = 40; break b } if (!(Pk(e, g, i) | 0)) { r = u; o = 40; break b } else break } if (m) { r = u; o = 40; break b } if ((b[g >> 0] | 0) == (p & 255) << 24 >> 24) { p = n; n = j; j = g; do { n = n + -1 | 0; p = p + 1 | 0; if (!n) { r = u; o = 40; break b } j = j + 1 | 0 } while ((b[p >> 0] | 0) == (b[j >> 0] | 0)) } } } else { if (a >>> 0 < l >>> 0) v = a; else v = (a >>> 0) % (l >>> 0) | 0; if ((v | 0) != (s | 0)) { r = 0; o = 40; break b } } while (0); u = f[u >> 2] | 0; if (!u) { r = 0; o = 40; break } } if ((o | 0) == 40) return r | 0; return 0 } function yd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0; c = a + 4 | 0; if (!b) { d = f[a >> 2] | 0; f[a >> 2] = 0; if (d | 0) br(d); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } d = dn(b << 2) | 0; e = f[a >> 2] | 0; f[a >> 2] = d; if (e | 0) br(e); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; e = f[c >> 2] | 0; if (!e) return; d = f[e + 4 >> 2] | 0; g = b + -1 | 0; h = (g & b | 0) == 0; if (!h) if (d >>> 0 < b >>> 0) i = d; else i = (d >>> 0) % (b >>> 0) | 0; else i = d & g; f[(f[a >> 2] | 0) + (i << 2) >> 2] = c; c = f[e >> 2] | 0; if (!c) return; else { j = i; k = e; l = c; m = e } a: while (1) { e = k; c = l; i = m; b: while (1) { c: do if (h) { d = c; while (1) { n = f[d + 4 >> 2] & g; if ((n | 0) == (j | 0)) { o = d; break c } p = (f[a >> 2] | 0) + (n << 2) | 0; if (!(f[p >> 2] | 0)) { q = d; r = n; s = p; break b } p = d + 12 | 0; t = f[d >> 2] | 0; d: do if (!t) u = d; else { v = f[d + 8 >> 2] | 0; w = d; x = t; while (1) { if ((v | 0) != (f[x + 8 >> 2] | 0)) { u = w; break d } if ((f[p >> 2] | 0) != (f[x + 12 >> 2] | 0)) { u = w; break d } y = f[x >> 2] | 0; if (!y) { u = x; break } else { z = x; x = y; w = z } } } while (0); f[i >> 2] = f[u >> 2]; f[u >> 2] = f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { A = 39; break a } } } else { d = c; while (1) { p = f[d + 4 >> 2] | 0; if (p >>> 0 < b >>> 0) B = p; else B = (p >>> 0) % (b >>> 0) | 0; if ((B | 0) == (j | 0)) { o = d; break c } p = (f[a >> 2] | 0) + (B << 2) | 0; if (!(f[p >> 2] | 0)) { q = d; r = B; s = p; break b } p = d + 12 | 0; t = f[d >> 2] | 0; e: do if (!t) C = d; else { w = f[d + 8 >> 2] | 0; x = d; v = t; while (1) { if ((w | 0) != (f[v + 8 >> 2] | 0)) { C = x; break e } if ((f[p >> 2] | 0) != (f[v + 12 >> 2] | 0)) { C = x; break e } z = f[v >> 2] | 0; if (!z) { C = v; break } else { y = v; v = z; x = y } } } while (0); f[i >> 2] = f[C >> 2]; f[C >> 2] = f[f[(f[a >> 2] | 0) + (B << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (B << 2) >> 2] >> 2] = d; d = f[e >> 2] | 0; if (!d) { A = 39; break a } } } while (0); c = f[o >> 2] | 0; if (!c) { A = 39; break a } else { e = o; i = o } } f[s >> 2] = i; l = f[q >> 2] | 0; if (!l) { A = 39; break } else { j = r; k = q; m = q } } if ((A | 0) == 39) return } function zd(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0; h = a + 4 | 0; i = f[c >> 2] | 0; c = i; do if ((i | 0) != (h | 0)) { j = i + 16 | 0; k = b[j + 11 >> 0] | 0; l = k << 24 >> 24 < 0; m = l ? f[i + 20 >> 2] | 0 : k & 255; k = b[g + 11 >> 0] | 0; n = k << 24 >> 24 < 0; o = n ? f[g + 4 >> 2] | 0 : k & 255; k = m >>> 0 < o >>> 0; p = k ? m : o; if ((p | 0) != 0 ? (q = Pk(n ? f[g >> 2] | 0 : g, l ? f[j >> 2] | 0 : j, p) | 0, (q | 0) != 0) : 0) { if ((q | 0) < 0) break } else r = 4; if ((r | 0) == 4 ? o >>> 0 < m >>> 0 : 0) break; q = o >>> 0 < m >>> 0 ? o : m; if ((q | 0) != 0 ? (m = Pk(l ? f[j >> 2] | 0 : j, n ? f[g >> 2] | 0 : g, q) | 0, (m | 0) != 0) : 0) { if ((m | 0) >= 0) r = 37 } else r = 21; if ((r | 0) == 21 ? !k : 0) r = 37; if ((r | 0) == 37) { f[d >> 2] = c; f[e >> 2] = c; s = e; return s | 0 } k = f[i + 4 >> 2] | 0; m = (k | 0) == 0; if (m) { q = i + 8 | 0; j = f[q >> 2] | 0; if ((f[j >> 2] | 0) == (i | 0)) t = j; else { j = q; do { q = f[j >> 2] | 0; j = q + 8 | 0; l = f[j >> 2] | 0 } while ((f[l >> 2] | 0) != (q | 0)); t = l } } else { j = k; while (1) { l = f[j >> 2] | 0; if (!l) break; else j = l } t = j } do if ((t | 0) != (h | 0)) { k = t + 16 | 0; l = b[k + 11 >> 0] | 0; q = l << 24 >> 24 < 0; p = q ? f[t + 20 >> 2] | 0 : l & 255; l = p >>> 0 < o >>> 0 ? p : o; if ((l | 0) != 0 ? (u = Pk(n ? f[g >> 2] | 0 : g, q ? f[k >> 2] | 0 : k, l) | 0, (u | 0) != 0) : 0) { if ((u | 0) < 0) break } else r = 31; if ((r | 0) == 31 ? o >>> 0 < p >>> 0 : 0) break; s = hg(a, d, g) | 0; return s | 0 } while (0); if (m) { f[d >> 2] = c; s = i + 4 | 0; return s | 0 } else { f[d >> 2] = t; s = t; return s | 0 } } while (0); t = f[i >> 2] | 0; do if ((f[a >> 2] | 0) == (i | 0)) v = c; else { if (!t) { h = i; while (1) { e = f[h + 8 >> 2] | 0; if ((f[e >> 2] | 0) == (h | 0)) h = e; else { w = e; break } } } else { h = t; while (1) { m = f[h + 4 >> 2] | 0; if (!m) { w = h; break } else h = m } } h = w; m = w + 16 | 0; e = b[g + 11 >> 0] | 0; o = e << 24 >> 24 < 0; n = o ? f[g + 4 >> 2] | 0 : e & 255; e = b[m + 11 >> 0] | 0; j = e << 24 >> 24 < 0; p = j ? f[w + 20 >> 2] | 0 : e & 255; e = n >>> 0 < p >>> 0 ? n : p; if ((e | 0) != 0 ? (u = Pk(j ? f[m >> 2] | 0 : m, o ? f[g >> 2] | 0 : g, e) | 0, (u | 0) != 0) : 0) { if ((u | 0) < 0) { v = h; break } } else r = 13; if ((r | 0) == 13 ? p >>> 0 < n >>> 0 : 0) { v = h; break } s = hg(a, d, g) | 0; return s | 0 } while (0); if (!t) { f[d >> 2] = i; s = i; return s | 0 } else { f[d >> 2] = v; s = v + 4 | 0; return s | 0 } return 0 } function Ad(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; g = u; u = u + 16 | 0; h = g; f[c + 48 >> 2] = d; f[c + 44 >> 2] = e; e = f[c + 8 >> 2] | 0; i = c + 12 | 0; j = f[i >> 2] | 0; if ((j | 0) != (e | 0)) { k = j; do { j = k + -4 | 0; f[i >> 2] = j; l = f[j >> 2] | 0; f[j >> 2] = 0; if (l | 0) Va[f[(f[l >> 2] | 0) + 4 >> 2] & 127](l); k = f[i >> 2] | 0 } while ((k | 0) != (e | 0)) } e = f[c + 20 >> 2] | 0; k = c + 24 | 0; i = f[k >> 2] | 0; if ((i | 0) != (e | 0)) f[k >> 2] = i + (~((i + -4 - e | 0) >>> 2) << 2); e = f[c + 32 >> 2] | 0; i = c + 36 | 0; k = f[i >> 2] | 0; if ((k | 0) != (e | 0)) f[i >> 2] = k + (~((k + -4 - e | 0) >>> 2) << 2); if (!(f[c + 4 >> 2] | 0)) { e = dn(32) | 0; f[h >> 2] = e; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 23; m = e; n = 14670; o = m + 23 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[e + 23 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, h); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); u = g; return } Jd(a, c); if (f[a >> 2] | 0) { u = g; return } e = a + 4 | 0; k = e + 11 | 0; if ((b[k >> 0] | 0) < 0) br(f[e >> 2] | 0); Ji(a, c); if (f[a >> 2] | 0) { u = g; return } if ((b[k >> 0] | 0) < 0) br(f[e >> 2] | 0); if (!(Qa[f[(f[c >> 2] | 0) + 16 >> 2] & 127](c) | 0)) { i = dn(32) | 0; f[h >> 2] = i; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 29; m = i; n = 14694; o = m + 29 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[i + 29 >> 0] = 0; f[a >> 2] = -1; dj(e, h); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); u = g; return } if (!(Qa[f[(f[c >> 2] | 0) + 20 >> 2] & 127](c) | 0)) { i = dn(32) | 0; f[h >> 2] = i; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 31; m = i; n = 14724; o = m + 31 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[i + 31 >> 0] = 0; f[a >> 2] = -1; dj(e, h); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); u = g; return } Wa[f[(f[c >> 2] | 0) + 24 >> 2] & 15](a, c); if (f[a >> 2] | 0) { u = g; return } if ((b[k >> 0] | 0) < 0) br(f[e >> 2] | 0); if (!(Qa[f[(f[c >> 2] | 0) + 28 >> 2] & 127](c) | 0)) { k = dn(48) | 0; f[h >> 2] = k; f[h + 8 >> 2] = -2147483600; f[h + 4 >> 2] = 34; m = k; n = 14756; o = m + 34 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[k + 34 >> 0] = 0; f[a >> 2] = -1; dj(e, h); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); u = g; return } e = dn(32) | 0; f[h >> 2] = e; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 30; m = e; n = 14791; o = m + 30 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[e + 30 >> 0] = 0; e = Oj(d, h, 0) | 0; if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); if (e) Va[f[(f[c >> 2] | 0) + 48 >> 2] & 127](c); f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = g; return } function Bd(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; g = a; h = b; i = h; j = c; k = d; l = k; if (!i) { m = (e | 0) != 0; if (!l) { if (m) { f[e >> 2] = (g >>> 0) % (j >>> 0); f[e + 4 >> 2] = 0 } n = 0; o = (g >>> 0) / (j >>> 0) >>> 0; return (I = n, o) | 0 } else { if (!m) { n = 0; o = 0; return (I = n, o) | 0 } f[e >> 2] = a | 0; f[e + 4 >> 2] = b & 0; n = 0; o = 0; return (I = n, o) | 0 } } m = (l | 0) == 0; do if (j) { if (!m) { p = (_(l | 0) | 0) - (_(i | 0) | 0) | 0; if (p >>> 0 <= 31) { q = p + 1 | 0; r = 31 - p | 0; s = p - 31 >> 31; t = q; u = g >>> (q >>> 0) & s | i << r; v = i >>> (q >>> 0) & s; w = 0; x = g << r; break } if (!e) { n = 0; o = 0; return (I = n, o) | 0 } f[e >> 2] = a | 0; f[e + 4 >> 2] = h | b & 0; n = 0; o = 0; return (I = n, o) | 0 } r = j - 1 | 0; if (r & j | 0) { s = (_(j | 0) | 0) + 33 - (_(i | 0) | 0) | 0; q = 64 - s | 0; p = 32 - s | 0; y = p >> 31; z = s - 32 | 0; A = z >> 31; t = s; u = p - 1 >> 31 & i >>> (z >>> 0) | (i << p | g >>> (s >>> 0)) & A; v = A & i >>> (s >>> 0); w = g << q & y; x = (i << q | g >>> (z >>> 0)) & y | g << p & s - 33 >> 31; break } if (e | 0) { f[e >> 2] = r & g; f[e + 4 >> 2] = 0 } if ((j | 0) == 1) { n = h | b & 0; o = a | 0 | 0; return (I = n, o) | 0 } else { r = im(j | 0) | 0; n = i >>> (r >>> 0) | 0; o = i << 32 - r | g >>> (r >>> 0) | 0; return (I = n, o) | 0 } } else { if (m) { if (e | 0) { f[e >> 2] = (i >>> 0) % (j >>> 0); f[e + 4 >> 2] = 0 } n = 0; o = (i >>> 0) / (j >>> 0) >>> 0; return (I = n, o) | 0 } if (!g) { if (e | 0) { f[e >> 2] = 0; f[e + 4 >> 2] = (i >>> 0) % (l >>> 0) } n = 0; o = (i >>> 0) / (l >>> 0) >>> 0; return (I = n, o) | 0 } r = l - 1 | 0; if (!(r & l)) { if (e | 0) { f[e >> 2] = a | 0; f[e + 4 >> 2] = r & i | b & 0 } n = 0; o = i >>> ((im(l | 0) | 0) >>> 0); return (I = n, o) | 0 } r = (_(l | 0) | 0) - (_(i | 0) | 0) | 0; if (r >>> 0 <= 30) { s = r + 1 | 0; p = 31 - r | 0; t = s; u = i << p | g >>> (s >>> 0); v = i >>> (s >>> 0); w = 0; x = g << p; break } if (!e) { n = 0; o = 0; return (I = n, o) | 0 } f[e >> 2] = a | 0; f[e + 4 >> 2] = h | b & 0; n = 0; o = 0; return (I = n, o) | 0 } while (0); if (!t) { B = x; C = w; D = v; E = u; F = 0; G = 0 } else { b = c | 0 | 0; c = k | d & 0; d = Tn(b | 0, c | 0, -1, -1) | 0; k = I; h = x; x = w; w = v; v = u; u = t; t = 0; do { a = h; h = x >>> 31 | h << 1; x = t | x << 1; g = v << 1 | a >>> 31 | 0; a = v >>> 31 | w << 1 | 0; Vn(d | 0, k | 0, g | 0, a | 0) | 0; i = I; l = i >> 31 | ((i | 0) < 0 ? -1 : 0) << 1; t = l & 1; v = Vn(g | 0, a | 0, l & b | 0, (((i | 0) < 0 ? -1 : 0) >> 31 | ((i | 0) < 0 ? -1 : 0) << 1) & c | 0) | 0; w = I; u = u - 1 | 0 } while ((u | 0) != 0); B = h; C = x; D = w; E = v; F = 0; G = t } t = C; C = 0; if (e | 0) { f[e >> 2] = E; f[e + 4 >> 2] = D } n = (t | 0) >>> 31 | (B | C) << 1 | (C << 1 | t >>> 31) & 0 | F; o = (t << 1 | 0 >>> 31) & -2 | G; return (I = n, o) | 0 } function Cd(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; c = u; u = u + 32 | 0; d = c + 4 | 0; e = c; g = c + 16 | 0; h = a + 48 | 0; i = f[h >> 2] | 0; j = dn(32) | 0; f[d >> 2] = j; f[d + 8 >> 2] = -2147483616; f[d + 4 >> 2] = 20; k = j; l = 13101; m = k + 20 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[j + 20 >> 0] = 0; j = vk(i + 24 | 0, d) | 0; if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); i = f[h >> 2] | 0; n = dn(32) | 0; f[d >> 2] = n; f[d + 8 >> 2] = -2147483616; f[d + 4 >> 2] = 22; k = n; l = 13122; m = k + 22 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[n + 22 >> 0] = 0; n = vk(i + 24 | 0, d) | 0; if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); i = a + 64 | 0; o = f[i >> 2] | 0; f[i >> 2] = 0; if (o | 0) Va[f[(f[o >> 2] | 0) + 4 >> 2] & 127](o); o = f[a + 56 >> 2] | 0; p = (((f[o + 100 >> 2] | 0) - (f[o + 96 >> 2] | 0) | 0) / 12 | 0) >>> 0 < 1e3; o = f[h >> 2] | 0; q = dn(32) | 0; f[d >> 2] = q; f[d + 8 >> 2] = -2147483616; f[d + 4 >> 2] = 18; k = q; l = 13145; m = k + 18 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[q + 18 >> 0] = 0; q = yk(o, d, -1) | 0; if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); switch (q | 0) { case -1: { if (j ? p | ((Yh(f[h >> 2] | 0) | 0) > 4 | n ^ 1) : 0) r = 13; else r = 17; break } case 0: { if (j) r = 13; else r = 21; break } case 2: { r = 17; break } default: r = 21 }if ((r | 0) == 13) { j = f[a + 44 >> 2] | 0; b[g >> 0] = 0; n = j + 16 | 0; h = f[n + 4 >> 2] | 0; if (!((h | 0) > 0 | (h | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) { f[e >> 2] = f[j + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(j, d, g, g + 1 | 0) | 0 } j = dn(296) | 0; Ni(j); n = f[i >> 2] | 0; f[i >> 2] = j; if (!n) s = j; else { Va[f[(f[n >> 2] | 0) + 4 >> 2] & 127](n); r = 21 } } else if ((r | 0) == 17) { n = f[a + 44 >> 2] | 0; b[g >> 0] = 2; j = n + 16 | 0; h = f[j + 4 >> 2] | 0; if (!((h | 0) > 0 | (h | 0) == 0 & (f[j >> 2] | 0) >>> 0 > 0)) { f[e >> 2] = f[n + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(n, d, g, g + 1 | 0) | 0 } g = dn(360) | 0; ji(g); d = f[i >> 2] | 0; f[i >> 2] = g; if (!d) s = g; else { Va[f[(f[d >> 2] | 0) + 4 >> 2] & 127](d); r = 21 } } if ((r | 0) == 21) { r = f[i >> 2] | 0; if (!r) { t = 0; u = c; return t | 0 } else s = r } t = Ra[f[(f[s >> 2] | 0) + 8 >> 2] & 127](s, a) | 0; u = c; return t | 0 } function Dd(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; e = b + 12 | 0; g = f[e >> 2] | 0; h = c + 4 | 0; i = (f[h >> 2] | 0) - g | 0; j = c; f[j >> 2] = (f[c >> 2] | 0) - g; f[j + 4 >> 2] = i; i = (f[d >> 2] | 0) - g | 0; j = d + 4 | 0; k = (f[j >> 2] | 0) - g | 0; g = d; f[g >> 2] = i; f[g + 4 >> 2] = k; g = f[e >> 2] | 0; if ((((k | 0) > -1 ? k : 0 - k | 0) + ((i | 0) > -1 ? i : 0 - i | 0) | 0) > (g | 0)) { l = f[c >> 2] | 0; m = f[h >> 2] | 0; if ((l | 0) > -1) if ((m | 0) <= -1) if ((l | 0) < 1) { n = -1; o = -1 } else p = 6; else { n = 1; o = 1 } else if ((m | 0) < 1) { n = -1; o = -1 } else p = 6; if ((p | 0) == 6) { n = (l | 0) > 0 ? 1 : -1; o = (m | 0) > 0 ? 1 : -1 } q = X(g, n) | 0; r = X(g, o) | 0; g = (l << 1) - q | 0; f[c >> 2] = g; l = (m << 1) - r | 0; f[h >> 2] = l; if ((X(n, o) | 0) > -1) { o = 0 - l | 0; f[c >> 2] = o; s = 0 - g | 0; t = o } else { f[c >> 2] = l; s = g; t = l } f[c >> 2] = (t + q | 0) / 2 | 0; f[h >> 2] = (s + r | 0) / 2 | 0; r = f[d >> 2] | 0; s = f[j >> 2] | 0; if ((r | 0) > -1) if ((s | 0) <= -1) if ((r | 0) < 1) { u = -1; v = -1 } else p = 14; else { u = 1; v = 1 } else if ((s | 0) < 1) { u = -1; v = -1 } else p = 14; if ((p | 0) == 14) { u = (r | 0) > 0 ? 1 : -1; v = (s | 0) > 0 ? 1 : -1 } q = f[e >> 2] | 0; e = X(q, u) | 0; t = X(q, v) | 0; q = (r << 1) - e | 0; f[d >> 2] = q; r = (s << 1) - t | 0; f[j >> 2] = r; if ((X(u, v) | 0) > -1) { v = 0 - r | 0; f[d >> 2] = v; w = 0 - q | 0; x = v } else { f[d >> 2] = r; w = q; x = r } r = (x + e | 0) / 2 | 0; f[d >> 2] = r; e = (w + t | 0) / 2 | 0; f[j >> 2] = e; y = r; z = e } else { y = i; z = k } if (!y) if (!z) { A = y; B = z } else p = 22; else if ((y | 0) < 0 & (z | 0) < 1) { A = y; B = z } else p = 22; if ((p | 0) == 22) { if (!y) C = (z | 0) == 0 ? 0 : (z | 0) > 0 ? 3 : 1; else C = (y | 0) > 0 ? (z >> 31) + 2 | 0 : (z | 0) < 1 ? 0 : 3; z = f[c >> 2] | 0; y = f[h >> 2] | 0; switch (C | 0) { case 1: { C = c; f[C >> 2] = y; f[C + 4 >> 2] = 0 - z; D = f[j >> 2] | 0; E = 0 - (f[d >> 2] | 0) | 0; break } case 2: { C = c; f[C >> 2] = 0 - z; f[C + 4 >> 2] = 0 - y; D = 0 - (f[d >> 2] | 0) | 0; E = 0 - (f[j >> 2] | 0) | 0; break } case 3: { C = c; f[C >> 2] = 0 - y; f[C + 4 >> 2] = z; D = 0 - (f[j >> 2] | 0) | 0; E = f[d >> 2] | 0; break } default: { C = c; f[C >> 2] = z; f[C + 4 >> 2] = y; D = f[d >> 2] | 0; E = f[j >> 2] | 0 } }j = d; f[j >> 2] = D; f[j + 4 >> 2] = E; A = D; B = E } E = (f[c >> 2] | 0) - A | 0; f[a >> 2] = E; A = (f[h >> 2] | 0) - B | 0; B = a + 4 | 0; f[B >> 2] = A; if ((E | 0) < 0) F = (f[b + 4 >> 2] | 0) + E | 0; else F = E; f[a >> 2] = F; if ((A | 0) >= 0) { G = A; f[B >> 2] = G; return } G = (f[b + 4 >> 2] | 0) + A | 0; f[B >> 2] = G; return } function Ed(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; c = a + 4 | 0; if (!b) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(b << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; g = f[c >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = b + -1 | 0; i = (h & b | 0) == 0; if (!i) if (e >>> 0 < b >>> 0) j = e; else j = (e >>> 0) % (b >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = c; c = f[g >> 2] | 0; if (!c) return; else { k = j; l = g; m = c; n = g } a: while (1) { b: do if (i) { g = l; c = m; j = n; while (1) { e = c; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) break; p = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[p >> 2] | 0)) { q = e; r = j; s = o; t = p; break b } p = e + 8 | 0; u = e; while (1) { v = f[u >> 2] | 0; if (!v) break; if ((d[p >> 1] | 0) == (d[v + 8 >> 1] | 0)) u = v; else break } f[j >> 2] = v; f[u >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; p = f[g >> 2] | 0; if (!p) { w = 37; break a } else e = p } c = f[e >> 2] | 0; if (!c) { w = 37; break a } else { g = e; j = e } } } else { j = l; g = m; c = n; while (1) { p = g; while (1) { x = f[p + 4 >> 2] | 0; if (x >>> 0 < b >>> 0) y = x; else y = (x >>> 0) % (b >>> 0) | 0; if ((y | 0) == (k | 0)) break; x = (f[a >> 2] | 0) + (y << 2) | 0; if (!(f[x >> 2] | 0)) { q = p; r = c; s = y; t = x; break b } x = p + 8 | 0; z = p; while (1) { A = f[z >> 2] | 0; if (!A) break; if ((d[x >> 1] | 0) == (d[A + 8 >> 1] | 0)) z = A; else break } f[c >> 2] = A; f[z >> 2] = f[f[(f[a >> 2] | 0) + (y << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (y << 2) >> 2] >> 2] = p; x = f[j >> 2] | 0; if (!x) { w = 37; break a } else p = x } g = f[p >> 2] | 0; if (!g) { w = 37; break a } else { j = p; c = p } } } while (0); f[t >> 2] = r; m = f[q >> 2] | 0; if (!m) { w = 37; break } else { k = s; l = q; n = q } } if ((w | 0) == 37) return } function Fd(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; else { k = j; l = g; m = d; n = g } a: while (1) { b: do if (i) { g = l; d = m; j = n; while (1) { e = d; while (1) { o = f[e + 4 >> 2] & h; if ((o | 0) == (k | 0)) break; p = (f[a >> 2] | 0) + (o << 2) | 0; if (!(f[p >> 2] | 0)) { q = e; r = j; s = o; t = p; break b } p = e + 8 | 0; u = e; while (1) { v = f[u >> 2] | 0; if (!v) break; if ((b[p >> 0] | 0) == (b[v + 8 >> 0] | 0)) u = v; else break } f[j >> 2] = v; f[u >> 2] = f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (o << 2) >> 2] >> 2] = e; p = f[g >> 2] | 0; if (!p) { w = 37; break a } else e = p } d = f[e >> 2] | 0; if (!d) { w = 37; break a } else { g = e; j = e } } } else { j = l; g = m; d = n; while (1) { p = g; while (1) { x = f[p + 4 >> 2] | 0; if (x >>> 0 < c >>> 0) y = x; else y = (x >>> 0) % (c >>> 0) | 0; if ((y | 0) == (k | 0)) break; x = (f[a >> 2] | 0) + (y << 2) | 0; if (!(f[x >> 2] | 0)) { q = p; r = d; s = y; t = x; break b } x = p + 8 | 0; z = p; while (1) { A = f[z >> 2] | 0; if (!A) break; if ((b[x >> 0] | 0) == (b[A + 8 >> 0] | 0)) z = A; else break } f[d >> 2] = A; f[z >> 2] = f[f[(f[a >> 2] | 0) + (y << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (y << 2) >> 2] >> 2] = p; x = f[j >> 2] | 0; if (!x) { w = 37; break a } else p = x } g = f[p >> 2] | 0; if (!g) { w = 37; break a } else { j = p; d = p } } } while (0); f[t >> 2] = r; m = f[q >> 2] | 0; if (!m) { w = 37; break } else { k = s; l = q; n = q } } if ((w | 0) == 37) return } function Gd(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0; g = f[c >> 2] | 0; c = f[b >> 2] | 0; h = g - c | 0; i = a + 8 | 0; j = f[i >> 2] | 0; if (h >>> 0 < 64) { if (j >>> 0 <= 1) { k = 0; return k | 0 } l = f[e >> 2] | 0; m = 0; n = 1; while (1) { o = (f[l + (m << 2) >> 2] | 0) >>> 0 > (f[l + (n << 2) >> 2] | 0) >>> 0 ? n : m; n = n + 1 | 0; if (n >>> 0 >= j >>> 0) { k = o; break } else m = o } return k | 0 } if (j) { j = f[a + 1128 >> 2] | 0; m = f[e >> 2] | 0; e = f[a + 1140 >> 2] | 0; n = f[d >> 2] | 0; d = b + 4 | 0; l = b + 8 | 0; if ((g | 0) == (c | 0)) { b = 0; do { o = j + (b << 2) | 0; f[o >> 2] = 0; p = (f[a >> 2] | 0) - (f[m + (b << 2) >> 2] | 0) | 0; f[e + (b << 2) >> 2] = p; if (p | 0) { p = f[o >> 2] | 0; q = h - p | 0; f[o >> 2] = q >>> 0 < p >>> 0 ? p : q } b = b + 1 | 0; q = f[i >> 2] | 0 } while (b >>> 0 < q >>> 0); r = q } else { b = 0; do { q = j + (b << 2) | 0; f[q >> 2] = 0; p = (f[a >> 2] | 0) - (f[m + (b << 2) >> 2] | 0) | 0; f[e + (b << 2) >> 2] = p; if (p | 0) { o = (f[n + (b << 2) >> 2] | 0) + (1 << p + -1) | 0; p = f[l >> 2] | 0; s = f[(f[d >> 2] | 0) + 24 >> 2] | 0; t = c; u = f[q >> 2] | 0; do { v = s + ((X(t, p) | 0) << 2) + (b << 2) | 0; u = u + ((f[v >> 2] | 0) >>> 0 < o >>> 0 & 1) | 0; f[q >> 2] = u; t = t + 1 | 0 } while ((t | 0) != (g | 0)); t = h - u | 0; f[q >> 2] = t >>> 0 < u >>> 0 ? u : t } b = b + 1 | 0; t = f[i >> 2] | 0 } while (b >>> 0 < t >>> 0); r = t } if (r) { b = f[a + 1140 >> 2] | 0; i = a + 1128 | 0; h = 0; g = 0; c = 0; while (1) { if (!(f[b + (g << 2) >> 2] | 0)) { w = h; x = c } else { d = f[(f[i >> 2] | 0) + (g << 2) >> 2] | 0; l = h >>> 0 < d >>> 0; w = l ? d : h; x = l ? g : c } g = g + 1 | 0; if (g >>> 0 >= r >>> 0) { y = x; break } else { h = w; c = x } } } else y = 0 } else y = 0; x = a + 1088 | 0; c = a + 1104 | 0; w = f[c >> 2] | 0; h = 32 - w | 0; if ((h | 0) < 4) { r = y & 15; g = 4 - h | 0; f[c >> 2] = g; h = a + 1100 | 0; i = f[h >> 2] | r >>> g; f[h >> 2] = i; g = a + 1092 | 0; b = f[g >> 2] | 0; if ((b | 0) == (f[a + 1096 >> 2] | 0)) Ci(x, h); else { f[b >> 2] = i; f[g >> 2] = b + 4 } f[h >> 2] = r << 32 - (f[c >> 2] | 0); k = y; return k | 0 } r = a + 1100 | 0; h = f[r >> 2] | y << 28 >>> w; f[r >> 2] = h; b = w + 4 | 0; f[c >> 2] = b; if ((b | 0) != 32) { k = y; return k | 0 } b = a + 1092 | 0; w = f[b >> 2] | 0; if ((w | 0) == (f[a + 1096 >> 2] | 0)) Ci(x, r); else { f[w >> 2] = h; f[b >> 2] = w + 4 } f[r >> 2] = 0; f[c >> 2] = 0; k = y; return k | 0 } function Hd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0; c = a + 4 | 0; if (!b) { d = f[a >> 2] | 0; f[a >> 2] = 0; if (d | 0) br(d); f[c >> 2] = 0; return } if (b >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } d = dn(b << 2) | 0; e = f[a >> 2] | 0; f[a >> 2] = d; if (e | 0) br(e); f[c >> 2] = b; c = 0; do { f[(f[a >> 2] | 0) + (c << 2) >> 2] = 0; c = c + 1 | 0 } while ((c | 0) != (b | 0)); c = a + 8 | 0; e = f[c >> 2] | 0; if (!e) return; d = f[e + 4 >> 2] | 0; g = b + -1 | 0; h = (g & b | 0) == 0; if (!h) if (d >>> 0 < b >>> 0) i = d; else i = (d >>> 0) % (b >>> 0) | 0; else i = d & g; f[(f[a >> 2] | 0) + (i << 2) >> 2] = c; c = f[e >> 2] | 0; if (!c) return; else { j = i; k = e; l = c; m = e } a: while (1) { b: do if (h) { e = k; c = l; i = m; while (1) { d = c; while (1) { n = f[d + 4 >> 2] & g; if ((n | 0) == (j | 0)) break; o = (f[a >> 2] | 0) + (n << 2) | 0; if (!(f[o >> 2] | 0)) { p = d; q = i; r = n; s = o; break b } o = d + 8 | 0; t = d; while (1) { u = f[t >> 2] | 0; if (!u) break; if ((f[o >> 2] | 0) == (f[u + 8 >> 2] | 0)) t = u; else break } f[i >> 2] = u; f[t >> 2] = f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (n << 2) >> 2] >> 2] = d; o = f[e >> 2] | 0; if (!o) { v = 37; break a } else d = o } c = f[d >> 2] | 0; if (!c) { v = 37; break a } else { e = d; i = d } } } else { i = k; e = l; c = m; while (1) { o = e; while (1) { w = f[o + 4 >> 2] | 0; if (w >>> 0 < b >>> 0) x = w; else x = (w >>> 0) % (b >>> 0) | 0; if ((x | 0) == (j | 0)) break; w = (f[a >> 2] | 0) + (x << 2) | 0; if (!(f[w >> 2] | 0)) { p = o; q = c; r = x; s = w; break b } w = o + 8 | 0; y = o; while (1) { z = f[y >> 2] | 0; if (!z) break; if ((f[w >> 2] | 0) == (f[z + 8 >> 2] | 0)) y = z; else break } f[c >> 2] = z; f[y >> 2] = f[f[(f[a >> 2] | 0) + (x << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (x << 2) >> 2] >> 2] = o; w = f[i >> 2] | 0; if (!w) { v = 37; break a } else o = w } e = f[o >> 2] | 0; if (!e) { v = 37; break a } else { i = o; c = o } } } while (0); f[s >> 2] = q; l = f[p >> 2] | 0; if (!l) { v = 37; break } else { j = r; k = p; m = p } } if ((v | 0) == 37) return } function Id(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; d = a + 4 | 0; if (!c) { e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) br(e); f[d >> 2] = 0; return } if (c >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } e = dn(c << 2) | 0; g = f[a >> 2] | 0; f[a >> 2] = e; if (g | 0) br(g); f[d >> 2] = c; d = 0; do { f[(f[a >> 2] | 0) + (d << 2) >> 2] = 0; d = d + 1 | 0 } while ((d | 0) != (c | 0)); d = a + 8 | 0; g = f[d >> 2] | 0; if (!g) return; e = f[g + 4 >> 2] | 0; h = c + -1 | 0; i = (h & c | 0) == 0; if (!i) if (e >>> 0 < c >>> 0) j = e; else j = (e >>> 0) % (c >>> 0) | 0; else j = e & h; f[(f[a >> 2] | 0) + (j << 2) >> 2] = d; d = f[g >> 2] | 0; if (!d) return; e = a + 24 | 0; k = j; j = g; l = d; d = g; a: while (1) { g = j; m = l; n = d; b: while (1) { o = m; while (1) { p = f[o + 4 >> 2] | 0; if (!i) if (p >>> 0 < c >>> 0) q = p; else q = (p >>> 0) % (c >>> 0) | 0; else q = p & h; if ((q | 0) == (k | 0)) break; r = (f[a >> 2] | 0) + (q << 2) | 0; if (!(f[r >> 2] | 0)) break b; p = f[o >> 2] | 0; c: do if (!p) s = o; else { t = f[o + 8 >> 2] | 0; u = f[e >> 2] | 0; v = f[u + 8 >> 2] | 0; w = (f[u + 12 >> 2] | 0) - v | 0; u = v; v = w >>> 2; if ((w | 0) > 0) { x = o; y = p } else { w = p; while (1) { z = f[w >> 2] | 0; if (!z) { s = w; break c } else w = z } } while (1) { w = f[y + 8 >> 2] | 0; z = 0; do { A = f[u + (z << 2) >> 2] | 0; if (!(b[A + 84 >> 0] | 0)) { B = f[A + 68 >> 2] | 0; C = f[B + (w << 2) >> 2] | 0; D = f[B + (t << 2) >> 2] | 0 } else { C = w; D = t } z = z + 1 | 0; if ((D | 0) != (C | 0)) { s = x; break c } } while ((z | 0) < (v | 0)); z = f[y >> 2] | 0; if (!z) { s = y; break } else { w = y; y = z; x = w } } } while (0); f[n >> 2] = f[s >> 2]; f[s >> 2] = f[f[(f[a >> 2] | 0) + (q << 2) >> 2] >> 2]; f[f[(f[a >> 2] | 0) + (q << 2) >> 2] >> 2] = o; p = f[g >> 2] | 0; if (!p) { E = 38; break a } else o = p } m = f[o >> 2] | 0; if (!m) { E = 38; break a } else { g = o; n = o } } f[r >> 2] = n; l = f[o >> 2] | 0; if (!l) { E = 38; break } else { k = q; j = o; d = o } } if ((E | 0) == 38) return } function Jd(a, c) { a = a | 0; c = c | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; i = e + 12 | 0; j = e + 11 | 0; k = e + 10 | 0; l = e + 8 | 0; m = c + 44 | 0; n = f[m >> 2] | 0; o = n + 16 | 0; p = f[o + 4 >> 2] | 0; if (!((p | 0) > 0 | (p | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[n + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(n, g, 14849, 14854) | 0 } n = Qa[f[(f[c >> 2] | 0) + 8 >> 2] & 127](c) | 0; b[i >> 0] = n; b[j >> 0] = 2; b[k >> 0] = (n & 255 | 0) == 0 ? 3 : 2; n = f[m >> 2] | 0; o = n + 16 | 0; p = f[o + 4 >> 2] | 0; if (!((p | 0) > 0 | (p | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[n + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(n, g, j, j + 1 | 0) | 0; j = f[m >> 2] | 0; o = j + 16 | 0; p = f[o + 4 >> 2] | 0; if (!((p | 0) > 0 | (p | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[j + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(j, g, k, k + 1 | 0) | 0; k = f[m >> 2] | 0; o = k + 16 | 0; p = f[o + 4 >> 2] | 0; if ((p | 0) > 0 | (p | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0) { q = h; r = k } else { f[h >> 2] = f[k + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(k, g, i, i + 1 | 0) | 0; q = h; r = f[m >> 2] | 0 } } else { s = h; t = j; v = 6 } } else { s = h; t = n; v = 6 } if ((v | 0) == 6) { q = h; r = t } t = Qa[f[(f[c >> 2] | 0) + 12 >> 2] & 127](c) | 0; b[l >> 0] = t; t = r + 16 | 0; q = f[t + 4 >> 2] | 0; if (!((q | 0) > 0 | (q | 0) == 0 & (f[t >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[r + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(r, g, l, l + 1 | 0) | 0 } d[l >> 1] = (f[(f[c + 4 >> 2] | 0) + 4 >> 2] | 0) == 0 ? 0 : -32768; c = f[m >> 2] | 0; m = c + 16 | 0; r = f[m + 4 >> 2] | 0; if ((r | 0) > 0 | (r | 0) == 0 & (f[m >> 2] | 0) >>> 0 > 0) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } f[h >> 2] = f[c + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(c, g, l, l + 2 | 0) | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } function Kd(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = Oa, x = 0, y = Oa, z = Oa, A = Oa, B = Oa; e = u; u = u + 16 | 0; g = e; h = a + 4 | 0; if ((f[h >> 2] | 0) != -1) { i = 0; u = e; return i | 0 } f[h >> 2] = d; d = b[c + 24 >> 0] | 0; h = d << 24 >> 24; j = a + 20 | 0; n[j >> 2] = $(0.0); f[g >> 2] = 0; k = g + 4 | 0; f[k >> 2] = 0; f[g + 8 >> 2] = 0; do if (d << 24 >> 24) if (d << 24 >> 24 < 0) mq(g); else { l = h << 2; m = dn(l) | 0; f[g >> 2] = m; o = m + (h << 2) | 0; f[g + 8 >> 2] = o; hj(m | 0, 0, l | 0) | 0; l = m + (h << 2) | 0; f[k >> 2] = l; p = m; q = l; r = o; break } else { p = 0; q = 0; r = 0 } while (0); k = a + 8 | 0; g = f[k >> 2] | 0; o = a + 12 | 0; if (!g) s = a + 16 | 0; else { l = f[o >> 2] | 0; if ((l | 0) != (g | 0)) f[o >> 2] = l + (~((l + -4 - g | 0) >>> 2) << 2); br(g); g = a + 16 | 0; f[g >> 2] = 0; f[o >> 2] = 0; f[k >> 2] = 0; s = g } f[k >> 2] = p; f[o >> 2] = q; f[s >> 2] = r; r = h >>> 0 > 1073741823 ? -1 : h << 2; s = _q(r) | 0; q = _q(r) | 0; r = c + 48 | 0; o = f[r >> 2] | 0; g = c + 40 | 0; a = f[g >> 2] | 0; l = f[c >> 2] | 0; Rg(q | 0, (f[l >> 2] | 0) + o | 0, a | 0) | 0; Rg(p | 0, (f[l >> 2] | 0) + o | 0, a | 0) | 0; a = r; r = f[a >> 2] | 0; o = f[a + 4 >> 2] | 0; a = g; g = f[a >> 2] | 0; l = f[a + 4 >> 2] | 0; a = f[c >> 2] | 0; Rg(s | 0, (f[a >> 2] | 0) + r | 0, g | 0) | 0; p = f[c + 80 >> 2] | 0; a: do if (p >>> 0 > 1) { if (d << 24 >> 24 <= 0) { c = 1; while (1) { m = on(g | 0, l | 0, c | 0, 0) | 0; t = Tn(m | 0, I | 0, r | 0, o | 0) | 0; Rg(q | 0, (f[a >> 2] | 0) + t | 0, g | 0) | 0; c = c + 1 | 0; if (c >>> 0 >= p >>> 0) break a } } c = f[k >> 2] | 0; t = 1; do { m = on(g | 0, l | 0, t | 0, 0) | 0; v = Tn(m | 0, I | 0, r | 0, o | 0) | 0; Rg(q | 0, (f[a >> 2] | 0) + v | 0, g | 0) | 0; v = 0; do { m = c + (v << 2) | 0; w = $(n[m >> 2]); x = q + (v << 2) | 0; y = $(n[x >> 2]); if (w > y) { n[m >> 2] = y; z = $(n[x >> 2]) } else z = y; x = s + (v << 2) | 0; if ($(n[x >> 2]) < z) n[x >> 2] = z; v = v + 1 | 0 } while ((v | 0) != (h | 0)); t = t + 1 | 0 } while (t >>> 0 < p >>> 0) } while (0); if (d << 24 >> 24 > 0) { d = f[k >> 2] | 0; k = 0; z = $(n[j >> 2]); while (1) { y = $(n[s + (k << 2) >> 2]); w = $(y - $(n[d + (k << 2) >> 2])); if (w > z) { n[j >> 2] = w; A = w } else A = z; k = k + 1 | 0; if ((k | 0) == (h | 0)) { B = A; break } else z = A } } else B = $(n[j >> 2]); if (B == $(0.0)) n[j >> 2] = $(1.0); $q(q); $q(s); i = 1; u = e; return i | 0 } function Ld(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0; g = a + 8 | 0; Ah(g, b, d, e); h = d - e | 0; if ((h | 0) > 0) { d = 0 - e | 0; i = a + 16 | 0; j = a + 32 | 0; k = a + 12 | 0; l = a + 28 | 0; m = a + 20 | 0; n = a + 24 | 0; o = h; h = f[g >> 2] | 0; while (1) { p = b + (o << 2) | 0; q = c + (o << 2) | 0; if ((h | 0) > 0) { r = 0; s = p + (d << 2) | 0; t = h; while (1) { if ((t | 0) > 0) { u = 0; do { v = f[s + (u << 2) >> 2] | 0; w = f[i >> 2] | 0; if ((v | 0) > (w | 0)) { x = f[j >> 2] | 0; f[x + (u << 2) >> 2] = w; y = x } else { x = f[k >> 2] | 0; w = f[j >> 2] | 0; f[w + (u << 2) >> 2] = (v | 0) < (x | 0) ? x : v; y = w } u = u + 1 | 0 } while ((u | 0) < (f[g >> 2] | 0)); z = y } else z = f[j >> 2] | 0; u = (f[p + (r << 2) >> 2] | 0) - (f[z + (r << 2) >> 2] | 0) | 0; w = q + (r << 2) | 0; f[w >> 2] = u; if ((u | 0) >= (f[l >> 2] | 0)) { if ((u | 0) > (f[n >> 2] | 0)) { A = u - (f[m >> 2] | 0) | 0; B = 31 } } else { A = (f[m >> 2] | 0) + u | 0; B = 31 } if ((B | 0) == 31) { B = 0; f[w >> 2] = A } r = r + 1 | 0; w = f[g >> 2] | 0; if ((r | 0) >= (w | 0)) { C = w; break } else { s = z; t = w } } } else C = h; o = o - e | 0; if ((o | 0) <= 0) { D = C; break } else h = C } } else D = f[g >> 2] | 0; C = e >>> 0 > 1073741823 ? -1 : e << 2; e = _q(C) | 0; hj(e | 0, 0, C | 0) | 0; if ((D | 0) <= 0) { $q(e); return 1 } C = a + 16 | 0; h = a + 32 | 0; o = a + 12 | 0; z = a + 28 | 0; A = a + 20 | 0; m = a + 24 | 0; a = 0; n = e; l = D; while (1) { if ((l | 0) > 0) { D = 0; do { j = f[n + (D << 2) >> 2] | 0; y = f[C >> 2] | 0; if ((j | 0) > (y | 0)) { k = f[h >> 2] | 0; f[k + (D << 2) >> 2] = y; E = k } else { k = f[o >> 2] | 0; y = f[h >> 2] | 0; f[y + (D << 2) >> 2] = (j | 0) < (k | 0) ? k : j; E = y } D = D + 1 | 0 } while ((D | 0) < (f[g >> 2] | 0)); F = E } else F = f[h >> 2] | 0; D = (f[b + (a << 2) >> 2] | 0) - (f[F + (a << 2) >> 2] | 0) | 0; y = c + (a << 2) | 0; f[y >> 2] = D; if ((D | 0) >= (f[z >> 2] | 0)) { if ((D | 0) > (f[m >> 2] | 0)) { G = D - (f[A >> 2] | 0) | 0; B = 16 } } else { G = (f[A >> 2] | 0) + D | 0; B = 16 } if ((B | 0) == 16) { B = 0; f[y >> 2] = G } a = a + 1 | 0; l = f[g >> 2] | 0; if ((a | 0) >= (l | 0)) break; else n = F } $q(e); return 1 } function Md(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0; e = f[a >> 2] | 0; g = e; h = (f[b >> 2] | 0) - g | 0; b = e + (h >> 2 << 2) | 0; i = f[c >> 2] | 0; c = f[d >> 2] | 0; d = c - i | 0; j = d >> 2; k = i; l = c; if ((d | 0) <= 0) { m = b; return m | 0 } d = a + 8 | 0; n = f[d >> 2] | 0; o = a + 4 | 0; p = f[o >> 2] | 0; q = p; if ((j | 0) <= (n - q >> 2 | 0)) { r = b; s = q - r | 0; t = s >> 2; if ((j | 0) > (t | 0)) { u = k + (t << 2) | 0; t = u; if ((u | 0) == (l | 0)) v = p; else { w = l + -4 - t | 0; x = u; u = p; while (1) { f[u >> 2] = f[x >> 2]; x = x + 4 | 0; if ((x | 0) == (l | 0)) break; else u = u + 4 | 0 } u = p + ((w >>> 2) + 1 << 2) | 0; f[o >> 2] = u; v = u } if ((s | 0) > 0) { y = t; z = v } else { m = b; return m | 0 } } else { y = c; z = p } c = z - (b + (j << 2)) >> 2; v = b + (c << 2) | 0; if (v >>> 0 < p >>> 0) { t = (p + (0 - c << 2) + ~r | 0) >>> 2; r = v; s = z; while (1) { f[s >> 2] = f[r >> 2]; r = r + 4 | 0; if (r >>> 0 >= p >>> 0) break; else s = s + 4 | 0 } f[o >> 2] = z + (t + 1 << 2) } if (c | 0) { c = v; v = z; do { c = c + -4 | 0; v = v + -4 | 0; f[v >> 2] = f[c >> 2] } while ((c | 0) != (b | 0)) } c = y; if ((k | 0) == (c | 0)) { m = b; return m | 0 } else { A = b; B = k } while (1) { f[A >> 2] = f[B >> 2]; B = B + 4 | 0; if ((B | 0) == (c | 0)) { m = b; break } else A = A + 4 | 0 } return m | 0 } A = (q - g >> 2) + j | 0; if (A >>> 0 > 1073741823) mq(a); j = n - g | 0; g = j >> 1; n = j >> 2 >>> 0 < 536870911 ? (g >>> 0 < A >>> 0 ? A : g) : 1073741823; g = b; A = h >> 2; do if (n) if (n >>> 0 > 1073741823) { j = ra(8) | 0; Wo(j, 14941); f[j >> 2] = 6944; va(j | 0, 1080, 114) } else { j = dn(n << 2) | 0; C = j; D = j; break } else { C = 0; D = 0 } while (0); j = D + (A << 2) | 0; A = D + (n << 2) | 0; if ((l | 0) == (k | 0)) E = j; else { n = ((l + -4 - i | 0) >>> 2) + 1 | 0; i = k; k = j; while (1) { f[k >> 2] = f[i >> 2]; i = i + 4 | 0; if ((i | 0) == (l | 0)) break; else k = k + 4 | 0 } E = j + (n << 2) | 0 } if ((h | 0) > 0) Rg(C | 0, e | 0, h | 0) | 0; h = q - g | 0; if ((h | 0) > 0) { Rg(E | 0, b | 0, h | 0) | 0; F = E + (h >>> 2 << 2) | 0 } else F = E; f[a >> 2] = D; f[o >> 2] = F; f[d >> 2] = A; if (!e) { m = j; return m | 0 } br(e); m = j; return m | 0 } function Nd(a, b, c, d, e, g, h) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0; switch (c | 0) { case 1: { c = dn(60) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; f[h + 16 >> 2] = f[e + 16 >> 2]; f[h + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); h = c + 44 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 1948; i = c; f[a >> 2] = i; return } case 4: { c = dn(168) | 0; Ei(c, d, e, g); i = c; f[a >> 2] = i; return } case 5: { c = dn(104) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; f[h + 16 >> 2] = f[e + 16 >> 2]; f[h + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); h = c + 44 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2004; f[c + 60 >> 2] = 0; f[c + 64 >> 2] = 0; f[c + 76 >> 2] = 0; f[c + 80 >> 2] = 0; f[c + 84 >> 2] = 0; h = c + 88 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; i = c; f[a >> 2] = i; return } case 6: { c = dn(140) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; d = c + 8 | 0; f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; f[d + 8 >> 2] = f[e + 8 >> 2]; f[d + 12 >> 2] = f[e + 12 >> 2]; f[d + 16 >> 2] = f[e + 16 >> 2]; f[d + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); e = c + 44 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2060; f[c + 64 >> 2] = 0; f[c + 68 >> 2] = 0; e = c + 72 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c + 60 >> 2] = 2116; f[c + 88 >> 2] = 1; g = c + 92 | 0; f[g >> 2] = -1; f[g + 4 >> 2] = -1; f[g + 8 >> 2] = -1; f[g + 12 >> 2] = -1; rn(c + 108 | 0); i = c; f[a >> 2] = i; return } default: { i = 0; f[a >> 2] = i; return } } } function Od(a, b, c, d, e, g, h) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0; switch (c | 0) { case 1: { c = dn(60) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; f[h + 16 >> 2] = f[e + 16 >> 2]; f[h + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); h = c + 44 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 1640; i = c; f[a >> 2] = i; return } case 4: { c = dn(168) | 0; Hi(c, d, e, g); i = c; f[a >> 2] = i; return } case 5: { c = dn(104) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; f[h + 16 >> 2] = f[e + 16 >> 2]; f[h + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); h = c + 44 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 1696; f[c + 60 >> 2] = 0; f[c + 64 >> 2] = 0; f[c + 76 >> 2] = 0; f[c + 80 >> 2] = 0; f[c + 84 >> 2] = 0; h = c + 88 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; i = c; f[a >> 2] = i; return } case 6: { c = dn(140) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = d; d = c + 8 | 0; f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; f[d + 8 >> 2] = f[e + 8 >> 2]; f[d + 12 >> 2] = f[e + 12 >> 2]; f[d + 16 >> 2] = f[e + 16 >> 2]; f[d + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); e = c + 44 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 1752; f[c + 64 >> 2] = 0; f[c + 68 >> 2] = 0; e = c + 72 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c + 60 >> 2] = 1808; f[c + 88 >> 2] = 1; g = c + 92 | 0; f[g >> 2] = -1; f[g + 4 >> 2] = -1; f[g + 8 >> 2] = -1; f[g + 12 >> 2] = -1; rn(c + 108 | 0); i = c; f[a >> 2] = i; return } default: { i = 0; f[a >> 2] = i; return } } } function Pd(a, b, c, d, e, g, h) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0, j = 0; switch (c | 0) { case 1: { c = dn(40) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2628; i = c; f[a >> 2] = i; return } case 4: { c = dn(152) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2684; h = c + 96 | 0; b = c + 40 | 0; j = b + 52 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (j | 0)); Sm(h); f[c + 136 >> 2] = 0; f[c + 140 >> 2] = 0; f[c + 144 >> 2] = 0; i = c; f[a >> 2] = i; return } case 5: { c = dn(84) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2740; f[c + 40 >> 2] = 0; f[c + 44 >> 2] = 0; f[c + 56 >> 2] = 0; f[c + 60 >> 2] = 0; f[c + 64 >> 2] = 0; h = c + 68 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; i = c; f[a >> 2] = i; return } case 6: { c = dn(120) | 0; f[c + 4 >> 2] = d; d = c + 8 | 0; f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; f[d + 8 >> 2] = f[e + 8 >> 2]; f[d + 12 >> 2] = f[e + 12 >> 2]; e = c + 24 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2796; f[c + 44 >> 2] = 0; f[c + 48 >> 2] = 0; e = c + 52 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c + 40 >> 2] = 2852; f[c + 68 >> 2] = 1; g = c + 72 | 0; f[g >> 2] = -1; f[g + 4 >> 2] = -1; f[g + 8 >> 2] = -1; f[g + 12 >> 2] = -1; rn(c + 88 | 0); i = c; f[a >> 2] = i; return } default: { i = 0; f[a >> 2] = i; return } } } function Qd(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0; switch (b - a >> 2 | 0) { case 2: { d = b + -4 | 0; e = f[d >> 2] | 0; g = f[a >> 2] | 0; h = f[c >> 2] | 0; i = f[h >> 2] | 0; j = (f[h + 4 >> 2] | 0) - i >> 3; if (j >>> 0 <= e >>> 0) mq(h); k = i; if (j >>> 0 <= g >>> 0) mq(h); if ((f[k + (e << 3) >> 2] | 0) >>> 0 >= (f[k + (g << 3) >> 2] | 0) >>> 0) { l = 1; return l | 0 } f[a >> 2] = e; f[d >> 2] = g; l = 1; return l | 0 } case 3: { Cg(a, a + 4 | 0, b + -4 | 0, c) | 0; l = 1; return l | 0 } case 4: { Qg(a, a + 4 | 0, a + 8 | 0, b + -4 | 0, c) | 0; l = 1; return l | 0 } case 5: { Tf(a, a + 4 | 0, a + 8 | 0, a + 12 | 0, b + -4 | 0, c) | 0; l = 1; return l | 0 } case 1: case 0: { l = 1; return l | 0 } default: { g = a + 8 | 0; Cg(a, a + 4 | 0, g, c) | 0; d = a + 12 | 0; a: do if ((d | 0) != (b | 0)) { e = f[c >> 2] | 0; k = f[e >> 2] | 0; h = (f[e + 4 >> 2] | 0) - k >> 3; j = k; k = d; i = 0; m = g; b: while (1) { n = f[k >> 2] | 0; o = f[m >> 2] | 0; if (h >>> 0 <= n >>> 0) { p = 14; break } if (h >>> 0 <= o >>> 0) { p = 16; break } q = j + (n << 3) | 0; if ((f[q >> 2] | 0) >>> 0 < (f[j + (o << 3) >> 2] | 0) >>> 0) { r = m; s = k; t = o; while (1) { f[s >> 2] = t; if ((r | 0) == (a | 0)) { u = a; break } o = r + -4 | 0; t = f[o >> 2] | 0; if (h >>> 0 <= t >>> 0) { p = 20; break b } if ((f[q >> 2] | 0) >>> 0 >= (f[j + (t << 3) >> 2] | 0) >>> 0) { u = r; break } else { v = r; r = o; s = v } } f[u >> 2] = n; s = i + 1 | 0; if ((s | 0) == 8) { w = 0; x = (k + 4 | 0) == (b | 0); break a } else y = s } else y = i; s = k + 4 | 0; if ((s | 0) == (b | 0)) { w = 1; x = 0; break a } else { r = k; k = s; i = y; m = r } } if ((p | 0) == 14) mq(e); else if ((p | 0) == 16) mq(e); else if ((p | 0) == 20) mq(e) } else { w = 1; x = 0 } while (0); l = x | w; return l | 0 } }return 0 } function Rd(a, b, c, d, e, g, h) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0, j = 0; switch (c | 0) { case 1: { c = dn(40) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2376; i = c; f[a >> 2] = i; return } case 4: { c = dn(152) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2432; h = c + 96 | 0; b = c + 40 | 0; j = b + 52 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (j | 0)); Sm(h); f[c + 136 >> 2] = 0; f[c + 140 >> 2] = 0; f[c + 144 >> 2] = 0; i = c; f[a >> 2] = i; return } case 5: { c = dn(84) | 0; f[c + 4 >> 2] = d; h = c + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[h + 12 >> 2] = f[e + 12 >> 2]; h = c + 24 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2488; f[c + 40 >> 2] = 0; f[c + 44 >> 2] = 0; f[c + 56 >> 2] = 0; f[c + 60 >> 2] = 0; f[c + 64 >> 2] = 0; h = c + 68 | 0; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; f[h + 12 >> 2] = f[g + 12 >> 2]; i = c; f[a >> 2] = i; return } case 6: { c = dn(120) | 0; f[c + 4 >> 2] = d; d = c + 8 | 0; f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; f[d + 8 >> 2] = f[e + 8 >> 2]; f[d + 12 >> 2] = f[e + 12 >> 2]; e = c + 24 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c >> 2] = 2544; f[c + 44 >> 2] = 0; f[c + 48 >> 2] = 0; e = c + 52 | 0; f[e >> 2] = f[g >> 2]; f[e + 4 >> 2] = f[g + 4 >> 2]; f[e + 8 >> 2] = f[g + 8 >> 2]; f[e + 12 >> 2] = f[g + 12 >> 2]; f[c + 40 >> 2] = 2600; f[c + 68 >> 2] = 1; g = c + 72 | 0; f[g >> 2] = -1; f[g + 4 >> 2] = -1; f[g + 8 >> 2] = -1; f[g + 12 >> 2] = -1; rn(c + 88 | 0); i = c; f[a >> 2] = i; return } default: { i = 0; f[a >> 2] = i; return } } } function Sd(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = Oa, t = Oa, u = Oa, v = 0, w = 0, x = 0, y = 0, z = 0; c = f[b >> 2] | 0; b = a + 4 | 0; d = f[b >> 2] | 0; e = (d | 0) == 0; a: do if (!e) { g = d + -1 | 0; h = (g & d | 0) == 0; if (!h) if (c >>> 0 < d >>> 0) i = c; else i = (c >>> 0) % (d >>> 0) | 0; else i = g & c; j = f[(f[a >> 2] | 0) + (i << 2) >> 2] | 0; if (!j) k = i; else { if (h) { h = j; while (1) { l = f[h >> 2] | 0; if (!l) { k = i; break a } m = f[l + 4 >> 2] | 0; if (!((m | 0) == (c | 0) | (m & g | 0) == (i | 0))) { k = i; break a } if ((f[l + 8 >> 2] | 0) == (c | 0)) { o = l; break } else h = l } p = o + 12 | 0; return p | 0 } else q = j; while (1) { h = f[q >> 2] | 0; if (!h) { k = i; break a } g = f[h + 4 >> 2] | 0; if ((g | 0) != (c | 0)) { if (g >>> 0 < d >>> 0) r = g; else r = (g >>> 0) % (d >>> 0) | 0; if ((r | 0) != (i | 0)) { k = i; break a } } if ((f[h + 8 >> 2] | 0) == (c | 0)) { o = h; break } else q = h } p = o + 12 | 0; return p | 0 } } else k = 0; while (0); q = dn(16) | 0; f[q + 8 >> 2] = c; f[q + 12 >> 2] = 0; f[q + 4 >> 2] = c; f[q >> 2] = 0; i = a + 12 | 0; s = $(((f[i >> 2] | 0) + 1 | 0) >>> 0); t = $(d >>> 0); u = $(n[a + 16 >> 2]); do if (e | $(u * t) < s) { r = d << 1 | (d >>> 0 < 3 | (d + -1 & d | 0) != 0) & 1; j = ~~$(W($(s / u))) >>> 0; ti(a, r >>> 0 < j >>> 0 ? j : r); r = f[b >> 2] | 0; j = r + -1 | 0; if (!(j & r)) { v = r; w = j & c; break } if (c >>> 0 < r >>> 0) { v = r; w = c } else { v = r; w = (c >>> 0) % (r >>> 0) | 0 } } else { v = d; w = k } while (0); k = (f[a >> 2] | 0) + (w << 2) | 0; w = f[k >> 2] | 0; if (!w) { d = a + 8 | 0; f[q >> 2] = f[d >> 2]; f[d >> 2] = q; f[k >> 2] = d; d = f[q >> 2] | 0; if (d | 0) { k = f[d + 4 >> 2] | 0; d = v + -1 | 0; if (d & v) if (k >>> 0 < v >>> 0) x = k; else x = (k >>> 0) % (v >>> 0) | 0; else x = k & d; y = (f[a >> 2] | 0) + (x << 2) | 0; z = 30 } } else { f[q >> 2] = f[w >> 2]; y = w; z = 30 } if ((z | 0) == 30) f[y >> 2] = q; f[i >> 2] = (f[i >> 2] | 0) + 1; o = q; p = o + 12 | 0; return p | 0 } function Td(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0; c = u; u = u + 16 | 0; d = c + 4 | 0; e = c; f[a + 64 >> 2] = b; g = a + 128 | 0; f[g >> 2] = 2; h = a + 132 | 0; f[h >> 2] = 7; i = Qa[f[(f[b >> 2] | 0) + 32 >> 2] & 127](b) | 0; b = a + 88 | 0; f[b >> 2] = i; j = a + 104 | 0; k = (f[i + 28 >> 2] | 0) - (f[i + 24 >> 2] | 0) >> 2; i = a + 108 | 0; l = f[i >> 2] | 0; m = f[j >> 2] | 0; n = l - m >> 2; o = m; p = l; if (k >>> 0 <= n >>> 0) if (k >>> 0 < n >>> 0 ? (q = o + (k << 2) | 0, (q | 0) != (p | 0)) : 0) { o = p + (~((p + -4 - q | 0) >>> 2) << 2) | 0; f[i >> 2] = o; r = o; s = m } else { r = l; s = m } else { oi(j, k - n | 0); r = f[i >> 2] | 0; s = f[j >> 2] | 0 } if ((r | 0) != (s | 0)) { s = 0; do { r = f[b >> 2] | 0; f[e >> 2] = s; f[d >> 2] = f[e >> 2]; n = Og(r, d) | 0; r = f[j >> 2] | 0; f[r + (s << 2) >> 2] = n; s = s + 1 | 0 } while (s >>> 0 < (f[i >> 2] | 0) - r >> 2 >>> 0) } i = a + 92 | 0; s = f[b >> 2] | 0; j = f[s >> 2] | 0; d = (f[s + 4 >> 2] | 0) - j >> 2; e = a + 96 | 0; r = f[e >> 2] | 0; n = f[i >> 2] | 0; k = r - n >> 2; m = n; n = r; if (d >>> 0 <= k >>> 0) if (d >>> 0 < k >>> 0 ? (r = m + (d << 2) | 0, (r | 0) != (n | 0)) : 0) { f[e >> 2] = n + (~((n + -4 - r | 0) >>> 2) << 2); t = s; v = j } else { t = s; v = j } else { oi(i, d - k | 0); k = f[b >> 2] | 0; t = k; v = f[k >> 2] | 0 } k = f[t + 4 >> 2] | 0; if ((k | 0) != (v | 0)) { v = f[i >> 2] | 0; i = f[t >> 2] | 0; t = k - i >> 2; k = 0; do { f[v + (k << 2) >> 2] = f[i + (k << 2) >> 2]; k = k + 1 | 0 } while (k >>> 0 < t >>> 0) } t = (f[h >> 2] | 0) - (f[g >> 2] | 0) + 1 | 0; g = a + 136 | 0; h = a + 140 | 0; a = f[h >> 2] | 0; k = f[g >> 2] | 0; i = (a - k | 0) / 12 | 0; v = a; if (t >>> 0 > i >>> 0) { vf(g, t - i | 0); u = c; return 1 } if (t >>> 0 >= i >>> 0) { u = c; return 1 } i = k + (t * 12 | 0) | 0; if ((i | 0) == (v | 0)) { u = c; return 1 } else w = v; while (1) { v = w + -12 | 0; f[h >> 2] = v; t = f[v >> 2] | 0; if (!t) x = v; else { v = w + -8 | 0; k = f[v >> 2] | 0; if ((k | 0) != (t | 0)) f[v >> 2] = k + (~((k + -4 - t | 0) >>> 2) << 2); br(t); x = f[h >> 2] | 0 } if ((x | 0) == (i | 0)) break; else w = x } u = c; return 1 } function Ud(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Oc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 4194304; if (d) { d = c; c = 4194304; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 20) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } xf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function Vd(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Pc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 4194304; if (d) { d = c; c = 4194304; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 20) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } xf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function Wd(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Qc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 4194304; if (d) { d = c; c = 4194304; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 20) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } xf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function Xd(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Rc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 4194304; if (d) { d = c; c = 4194304; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 20) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } xf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function Yd(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Sc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 4194304; if (d) { d = c; c = 4194304; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 20) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } xf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function Zd(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Tc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 2097152; if (d) { d = c; c = 2097152; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 19) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } yf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function _d(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Uc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 1048576; if (d) { d = c; c = 1048576; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 18) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } zf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function $d(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Vc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 262144; if (d) { d = c; c = 262144; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 16) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Cf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ae(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Wc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 131072; if (d) { d = c; c = 131072; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 15) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Df(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function be(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Xc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 32768; if (d) { d = c; c = 32768; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 13) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Ef(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ce(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Yc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function de(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); Zc(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ee(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); _c(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function fe(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); $c(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ge(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); ad(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function he(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); bd(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ie(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); cd(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function je(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; g = u; u = u + 64 | 0; h = g + 48 | 0; i = g; j = d + 1 | 0; f[h >> 2] = 0; k = h + 4 | 0; f[k >> 2] = 0; f[h + 8 >> 2] = 0; do if (j) if (j >>> 0 > 536870911) mq(h); else { l = dn(j << 3) | 0; f[h >> 2] = l; m = l + (j << 3) | 0; f[h + 8 >> 2] = m; hj(l | 0, 0, (d << 3) + 8 | 0) | 0; f[k >> 2] = m; n = l; o = m; break } else { n = 0; o = 0 } while (0); d = (c | 0) > 0; if (d) { j = 0; do { m = n + (f[a + (j << 2) >> 2] << 3) | 0; l = m; p = Tn(f[l >> 2] | 0, f[l + 4 >> 2] | 0, 1, 0) | 0; l = m; f[l >> 2] = p; f[l + 4 >> 2] = I; j = j + 1 | 0 } while ((j | 0) != (c | 0)) } j = i + 40 | 0; l = j; f[l >> 2] = 0; f[l + 4 >> 2] = 0; l = i; p = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (p | 0)); dd(i, n, o - n >> 3, e) | 0; n = i + 16 | 0; o = Rn(f[n >> 2] | 0, f[n + 4 >> 2] | 0, 1) | 0; n = (f[e + 4 >> 2] | 0) - (f[e >> 2] | 0) | 0; l = j; f[l >> 2] = n; f[l + 4 >> 2] = 0; l = Tn(o | 0, I | 0, 39, 0) | 0; o = Wn(l | 0, I | 0, 3) | 0; l = Tn(o | 0, I | 0, 8, 0) | 0; o = Tn(l | 0, I | 0, n | 0, 0) | 0; vl(e, o, I); o = i + 24 | 0; f[o >> 2] = (f[e >> 2] | 0) + (f[j >> 2] | 0); j = i + 28 | 0; f[j >> 2] = 0; n = i + 32 | 0; f[n >> 2] = 16384; if (d) { d = c; c = 16384; do { l = d; d = d + -1 | 0; p = f[a + (d << 2) >> 2] | 0; m = f[i >> 2] | 0; q = f[m + (p << 3) >> 2] | 0; r = q << 10; if (c >>> 0 < r >>> 0) s = c; else { t = c; while (1) { v = f[o >> 2] | 0; w = f[j >> 2] | 0; f[j >> 2] = w + 1; b[v + w >> 0] = t; w = (f[n >> 2] | 0) >>> 8; f[n >> 2] = w; if (w >>> 0 < r >>> 0) { s = w; break } else t = w } } c = (((s >>> 0) / (q >>> 0) | 0) << 12) + ((s >>> 0) % (q >>> 0) | 0) + (f[m + (p << 3) + 4 >> 2] | 0) | 0; f[n >> 2] = c } while ((l | 0) > 1) } Lf(i, e); e = f[i >> 2] | 0; if (e | 0) { c = i + 4 | 0; i = f[c >> 2] | 0; if ((i | 0) != (e | 0)) f[c >> 2] = i + (~((i + -8 - e | 0) >>> 3) << 3); br(e) } e = f[h >> 2] | 0; if (!e) { u = g; return 1 } h = f[k >> 2] | 0; if ((h | 0) != (e | 0)) f[k >> 2] = h + (~((h + -8 - e | 0) >>> 3) << 3); br(e); u = g; return 1 } function ke(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0; e = f[b >> 2] | 0; g = b + 4 | 0; h = f[g >> 2] | 0; i = ((f[c >> 2] | 0) - e << 3) + (f[c + 4 >> 2] | 0) - h | 0; c = e; if ((i | 0) <= 0) { j = d + 4 | 0; k = f[d >> 2] | 0; f[a >> 2] = k; l = a + 4 | 0; m = f[j >> 2] | 0; f[l >> 2] = m; return } if (!h) { e = d + 4 | 0; n = i; o = e; p = c; q = f[e >> 2] | 0 } else { e = 32 - h | 0; r = (i | 0) < (e | 0) ? i : e; s = -1 >>> (e - r | 0) & -1 << h & f[c >> 2]; c = d + 4 | 0; h = f[c >> 2] | 0; e = 32 - h | 0; t = e >>> 0 < r >>> 0 ? e : r; u = f[d >> 2] | 0; v = f[u >> 2] & ~(-1 >>> (e - t | 0) & -1 << h); f[u >> 2] = v; h = f[c >> 2] | 0; e = f[g >> 2] | 0; f[u >> 2] = (h >>> 0 > e >>> 0 ? s << h - e : s >>> (e - h | 0)) | v; v = (f[c >> 2] | 0) + t | 0; h = u + (v >>> 5 << 2) | 0; f[d >> 2] = h; u = v & 31; f[c >> 2] = u; v = r - t | 0; if ((v | 0) > 0) { e = f[h >> 2] & ~(-1 >>> (32 - v | 0)); f[h >> 2] = e; f[h >> 2] = e | s >>> ((f[g >> 2] | 0) + t | 0); f[c >> 2] = v; w = v } else w = u; u = (f[b >> 2] | 0) + 4 | 0; f[b >> 2] = u; n = i - r | 0; o = c; p = u; q = w } w = 32 - q | 0; u = -1 << q; if ((n | 0) > 31) { q = ~u; c = ~n; r = n + ((c | 0) > -64 ? c : -64) + 32 & -32; c = n; i = p; while (1) { v = f[i >> 2] | 0; t = f[d >> 2] | 0; g = f[t >> 2] & q; f[t >> 2] = g; f[t >> 2] = g | v << f[o >> 2]; g = t + 4 | 0; f[d >> 2] = g; f[g >> 2] = f[g >> 2] & u | v >>> w; i = (f[b >> 2] | 0) + 4 | 0; f[b >> 2] = i; if ((c | 0) <= 63) break; else c = c + -32 | 0 } x = n + -32 - r | 0; y = i } else { x = n; y = p } if ((x | 0) <= 0) { j = o; k = f[d >> 2] | 0; f[a >> 2] = k; l = a + 4 | 0; m = f[j >> 2] | 0; f[l >> 2] = m; return } p = f[y >> 2] & -1 >>> (32 - x | 0); y = (w | 0) < (x | 0) ? w : x; n = f[d >> 2] | 0; i = f[n >> 2] & ~(-1 << f[o >> 2] & -1 >>> (w - y | 0)); f[n >> 2] = i; f[n >> 2] = i | p << f[o >> 2]; i = (f[o >> 2] | 0) + y | 0; w = n + (i >>> 5 << 2) | 0; f[d >> 2] = w; f[o >> 2] = i & 31; i = x - y | 0; if ((i | 0) <= 0) { j = o; k = f[d >> 2] | 0; f[a >> 2] = k; l = a + 4 | 0; m = f[j >> 2] | 0; f[l >> 2] = m; return } f[w >> 2] = f[w >> 2] & ~(-1 >>> (32 - i | 0)) | p >>> y; f[o >> 2] = i; j = o; k = f[d >> 2] | 0; f[a >> 2] = k; l = a + 4 | 0; m = f[j >> 2] | 0; f[l >> 2] = m; return } function le(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 9 | 0; i = d + 8 | 0; j = f[(f[a + 184 >> 2] | 0) + (c << 2) >> 2] & 255; b[h >> 0] = j; c = a + 4 | 0; k = f[(f[c >> 2] | 0) + 44 >> 2] | 0; l = k + 16 | 0; m = f[l + 4 >> 2] | 0; if ((m | 0) > 0 | (m | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0) n = j; else { f[g >> 2] = f[k + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(k, e, h, h + 1 | 0) | 0; n = b[h >> 0] | 0 } a: do if (n << 24 >> 24 > -1) { k = a + 172 | 0; j = f[(f[k >> 2] | 0) + ((n << 24 >> 24) * 136 | 0) >> 2] | 0; l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 56 | 0; m = b[h >> 0] | 0; o = f[k >> 2] | 0; k = f[o + (m * 136 | 0) + 132 >> 2] | 0; switch (f[(f[(f[l >> 2] | 0) + 84 >> 2] | 0) + (j << 2) >> 2] | 0) { case 0: { p = k; q = 7; break a; break } case 1: { if (b[o + (m * 136 | 0) + 28 >> 0] | 0) { p = k; q = 7; break a } break } default: { } }m = f[(f[c >> 2] | 0) + 44 >> 2] | 0; b[i >> 0] = 1; o = m + 16 | 0; j = f[o + 4 >> 2] | 0; if (!((j | 0) > 0 | (j | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[m + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(m, e, i, i + 1 | 0) | 0 } r = k } else { p = f[a + 68 >> 2] | 0; q = 7 } while (0); if ((q | 0) == 7) { q = f[(f[c >> 2] | 0) + 44 >> 2] | 0; b[i >> 0] = 0; a = q + 16 | 0; h = f[a + 4 >> 2] | 0; if (!((h | 0) > 0 | (h | 0) == 0 & (f[a >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[q + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(q, e, i, i + 1 | 0) | 0 } r = p } p = f[(f[c >> 2] | 0) + 44 >> 2] | 0; b[i >> 0] = r; r = p + 16 | 0; c = f[r + 4 >> 2] | 0; if ((c | 0) > 0 | (c | 0) == 0 & (f[r >> 2] | 0) >>> 0 > 0) { u = d; return 1 } f[g >> 2] = f[p + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(p, e, i, i + 1 | 0) | 0; u = d; return 1 } function me(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0; h = u; u = u + 16 | 0; i = h + 4 | 0; j = h; k = a + 60 | 0; f[a + 64 >> 2] = g; g = a + 8 | 0; Ah(g, b, d, e); d = a + 56 | 0; l = f[d >> 2] | 0; m = f[l + 4 >> 2] | 0; n = f[l >> 2] | 0; o = m - n | 0; if ((o | 0) <= 0) { u = h; return 1 } p = (o >>> 2) + -1 | 0; o = a + 68 | 0; q = a + 16 | 0; r = a + 32 | 0; s = a + 12 | 0; t = a + 28 | 0; v = a + 20 | 0; w = a + 24 | 0; if (m - n >> 2 >>> 0 > p >>> 0) { x = p; y = n } else { z = l; mq(z) } while (1) { f[j >> 2] = f[y + (x << 2) >> 2]; f[i >> 2] = f[j >> 2]; tb(k, i, b, x) | 0; l = X(x, e) | 0; n = b + (l << 2) | 0; p = c + (l << 2) | 0; l = f[g >> 2] | 0; if ((l | 0) > 0) { m = 0; a = o; A = l; while (1) { if ((A | 0) > 0) { l = 0; do { B = f[a + (l << 2) >> 2] | 0; C = f[q >> 2] | 0; if ((B | 0) > (C | 0)) { D = f[r >> 2] | 0; f[D + (l << 2) >> 2] = C; E = D } else { D = f[s >> 2] | 0; C = f[r >> 2] | 0; f[C + (l << 2) >> 2] = (B | 0) < (D | 0) ? D : B; E = C } l = l + 1 | 0 } while ((l | 0) < (f[g >> 2] | 0)); F = E } else F = f[r >> 2] | 0; l = (f[n + (m << 2) >> 2] | 0) - (f[F + (m << 2) >> 2] | 0) | 0; C = p + (m << 2) | 0; f[C >> 2] = l; if ((l | 0) >= (f[t >> 2] | 0)) { if ((l | 0) > (f[w >> 2] | 0)) { G = l - (f[v >> 2] | 0) | 0; H = 18 } } else { G = (f[v >> 2] | 0) + l | 0; H = 18 } if ((H | 0) == 18) { H = 0; f[C >> 2] = G } m = m + 1 | 0; A = f[g >> 2] | 0; if ((m | 0) >= (A | 0)) break; else a = F } } x = x + -1 | 0; if ((x | 0) <= -1) { H = 3; break } a = f[d >> 2] | 0; y = f[a >> 2] | 0; if ((f[a + 4 >> 2] | 0) - y >> 2 >>> 0 <= x >>> 0) { z = a; H = 4; break } } if ((H | 0) == 3) { u = h; return 1 } else if ((H | 0) == 4) mq(z); return 0 } function ne(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0; h = u; u = u + 16 | 0; i = h + 4 | 0; j = h; k = a + 60 | 0; f[a + 64 >> 2] = g; g = a + 8 | 0; Ah(g, b, d, e); d = a + 56 | 0; l = f[d >> 2] | 0; m = f[l + 4 >> 2] | 0; n = f[l >> 2] | 0; o = m - n | 0; if ((o | 0) <= 0) { u = h; return 1 } p = (o >>> 2) + -1 | 0; o = a + 68 | 0; q = a + 16 | 0; r = a + 32 | 0; s = a + 12 | 0; t = a + 28 | 0; v = a + 20 | 0; w = a + 24 | 0; if (m - n >> 2 >>> 0 > p >>> 0) { x = p; y = n } else { z = l; mq(z) } while (1) { f[j >> 2] = f[y + (x << 2) >> 2]; f[i >> 2] = f[j >> 2]; sb(k, i, b, x) | 0; l = X(x, e) | 0; n = b + (l << 2) | 0; p = c + (l << 2) | 0; l = f[g >> 2] | 0; if ((l | 0) > 0) { m = 0; a = o; A = l; while (1) { if ((A | 0) > 0) { l = 0; do { B = f[a + (l << 2) >> 2] | 0; C = f[q >> 2] | 0; if ((B | 0) > (C | 0)) { D = f[r >> 2] | 0; f[D + (l << 2) >> 2] = C; E = D } else { D = f[s >> 2] | 0; C = f[r >> 2] | 0; f[C + (l << 2) >> 2] = (B | 0) < (D | 0) ? D : B; E = C } l = l + 1 | 0 } while ((l | 0) < (f[g >> 2] | 0)); F = E } else F = f[r >> 2] | 0; l = (f[n + (m << 2) >> 2] | 0) - (f[F + (m << 2) >> 2] | 0) | 0; C = p + (m << 2) | 0; f[C >> 2] = l; if ((l | 0) >= (f[t >> 2] | 0)) { if ((l | 0) > (f[w >> 2] | 0)) { G = l - (f[v >> 2] | 0) | 0; H = 18 } } else { G = (f[v >> 2] | 0) + l | 0; H = 18 } if ((H | 0) == 18) { H = 0; f[C >> 2] = G } m = m + 1 | 0; A = f[g >> 2] | 0; if ((m | 0) >= (A | 0)) break; else a = F } } x = x + -1 | 0; if ((x | 0) <= -1) { H = 3; break } a = f[d >> 2] | 0; y = f[a >> 2] | 0; if ((f[a + 4 >> 2] | 0) - y >> 2 >>> 0 <= x >>> 0) { z = a; H = 4; break } } if ((H | 0) == 3) { u = h; return 1 } else if ((H | 0) == 4) mq(z); return 0 } function oe(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; e = a + 12 | 0; g = f[e >> 2] | 0; h = (f[g + 4 >> 2] | 0) - (f[g >> 2] | 0) >> 2; if (!h) { u = b; return 1 } i = a + 152 | 0; j = a + 140 | 0; k = a + 144 | 0; l = a + 148 | 0; a = 0; m = g; while (1) { f[d >> 2] = (a >>> 0) / 3 | 0; f[c >> 2] = f[d >> 2]; if (!(Rj(m, c) | 0) ? (g = f[e >> 2] | 0, (f[(f[g + 12 >> 2] | 0) + (a << 2) >> 2] | 0) == -1) : 0) { n = a + 1 | 0; o = ((n >>> 0) % 3 | 0 | 0) == 0 ? a + -2 | 0 : n; if ((o | 0) == -1) p = -1; else p = f[(f[g >> 2] | 0) + (o << 2) >> 2] | 0; o = f[i >> 2] | 0; if ((f[o + (p << 2) >> 2] | 0) == -1) { g = f[k >> 2] | 0; n = f[l >> 2] | 0; if ((g | 0) == (n << 5 | 0)) { if ((g + 1 | 0) < 0) { q = 11; break } r = n << 6; n = g + 32 & -32; hi(j, g >>> 0 < 1073741823 ? (r >>> 0 < n >>> 0 ? n : r) : 2147483647); s = f[k >> 2] | 0; t = f[i >> 2] | 0 } else { s = g; t = o } f[k >> 2] = s + 1; o = (f[j >> 2] | 0) + (s >>> 5 << 2) | 0; f[o >> 2] = f[o >> 2] & ~(1 << (s & 31)); o = t + (p << 2) | 0; if ((f[o >> 2] | 0) == -1) { r = a; n = o; while (1) { f[n >> 2] = g; o = r + 1 | 0; a: do if ((r | 0) != -1 ? (v = ((o >>> 0) % 3 | 0 | 0) == 0 ? r + -2 | 0 : o, (v | 0) != -1) : 0) { w = f[e >> 2] | 0; x = f[w + 12 >> 2] | 0; y = v; while (1) { v = f[x + (y << 2) >> 2] | 0; if ((v | 0) == -1) break; z = v + 1 | 0; A = ((z >>> 0) % 3 | 0 | 0) == 0 ? v + -2 | 0 : z; if ((A | 0) == -1) { B = -1; C = -1; break a } else y = A } x = y + 1 | 0; A = ((x >>> 0) % 3 | 0 | 0) == 0 ? y + -2 | 0 : x; if ((A | 0) == -1) { B = y; C = -1 } else { B = y; C = f[(f[w >> 2] | 0) + (A << 2) >> 2] | 0 } } else { B = -1; C = -1 } while (0); n = t + (C << 2) | 0; if ((f[n >> 2] | 0) != -1) break; else r = B } } } } r = a + 1 | 0; if (r >>> 0 >= h >>> 0) { q = 3; break } a = r; m = f[e >> 2] | 0 } if ((q | 0) == 3) { u = b; return 1 } else if ((q | 0) == 11) mq(j); return 0 }
    function pe(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; d = u; u = u + 32 | 0; e = d + 8 | 0; g = d; h = a + 4 | 0; i = f[h >> 2] | 0; if (i >>> 0 >= b >>> 0) { f[h >> 2] = b; u = d; return } j = a + 8 | 0; k = f[j >> 2] | 0; l = k << 5; m = b - i | 0; if (l >>> 0 < m >>> 0 | i >>> 0 > (l - m | 0) >>> 0) { f[e >> 2] = 0; n = e + 4 | 0; f[n >> 2] = 0; o = e + 8 | 0; f[o >> 2] = 0; if ((b | 0) < 0) mq(a); p = k << 6; k = b + 31 & -32; hi(e, l >>> 0 < 1073741823 ? (p >>> 0 < k >>> 0 ? k : p) : 2147483647); p = f[h >> 2] | 0; f[n >> 2] = p + m; k = f[a >> 2] | 0; l = k; q = f[e >> 2] | 0; r = (l + (p >>> 5 << 2) - k << 3) + (p & 31) | 0; if ((r | 0) > 0) { p = r >>> 5; Xl(q | 0, k | 0, p << 2 | 0) | 0; k = r & 31; r = q + (p << 2) | 0; s = r; if (!k) { t = 0; v = s } else { w = -1 >>> (32 - k | 0); f[r >> 2] = f[r >> 2] & ~w | f[l + (p << 2) >> 2] & w; t = k; v = s } } else { t = 0; v = q } f[g >> 2] = v; f[g + 4 >> 2] = t; t = g; g = f[t >> 2] | 0; v = f[t + 4 >> 2] | 0; t = f[a >> 2] | 0; f[a >> 2] = f[e >> 2]; f[e >> 2] = t; e = f[h >> 2] | 0; f[h >> 2] = f[n >> 2]; f[n >> 2] = e; e = f[j >> 2] | 0; f[j >> 2] = f[o >> 2]; f[o >> 2] = e; if (t | 0) br(t); x = g; y = v } else { v = (f[a >> 2] | 0) + (i >>> 5 << 2) | 0; f[h >> 2] = b; x = v; y = i & 31 } if (!m) { u = d; return } i = (y | 0) == 0; v = x; if (c) { if (i) { z = m; A = x; B = v } else { c = 32 - y | 0; b = c >>> 0 > m >>> 0 ? m : c; f[v >> 2] = f[v >> 2] | -1 >>> (c - b | 0) & -1 << y; c = v + 4 | 0; z = m - b | 0; A = c; B = c } c = z >>> 5; hj(A | 0, -1, c << 2 | 0) | 0; A = z & 31; z = B + (c << 2) | 0; if (!A) { u = d; return } f[z >> 2] = f[z >> 2] | -1 >>> (32 - A | 0); u = d; return } else { if (i) { C = m; D = x; E = v } else { x = 32 - y | 0; i = x >>> 0 > m >>> 0 ? m : x; f[v >> 2] = f[v >> 2] & ~(-1 >>> (x - i | 0) & -1 << y); y = v + 4 | 0; C = m - i | 0; D = y; E = y } y = C >>> 5; hj(D | 0, 0, y << 2 | 0) | 0; D = C & 31; C = E + (y << 2) | 0; if (!D) { u = d; return } f[C >> 2] = f[C >> 2] & ~(-1 >>> (32 - D | 0)); u = d; return } } function qe(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0; a = u; u = u + 48 | 0; g = a + 36 | 0; h = a + 24 | 0; i = a + 12 | 0; j = a; if (!c) { k = 0; u = a; return k | 0 } f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; l = vj(d) | 0; if (l >>> 0 > 4294967279) mq(g); if (l >>> 0 < 11) { b[g + 11 >> 0] = l; if (!l) m = g; else { n = g; o = 7 } } else { p = l + 16 & -16; q = dn(p) | 0; f[g >> 2] = q; f[g + 8 >> 2] = p | -2147483648; f[g + 4 >> 2] = l; n = q; o = 7 } if ((o | 0) == 7) { Rg(n | 0, d | 0, l | 0) | 0; m = n } b[m + l >> 0] = 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; l = vj(e) | 0; if (l >>> 0 > 4294967279) mq(h); if (l >>> 0 < 11) { b[h + 11 >> 0] = l; if (!l) r = h; else { s = h; o = 13 } } else { m = l + 16 & -16; n = dn(m) | 0; f[h >> 2] = n; f[h + 8 >> 2] = m | -2147483648; f[h + 4 >> 2] = l; s = n; o = 13 } if ((o | 0) == 13) { Rg(s | 0, e | 0, l | 0) | 0; r = s } b[r + l >> 0] = 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; l = vj(d) | 0; if (l >>> 0 > 4294967279) mq(i); if (l >>> 0 < 11) { b[i + 11 >> 0] = l; if (!l) t = i; else { v = i; o = 19 } } else { r = l + 16 & -16; s = dn(r) | 0; f[i >> 2] = s; f[i + 8 >> 2] = r | -2147483648; f[i + 4 >> 2] = l; v = s; o = 19 } if ((o | 0) == 19) { Rg(v | 0, d | 0, l | 0) | 0; t = v } b[t + l >> 0] = 0; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; l = vj(e) | 0; if (l >>> 0 > 4294967279) mq(j); if (l >>> 0 < 11) { b[j + 11 >> 0] = l; if (!l) w = j; else { x = j; o = 25 } } else { t = l + 16 & -16; v = dn(t) | 0; f[j >> 2] = v; f[j + 8 >> 2] = t | -2147483648; f[j + 4 >> 2] = l; x = v; o = 25 } if ((o | 0) == 25) { Rg(x | 0, e | 0, l | 0) | 0; w = x } b[w + l >> 0] = 0; en(c, i, j); if ((b[j + 11 >> 0] | 0) < 0) br(f[j >> 2] | 0); if ((b[i + 11 >> 0] | 0) < 0) br(f[i >> 2] | 0); if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); k = 1; u = a; return k | 0 } function re(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0; f[a >> 2] = f[c >> 2]; d = c + 4 | 0; f[a + 4 >> 2] = f[d >> 2]; e = c + 8 | 0; f[a + 8 >> 2] = f[e >> 2]; g = c + 12 | 0; f[a + 12 >> 2] = f[g >> 2]; f[d >> 2] = 0; f[e >> 2] = 0; f[g >> 2] = 0; g = c + 16 | 0; f[a + 16 >> 2] = f[g >> 2]; e = c + 20 | 0; f[a + 20 >> 2] = f[e >> 2]; d = c + 24 | 0; f[a + 24 >> 2] = f[d >> 2]; f[g >> 2] = 0; f[e >> 2] = 0; f[d >> 2] = 0; b[a + 28 >> 0] = b[c + 28 >> 0] | 0; d = a + 32 | 0; e = c + 32 | 0; f[d >> 2] = 0; g = a + 36 | 0; f[g >> 2] = 0; f[a + 40 >> 2] = 0; f[d >> 2] = f[e >> 2]; d = c + 36 | 0; f[g >> 2] = f[d >> 2]; g = c + 40 | 0; f[a + 40 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[d >> 2] = 0; f[e >> 2] = 0; e = a + 44 | 0; d = c + 44 | 0; f[e >> 2] = 0; g = a + 48 | 0; f[g >> 2] = 0; f[a + 52 >> 2] = 0; f[e >> 2] = f[d >> 2]; e = c + 48 | 0; f[g >> 2] = f[e >> 2]; g = c + 52 | 0; f[a + 52 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[e >> 2] = 0; f[d >> 2] = 0; d = a + 56 | 0; e = c + 56 | 0; f[d >> 2] = 0; g = a + 60 | 0; f[g >> 2] = 0; f[a + 64 >> 2] = 0; f[d >> 2] = f[e >> 2]; d = c + 60 | 0; f[g >> 2] = f[d >> 2]; g = c + 64 | 0; f[a + 64 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[d >> 2] = 0; f[e >> 2] = 0; f[a + 68 >> 2] = f[c + 68 >> 2]; f[a + 72 >> 2] = f[c + 72 >> 2]; e = a + 76 | 0; d = c + 76 | 0; f[e >> 2] = 0; g = a + 80 | 0; f[g >> 2] = 0; f[a + 84 >> 2] = 0; f[e >> 2] = f[d >> 2]; e = c + 80 | 0; f[g >> 2] = f[e >> 2]; g = c + 84 | 0; f[a + 84 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[e >> 2] = 0; f[d >> 2] = 0; d = a + 88 | 0; e = c + 88 | 0; f[d >> 2] = 0; g = a + 92 | 0; f[g >> 2] = 0; f[a + 96 >> 2] = 0; f[d >> 2] = f[e >> 2]; d = c + 92 | 0; f[g >> 2] = f[d >> 2]; g = c + 96 | 0; f[a + 96 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[d >> 2] = 0; f[e >> 2] = 0; b[a + 100 >> 0] = b[c + 100 >> 0] | 0; e = a + 104 | 0; d = c + 104 | 0; f[e >> 2] = 0; g = a + 108 | 0; f[g >> 2] = 0; f[a + 112 >> 2] = 0; f[e >> 2] = f[d >> 2]; e = c + 108 | 0; f[g >> 2] = f[e >> 2]; g = c + 112 | 0; f[a + 112 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[e >> 2] = 0; f[d >> 2] = 0; d = a + 116 | 0; e = c + 116 | 0; f[d >> 2] = 0; g = a + 120 | 0; f[g >> 2] = 0; f[a + 124 >> 2] = 0; f[d >> 2] = f[e >> 2]; d = c + 120 | 0; f[g >> 2] = f[d >> 2]; g = c + 124 | 0; f[a + 124 >> 2] = f[g >> 2]; f[g >> 2] = 0; f[d >> 2] = 0; f[e >> 2] = 0; f[a + 128 >> 2] = f[c + 128 >> 2]; f[a + 132 >> 2] = f[c + 132 >> 2]; return } function se(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0; h = u; u = u + 48 | 0; i = h + 36 | 0; j = h + 24 | 0; k = h + 8 | 0; l = h + 4 | 0; m = h; n = e + 4 | 0; Bh(i, c, (f[n >> 2] | 0) - (f[e >> 2] | 0) >> 2, 2, g, d, 1); g = f[i >> 2] | 0; o = (f[f[g >> 2] >> 2] | 0) + (f[g + 48 >> 2] | 0) | 0; f[k >> 2] = -1; f[k + 4 >> 2] = -1; f[k + 8 >> 2] = -1; f[k + 12 >> 2] = -1; p = f[c + 4 >> 2] | 0; if ((p + -2 | 0) >>> 0 <= 28) { f[k >> 2] = p; c = 1 << p; f[k + 4 >> 2] = c + -1; p = c + -2 | 0; f[k + 8 >> 2] = p; f[k + 12 >> 2] = (p | 0) / 2 | 0; p = f[e >> 2] | 0; if ((f[n >> 2] | 0) == (p | 0)) q = g; else { c = d + 84 | 0; r = d + 68 | 0; s = d + 48 | 0; t = d + 40 | 0; v = 0; w = 0; x = p; while (1) { p = f[x + (v << 2) >> 2] | 0; if (!(b[c >> 0] | 0)) y = f[(f[r >> 2] | 0) + (p << 2) >> 2] | 0; else y = p; p = s; z = f[p >> 2] | 0; A = f[p + 4 >> 2] | 0; p = t; B = f[p >> 2] | 0; C = on(B | 0, f[p + 4 >> 2] | 0, y | 0, 0) | 0; p = Tn(C | 0, I | 0, z | 0, A | 0) | 0; Rg(j | 0, (f[f[d >> 2] >> 2] | 0) + p | 0, B | 0) | 0; df(k, j, l, m); f[o + (w << 2) >> 2] = f[l >> 2]; f[o + ((w | 1) << 2) >> 2] = f[m >> 2]; v = v + 1 | 0; x = f[e >> 2] | 0; if (v >>> 0 >= (f[n >> 2] | 0) - x >> 2 >>> 0) break; else w = w + 2 | 0 } q = f[i >> 2] | 0 } f[a >> 2] = q; f[i >> 2] = 0; u = h; return } f[a >> 2] = 0; f[i >> 2] = 0; if (!g) { u = h; return } i = g + 88 | 0; a = f[i >> 2] | 0; f[i >> 2] = 0; if (a | 0) { i = f[a + 8 >> 2] | 0; if (i | 0) { q = a + 12 | 0; if ((f[q >> 2] | 0) != (i | 0)) f[q >> 2] = i; br(i) } br(a) } a = f[g + 68 >> 2] | 0; if (a | 0) { i = g + 72 | 0; q = f[i >> 2] | 0; if ((q | 0) != (a | 0)) f[i >> 2] = q + (~((q + -4 - a | 0) >>> 2) << 2); br(a) } a = g + 64 | 0; q = f[a >> 2] | 0; f[a >> 2] = 0; if (q | 0) { a = f[q >> 2] | 0; if (a | 0) { i = q + 4 | 0; if ((f[i >> 2] | 0) != (a | 0)) f[i >> 2] = a; br(a) } br(q) } br(g); u = h; return } function te(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = a + 4 | 0; h = f[g >> 2] | 0; if (((e - h | 0) / 136 | 0) >>> 0 >= c >>> 0) { i = c; j = h; do { f[j >> 2] = -1; Ek(j + 4 | 0); b[j + 100 >> 0] = 1; k = j + 104 | 0; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; f[k + 24 >> 2] = 0; j = (f[g >> 2] | 0) + 136 | 0; f[g >> 2] = j; i = i + -1 | 0 } while ((i | 0) != 0); return } i = f[a >> 2] | 0; j = (h - i | 0) / 136 | 0; h = j + c | 0; if (h >>> 0 > 31580641) mq(a); k = (e - i | 0) / 136 | 0; i = k << 1; e = k >>> 0 < 15790320 ? (i >>> 0 < h >>> 0 ? h : i) : 31580641; do if (e) if (e >>> 0 > 31580641) { i = ra(8) | 0; Wo(i, 14941); f[i >> 2] = 6944; va(i | 0, 1080, 114) } else { l = dn(e * 136 | 0) | 0; break } else l = 0; while (0); i = l + (j * 136 | 0) | 0; j = i; h = l + (e * 136 | 0) | 0; e = c; c = j; l = i; do { f[l >> 2] = -1; Ek(l + 4 | 0); b[l + 100 >> 0] = 1; k = l + 104 | 0; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; f[k + 24 >> 2] = 0; l = c + 136 | 0; c = l; e = e + -1 | 0 } while ((e | 0) != 0); e = f[a >> 2] | 0; l = f[g >> 2] | 0; if ((l | 0) == (e | 0)) { m = j; n = e; o = e } else { k = l; l = j; j = i; do { k = k + -136 | 0; re(j + -136 | 0, k); j = l + -136 | 0; l = j } while ((k | 0) != (e | 0)); m = l; n = f[a >> 2] | 0; o = f[g >> 2] | 0 } f[a >> 2] = m; f[g >> 2] = c; f[d >> 2] = h; h = n; if ((o | 0) != (h | 0)) { d = o; do { o = f[d + -20 >> 2] | 0; if (o | 0) { c = d + -16 | 0; g = f[c >> 2] | 0; if ((g | 0) != (o | 0)) f[c >> 2] = g + (~((g + -4 - o | 0) >>> 2) << 2); br(o) } o = f[d + -32 >> 2] | 0; if (o | 0) { g = d + -28 | 0; c = f[g >> 2] | 0; if ((c | 0) != (o | 0)) f[g >> 2] = c + (~((c + -4 - o | 0) >>> 2) << 2); br(o) } yi(d + -132 | 0); d = d + -136 | 0 } while ((d | 0) != (h | 0)) } if (!n) return; br(n); return } function ue(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = f[b >> 2] | 0; b = a + 12 | 0; d = (c | 0) == -1; e = c + 1 | 0; do if (!d) { g = ((e >>> 0) % 3 | 0 | 0) == 0 ? c + -2 | 0 : e; if (!((c >>> 0) % 3 | 0)) { h = g; i = c + 2 | 0; break } else { h = g; i = c + -1 | 0; break } } else { h = -1; i = -1 } while (0); e = d ? -1 : (c >>> 0) / 3 | 0; g = a + 28 | 0; j = (f[g >> 2] | 0) + (e >>> 5 << 2) | 0; f[j >> 2] = 1 << (e & 31) | f[j >> 2]; j = a + 172 | 0; e = a + 176 | 0; k = a + 280 | 0; if (((!d ? (d = f[(f[(f[b >> 2] | 0) + 12 >> 2] | 0) + (c << 2) >> 2] | 0, (d | 0) != -1) : 0) ? (a = (d >>> 0) / 3 | 0, (f[(f[g >> 2] | 0) + (a >>> 5 << 2) >> 2] & 1 << (a & 31) | 0) == 0) : 0) ? (a = f[j >> 2] | 0, (f[e >> 2] | 0) != (a | 0)) : 0) { d = c >>> 5; l = 1 << (c & 31); c = 0; m = a; do { a = (f[k >> 2] | 0) + (c << 5) | 0; if (!(l & f[(f[m + (c * 136 | 0) + 4 >> 2] | 0) + (d << 2) >> 2])) Vi(a, 0); else Vi(a, 1); c = c + 1 | 0; m = f[j >> 2] | 0 } while (c >>> 0 < (((f[e >> 2] | 0) - m | 0) / 136 | 0) >>> 0) } if ((((h | 0) != -1 ? (m = f[(f[(f[b >> 2] | 0) + 12 >> 2] | 0) + (h << 2) >> 2] | 0, (m | 0) != -1) : 0) ? (c = (m >>> 0) / 3 | 0, (f[(f[g >> 2] | 0) + (c >>> 5 << 2) >> 2] & 1 << (c & 31) | 0) == 0) : 0) ? (c = f[j >> 2] | 0, (f[e >> 2] | 0) != (c | 0)) : 0) { m = h >>> 5; d = 1 << (h & 31); h = 0; l = c; do { c = (f[k >> 2] | 0) + (h << 5) | 0; if (!(d & f[(f[l + (h * 136 | 0) + 4 >> 2] | 0) + (m << 2) >> 2])) Vi(c, 0); else Vi(c, 1); h = h + 1 | 0; l = f[j >> 2] | 0 } while (h >>> 0 < (((f[e >> 2] | 0) - l | 0) / 136 | 0) >>> 0) } if ((i | 0) == -1) return 1; l = f[(f[(f[b >> 2] | 0) + 12 >> 2] | 0) + (i << 2) >> 2] | 0; if ((l | 0) == -1) return 1; b = (l >>> 0) / 3 | 0; if (f[(f[g >> 2] | 0) + (b >>> 5 << 2) >> 2] & 1 << (b & 31) | 0) return 1; b = f[j >> 2] | 0; if ((f[e >> 2] | 0) == (b | 0)) return 1; g = i >>> 5; l = 1 << (i & 31); i = 0; h = b; do { b = (f[k >> 2] | 0) + (i << 5) | 0; if (!(l & f[(f[h + (i * 136 | 0) + 4 >> 2] | 0) + (g << 2) >> 2])) Vi(b, 0); else Vi(b, 1); i = i + 1 | 0; h = f[j >> 2] | 0 } while (i >>> 0 < (((f[e >> 2] | 0) - h | 0) / 136 | 0) >>> 0); return 1 } function ve(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; i = a + 4 | 0; j = a + 8 | 0; Nh((f[j >> 2] | 0) - (f[i >> 2] | 0) >> 2, c) | 0; k = f[i >> 2] | 0; if ((f[j >> 2] | 0) == (k | 0)) { u = d; return 1 } l = a + 32 | 0; a = c + 16 | 0; m = c + 4 | 0; n = h + 1 | 0; o = h + 1 | 0; p = h + 1 | 0; q = h + 1 | 0; r = 0; s = k; do { k = f[(f[(f[l >> 2] | 0) + 8 >> 2] | 0) + (f[s + (r << 2) >> 2] << 2) >> 2] | 0; b[h >> 0] = f[k + 56 >> 2]; t = a; v = f[t >> 2] | 0; w = f[t + 4 >> 2] | 0; if ((w | 0) > 0 | (w | 0) == 0 & v >>> 0 > 0) { x = w; y = v } else { f[g >> 2] = f[m >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, q) | 0; v = a; x = f[v + 4 >> 2] | 0; y = f[v >> 2] | 0 } b[h >> 0] = f[k + 28 >> 2]; if ((x | 0) > 0 | (x | 0) == 0 & y >>> 0 > 0) { z = x; A = y } else { f[g >> 2] = f[m >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, p) | 0; v = a; z = f[v + 4 >> 2] | 0; A = f[v >> 2] | 0 } b[h >> 0] = b[k + 24 >> 0] | 0; if ((z | 0) > 0 | (z | 0) == 0 & A >>> 0 > 0) { B = z; C = A } else { f[g >> 2] = f[m >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, o) | 0; v = a; B = f[v + 4 >> 2] | 0; C = f[v >> 2] | 0 } b[h >> 0] = b[k + 32 >> 0] | 0; if (!((B | 0) > 0 | (B | 0) == 0 & C >>> 0 > 0)) { f[g >> 2] = f[m >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, n) | 0 } Nh(f[k + 60 >> 2] | 0, c) | 0; r = r + 1 | 0; s = f[i >> 2] | 0 } while (r >>> 0 < (f[j >> 2] | 0) - s >> 2 >>> 0); u = d; return 1 } function we(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0; d = u; u = u + 32 | 0; e = d + 16 | 0; g = d + 12 | 0; h = d + 8 | 0; i = d + 4 | 0; j = d; wp(a); f[a + 16 >> 2] = 0; f[a + 20 >> 2] = 0; f[a + 12 >> 2] = a + 16; k = a + 24 | 0; wp(k); l = b + 4 | 0; if ((a | 0) != (l | 0)) { f[h >> 2] = f[l >> 2]; f[i >> 2] = b + 8; f[g >> 2] = f[h >> 2]; f[e >> 2] = f[i >> 2]; Hc(a, g, e) } l = b + 28 | 0; if ((k | 0) != (l | 0)) { f[h >> 2] = f[l >> 2]; f[i >> 2] = b + 32; f[g >> 2] = f[h >> 2]; f[e >> 2] = f[i >> 2]; Hc(k, g, e) } f[j >> 2] = 0; k = c + 8 | 0; l = c + 12 | 0; c = f[l >> 2] | 0; m = f[k >> 2] | 0; if ((c - m | 0) <= 0) { u = d; return } n = b + 20 | 0; b = m; m = c; c = 0; while (1) { o = f[(f[b + (c << 2) >> 2] | 0) + 56 >> 2] | 0; p = f[n >> 2] | 0; if (p) { q = n; r = p; a: while (1) { p = r; while (1) { if ((f[p + 16 >> 2] | 0) >= (o | 0)) break; s = f[p + 4 >> 2] | 0; if (!s) { t = q; break a } else p = s } r = f[p >> 2] | 0; if (!r) { t = p; break } else q = p } if ((t | 0) != (n | 0) ? (o | 0) >= (f[t + 16 >> 2] | 0) : 0) { q = t + 20 | 0; r = wd(a, j) | 0; if ((r | 0) != (q | 0)) { f[h >> 2] = f[q >> 2]; f[i >> 2] = t + 24; f[g >> 2] = f[h >> 2]; f[e >> 2] = f[i >> 2]; Hc(r, g, e) } v = f[j >> 2] | 0; w = f[k >> 2] | 0; x = f[l >> 2] | 0 } else { v = c; w = b; x = m } } else { v = c; w = b; x = m } c = v + 1 | 0; f[j >> 2] = c; if ((c | 0) >= (x - w >> 2 | 0)) break; else { b = w; m = x } } u = d; return } function xe(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; i = a + 12 | 0; Nh(f[i >> 2] | 0, c) | 0; if (!(f[i >> 2] | 0)) { j = 1; u = d; return j | 0 } k = c + 16 | 0; l = c + 4 | 0; m = h + 1 | 0; n = h + 1 | 0; o = h + 1 | 0; p = 0; while (1) { q = f[a >> 2] | 0; r = f[q + (p << 3) >> 2] | 0; if (r >>> 0 > 63) if (r >>> 0 > 16383) if (r >>> 0 > 4194303) { j = 0; s = 20; break } else { t = 2; s = 13 } else { t = 1; s = 13 } else if (!r) { v = p + 1 | 0; w = 0; while (1) { if (f[q + (v + w << 3) >> 2] | 0) { x = w; break } y = w + 1 | 0; if (y >>> 0 < 63) w = y; else { x = y; break } } b[h >> 0] = x << 2 | 3; w = k; v = f[w + 4 >> 2] | 0; if (!((v | 0) > 0 | (v | 0) == 0 & (f[w >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[l >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, o) | 0 } z = x + p | 0 } else { t = 0; s = 13 } if ((s | 0) == 13) { s = 0; b[h >> 0] = t | r << 2; w = k; v = f[w + 4 >> 2] | 0; if (!((v | 0) > 0 | (v | 0) == 0 & (f[w >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[l >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, n) | 0 } if (!t) z = p; else { w = 0; do { w = w + 1 | 0; b[h >> 0] = r >>> ((w << 3) + -2 | 0); v = k; q = f[v + 4 >> 2] | 0; if (!((q | 0) > 0 | (q | 0) == 0 & (f[v >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[l >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, m) | 0 } } while ((w | 0) < (t | 0)); z = p } } p = z + 1 | 0; if (p >>> 0 >= (f[i >> 2] | 0) >>> 0) { j = 1; s = 20; break } } if ((s | 0) == 20) { u = d; return j | 0 } return 0 } function ye(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; g = f[a >> 2] | 0; h = g; i = (f[c >> 2] | 0) - h | 0; c = g + i | 0; j = e - d | 0; if ((j | 0) <= 0) { k = c; return k | 0 } l = a + 8 | 0; m = f[l >> 2] | 0; n = a + 4 | 0; o = f[n >> 2] | 0; p = o; if ((j | 0) <= (m - p | 0)) { q = p - c | 0; if ((j | 0) > (q | 0)) { r = d + q | 0; if ((r | 0) == (e | 0)) s = o; else { t = r; u = o; while (1) { b[u >> 0] = b[t >> 0] | 0; t = t + 1 | 0; v = (f[n >> 2] | 0) + 1 | 0; f[n >> 2] = v; if ((t | 0) == (e | 0)) { s = v; break } else u = v } } if ((q | 0) > 0) { w = r; x = s } else { k = c; return k | 0 } } else { w = e; x = o } s = x - (c + j) | 0; r = c + s | 0; if (r >>> 0 < o >>> 0) { q = r; r = x; do { b[r >> 0] = b[q >> 0] | 0; q = q + 1 | 0; r = (f[n >> 2] | 0) + 1 | 0; f[n >> 2] = r } while ((q | 0) != (o | 0)) } if (s | 0) Xl(x + (0 - s) | 0, c | 0, s | 0) | 0; if ((w | 0) == (d | 0)) { k = c; return k | 0 } else { y = d; z = c } while (1) { b[z >> 0] = b[y >> 0] | 0; y = y + 1 | 0; if ((y | 0) == (w | 0)) { k = c; break } else z = z + 1 | 0 } return k | 0 } z = p - h + j | 0; if ((z | 0) < 0) mq(a); j = m - h | 0; h = j << 1; m = j >>> 0 < 1073741823 ? (h >>> 0 < z >>> 0 ? z : h) : 2147483647; h = c; if (!m) A = 0; else A = dn(m) | 0; z = A + i | 0; i = z; j = A + m | 0; if ((d | 0) == (e | 0)) { B = i; C = g } else { g = d; d = i; i = z; do { b[i >> 0] = b[g >> 0] | 0; i = d + 1 | 0; d = i; g = g + 1 | 0 } while ((g | 0) != (e | 0)); B = d; C = f[a >> 2] | 0 } d = h - C | 0; e = z + (0 - d) | 0; if ((d | 0) > 0) Rg(e | 0, C | 0, d | 0) | 0; d = (f[n >> 2] | 0) - h | 0; if ((d | 0) > 0) { h = B; Rg(h | 0, c | 0, d | 0) | 0; D = h + d | 0; E = f[a >> 2] | 0 } else { D = B; E = C } f[a >> 2] = e; f[n >> 2] = D; f[l >> 2] = j; if (!E) { k = z; return k | 0 } br(E); k = z; return k | 0 } function ze(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; e = u; u = u + 16 | 0; g = e; h = f[(f[c + 4 >> 2] | 0) + (d << 2) >> 2] | 0; d = f[c + 28 >> 2] | 0; c = f[(f[(f[d + 4 >> 2] | 0) + 8 >> 2] | 0) + (h << 2) >> 2] | 0; switch (f[c + 28 >> 2] | 0) { case 5: case 6: case 3: case 4: case 1: case 2: { i = dn(40) | 0; Ao(i); j = i; k = j; f[a >> 2] = k; u = e; return } case 9: { l = 3; break } default: { } }if ((l | 0) == 3) { i = f[d + 48 >> 2] | 0; d = dn(32) | 0; f[g >> 2] = d; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 17; m = d; n = 12932; o = m + 17 | 0; do { b[m >> 0] = b[n >> 0] | 0; m = m + 1 | 0; n = n + 1 | 0 } while ((m | 0) < (o | 0)); b[d + 17 >> 0] = 0; d = i + 16 | 0; n = f[d >> 2] | 0; if (n) { p = d; q = n; a: while (1) { n = q; while (1) { if ((f[n + 16 >> 2] | 0) >= (h | 0)) break; r = f[n + 4 >> 2] | 0; if (!r) { s = p; break a } else n = r } q = f[n >> 2] | 0; if (!q) { s = n; break } else p = n } if (((s | 0) != (d | 0) ? (h | 0) >= (f[s + 16 >> 2] | 0) : 0) ? (h = s + 20 | 0, (sh(h, g) | 0) != 0) : 0) t = yk(h, g, -1) | 0; else l = 12 } else l = 12; if ((l | 0) == 12) t = yk(i, g, -1) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); if ((t | 0) > 0) if ((f[c + 56 >> 2] | 0) == 1) { c = dn(48) | 0; m = c; o = m + 48 | 0; do { f[m >> 2] = 0; m = m + 4 | 0 } while ((m | 0) < (o | 0)); Ao(c); f[c >> 2] = 2256; f[c + 40 >> 2] = 1152; f[c + 44 >> 2] = -1; j = c; k = j; f[a >> 2] = k; u = e; return } else { c = dn(64) | 0; mm(c); j = c; k = j; f[a >> 2] = k; u = e; return } } c = dn(36) | 0; wm(c); j = c; k = j; f[a >> 2] = k; u = e; return } function Ae(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; d = (c | 0) == (a | 0); b[c + 12 >> 0] = d & 1; if (d) return; else e = c; while (1) { g = e + 8 | 0; h = f[g >> 2] | 0; c = h + 12 | 0; if (b[c >> 0] | 0) { i = 23; break } j = h + 8 | 0; k = f[j >> 2] | 0; d = f[k >> 2] | 0; if ((d | 0) == (h | 0)) { l = f[k + 4 >> 2] | 0; if (!l) { i = 7; break } m = l + 12 | 0; if (!(b[m >> 0] | 0)) n = m; else { i = 7; break } } else { if (!d) { i = 16; break } m = d + 12 | 0; if (!(b[m >> 0] | 0)) n = m; else { i = 16; break } } b[c >> 0] = 1; c = (k | 0) == (a | 0); b[k + 12 >> 0] = c & 1; b[n >> 0] = 1; if (c) { i = 23; break } else e = k } if ((i | 0) == 7) { if ((f[h >> 2] | 0) == (e | 0)) { o = h; p = k } else { n = h + 4 | 0; a = f[n >> 2] | 0; c = f[a >> 2] | 0; f[n >> 2] = c; if (!c) q = k; else { f[c + 8 >> 2] = h; q = f[j >> 2] | 0 } f[a + 8 >> 2] = q; q = f[j >> 2] | 0; f[((f[q >> 2] | 0) == (h | 0) ? q : q + 4 | 0) >> 2] = a; f[a >> 2] = h; f[j >> 2] = a; o = a; p = f[a + 8 >> 2] | 0 } b[o + 12 >> 0] = 1; b[p + 12 >> 0] = 0; o = f[p >> 2] | 0; a = o + 4 | 0; q = f[a >> 2] | 0; f[p >> 2] = q; if (q | 0) f[q + 8 >> 2] = p; q = p + 8 | 0; f[o + 8 >> 2] = f[q >> 2]; c = f[q >> 2] | 0; f[((f[c >> 2] | 0) == (p | 0) ? c : c + 4 | 0) >> 2] = o; f[a >> 2] = p; f[q >> 2] = o; return } else if ((i | 0) == 16) { if ((f[h >> 2] | 0) == (e | 0)) { o = e + 4 | 0; q = f[o >> 2] | 0; f[h >> 2] = q; if (!q) r = k; else { f[q + 8 >> 2] = h; r = f[j >> 2] | 0 } f[g >> 2] = r; r = f[j >> 2] | 0; f[((f[r >> 2] | 0) == (h | 0) ? r : r + 4 | 0) >> 2] = e; f[o >> 2] = h; f[j >> 2] = e; s = e; t = f[e + 8 >> 2] | 0 } else { s = h; t = k } b[s + 12 >> 0] = 1; b[t + 12 >> 0] = 0; s = t + 4 | 0; k = f[s >> 2] | 0; h = f[k >> 2] | 0; f[s >> 2] = h; if (h | 0) f[h + 8 >> 2] = t; h = t + 8 | 0; f[k + 8 >> 2] = f[h >> 2]; s = f[h >> 2] | 0; f[((f[s >> 2] | 0) == (t | 0) ? s : s + 4 | 0) >> 2] = k; f[k >> 2] = t; f[h >> 2] = k; return } else if ((i | 0) == 23) return } function Be(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = Oa, C = Oa; h = u; u = u + 16 | 0; i = h; j = e + 4 | 0; k = b[d + 24 >> 0] | 0; l = k << 24 >> 24; Bh(a, c, (f[j >> 2] | 0) - (f[e >> 2] | 0) >> 2, l, g, d, 1); g = f[a >> 2] | 0; a = (f[f[g >> 2] >> 2] | 0) + (f[g + 48 >> 2] | 0) | 0; g = f[c + 4 >> 2] | 0; sq(i); yo(i, $(n[c + 20 >> 2]), (1 << g) + -1 | 0); g = _q(l >>> 0 > 1073741823 ? -1 : l << 2) | 0; m = f[j >> 2] | 0; j = f[e >> 2] | 0; e = j; if ((m | 0) == (j | 0)) { $q(g); u = h; return } o = d + 68 | 0; p = d + 48 | 0; q = d + 40 | 0; r = c + 8 | 0; c = (b[d + 84 >> 0] | 0) == 0; s = m - j >> 2; if (k << 24 >> 24 > 0) { t = 0; v = 0 } else { k = 0; do { j = f[e + (k << 2) >> 2] | 0; if (c) w = f[(f[o >> 2] | 0) + (j << 2) >> 2] | 0; else w = j; j = p; m = f[j >> 2] | 0; x = f[j + 4 >> 2] | 0; j = q; y = f[j >> 2] | 0; z = on(y | 0, f[j + 4 >> 2] | 0, w | 0, 0) | 0; j = Tn(z | 0, I | 0, m | 0, x | 0) | 0; Rg(g | 0, (f[f[d >> 2] >> 2] | 0) + j | 0, y | 0) | 0; k = k + 1 | 0 } while (k >>> 0 < s >>> 0); $q(g); u = h; return } while (1) { k = f[e + (t << 2) >> 2] | 0; if (c) A = f[(f[o >> 2] | 0) + (k << 2) >> 2] | 0; else A = k; k = p; w = f[k >> 2] | 0; y = f[k + 4 >> 2] | 0; k = q; j = f[k >> 2] | 0; x = on(j | 0, f[k + 4 >> 2] | 0, A | 0, 0) | 0; k = Tn(x | 0, I | 0, w | 0, y | 0) | 0; Rg(g | 0, (f[f[d >> 2] >> 2] | 0) + k | 0, j | 0) | 0; j = f[r >> 2] | 0; B = $(n[i >> 2]); k = 0; y = v; while (1) { C = $(n[g + (k << 2) >> 2]); w = ~~$(J($($(B * $(C - $(n[j + (k << 2) >> 2]))) + $(.5)))); f[a + (y << 2) >> 2] = w; k = k + 1 | 0; if ((k | 0) == (l | 0)) break; else y = y + 1 | 0 } t = t + 1 | 0; if (t >>> 0 >= s >>> 0) break; else v = v + l | 0 } $q(g); u = h; return } function Ce(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0; d = f[b >> 2] | 0; b = a + 12 | 0; e = (d | 0) == -1; do if (e) { g = 1; h = -1; i = -1 } else { j = d + (((d >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((j | 0) != -1) { k = f[(f[b >> 2] | 0) + 12 >> 2] | 0; l = j; while (1) { j = f[k + (l << 2) >> 2] | 0; if ((j | 0) == -1) { m = 0; n = l; break } o = j + 1 | 0; l = ((o >>> 0) % 3 | 0 | 0) == 0 ? j + -2 | 0 : o; if ((l | 0) == -1) { m = 1; n = -1; break } } if (e) { g = m; h = -1; i = n; break } else { p = m; q = n } } else { p = 1; q = -1 } g = p; h = f[(f[f[b >> 2] >> 2] | 0) + (d << 2) >> 2] | 0; i = q } while (0); if (c) { c = (f[a + 84 >> 2] | 0) + (h >>> 5 << 2) | 0; f[c >> 2] = f[c >> 2] | 1 << (h & 31); r = 1 } else r = 0; c = f[(f[a + 152 >> 2] | 0) + (h << 2) >> 2] | 0; q = (f[a + 140 >> 2] | 0) + (c >>> 5 << 2) | 0; f[q >> 2] = f[q >> 2] | 1 << (c & 31); if (!g) { g = (((i >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + i | 0; if ((g | 0) == -1) { s = -1; t = i } else { s = f[(f[f[b >> 2] >> 2] | 0) + (g << 2) >> 2] | 0; t = i } } else { s = -1; t = -1 } if ((s | 0) == (h | 0)) { u = r; return u | 0 } i = f[a + 84 >> 2] | 0; a = r; r = s; s = t; while (1) { t = i + (r >>> 5 << 2) | 0; f[t >> 2] = f[t >> 2] | 1 << (r & 31); t = a + 1 | 0; g = s + 1 | 0; a: do if ((s | 0) != -1 ? (c = ((g >>> 0) % 3 | 0 | 0) == 0 ? s + -2 | 0 : g, (c | 0) != -1) : 0) { q = f[b >> 2] | 0; d = f[q + 12 >> 2] | 0; p = c; while (1) { c = f[d + (p << 2) >> 2] | 0; if ((c | 0) == -1) break; n = c + 1 | 0; m = ((n >>> 0) % 3 | 0 | 0) == 0 ? c + -2 | 0 : n; if ((m | 0) == -1) { v = -1; w = -1; break a } else p = m } d = (((p >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + p | 0; if ((d | 0) == -1) { v = -1; w = p } else { v = f[(f[q >> 2] | 0) + (d << 2) >> 2] | 0; w = p } } else { v = -1; w = -1 } while (0); if ((v | 0) == (h | 0)) { u = t; break } else { a = t; r = v; s = w } } return u | 0 } function De(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = a + 100 | 0; if (d >>> 0 < (f[e >> 2] | 0) >>> 0) { f[c >> 2] = d + 1; g = h[d >> 0] | 0 } else g = Di(a) | 0; switch (g | 0) { case 43: case 45: { d = (g | 0) == 45 & 1; i = f[c >> 2] | 0; if (i >>> 0 < (f[e >> 2] | 0) >>> 0) { f[c >> 2] = i + 1; j = h[i >> 0] | 0 } else j = Di(a) | 0; if ((b | 0) != 0 & (j + -48 | 0) >>> 0 > 9 ? (f[e >> 2] | 0) != 0 : 0) { f[c >> 2] = (f[c >> 2] | 0) + -1; k = d; l = j } else { k = d; l = j } break } default: { k = 0; l = g } }if ((l + -48 | 0) >>> 0 > 9) if (!(f[e >> 2] | 0)) { m = -2147483648; n = 0 } else { f[c >> 2] = (f[c >> 2] | 0) + -1; m = -2147483648; n = 0 } else { g = 0; j = l; while (1) { g = j + -48 + (g * 10 | 0) | 0; l = f[c >> 2] | 0; if (l >>> 0 < (f[e >> 2] | 0) >>> 0) { f[c >> 2] = l + 1; o = h[l >> 0] | 0 } else o = Di(a) | 0; if (!((o + -48 | 0) >>> 0 < 10 & (g | 0) < 214748364)) break; else j = o } j = ((g | 0) < 0) << 31 >> 31; if ((o + -48 | 0) >>> 0 < 10) { l = o; d = g; b = j; while (1) { i = on(d | 0, b | 0, 10, 0) | 0; p = I; q = Tn(l | 0, ((l | 0) < 0) << 31 >> 31 | 0, -48, -1) | 0; r = Tn(q | 0, I | 0, i | 0, p | 0) | 0; p = I; i = f[c >> 2] | 0; if (i >>> 0 < (f[e >> 2] | 0) >>> 0) { f[c >> 2] = i + 1; s = h[i >> 0] | 0 } else s = Di(a) | 0; if ((s + -48 | 0) >>> 0 < 10 & ((p | 0) < 21474836 | (p | 0) == 21474836 & r >>> 0 < 2061584302)) { l = s; d = r; b = p } else { t = s; u = r; v = p; break } } } else { t = o; u = g; v = j } if ((t + -48 | 0) >>> 0 < 10) do { t = f[c >> 2] | 0; if (t >>> 0 < (f[e >> 2] | 0) >>> 0) { f[c >> 2] = t + 1; w = h[t >> 0] | 0 } else w = Di(a) | 0 } while ((w + -48 | 0) >>> 0 < 10); if (f[e >> 2] | 0) f[c >> 2] = (f[c >> 2] | 0) + -1; c = (k | 0) != 0; k = Vn(0, 0, u | 0, v | 0) | 0; m = c ? I : v; n = c ? k : u } I = m; return n | 0 } function Ee(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; b = a + 1176 | 0; c = f[b >> 2] | 0; if (c | 0) { d = a + 1180 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) g = c; else { h = e; while (1) { e = h + -12 | 0; f[d >> 2] = e; i = f[e >> 2] | 0; if (!i) j = e; else { e = h + -8 | 0; k = f[e >> 2] | 0; if ((k | 0) != (i | 0)) f[e >> 2] = k + (~((k + -4 - i | 0) >>> 2) << 2); br(i); j = f[d >> 2] | 0 } if ((j | 0) == (c | 0)) break; else h = j } g = f[b >> 2] | 0 } br(g) } g = a + 1164 | 0; b = f[g >> 2] | 0; if (b | 0) { j = a + 1168 | 0; h = f[j >> 2] | 0; if ((h | 0) == (b | 0)) l = b; else { c = h; while (1) { h = c + -12 | 0; f[j >> 2] = h; d = f[h >> 2] | 0; if (!d) m = h; else { h = c + -8 | 0; i = f[h >> 2] | 0; if ((i | 0) != (d | 0)) f[h >> 2] = i + (~((i + -4 - d | 0) >>> 2) << 2); br(d); m = f[j >> 2] | 0 } if ((m | 0) == (b | 0)) break; else c = m } l = f[g >> 2] | 0 } br(l) } l = f[a + 1152 >> 2] | 0; if (l | 0) { g = a + 1156 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 1140 >> 2] | 0; if (l | 0) { m = a + 1144 | 0; g = f[m >> 2] | 0; if ((g | 0) != (l | 0)) f[m >> 2] = g + (~((g + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 1128 >> 2] | 0; if (!l) { n = a + 1108 | 0; dl(n); o = a + 1088 | 0; dl(o); p = a + 1068 | 0; dl(p); q = a + 1036 | 0; tj(q); r = a + 12 | 0; xh(r); return } g = a + 1132 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l); n = a + 1108 | 0; dl(n); o = a + 1088 | 0; dl(o); p = a + 1068 | 0; dl(p); q = a + 1036 | 0; tj(q); r = a + 12 | 0; xh(r); return } function Fe(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; d = u; u = u + 16 | 0; e = d; g = a + 4 | 0; h = f[g >> 2] | 0; i = f[(f[a >> 2] | 0) + 52 >> 2] | 0; if (!h) { if (!(Sa[i & 31](a, c, 0) | 0)) { j = 0; u = d; return j | 0 } } else if (!(Sa[i & 31](a, c, f[(f[h + 4 >> 2] | 0) + 80 >> 2] | 0) | 0)) { j = 0; u = d; return j | 0 } if (!(b[a + 28 >> 0] | 0)) { j = 1; u = d; return j | 0 } h = f[a + 8 >> 2] | 0; i = f[a + 32 >> 2] | 0; a = f[h + 80 >> 2] | 0; f[e >> 2] = 0; k = e + 4 | 0; f[k >> 2] = 0; f[e + 8 >> 2] = 0; do if (a) if (a >>> 0 > 1073741823) mq(e); else { l = a << 2; m = dn(l) | 0; f[e >> 2] = m; n = m + (a << 2) | 0; f[e + 8 >> 2] = n; hj(m | 0, 0, l | 0) | 0; f[k >> 2] = n; o = m; p = n; q = m; break } else { o = 0; p = 0; q = 0 } while (0); e = f[c + 4 >> 2] | 0; a = f[c >> 2] | 0; c = a; a: do if ((e | 0) != (a | 0)) { m = e - a >> 2; if (b[h + 84 >> 0] | 0) { n = 0; while (1) { f[o + (f[c + (n << 2) >> 2] << 2) >> 2] = n; n = n + 1 | 0; if (n >>> 0 >= m >>> 0) break a } } n = f[h + 68 >> 2] | 0; l = 0; do { f[o + (f[n + (f[c + (l << 2) >> 2] << 2) >> 2] << 2) >> 2] = l; l = l + 1 | 0 } while (l >>> 0 < m >>> 0) } while (0); c = f[(f[(f[g >> 2] | 0) + 4 >> 2] | 0) + 80 >> 2] | 0; b: do if (c | 0) { g = f[i + 68 >> 2] | 0; if (b[h + 84 >> 0] | 0) { a = 0; while (1) { f[g + (a << 2) >> 2] = f[o + (a << 2) >> 2]; a = a + 1 | 0; if (a >>> 0 >= c >>> 0) break b } } a = f[h + 68 >> 2] | 0; e = 0; do { f[g + (e << 2) >> 2] = f[o + (f[a + (e << 2) >> 2] << 2) >> 2]; e = e + 1 | 0 } while (e >>> 0 < c >>> 0) } while (0); if (o | 0) { if ((p | 0) != (o | 0)) f[k >> 2] = p + (~((p + -4 - o | 0) >>> 2) << 2); br(q) } j = 1; u = d; return j | 0 } function Ge(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; c = u; u = u + 16 | 0; d = c; f[a >> 2] = 0; f[a + 8 >> 2] = b; yh(a + 12 | 0); rn(a + 1036 | 0); to(a + 1068 | 0); to(a + 1088 | 0); to(a + 1108 | 0); e = a + 1128 | 0; f[e >> 2] = 0; g = a + 1132 | 0; f[g >> 2] = 0; f[a + 1136 >> 2] = 0; h = (b | 0) == 0; do if (!h) if (b >>> 0 > 1073741823) mq(e); else { i = b << 2; j = dn(i) | 0; f[e >> 2] = j; k = j + (b << 2) | 0; f[a + 1136 >> 2] = k; hj(j | 0, 0, i | 0) | 0; f[g >> 2] = k; break } while (0); g = a + 1140 | 0; f[g >> 2] = 0; e = a + 1144 | 0; f[e >> 2] = 0; f[a + 1148 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 1148 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = a + 1152 | 0; f[g >> 2] = 0; e = a + 1156 | 0; f[e >> 2] = 0; f[a + 1160 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 1160 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = b << 5 | 1; f[d >> 2] = 0; e = d + 4 | 0; f[e >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[d >> 2] = i; j = i + (b << 2) | 0; f[d + 8 >> 2] = j; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = j } fk(a + 1164 | 0, g, d); j = f[d >> 2] | 0; if (j | 0) { k = f[e >> 2] | 0; if ((k | 0) != (j | 0)) f[e >> 2] = k + (~((k + -4 - j | 0) >>> 2) << 2); br(j) } f[d >> 2] = 0; j = d + 4 | 0; f[j >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { h = b << 2; k = dn(h) | 0; f[d >> 2] = k; e = k + (b << 2) | 0; f[d + 8 >> 2] = e; hj(k | 0, 0, h | 0) | 0; f[j >> 2] = e } fk(a + 1176 | 0, g, d); g = f[d >> 2] | 0; if (!g) { u = c; return } d = f[j >> 2] | 0; if ((d | 0) != (g | 0)) f[j >> 2] = d + (~((d + -4 - g | 0) >>> 2) << 2); br(g); u = c; return } function He(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0.0, D = 0.0, E = 0.0; g = u; u = u + 16 | 0; h = g; i = b + 16 | 0; f[a >> 2] = f[i >> 2]; f[a + 4 >> 2] = f[i + 4 >> 2]; f[a + 8 >> 2] = f[i + 8 >> 2]; f[a + 12 >> 2] = f[i + 12 >> 2]; f[a + 16 >> 2] = f[i + 16 >> 2]; f[a + 20 >> 2] = f[i + 20 >> 2]; j = a + 8 | 0; f[j >> 2] = (f[j >> 2] | 0) + d; j = (d | 0) > 0; if (j) { k = b + 4 | 0; l = a + 16 | 0; m = a + 12 | 0; n = f[b >> 2] | 0; o = n; q = 0; r = o; s = n; n = o; while (1) { o = f[c + (q << 2) >> 2] | 0; t = f[k >> 2] | 0; if (t - s >> 2 >>> 0 > o >>> 0) { v = r; w = n } else { x = o + 1 | 0; f[h >> 2] = 0; y = t - s >> 2; z = s; A = t; if (x >>> 0 <= y >>> 0) if (x >>> 0 < y >>> 0 ? (t = z + (x << 2) | 0, (t | 0) != (A | 0)) : 0) { f[k >> 2] = A + (~((A + -4 - t | 0) >>> 2) << 2); B = r } else B = r; else { kh(b, x - y | 0, h); B = f[b >> 2] | 0 } v = B; w = B } y = w + (o << 2) | 0; x = f[y >> 2] | 0; s = w; if ((x | 0) <= 1) if ((x | 0) == 0 ? (f[l >> 2] = (f[l >> 2] | 0) + 1, o >>> 0 > (f[m >> 2] | 0) >>> 0) : 0) { f[m >> 2] = o; C = 0.0 } else C = 0.0; else { D = +(x | 0); C = +Fg(D) * D } x = (f[y >> 2] | 0) + 1 | 0; f[y >> 2] = x; D = +(x | 0); E = +Fg(D) * D - C; p[a >> 3] = +p[a >> 3] + E; q = q + 1 | 0; if ((q | 0) == (d | 0)) break; else { r = v; n = w } } } if (e) { f[i >> 2] = f[a >> 2]; f[i + 4 >> 2] = f[a + 4 >> 2]; f[i + 8 >> 2] = f[a + 8 >> 2]; f[i + 12 >> 2] = f[a + 12 >> 2]; f[i + 16 >> 2] = f[a + 16 >> 2]; u = g; return } if (!j) { u = g; return } j = f[b >> 2] | 0; b = 0; do { a = j + (f[c + (b << 2) >> 2] << 2) | 0; f[a >> 2] = (f[a >> 2] | 0) + -1; b = b + 1 | 0 } while ((b | 0) != (d | 0)); u = g; return } function Ie(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0.0; a: do if (b >>> 0 <= 20) do switch (b | 0) { case 9: { d = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); e = f[d >> 2] | 0; f[c >> 2] = d + 4; f[a >> 2] = e; break a; break } case 10: { e = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); d = f[e >> 2] | 0; f[c >> 2] = e + 4; e = a; f[e >> 2] = d; f[e + 4 >> 2] = ((d | 0) < 0) << 31 >> 31; break a; break } case 11: { d = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); e = f[d >> 2] | 0; f[c >> 2] = d + 4; d = a; f[d >> 2] = e; f[d + 4 >> 2] = 0; break a; break } case 12: { d = (f[c >> 2] | 0) + (8 - 1) & ~(8 - 1); e = d; g = f[e >> 2] | 0; h = f[e + 4 >> 2] | 0; f[c >> 2] = d + 8; d = a; f[d >> 2] = g; f[d + 4 >> 2] = h; break a; break } case 13: { h = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); d = f[h >> 2] | 0; f[c >> 2] = h + 4; h = (d & 65535) << 16 >> 16; d = a; f[d >> 2] = h; f[d + 4 >> 2] = ((h | 0) < 0) << 31 >> 31; break a; break } case 14: { h = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); d = f[h >> 2] | 0; f[c >> 2] = h + 4; h = a; f[h >> 2] = d & 65535; f[h + 4 >> 2] = 0; break a; break } case 15: { h = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); d = f[h >> 2] | 0; f[c >> 2] = h + 4; h = (d & 255) << 24 >> 24; d = a; f[d >> 2] = h; f[d + 4 >> 2] = ((h | 0) < 0) << 31 >> 31; break a; break } case 16: { h = (f[c >> 2] | 0) + (4 - 1) & ~(4 - 1); d = f[h >> 2] | 0; f[c >> 2] = h + 4; h = a; f[h >> 2] = d & 255; f[h + 4 >> 2] = 0; break a; break } case 17: { h = (f[c >> 2] | 0) + (8 - 1) & ~(8 - 1); i = +p[h >> 3]; f[c >> 2] = h + 8; p[a >> 3] = i; break a; break } case 18: { h = (f[c >> 2] | 0) + (8 - 1) & ~(8 - 1); i = +p[h >> 3]; f[c >> 2] = h + 8; p[a >> 3] = i; break a; break } default: break a } while (0); while (0); return } function Je(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; c = u; u = u + 16 | 0; d = c + 4 | 0; e = c; g = c + 8 | 0; if (!(Qa[f[(f[a >> 2] | 0) + 32 >> 2] & 127](a) | 0)) { h = 0; u = c; return h | 0 } i = a + 44 | 0; j = f[i >> 2] | 0; k = a + 8 | 0; l = a + 12 | 0; m = f[l >> 2] | 0; n = f[k >> 2] | 0; b[g >> 0] = (m - n | 0) >>> 2; o = j + 16 | 0; p = f[o + 4 >> 2] | 0; if ((p | 0) > 0 | (p | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0) { q = k; r = n; s = m } else { f[e >> 2] = f[j + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(j, d, g, g + 1 | 0) | 0; q = k; r = f[k >> 2] | 0; s = f[l >> 2] | 0 } a: do if ((r | 0) != (s | 0)) { l = a + 4 | 0; k = r; while (1) { g = f[k >> 2] | 0; k = k + 4 | 0; if (!(Sa[f[(f[g >> 2] | 0) + 8 >> 2] & 31](g, a, f[l >> 2] | 0) | 0)) { h = 0; break } if ((k | 0) == (s | 0)) break a } u = c; return h | 0 } while (0); if (!(vc(a) | 0)) { h = 0; u = c; return h | 0 } s = a + 32 | 0; r = f[s >> 2] | 0; k = a + 36 | 0; l = f[k >> 2] | 0; b: do if ((r | 0) != (l | 0)) { g = r; do { if (!(Ra[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a, f[g >> 2] | 0) | 0)) { h = 0; t = 18; break } g = g + 4 | 0 } while ((g | 0) != (l | 0)); if ((t | 0) == 18) { u = c; return h | 0 } g = f[s >> 2] | 0; d = f[k >> 2] | 0; if ((g | 0) != (d | 0)) { j = g; while (1) { g = f[(f[q >> 2] | 0) + (f[j >> 2] << 2) >> 2] | 0; j = j + 4 | 0; if (!(Ra[f[(f[g >> 2] | 0) + 12 >> 2] & 127](g, f[i >> 2] | 0) | 0)) { h = 0; break } if ((j | 0) == (d | 0)) break b } u = c; return h | 0 } } while (0); h = Qa[f[(f[a >> 2] | 0) + 44 >> 2] & 127](a) | 0; u = c; return h | 0 } function Ke(a, b) { a = a | 0; b = b | 0; fd(a, b); fd(a + 32 | 0, b); fd(a + 64 | 0, b); fd(a + 96 | 0, b); fd(a + 128 | 0, b); fd(a + 160 | 0, b); fd(a + 192 | 0, b); fd(a + 224 | 0, b); fd(a + 256 | 0, b); fd(a + 288 | 0, b); fd(a + 320 | 0, b); fd(a + 352 | 0, b); fd(a + 384 | 0, b); fd(a + 416 | 0, b); fd(a + 448 | 0, b); fd(a + 480 | 0, b); fd(a + 512 | 0, b); fd(a + 544 | 0, b); fd(a + 576 | 0, b); fd(a + 608 | 0, b); fd(a + 640 | 0, b); fd(a + 672 | 0, b); fd(a + 704 | 0, b); fd(a + 736 | 0, b); fd(a + 768 | 0, b); fd(a + 800 | 0, b); fd(a + 832 | 0, b); fd(a + 864 | 0, b); fd(a + 896 | 0, b); fd(a + 928 | 0, b); fd(a + 960 | 0, b); fd(a + 992 | 0, b); fd(a + 1024 | 0, b); return } function Le(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; e = u; u = u + 64 | 0; g = e + 60 | 0; h = e; i = dn(80) | 0; j = f[c + 8 >> 2] | 0; f[i + 4 >> 2] = 0; f[i >> 2] = 3232; k = i + 8 | 0; l = i + 12 | 0; m = l + 44 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[k >> 2] = 3256; n = i + 56 | 0; f[n >> 2] = 0; f[i + 60 >> 2] = 0; f[i + 64 >> 2] = 0; f[i + 68 >> 2] = j; f[i + 72 >> 2] = d; o = i + 76 | 0; f[o >> 2] = 0; p = i; q = f[c + 12 >> 2] | 0; r = h + 4 | 0; l = r + 4 | 0; m = l + 40 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[h >> 2] = 3256; l = h + 48 | 0; f[l >> 2] = 0; m = h + 52 | 0; f[m >> 2] = 0; f[h + 56 >> 2] = 0; s = q; f[r >> 2] = s; t = ((f[s + 4 >> 2] | 0) - (f[q >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[g >> 0] = 0; Xg(h + 24 | 0, t, g); t = f[r >> 2] | 0; r = (f[t + 28 >> 2] | 0) - (f[t + 24 >> 2] | 0) >> 2; b[g >> 0] = 0; Xg(h + 36 | 0, r, g); f[h + 8 >> 2] = q; f[h + 12 >> 2] = d; f[h + 16 >> 2] = j; f[h + 20 >> 2] = i; f[o >> 2] = c + 72; ef(k, h) | 0; Yf(n, f[l >> 2] | 0, f[m >> 2] | 0); f[a >> 2] = p; f[h >> 2] = 3256; p = f[l >> 2] | 0; if (p | 0) { l = f[m >> 2] | 0; if ((l | 0) != (p | 0)) f[m >> 2] = l + (~((l + -4 - p | 0) >>> 2) << 2); br(p) } f[h >> 2] = 3276; p = f[h + 36 >> 2] | 0; if (p | 0) br(p); p = f[h + 24 >> 2] | 0; if (!p) { u = e; return } br(p); u = e; return } function Me(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0; c = u; u = u + 32 | 0; d = c; e = a + 4 | 0; g = f[a >> 2] | 0; h = (f[e >> 2] | 0) - g >> 2; i = h + 1 | 0; if (i >>> 0 > 1073741823) mq(a); j = a + 8 | 0; k = (f[j >> 2] | 0) - g | 0; g = k >> 1; l = k >> 2 >>> 0 < 536870911 ? (g >>> 0 < i >>> 0 ? i : g) : 1073741823; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = a + 8; do if (l) if (l >>> 0 > 1073741823) { g = ra(8) | 0; Wo(g, 14941); f[g >> 2] = 6944; va(g | 0, 1080, 114) } else { m = dn(l << 2) | 0; break } else m = 0; while (0); f[d >> 2] = m; g = m + (h << 2) | 0; h = d + 8 | 0; i = d + 4 | 0; f[i >> 2] = g; k = m + (l << 2) | 0; l = d + 12 | 0; f[l >> 2] = k; m = f[b >> 2] | 0; f[b >> 2] = 0; f[g >> 2] = m; m = g + 4 | 0; f[h >> 2] = m; b = f[a >> 2] | 0; n = f[e >> 2] | 0; if ((n | 0) == (b | 0)) { o = g; p = l; q = h; r = b; s = m; t = n; v = k; w = o; f[a >> 2] = w; f[i >> 2] = r; f[e >> 2] = s; f[q >> 2] = t; x = f[j >> 2] | 0; f[j >> 2] = v; f[p >> 2] = x; f[d >> 2] = r; Wh(d); u = c; return } else { y = n; z = g } do { y = y + -4 | 0; g = f[y >> 2] | 0; f[y >> 2] = 0; f[z + -4 >> 2] = g; z = (f[i >> 2] | 0) + -4 | 0; f[i >> 2] = z } while ((y | 0) != (b | 0)); o = z; p = l; q = h; r = f[a >> 2] | 0; s = f[h >> 2] | 0; t = f[e >> 2] | 0; v = f[l >> 2] | 0; w = o; f[a >> 2] = w; f[i >> 2] = r; f[e >> 2] = s; f[q >> 2] = t; x = f[j >> 2] | 0; f[j >> 2] = v; f[p >> 2] = x; f[d >> 2] = r; Wh(d); u = c; return } function Ne(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; d = u; u = u + 32 | 0; e = d + 12 | 0; g = d; h = hl(c, 0) | 0; if (!h) { f[a >> 2] = 0; u = d; return } i = f[c + 100 >> 2] | 0; j = f[c + 96 >> 2] | 0; c = i - j | 0; k = (c | 0) / 12 | 0; f[e >> 2] = 0; l = e + 4 | 0; f[l >> 2] = 0; f[e + 8 >> 2] = 0; m = j; do if (c) if (k >>> 0 > 357913941) mq(e); else { n = dn(c) | 0; f[e >> 2] = n; f[e + 8 >> 2] = n + (k * 12 | 0); hj(n | 0, 0, c | 0) | 0; f[l >> 2] = n + c; o = n; break } else o = 0; while (0); f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; a: do if ((i | 0) != (j | 0)) { c = g + 4 | 0; n = g + 8 | 0; if (b[h + 84 >> 0] | 0) { p = 0; while (1) { q = m + (p * 12 | 0) | 0; f[g >> 2] = f[q >> 2]; f[g + 4 >> 2] = f[q + 4 >> 2]; f[g + 8 >> 2] = f[q + 8 >> 2]; f[o + (p * 12 | 0) >> 2] = f[g >> 2]; f[o + (p * 12 | 0) + 4 >> 2] = f[c >> 2]; f[o + (p * 12 | 0) + 8 >> 2] = f[n >> 2]; p = p + 1 | 0; if (p >>> 0 >= k >>> 0) break a } } p = f[h + 68 >> 2] | 0; q = 0; do { r = f[p + (f[m + (q * 12 | 0) >> 2] << 2) >> 2] | 0; f[g >> 2] = r; s = f[p + (f[m + (q * 12 | 0) + 4 >> 2] << 2) >> 2] | 0; f[c >> 2] = s; t = f[p + (f[m + (q * 12 | 0) + 8 >> 2] << 2) >> 2] | 0; f[n >> 2] = t; f[o + (q * 12 | 0) >> 2] = r; f[o + (q * 12 | 0) + 4 >> 2] = s; f[o + (q * 12 | 0) + 8 >> 2] = t; q = q + 1 | 0 } while (q >>> 0 < k >>> 0) } while (0); Cj(a, e); a = f[e >> 2] | 0; if (a | 0) { e = f[l >> 2] | 0; if ((e | 0) != (a | 0)) f[l >> 2] = e + (~(((e + -12 - a | 0) >>> 0) / 12 | 0) * 12 | 0); br(a) } u = d; return } function Oe(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; c = u; u = u + 16 | 0; d = c; f[a >> 2] = 0; f[a + 8 >> 2] = b; rn(a + 12 | 0); to(a + 44 | 0); to(a + 64 | 0); to(a + 84 | 0); e = a + 104 | 0; f[e >> 2] = 0; g = a + 108 | 0; f[g >> 2] = 0; f[a + 112 >> 2] = 0; h = (b | 0) == 0; do if (!h) if (b >>> 0 > 1073741823) mq(e); else { i = b << 2; j = dn(i) | 0; f[e >> 2] = j; k = j + (b << 2) | 0; f[a + 112 >> 2] = k; hj(j | 0, 0, i | 0) | 0; f[g >> 2] = k; break } while (0); g = a + 116 | 0; f[g >> 2] = 0; e = a + 120 | 0; f[e >> 2] = 0; f[a + 124 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 124 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = a + 128 | 0; f[g >> 2] = 0; e = a + 132 | 0; f[e >> 2] = 0; f[a + 136 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 136 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = b << 5 | 1; f[d >> 2] = 0; e = d + 4 | 0; f[e >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[d >> 2] = i; j = i + (b << 2) | 0; f[d + 8 >> 2] = j; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = j } fk(a + 140 | 0, g, d); j = f[d >> 2] | 0; if (j | 0) { k = f[e >> 2] | 0; if ((k | 0) != (j | 0)) f[e >> 2] = k + (~((k + -4 - j | 0) >>> 2) << 2); br(j) } f[d >> 2] = 0; j = d + 4 | 0; f[j >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { h = b << 2; k = dn(h) | 0; f[d >> 2] = k; e = k + (b << 2) | 0; f[d + 8 >> 2] = e; hj(k | 0, 0, h | 0) | 0; f[j >> 2] = e } fk(a + 152 | 0, g, d); g = f[d >> 2] | 0; if (!g) { u = c; return } d = f[j >> 2] | 0; if ((d | 0) != (g | 0)) f[j >> 2] = d + (~((d + -4 - g | 0) >>> 2) << 2); br(g); u = c; return } function Pe(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; c = u; u = u + 16 | 0; d = c; f[a >> 2] = 0; f[a + 8 >> 2] = b; to(a + 12 | 0); to(a + 32 | 0); to(a + 52 | 0); to(a + 72 | 0); e = a + 92 | 0; f[e >> 2] = 0; g = a + 96 | 0; f[g >> 2] = 0; f[a + 100 >> 2] = 0; h = (b | 0) == 0; do if (!h) if (b >>> 0 > 1073741823) mq(e); else { i = b << 2; j = dn(i) | 0; f[e >> 2] = j; k = j + (b << 2) | 0; f[a + 100 >> 2] = k; hj(j | 0, 0, i | 0) | 0; f[g >> 2] = k; break } while (0); g = a + 104 | 0; f[g >> 2] = 0; e = a + 108 | 0; f[e >> 2] = 0; f[a + 112 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 112 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = a + 116 | 0; f[g >> 2] = 0; e = a + 120 | 0; f[e >> 2] = 0; f[a + 124 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[g >> 2] = i; g = i + (b << 2) | 0; f[a + 124 >> 2] = g; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = g } g = b << 5 | 1; f[d >> 2] = 0; e = d + 4 | 0; f[e >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { k = b << 2; i = dn(k) | 0; f[d >> 2] = i; j = i + (b << 2) | 0; f[d + 8 >> 2] = j; hj(i | 0, 0, k | 0) | 0; f[e >> 2] = j } fk(a + 128 | 0, g, d); j = f[d >> 2] | 0; if (j | 0) { k = f[e >> 2] | 0; if ((k | 0) != (j | 0)) f[e >> 2] = k + (~((k + -4 - j | 0) >>> 2) << 2); br(j) } f[d >> 2] = 0; j = d + 4 | 0; f[j >> 2] = 0; f[d + 8 >> 2] = 0; if (!h) { h = b << 2; k = dn(h) | 0; f[d >> 2] = k; e = k + (b << 2) | 0; f[d + 8 >> 2] = e; hj(k | 0, 0, h | 0) | 0; f[j >> 2] = e } fk(a + 140 | 0, g, d); g = f[d >> 2] | 0; if (!g) { u = c; return } d = f[j >> 2] | 0; if ((d | 0) != (g | 0)) f[j >> 2] = d + (~((d + -4 - g | 0) >>> 2) << 2); br(g); u = c; return } function Qe(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0; d = dn(40) | 0; e = d + 16 | 0; dj(e, c); dj(d + 28 | 0, c + 12 | 0); c = a + 4 | 0; g = f[c >> 2] | 0; do if (g) { h = b[d + 27 >> 0] | 0; i = h << 24 >> 24 < 0; j = i ? f[d + 20 >> 2] | 0 : h & 255; h = i ? f[e >> 2] | 0 : e; i = g; while (1) { k = i + 16 | 0; l = b[k + 11 >> 0] | 0; m = l << 24 >> 24 < 0; n = m ? f[i + 20 >> 2] | 0 : l & 255; l = n >>> 0 < j >>> 0 ? n : j; if ((l | 0) != 0 ? (o = Pk(h, m ? f[k >> 2] | 0 : k, l) | 0, (o | 0) != 0) : 0) if ((o | 0) < 0) p = 7; else p = 9; else if (j >>> 0 < n >>> 0) p = 7; else p = 9; if ((p | 0) == 7) { p = 0; n = f[i >> 2] | 0; if (!n) { p = 8; break } else q = n } else if ((p | 0) == 9) { p = 0; r = i + 4 | 0; n = f[r >> 2] | 0; if (!n) { p = 11; break } else q = n } i = q } if ((p | 0) == 8) { s = i; t = i; break } else if ((p | 0) == 11) { s = i; t = r; break } } else { s = c; t = c } while (0); f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = s; f[t >> 2] = d; s = f[f[a >> 2] >> 2] | 0; if (!s) { u = d; v = a + 4 | 0; w = f[v >> 2] | 0; Ae(w, u); x = a + 8 | 0; y = f[x >> 2] | 0; z = y + 1 | 0; f[x >> 2] = z; return d | 0 } f[a >> 2] = s; u = f[t >> 2] | 0; v = a + 4 | 0; w = f[v >> 2] | 0; Ae(w, u); x = a + 8 | 0; y = f[x >> 2] | 0; z = y + 1 | 0; f[x >> 2] = z; return d | 0 } function Re(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = Oa, B = Oa; g = u; u = u + 16 | 0; h = g; i = b[d + 24 >> 0] | 0; j = i << 24 >> 24; Bh(a, c, e, j, 0, d, 1); k = f[a >> 2] | 0; a = (f[f[k >> 2] >> 2] | 0) + (f[k + 48 >> 2] | 0) | 0; k = f[c + 4 >> 2] | 0; sq(h); yo(h, $(n[c + 20 >> 2]), (1 << k) + -1 | 0); k = _q(j >>> 0 > 1073741823 ? -1 : j << 2) | 0; if (!e) { $q(k); u = g; return } l = d + 68 | 0; m = d + 48 | 0; o = d + 40 | 0; p = c + 8 | 0; c = (b[d + 84 >> 0] | 0) == 0; if (i << 24 >> 24 > 0) { q = 0; r = 0 } else { i = 0; do { if (c) s = f[(f[l >> 2] | 0) + (i << 2) >> 2] | 0; else s = i; t = m; v = f[t >> 2] | 0; w = f[t + 4 >> 2] | 0; t = o; x = f[t >> 2] | 0; y = on(x | 0, f[t + 4 >> 2] | 0, s | 0, 0) | 0; t = Tn(y | 0, I | 0, v | 0, w | 0) | 0; Rg(k | 0, (f[f[d >> 2] >> 2] | 0) + t | 0, x | 0) | 0; i = i + 1 | 0 } while ((i | 0) != (e | 0)); $q(k); u = g; return } while (1) { if (c) z = f[(f[l >> 2] | 0) + (r << 2) >> 2] | 0; else z = r; i = m; s = f[i >> 2] | 0; x = f[i + 4 >> 2] | 0; i = o; t = f[i >> 2] | 0; w = on(t | 0, f[i + 4 >> 2] | 0, z | 0, 0) | 0; i = Tn(w | 0, I | 0, s | 0, x | 0) | 0; Rg(k | 0, (f[f[d >> 2] >> 2] | 0) + i | 0, t | 0) | 0; t = f[p >> 2] | 0; A = $(n[h >> 2]); i = 0; x = q; while (1) { B = $(n[k + (i << 2) >> 2]); s = ~~$(J($($(A * $(B - $(n[t + (i << 2) >> 2]))) + $(.5)))); f[a + (x << 2) >> 2] = s; i = i + 1 | 0; if ((i | 0) == (j | 0)) break; else x = x + 1 | 0 } r = r + 1 | 0; if ((r | 0) == (e | 0)) break; else q = q + j | 0 } $q(k); u = g; return } function Se(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3340; ii(a + 200 | 0); b = f[a + 184 >> 2] | 0; if (b | 0) { c = a + 188 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } _i(a + 172 | 0); b = f[a + 152 >> 2] | 0; if (b | 0) { d = a + 156 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 140 >> 2] | 0; if (b | 0) br(b); b = f[a + 128 >> 2] | 0; if (b | 0) { c = b; do { b = c; c = f[c >> 2] | 0; br(b) } while ((c | 0) != 0) } c = a + 120 | 0; b = f[c >> 2] | 0; f[c >> 2] = 0; if (b | 0) br(b); b = f[a + 108 >> 2] | 0; if (b | 0) { c = a + 112 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~(((d + -12 - b | 0) >>> 0) / 12 | 0) * 12 | 0); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) { d = a + 100 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 84 >> 2] | 0; if (b | 0) br(b); b = f[a + 72 >> 2] | 0; if (b | 0) { c = a + 76 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 52 >> 2] | 0; if (b | 0) { d = a + 56 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 40 >> 2] | 0; if (b | 0) { c = a + 44 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 28 >> 2] | 0; if (b | 0) br(b); b = f[a + 16 >> 2] | 0; if (b | 0) { d = a + 20 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = a + 12 | 0; a = f[b >> 2] | 0; f[b >> 2] = 0; if (!a) return; ui(a); br(a); return } function Te(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; b = a + 140 | 0; c = f[b >> 2] | 0; if (c | 0) { d = a + 144 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) g = c; else { h = e; while (1) { e = h + -12 | 0; f[d >> 2] = e; i = f[e >> 2] | 0; if (!i) j = e; else { e = h + -8 | 0; k = f[e >> 2] | 0; if ((k | 0) != (i | 0)) f[e >> 2] = k + (~((k + -4 - i | 0) >>> 2) << 2); br(i); j = f[d >> 2] | 0 } if ((j | 0) == (c | 0)) break; else h = j } g = f[b >> 2] | 0 } br(g) } g = a + 128 | 0; b = f[g >> 2] | 0; if (b | 0) { j = a + 132 | 0; h = f[j >> 2] | 0; if ((h | 0) == (b | 0)) l = b; else { c = h; while (1) { h = c + -12 | 0; f[j >> 2] = h; d = f[h >> 2] | 0; if (!d) m = h; else { h = c + -8 | 0; i = f[h >> 2] | 0; if ((i | 0) != (d | 0)) f[h >> 2] = i + (~((i + -4 - d | 0) >>> 2) << 2); br(d); m = f[j >> 2] | 0 } if ((m | 0) == (b | 0)) break; else c = m } l = f[g >> 2] | 0 } br(l) } l = f[a + 116 >> 2] | 0; if (l | 0) { g = a + 120 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 104 >> 2] | 0; if (l | 0) { m = a + 108 | 0; g = f[m >> 2] | 0; if ((g | 0) != (l | 0)) f[m >> 2] = g + (~((g + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 92 >> 2] | 0; if (!l) { n = a + 72 | 0; dl(n); o = a + 52 | 0; dl(o); p = a + 32 | 0; dl(p); q = a + 12 | 0; dl(q); return } g = a + 96 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l); n = a + 72 | 0; dl(n); o = a + 52 | 0; dl(o); p = a + 32 | 0; dl(p); q = a + 12 | 0; dl(q); return } function Ue(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; b = a + 152 | 0; c = f[b >> 2] | 0; if (c | 0) { d = a + 156 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) g = c; else { h = e; while (1) { e = h + -12 | 0; f[d >> 2] = e; i = f[e >> 2] | 0; if (!i) j = e; else { e = h + -8 | 0; k = f[e >> 2] | 0; if ((k | 0) != (i | 0)) f[e >> 2] = k + (~((k + -4 - i | 0) >>> 2) << 2); br(i); j = f[d >> 2] | 0 } if ((j | 0) == (c | 0)) break; else h = j } g = f[b >> 2] | 0 } br(g) } g = a + 140 | 0; b = f[g >> 2] | 0; if (b | 0) { j = a + 144 | 0; h = f[j >> 2] | 0; if ((h | 0) == (b | 0)) l = b; else { c = h; while (1) { h = c + -12 | 0; f[j >> 2] = h; d = f[h >> 2] | 0; if (!d) m = h; else { h = c + -8 | 0; i = f[h >> 2] | 0; if ((i | 0) != (d | 0)) f[h >> 2] = i + (~((i + -4 - d | 0) >>> 2) << 2); br(d); m = f[j >> 2] | 0 } if ((m | 0) == (b | 0)) break; else c = m } l = f[g >> 2] | 0 } br(l) } l = f[a + 128 >> 2] | 0; if (l | 0) { g = a + 132 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 116 >> 2] | 0; if (l | 0) { m = a + 120 | 0; g = f[m >> 2] | 0; if ((g | 0) != (l | 0)) f[m >> 2] = g + (~((g + -4 - l | 0) >>> 2) << 2); br(l) } l = f[a + 104 >> 2] | 0; if (!l) { n = a + 84 | 0; dl(n); o = a + 64 | 0; dl(o); p = a + 44 | 0; dl(p); q = a + 12 | 0; tj(q); return } g = a + 108 | 0; m = f[g >> 2] | 0; if ((m | 0) != (l | 0)) f[g >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(l); n = a + 84 | 0; dl(n); o = a + 64 | 0; dl(o); p = a + 44 | 0; dl(p); q = a + 12 | 0; tj(q); return } function Ve(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3080; jj(a + 200 | 0); b = f[a + 184 >> 2] | 0; if (b | 0) { c = a + 188 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } _i(a + 172 | 0); b = f[a + 152 >> 2] | 0; if (b | 0) { d = a + 156 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 140 >> 2] | 0; if (b | 0) br(b); b = f[a + 128 >> 2] | 0; if (b | 0) { c = b; do { b = c; c = f[c >> 2] | 0; br(b) } while ((c | 0) != 0) } c = a + 120 | 0; b = f[c >> 2] | 0; f[c >> 2] = 0; if (b | 0) br(b); b = f[a + 108 >> 2] | 0; if (b | 0) { c = a + 112 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~(((d + -12 - b | 0) >>> 0) / 12 | 0) * 12 | 0); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) { d = a + 100 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 84 >> 2] | 0; if (b | 0) br(b); b = f[a + 72 >> 2] | 0; if (b | 0) { c = a + 76 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 52 >> 2] | 0; if (b | 0) { d = a + 56 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 40 >> 2] | 0; if (b | 0) { c = a + 44 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 28 >> 2] | 0; if (b | 0) br(b); b = f[a + 16 >> 2] | 0; if (b | 0) { d = a + 20 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = a + 12 | 0; a = f[b >> 2] | 0; f[b >> 2] = 0; if (!a) return; ui(a); br(a); return } function We(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; c = u; u = u + 48 | 0; d = c + 44 | 0; e = c + 40 | 0; g = c + 36 | 0; h = c + 32 | 0; i = c; f[h >> 2] = f[a + 60 >> 2]; j = b + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0)) { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, h, h + 4 | 0) | 0 } rn(i); lk(i); if ((f[h >> 2] | 0) > 0) { k = a + 56 | 0; l = 1; m = 0; do { n = l; l = (f[(f[k >> 2] | 0) + (m >>> 5 << 2) >> 2] & 1 << (m & 31) | 0) != 0; Vi(i, n ^ l ^ 1); m = m + 1 | 0 } while ((m | 0) < (f[h >> 2] | 0)) } fd(i, b); f[g >> 2] = f[a + 12 >> 2]; h = j; m = f[h >> 2] | 0; l = f[h + 4 >> 2] | 0; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { o = l; p = m } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; m = j; o = f[m + 4 >> 2] | 0; p = f[m >> 2] | 0 } f[g >> 2] = f[a + 20 >> 2]; if ((o | 0) > 0 | (o | 0) == 0 & p >>> 0 > 0) { tj(i); u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; tj(i); u = c; return 1 } function Xe(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; d = f[c >> 2] | 0; c = f[d >> 2] | 0; e = f[a + 4 >> 2] | 0; g = f[d + 4 >> 2] | 0; h = e + -1 | 0; i = (h & e | 0) == 0; if (!i) if (g >>> 0 < e >>> 0) j = g; else j = (g >>> 0) % (e >>> 0) | 0; else j = h & g; g = (f[a >> 2] | 0) + (j << 2) | 0; k = f[g >> 2] | 0; while (1) { l = f[k >> 2] | 0; if ((l | 0) == (d | 0)) break; else k = l } if ((k | 0) != (a + 8 | 0)) { l = f[k + 4 >> 2] | 0; if (!i) if (l >>> 0 < e >>> 0) m = l; else m = (l >>> 0) % (e >>> 0) | 0; else m = l & h; if ((m | 0) == (j | 0)) { n = c; o = 21 } else o = 13 } else o = 13; do if ((o | 0) == 13) { if (c | 0) { m = f[c + 4 >> 2] | 0; if (!i) if (m >>> 0 < e >>> 0) p = m; else p = (m >>> 0) % (e >>> 0) | 0; else p = m & h; if ((p | 0) == (j | 0)) { q = c; r = c; o = 22; break } } f[g >> 2] = 0; n = f[d >> 2] | 0; o = 21 } while (0); if ((o | 0) == 21) { g = n; if (!n) s = g; else { q = n; r = g; o = 22 } } if ((o | 0) == 22) { o = f[q + 4 >> 2] | 0; if (!i) if (o >>> 0 < e >>> 0) t = o; else t = (o >>> 0) % (e >>> 0) | 0; else t = o & h; if ((t | 0) == (j | 0)) s = r; else { f[(f[a >> 2] | 0) + (t << 2) >> 2] = k; s = f[d >> 2] | 0 } } f[k >> 2] = s; f[d >> 2] = 0; s = a + 12 | 0; f[s >> 2] = (f[s >> 2] | 0) + -1; if (!d) return c | 0; s = d + 8 | 0; a = f[d + 20 >> 2] | 0; if (a | 0) { k = d + 24 | 0; if ((f[k >> 2] | 0) != (a | 0)) f[k >> 2] = a; br(a) } if ((b[s + 11 >> 0] | 0) < 0) br(f[s >> 2] | 0); br(d); return c | 0 } function Ye(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; f[c >> 2] = 0; e = c + 4 | 0; f[e >> 2] = 0; f[c + 8 >> 2] = 0; g = a + 56 | 0; h = f[g >> 2] | 0; i = (f[h + 100 >> 2] | 0) - (f[h + 96 >> 2] | 0) | 0; j = (i | 0) / 12 | 0; if (!i) { k = 0; l = 0 } else { i = c + 8 | 0; m = 0; n = 0; o = h; h = 0; p = 0; while (1) { q = f[o + 96 >> 2] | 0; r = f[q + (n * 12 | 0) >> 2] | 0; s = r - m | 0; t = ((s | 0) > -1 ? s : 0 - s | 0) << 1 | s >>> 31; f[d >> 2] = t; if ((h | 0) == (p | 0)) { Ci(c, d); v = f[e >> 2] | 0; w = f[i >> 2] | 0 } else { f[h >> 2] = t; t = h + 4 | 0; f[e >> 2] = t; v = t; w = p } t = f[q + (n * 12 | 0) + 4 >> 2] | 0; s = t - r | 0; r = ((s | 0) > -1 ? s : 0 - s | 0) << 1 | s >>> 31; f[d >> 2] = r; if ((v | 0) == (w | 0)) { Ci(c, d); x = f[e >> 2] | 0; y = f[i >> 2] | 0 } else { f[v >> 2] = r; r = v + 4 | 0; f[e >> 2] = r; x = r; y = w } r = f[q + (n * 12 | 0) + 8 >> 2] | 0; q = r - t | 0; t = ((q | 0) > -1 ? q : 0 - q | 0) << 1 | q >>> 31; f[d >> 2] = t; if ((x | 0) == (y | 0)) Ci(c, d); else { f[x >> 2] = t; f[e >> 2] = x + 4 } t = n + 1 | 0; if (t >>> 0 >= j >>> 0) break; m = r; n = t; o = f[g >> 2] | 0; h = f[e >> 2] | 0; p = f[i >> 2] | 0 } k = f[c >> 2] | 0; l = f[e >> 2] | 0 } Dc(k, l - k >> 2, 1, 0, f[a + 44 >> 2] | 0) | 0; a = f[c >> 2] | 0; if (!a) { u = b; return 1 } c = f[e >> 2] | 0; if ((c | 0) != (a | 0)) f[e >> 2] = c + (~((c + -4 - a | 0) >>> 2) << 2); br(a); u = b; return 1 } function Ze(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = f[a + 12 >> 2] | 0; e = a + 108 | 0; g = f[e >> 2] | 0; h = f[g + 80 >> 2] | 0; b[c + 84 >> 0] = 0; i = c + 68 | 0; j = c + 72 | 0; k = f[j >> 2] | 0; l = f[i >> 2] | 0; m = k - l >> 2; n = l; l = k; if (h >>> 0 <= m >>> 0) if (h >>> 0 < m >>> 0 ? (k = n + (h << 2) | 0, (k | 0) != (l | 0)) : 0) { f[j >> 2] = l + (~((l + -4 - k | 0) >>> 2) << 2); o = g; p = h } else { o = g; p = h } else { kh(i, h - m | 0, 3220); m = f[e >> 2] | 0; o = m; p = f[m + 80 >> 2] | 0 } m = (f[o + 100 >> 2] | 0) - (f[o + 96 >> 2] | 0) | 0; e = (m | 0) / 12 | 0; if (!m) { q = 1; return q | 0 } m = a + 112 | 0; a = c + 68 | 0; c = f[o + 96 >> 2] | 0; o = 0; while (1) { h = o * 3 | 0; if ((h | 0) == -1) { q = 0; r = 12; break } i = f[d >> 2] | 0; g = f[i + (h << 2) >> 2] | 0; if ((g | 0) == -1) { q = 0; r = 12; break } k = f[(f[m >> 2] | 0) + 12 >> 2] | 0; l = f[k + (g << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } g = f[a >> 2] | 0; f[g + (f[c + (o * 12 | 0) >> 2] << 2) >> 2] = l; l = h + 1 | 0; if ((l | 0) == -1) { q = 0; r = 12; break } j = f[i + (l << 2) >> 2] | 0; if ((j | 0) == -1) { q = 0; r = 12; break } l = f[k + (j << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } f[g + (f[c + (o * 12 | 0) + 4 >> 2] << 2) >> 2] = l; l = h + 2 | 0; if ((l | 0) == -1) { q = 0; r = 12; break } h = f[i + (l << 2) >> 2] | 0; if ((h | 0) == -1) { q = 0; r = 12; break } l = f[k + (h << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } f[g + (f[c + (o * 12 | 0) + 8 >> 2] << 2) >> 2] = l; o = o + 1 | 0; if (o >>> 0 >= e >>> 0) { q = 1; r = 12; break } } if ((r | 0) == 12) return q | 0; return 0 } function _e(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; c = u; u = u + 48 | 0; d = c + 44 | 0; e = c + 40 | 0; g = c + 36 | 0; h = c + 32 | 0; i = c; f[h >> 2] = f[a + 80 >> 2]; j = b + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0)) { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, h, h + 4 | 0) | 0 } rn(i); lk(i); if ((f[h >> 2] | 0) > 0) { k = a + 76 | 0; l = 1; m = 0; do { n = l; l = (f[(f[k >> 2] | 0) + (m >>> 5 << 2) >> 2] & 1 << (m & 31) | 0) != 0; Vi(i, n ^ l ^ 1); m = m + 1 | 0 } while ((m | 0) < (f[h >> 2] | 0)) } fd(i, b); f[g >> 2] = f[a + 12 >> 2]; h = j; m = f[h >> 2] | 0; l = f[h + 4 >> 2] | 0; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { o = l; p = m } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; m = j; o = f[m + 4 >> 2] | 0; p = f[m >> 2] | 0 } f[g >> 2] = f[a + 16 >> 2]; if ((o | 0) > 0 | (o | 0) == 0 & p >>> 0 > 0) { tj(i); u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; tj(i); u = c; return 1 } function $e(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; e = a + 8 | 0; g = a + 12 | 0; h = f[g >> 2] | 0; $j(f[a + 4 >> 2] | 0, (f[h + 28 >> 2] | 0) - (f[h + 24 >> 2] | 0) >> 2); h = a + 96 | 0; i = f[g >> 2] | 0; j = (f[i + 28 >> 2] | 0) - (f[i + 24 >> 2] | 0) >> 2; f[c >> 2] = 0; i = a + 100 | 0; k = f[i >> 2] | 0; l = f[h >> 2] | 0; m = k - l >> 2; n = l; l = k; if (j >>> 0 <= m >>> 0) { if (j >>> 0 < m >>> 0 ? (k = n + (j << 2) | 0, (k | 0) != (l | 0)) : 0) f[i >> 2] = l + (~((l + -4 - k | 0) >>> 2) << 2) } else kh(h, j - m | 0, c); m = a + 116 | 0; a = f[m >> 2] | 0; if (!a) { j = f[g >> 2] | 0; g = (f[j + 4 >> 2] | 0) - (f[j >> 2] | 0) >> 2; j = (g >>> 0) / 3 | 0; if (g >>> 0 <= 2) { o = 1; u = b; return o | 0 } g = 0; while (1) { f[d >> 2] = g * 3; f[c >> 2] = f[d >> 2]; g = g + 1 | 0; if (!(vb(e, c) | 0)) { o = 0; p = 15; break } if ((g | 0) >= (j | 0)) { o = 1; p = 15; break } } if ((p | 0) == 15) { u = b; return o | 0 } } else { j = f[a >> 2] | 0; if ((f[a + 4 >> 2] | 0) == (j | 0)) { o = 1; u = b; return o | 0 } a = 0; g = j; while (1) { f[d >> 2] = f[g + (a << 2) >> 2]; f[c >> 2] = f[d >> 2]; a = a + 1 | 0; if (!(vb(e, c) | 0)) { o = 0; p = 15; break } j = f[m >> 2] | 0; g = f[j >> 2] | 0; if (a >>> 0 >= (f[j + 4 >> 2] | 0) - g >> 2 >>> 0) { o = 1; p = 15; break } } if ((p | 0) == 15) { u = b; return o | 0 } } return 0 } function af(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = f[a + 12 >> 2] | 0; e = a + 68 | 0; g = f[e >> 2] | 0; h = f[g + 80 >> 2] | 0; b[c + 84 >> 0] = 0; i = c + 68 | 0; j = c + 72 | 0; k = f[j >> 2] | 0; l = f[i >> 2] | 0; m = k - l >> 2; n = l; l = k; if (h >>> 0 <= m >>> 0) if (h >>> 0 < m >>> 0 ? (k = n + (h << 2) | 0, (k | 0) != (l | 0)) : 0) { f[j >> 2] = l + (~((l + -4 - k | 0) >>> 2) << 2); o = g; p = h } else { o = g; p = h } else { kh(i, h - m | 0, 3220); m = f[e >> 2] | 0; o = m; p = f[m + 80 >> 2] | 0 } m = (f[o + 100 >> 2] | 0) - (f[o + 96 >> 2] | 0) | 0; e = (m | 0) / 12 | 0; if (!m) { q = 1; return q | 0 } m = a + 72 | 0; a = c + 68 | 0; c = f[o + 96 >> 2] | 0; o = 0; while (1) { h = o * 3 | 0; if ((h | 0) == -1) { q = 0; r = 12; break } i = f[d >> 2] | 0; g = f[i + (h << 2) >> 2] | 0; if ((g | 0) == -1) { q = 0; r = 12; break } k = f[(f[m >> 2] | 0) + 12 >> 2] | 0; l = f[k + (g << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } g = f[a >> 2] | 0; f[g + (f[c + (o * 12 | 0) >> 2] << 2) >> 2] = l; l = h + 1 | 0; if ((l | 0) == -1) { q = 0; r = 12; break } j = f[i + (l << 2) >> 2] | 0; if ((j | 0) == -1) { q = 0; r = 12; break } l = f[k + (j << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } f[g + (f[c + (o * 12 | 0) + 4 >> 2] << 2) >> 2] = l; l = h + 2 | 0; if ((l | 0) == -1) { q = 0; r = 12; break } h = f[i + (l << 2) >> 2] | 0; if ((h | 0) == -1) { q = 0; r = 12; break } l = f[k + (h << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 12; break } f[g + (f[c + (o * 12 | 0) + 8 >> 2] << 2) >> 2] = l; o = o + 1 | 0; if (o >>> 0 >= e >>> 0) { q = 1; r = 12; break } } if ((r | 0) == 12) return q | 0; return 0 } function bf(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; c = u; u = u + 16 | 0; d = c + 12 | 0; e = c + 8 | 0; g = c + 4 | 0; h = c; if (!b) { i = dn(76) | 0; j = dn(12) | 0; k = f[(f[a + 4 >> 2] | 0) + 80 >> 2] | 0; f[j + 4 >> 2] = 0; f[j >> 2] = 3584; f[j + 8 >> 2] = k; f[h >> 2] = j; ml(i, h, 0); j = i; f[g >> 2] = j; i = a + 12 | 0; k = f[i >> 2] | 0; if (k >>> 0 < (f[a + 16 >> 2] | 0) >>> 0) { f[g >> 2] = 0; f[k >> 2] = j; f[i >> 2] = k + 4; l = g } else { yg(a + 8 | 0, g); l = g } g = f[l >> 2] | 0; f[l >> 2] = 0; if (g | 0) Va[f[(f[g >> 2] | 0) + 4 >> 2] & 127](g); g = f[h >> 2] | 0; f[h >> 2] = 0; if (!g) { u = c; return 1 } Va[f[(f[g >> 2] | 0) + 4 >> 2] & 127](g); u = c; return 1 } g = f[f[a + 8 >> 2] >> 2] | 0; f[d >> 2] = b; a = g + 4 | 0; h = g + 8 | 0; l = f[h >> 2] | 0; if ((l | 0) == (f[g + 12 >> 2] | 0)) Ci(a, d); else { f[l >> 2] = b; f[h >> 2] = l + 4 } l = f[d >> 2] | 0; b = g + 16 | 0; k = g + 20 | 0; g = f[k >> 2] | 0; i = f[b >> 2] | 0; j = g - i >> 2; m = i; if ((l | 0) < (j | 0)) { n = m; o = l } else { i = l + 1 | 0; f[e >> 2] = -1; p = g; if (i >>> 0 <= j >>> 0) if (i >>> 0 < j >>> 0 ? (g = m + (i << 2) | 0, (g | 0) != (p | 0)) : 0) { f[k >> 2] = p + (~((p + -4 - g | 0) >>> 2) << 2); q = l; r = m } else { q = l; r = m } else { kh(b, i - j | 0, e); q = f[d >> 2] | 0; r = f[b >> 2] | 0 } n = r; o = q } f[n + (o << 2) >> 2] = ((f[h >> 2] | 0) - (f[a >> 2] | 0) >> 2) + -1; u = c; return 1 } function cf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = f[a >> 2] | 0; h = g; do if (e - g >> 3 >>> 0 >= b >>> 0) { i = a + 4 | 0; j = f[i >> 2] | 0; k = j - g >> 3; l = k >>> 0 < b >>> 0; m = l ? k : b; n = j; if (m | 0) { j = m; m = h; while (1) { o = c; p = f[o + 4 >> 2] | 0; q = m; f[q >> 2] = f[o >> 2]; f[q + 4 >> 2] = p; j = j + -1 | 0; if (!j) break; else m = m + 8 | 0 } } if (!l) { m = h + (b << 3) | 0; if ((m | 0) == (n | 0)) return; else { r = i; s = n + (~((n + -8 - m | 0) >>> 3) << 3) | 0; break } } else { m = b - k | 0; j = m; p = n; while (1) { q = c; o = f[q + 4 >> 2] | 0; t = p; f[t >> 2] = f[q >> 2]; f[t + 4 >> 2] = o; j = j + -1 | 0; if (!j) break; else p = p + 8 | 0 } r = i; s = n + (m << 3) | 0; break } } else { p = g; if (!g) u = e; else { j = a + 4 | 0; k = f[j >> 2] | 0; if ((k | 0) != (h | 0)) f[j >> 2] = k + (~((k + -8 - g | 0) >>> 3) << 3); br(p); f[d >> 2] = 0; f[j >> 2] = 0; f[a >> 2] = 0; u = 0 } if (b >>> 0 > 536870911) mq(a); j = u >> 2; p = u >> 3 >>> 0 < 268435455 ? (j >>> 0 < b >>> 0 ? b : j) : 536870911; if (p >>> 0 > 536870911) mq(a); j = dn(p << 3) | 0; k = a + 4 | 0; f[k >> 2] = j; f[a >> 2] = j; f[d >> 2] = j + (p << 3); p = b; l = j; while (1) { o = c; t = f[o + 4 >> 2] | 0; q = l; f[q >> 2] = f[o >> 2]; f[q + 4 >> 2] = t; p = p + -1 | 0; if (!p) break; else l = l + 8 | 0 } r = k; s = j + (b << 3) | 0 } while (0); f[r >> 2] = s; return } function df(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0.0, g = 0.0, h = 0.0, i = 0.0, j = 0.0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0; e = +$(n[b >> 2]); g = +K(+e); h = +$(n[b + 4 >> 2]); i = g + +K(+h); g = +$(n[b + 8 >> 2]); j = i + +K(+g); b = j > 1.0e-06; i = 1.0 / j; k = f[a + 12 >> 2] | 0; j = +(k | 0); l = ~~+J(+((b ? i * e : 1.0) * j + .5)); m = ~~+J(+((b ? i * h : 0.0) * j + .5)); o = (l | 0) > -1; p = k - (o ? l : 0 - l | 0) - ((m | 0) > -1 ? m : 0 - m | 0) | 0; l = (p | 0) < 0; q = (l ? ((m | 0) > 0 ? p : 0 - p | 0) : 0) + m | 0; m = l ? 0 : p; p = (b ? i * g : 0.0) < 0.0 ? 0 - m | 0 : m; do if (!o) { if ((q | 0) < 0) r = (p | 0) > -1 ? p : 0 - p | 0; else r = (f[a + 8 >> 2] | 0) - ((p | 0) > -1 ? p : 0 - p | 0) | 0; if ((p | 0) < 0) { s = (q | 0) > -1 ? q : 0 - q | 0; t = r; break } else { s = (f[a + 8 >> 2] | 0) - ((q | 0) > -1 ? q : 0 - q | 0) | 0; t = r; break } } else { s = k + p | 0; t = k + q | 0 } while (0); q = (t | 0) == 0; p = (s | 0) == 0; r = f[a + 8 >> 2] | 0; if (!(s | t)) { u = r; v = r; f[c >> 2] = u; f[d >> 2] = v; return } a = (r | 0) == (s | 0); if (q & a) { u = s; v = s; f[c >> 2] = u; f[d >> 2] = v; return } o = (r | 0) == (t | 0); if (p & o) { u = t; v = t; f[c >> 2] = u; f[d >> 2] = v; return } if (q & (k | 0) < (s | 0)) { u = 0; v = (k << 1) - s | 0; f[c >> 2] = u; f[d >> 2] = v; return } if (o & (k | 0) > (s | 0)) { u = t; v = (k << 1) - s | 0; f[c >> 2] = u; f[d >> 2] = v; return } if (a & (k | 0) > (t | 0)) { u = (k << 1) - t | 0; v = s; f[c >> 2] = u; f[d >> 2] = v; return } if (!p) { u = t; v = s; f[c >> 2] = u; f[d >> 2] = v; return } u = (k | 0) < (t | 0) ? (k << 1) - t | 0 : t; v = 0; f[c >> 2] = u; f[d >> 2] = v; return } function ef(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; c = a + 4 | 0; d = b + 4 | 0; f[c >> 2] = f[d >> 2]; f[c + 4 >> 2] = f[d + 4 >> 2]; f[c + 8 >> 2] = f[d + 8 >> 2]; f[c + 12 >> 2] = f[d + 12 >> 2]; f[c + 16 >> 2] = f[d + 16 >> 2]; d = a + 24 | 0; c = b + 24 | 0; if ((a | 0) == (b | 0)) return a | 0; e = b + 28 | 0; g = f[e >> 2] | 0; if (!g) h = 0; else { i = a + 32 | 0; do if (g >>> 0 > f[i >> 2] << 5 >>> 0) { j = f[d >> 2] | 0; if (!j) k = g; else { br(j); f[d >> 2] = 0; f[i >> 2] = 0; f[a + 28 >> 2] = 0; k = f[e >> 2] | 0 } if ((k | 0) < 0) mq(d); else { j = ((k + -1 | 0) >>> 5) + 1 | 0; l = dn(j << 2) | 0; f[d >> 2] = l; f[a + 28 >> 2] = 0; f[i >> 2] = j; m = f[e >> 2] | 0; n = l; break } } else { m = g; n = f[d >> 2] | 0 } while (0); Xl(n | 0, f[c >> 2] | 0, ((m + -1 | 0) >>> 5 << 2) + 4 | 0) | 0; h = f[e >> 2] | 0 } f[a + 28 >> 2] = h; h = a + 36 | 0; e = b + 36 | 0; m = b + 40 | 0; b = f[m >> 2] | 0; if (!b) o = 0; else { c = a + 44 | 0; do if (b >>> 0 > f[c >> 2] << 5 >>> 0) { n = f[h >> 2] | 0; if (!n) p = b; else { br(n); f[h >> 2] = 0; f[c >> 2] = 0; f[a + 40 >> 2] = 0; p = f[m >> 2] | 0 } if ((p | 0) < 0) mq(h); else { n = ((p + -1 | 0) >>> 5) + 1 | 0; d = dn(n << 2) | 0; f[h >> 2] = d; f[a + 40 >> 2] = 0; f[c >> 2] = n; q = f[m >> 2] | 0; r = d; break } } else { q = b; r = f[h >> 2] | 0 } while (0); Xl(r | 0, f[e >> 2] | 0, ((q + -1 | 0) >>> 5 << 2) + 4 | 0) | 0; o = f[m >> 2] | 0 } f[a + 40 >> 2] = o; return a | 0 } function ff(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = u; u = u + 32 | 0; h = g + 12 | 0; i = g; f[a >> 2] = f[d >> 2]; d = a + 4 | 0; f[d >> 2] = (f[c >> 2] | 0) - (f[b >> 2] | 0); j = e + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) ? (k = e + 4 | 0, f[i >> 2] = f[k >> 2], f[h >> 2] = f[i >> 2], ye(e, h, a, a + 4 | 0) | 0, l = j, j = f[l + 4 >> 2] | 0, !((j | 0) > 0 | (j | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0)) : 0) { f[i >> 2] = f[k >> 2]; f[h >> 2] = f[i >> 2]; ye(e, h, d, d + 4 | 0) | 0; m = i } else m = i; if (!(f[d >> 2] | 0)) { u = g; return 1 } d = a + 12 | 0; og(d); m = a + 1068 | 0; Cm(m); k = a + 1088 | 0; Cm(k); l = a + 1108 | 0; Cm(l); f[i >> 2] = f[b >> 2]; f[i + 4 >> 2] = f[b + 4 >> 2]; f[i + 8 >> 2] = f[b + 8 >> 2]; f[h >> 2] = f[c >> 2]; f[h + 4 >> 2] = f[c + 4 >> 2]; f[h + 8 >> 2] = f[c + 8 >> 2]; jb(a, i, h); Ke(d, e); mg(m, e); mg(k, e); mg(l, e); u = g; return 1 } function gf(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = u; u = u + 32 | 0; h = g + 12 | 0; i = g; f[a >> 2] = f[d >> 2]; d = a + 4 | 0; f[d >> 2] = (f[c >> 2] | 0) - (f[b >> 2] | 0); j = e + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) ? (k = e + 4 | 0, f[i >> 2] = f[k >> 2], f[h >> 2] = f[i >> 2], ye(e, h, a, a + 4 | 0) | 0, l = j, j = f[l + 4 >> 2] | 0, !((j | 0) > 0 | (j | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0)) : 0) { f[i >> 2] = f[k >> 2]; f[h >> 2] = f[i >> 2]; ye(e, h, d, d + 4 | 0) | 0; m = i } else m = i; if (!(f[d >> 2] | 0)) { u = g; return 1 } d = a + 12 | 0; og(d); m = a + 1068 | 0; Cm(m); k = a + 1088 | 0; Cm(k); l = a + 1108 | 0; Cm(l); f[i >> 2] = f[b >> 2]; f[i + 4 >> 2] = f[b + 4 >> 2]; f[i + 8 >> 2] = f[b + 8 >> 2]; f[h >> 2] = f[c >> 2]; f[h + 4 >> 2] = f[c + 4 >> 2]; f[h + 8 >> 2] = f[c + 8 >> 2]; mb(a, i, h); Ke(d, e); mg(m, e); mg(k, e); mg(l, e); u = g; return 1 } function hf(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; c = u; u = u + 32 | 0; d = c; e = a + 8 | 0; g = f[e >> 2] | 0; h = a + 4 | 0; i = f[h >> 2] | 0; j = i; if (g - i >> 2 >>> 0 >= b >>> 0) { hj(i | 0, 0, b << 2 | 0) | 0; f[h >> 2] = i + (b << 2); u = c; return } k = f[a >> 2] | 0; l = i - k >> 2; m = l + b | 0; n = k; if (m >>> 0 > 1073741823) mq(a); o = g - k | 0; p = o >> 1; q = o >> 2 >>> 0 < 536870911 ? (p >>> 0 < m >>> 0 ? m : p) : 1073741823; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = a + 8; do if (q) if (q >>> 0 > 1073741823) { p = ra(8) | 0; Wo(p, 14941); f[p >> 2] = 6944; va(p | 0, 1080, 114) } else { r = dn(q << 2) | 0; break } else r = 0; while (0); f[d >> 2] = r; p = r + (l << 2) | 0; l = d + 8 | 0; m = d + 4 | 0; f[m >> 2] = p; o = r + (q << 2) | 0; q = d + 12 | 0; f[q >> 2] = o; r = p + (b << 2) | 0; hj(p | 0, 0, b << 2 | 0) | 0; f[l >> 2] = r; if ((j | 0) == (n | 0)) { s = p; t = q; v = l; w = k; x = r; y = i; z = o; A = g } else { g = j; j = p; do { g = g + -4 | 0; p = f[g >> 2] | 0; f[g >> 2] = 0; f[j + -4 >> 2] = p; j = (f[m >> 2] | 0) + -4 | 0; f[m >> 2] = j } while ((g | 0) != (n | 0)); s = j; t = q; v = l; w = f[a >> 2] | 0; x = f[l >> 2] | 0; y = f[h >> 2] | 0; z = f[q >> 2] | 0; A = f[e >> 2] | 0 } f[a >> 2] = s; f[m >> 2] = w; f[h >> 2] = x; f[v >> 2] = y; f[e >> 2] = z; f[t >> 2] = A; f[d >> 2] = w; Wh(d); u = c; return } function jf(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; d = u; u = u + 16 | 0; h = d; i = f[a + 124 >> 2] | 0; if (!i) { u = d; return } j = i + -1 | 0; k = (j & i | 0) == 0; if (!k) if (i >>> 0 > g >>> 0) l = g; else l = (g >>> 0) % (i >>> 0) | 0; else l = j & g; m = f[(f[a + 120 >> 2] | 0) + (l << 2) >> 2] | 0; if (!m) { u = d; return } n = f[m >> 2] | 0; if (!n) { u = d; return } a: do if (k) { m = n; while (1) { o = f[m + 4 >> 2] | 0; p = (o | 0) == (g | 0); if (!(p | (o & j | 0) == (l | 0))) { q = 24; break } if (p ? (f[m + 8 >> 2] | 0) == (g | 0) : 0) { r = m; break a } m = f[m >> 2] | 0; if (!m) { q = 24; break } } if ((q | 0) == 24) { u = d; return } } else { m = n; while (1) { p = f[m + 4 >> 2] | 0; if ((p | 0) == (g | 0)) { if ((f[m + 8 >> 2] | 0) == (g | 0)) { r = m; break a } } else { if (p >>> 0 < i >>> 0) s = p; else s = (p >>> 0) % (i >>> 0) | 0; if ((s | 0) != (l | 0)) { q = 24; break } } m = f[m >> 2] | 0; if (!m) { q = 24; break } } if ((q | 0) == 24) { u = d; return } } while (0); q = f[r + 12 >> 2] | 0; if ((q | 0) == -1) { u = d; return } f[h >> 2] = q; f[h + 4 >> 2] = c; b[h + 8 >> 0] = e & 1; e = a + 112 | 0; c = f[e >> 2] | 0; if ((c | 0) == (f[a + 116 >> 2] | 0)) ki(a + 108 | 0, h); else { f[c >> 2] = f[h >> 2]; f[c + 4 >> 2] = f[h + 4 >> 2]; f[c + 8 >> 2] = f[h + 8 >> 2]; f[e >> 2] = (f[e >> 2] | 0) + 12 } u = d; return } function kf(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; c = d[b >> 1] | 0; e = d[b + 2 >> 1] | 0; g = d[b + 4 >> 1] | 0; h = d[b + 6 >> 1] | 0; b = ((((c ^ 318) & 65535) + 239 ^ e & 65535) + 239 ^ g & 65535) + 239 ^ h & 65535; i = f[a + 4 >> 2] | 0; if (!i) { j = 0; return j | 0 } k = i + -1 | 0; l = (k & i | 0) == 0; if (!l) if (b >>> 0 < i >>> 0) m = b; else m = (b >>> 0) % (i >>> 0) | 0; else m = b & k; n = f[(f[a >> 2] | 0) + (m << 2) >> 2] | 0; if (!n) { j = 0; return j | 0 } a = f[n >> 2] | 0; if (!a) { j = 0; return j | 0 } if (l) { l = a; while (1) { n = f[l + 4 >> 2] | 0; o = (n | 0) == (b | 0); if (!(o | (n & k | 0) == (m | 0))) { j = 0; p = 25; break } if ((((o ? (o = l + 8 | 0, (d[o >> 1] | 0) == c << 16 >> 16) : 0) ? (d[o + 2 >> 1] | 0) == e << 16 >> 16 : 0) ? (d[l + 12 >> 1] | 0) == g << 16 >> 16 : 0) ? (d[o + 6 >> 1] | 0) == h << 16 >> 16 : 0) { j = l; p = 25; break } l = f[l >> 2] | 0; if (!l) { j = 0; p = 25; break } } if ((p | 0) == 25) return j | 0 } else q = a; while (1) { a = f[q + 4 >> 2] | 0; if ((a | 0) == (b | 0)) { l = q + 8 | 0; if ((((d[l >> 1] | 0) == c << 16 >> 16 ? (d[l + 2 >> 1] | 0) == e << 16 >> 16 : 0) ? (d[q + 12 >> 1] | 0) == g << 16 >> 16 : 0) ? (d[l + 6 >> 1] | 0) == h << 16 >> 16 : 0) { j = q; p = 25; break } } else { if (a >>> 0 < i >>> 0) r = a; else r = (a >>> 0) % (i >>> 0) | 0; if ((r | 0) != (m | 0)) { j = 0; p = 25; break } } q = f[q >> 2] | 0; if (!q) { j = 0; p = 25; break } } if ((p | 0) == 25) return j | 0; return 0 } function lf(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = u; u = u + 32 | 0; h = g + 12 | 0; i = g; f[a >> 2] = f[d >> 2]; d = a + 4 | 0; f[d >> 2] = (f[c >> 2] | 0) - (f[b >> 2] | 0); j = e + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) ? (k = e + 4 | 0, f[i >> 2] = f[k >> 2], f[h >> 2] = f[i >> 2], ye(e, h, a, a + 4 | 0) | 0, l = j, j = f[l + 4 >> 2] | 0, !((j | 0) > 0 | (j | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0)) : 0) { f[i >> 2] = f[k >> 2]; f[h >> 2] = f[i >> 2]; ye(e, h, d, d + 4 | 0) | 0; m = i } else m = i; if (!(f[d >> 2] | 0)) { u = g; return 1 } d = a + 12 | 0; Cm(d); m = a + 32 | 0; Cm(m); k = a + 52 | 0; Cm(k); l = a + 72 | 0; Cm(l); f[i >> 2] = f[b >> 2]; f[i + 4 >> 2] = f[b + 4 >> 2]; f[i + 8 >> 2] = f[b + 8 >> 2]; f[h >> 2] = f[c >> 2]; f[h + 4 >> 2] = f[c + 4 >> 2]; f[h + 8 >> 2] = f[c + 8 >> 2]; hb(a, i, h); mg(d, e); mg(m, e); mg(k, e); mg(l, e); u = g; return 1 } function mf(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = u; u = u + 32 | 0; h = g + 12 | 0; i = g; f[a >> 2] = f[d >> 2]; d = a + 4 | 0; f[d >> 2] = (f[c >> 2] | 0) - (f[b >> 2] | 0); j = e + 16 | 0; k = j; l = f[k + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) ? (k = e + 4 | 0, f[i >> 2] = f[k >> 2], f[h >> 2] = f[i >> 2], ye(e, h, a, a + 4 | 0) | 0, l = j, j = f[l + 4 >> 2] | 0, !((j | 0) > 0 | (j | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0)) : 0) { f[i >> 2] = f[k >> 2]; f[h >> 2] = f[i >> 2]; ye(e, h, d, d + 4 | 0) | 0; m = i } else m = i; if (!(f[d >> 2] | 0)) { u = g; return 1 } d = a + 12 | 0; lk(d); m = a + 44 | 0; Cm(m); k = a + 64 | 0; Cm(k); l = a + 84 | 0; Cm(l); f[i >> 2] = f[b >> 2]; f[i + 4 >> 2] = f[b + 4 >> 2]; f[i + 8 >> 2] = f[b + 8 >> 2]; f[h >> 2] = f[c >> 2]; f[h + 4 >> 2] = f[c + 4 >> 2]; f[h + 8 >> 2] = f[c + 8 >> 2]; nb(a, i, h); fd(d, e); mg(m, e); mg(k, e); mg(l, e); u = g; return 1 } function nf(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0; a = u; u = u + 16 | 0; e = a + 4 | 0; g = a; h = a + 8 | 0; i = d + 11 | 0; j = b[i >> 0] | 0; k = j << 24 >> 24 < 0; if (k) { l = f[d + 4 >> 2] | 0; if (l >>> 0 > 255) { m = 0; u = a; return m | 0 } else n = l } else n = j & 255; if (!n) { b[h >> 0] = 0; n = c + 16 | 0; l = f[n + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0 } m = 1; u = a; return m | 0 } n = d + 4 | 0; l = f[n >> 2] | 0; b[h >> 0] = k ? l : j & 255; k = c + 16 | 0; o = k; p = f[o >> 2] | 0; q = f[o + 4 >> 2] | 0; if ((q | 0) > 0 | (q | 0) == 0 & p >>> 0 > 0) { r = j; s = q; t = p; v = l } else { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0; h = k; r = b[i >> 0] | 0; s = f[h + 4 >> 2] | 0; t = f[h >> 2] | 0; v = f[n >> 2] | 0 } n = r << 24 >> 24 < 0; h = n ? f[d >> 2] | 0 : d; if (!((s | 0) > 0 | (s | 0) == 0 & t >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + (n ? v : r & 255) | 0) | 0 } m = 1; u = a; return m | 0 } function of(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = ((f[c >> 2] | 0) - d | 0) / 24 | 0; g = e + 1 | 0; if (g >>> 0 > 178956970) mq(a); h = a + 8 | 0; i = ((f[h >> 2] | 0) - d | 0) / 24 | 0; d = i << 1; j = i >>> 0 < 89478485 ? (d >>> 0 < g >>> 0 ? g : d) : 178956970; do if (j) if (j >>> 0 > 178956970) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { k = dn(j * 24 | 0) | 0; break } else k = 0; while (0); d = k + (e * 24 | 0) | 0; g = d; i = k + (j * 24 | 0) | 0; f[d >> 2] = 1180; f[k + (e * 24 | 0) + 4 >> 2] = f[b + 4 >> 2]; _j(k + (e * 24 | 0) + 8 | 0, b + 8 | 0); f[k + (e * 24 | 0) + 20 >> 2] = f[b + 20 >> 2]; b = d + 24 | 0; e = f[a >> 2] | 0; k = f[c >> 2] | 0; if ((k | 0) == (e | 0)) { l = g; m = e; n = e } else { j = k; k = g; g = d; do { f[g + -24 >> 2] = 1180; f[g + -20 >> 2] = f[j + -20 >> 2]; d = g + -16 | 0; o = j + -16 | 0; f[d >> 2] = 0; p = g + -12 | 0; f[p >> 2] = 0; f[g + -8 >> 2] = 0; f[d >> 2] = f[o >> 2]; d = j + -12 | 0; f[p >> 2] = f[d >> 2]; p = j + -8 | 0; f[g + -8 >> 2] = f[p >> 2]; f[p >> 2] = 0; f[d >> 2] = 0; f[o >> 2] = 0; f[g + -4 >> 2] = f[j + -4 >> 2]; j = j + -24 | 0; g = k + -24 | 0; k = g } while ((j | 0) != (e | 0)); l = k; m = f[a >> 2] | 0; n = f[c >> 2] | 0 } f[a >> 2] = l; f[c >> 2] = b; f[h >> 2] = i; i = m; if ((n | 0) != (i | 0)) { h = n; do { h = h + -24 | 0; Va[f[f[h >> 2] >> 2] & 127](h) } while ((h | 0) != (i | 0)) } if (!m) return; br(m); return } function pf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = b[c >> 0] | 0; e = b[c + 1 >> 0] | 0; g = b[c + 2 >> 0] | 0; h = b[c + 3 >> 0] | 0; c = (((d & 255 ^ 318) + 239 ^ e & 255) + 239 ^ g & 255) + 239 ^ h & 255; i = f[a + 4 >> 2] | 0; if (!i) { j = 0; return j | 0 } k = i + -1 | 0; l = (k & i | 0) == 0; if (!l) if (c >>> 0 < i >>> 0) m = c; else m = (c >>> 0) % (i >>> 0) | 0; else m = c & k; n = f[(f[a >> 2] | 0) + (m << 2) >> 2] | 0; if (!n) { j = 0; return j | 0 } a = f[n >> 2] | 0; if (!a) { j = 0; return j | 0 } if (l) { l = a; while (1) { n = f[l + 4 >> 2] | 0; o = (n | 0) == (c | 0); if (!(o | (n & k | 0) == (m | 0))) { j = 0; p = 25; break } if ((((o ? (o = l + 8 | 0, (b[o >> 0] | 0) == d << 24 >> 24) : 0) ? (b[o + 1 >> 0] | 0) == e << 24 >> 24 : 0) ? (b[o + 2 >> 0] | 0) == g << 24 >> 24 : 0) ? (b[o + 3 >> 0] | 0) == h << 24 >> 24 : 0) { j = l; p = 25; break } l = f[l >> 2] | 0; if (!l) { j = 0; p = 25; break } } if ((p | 0) == 25) return j | 0 } else q = a; while (1) { a = f[q + 4 >> 2] | 0; if ((a | 0) == (c | 0)) { l = q + 8 | 0; if ((((b[l >> 0] | 0) == d << 24 >> 24 ? (b[l + 1 >> 0] | 0) == e << 24 >> 24 : 0) ? (b[l + 2 >> 0] | 0) == g << 24 >> 24 : 0) ? (b[l + 3 >> 0] | 0) == h << 24 >> 24 : 0) { j = q; p = 25; break } } else { if (a >>> 0 < i >>> 0) r = a; else r = (a >>> 0) % (i >>> 0) | 0; if ((r | 0) != (m | 0)) { j = 0; p = 25; break } } q = f[q >> 2] | 0; if (!q) { j = 0; p = 25; break } } if ((p | 0) == 25) return j | 0; return 0 } function qf(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; d = u; u = u + 32 | 0; h = d + 24 | 0; i = d + 16 | 0; j = d; k = d + 8 | 0; l = a + 40 | 0; f[a + 44 >> 2] = g; g = a + 36 | 0; m = f[g >> 2] | 0; n = f[m + 4 >> 2] | 0; o = f[m >> 2] | 0; p = n - o | 0; if ((p | 0) <= 0) { u = d; return 1 } q = (p >>> 2) + -1 | 0; p = a + 8 | 0; r = a + 48 | 0; s = a + 52 | 0; a = i + 4 | 0; t = j + 4 | 0; v = h + 4 | 0; if (n - o >> 2 >>> 0 > q >>> 0) { w = q; x = o } else { y = m; mq(y) } while (1) { f[k >> 2] = f[x + (w << 2) >> 2]; f[h >> 2] = f[k >> 2]; tb(l, h, b, w) | 0; m = X(w, e) | 0; o = b + (m << 2) | 0; q = c + (m << 2) | 0; m = f[o + 4 >> 2] | 0; n = f[r >> 2] | 0; z = f[s >> 2] | 0; f[i >> 2] = f[o >> 2]; f[a >> 2] = m; f[j >> 2] = n; f[t >> 2] = z; Dd(h, p, i, j); f[q >> 2] = f[h >> 2]; f[q + 4 >> 2] = f[v >> 2]; w = w + -1 | 0; if ((w | 0) <= -1) { A = 3; break } q = f[g >> 2] | 0; x = f[q >> 2] | 0; if ((f[q + 4 >> 2] | 0) - x >> 2 >>> 0 <= w >>> 0) { y = q; A = 4; break } } if ((A | 0) == 3) { u = d; return 1 } else if ((A | 0) == 4) mq(y); return 0 } function rf(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; h = u; u = u + 32 | 0; i = h; j = h + 16 | 0; k = f[(f[(f[b + 4 >> 2] | 0) + 8 >> 2] | 0) + (d << 2) >> 2] | 0; do if ((c + -1 | 0) >>> 0 < 6 & (Qa[f[(f[b >> 2] | 0) + 8 >> 2] & 127](b) | 0) == 1) { l = Qa[f[(f[b >> 2] | 0) + 52 >> 2] & 127](b) | 0; m = Ra[f[(f[b >> 2] | 0) + 60 >> 2] & 127](b, d) | 0; if ((l | 0) == 0 | (m | 0) == 0) { f[a >> 2] = 0; u = h; return } n = Ra[f[(f[b >> 2] | 0) + 56 >> 2] & 127](b, d) | 0; if (!n) { f[i >> 2] = f[b + 56 >> 2]; f[i + 4 >> 2] = l; f[i + 12 >> 2] = m; f[i + 8 >> 2] = m + 12; Rd(a, j, c, k, e, i, g); if (!(f[a >> 2] | 0)) { f[a >> 2] = 0; break } u = h; return } else { f[i >> 2] = f[b + 56 >> 2]; f[i + 4 >> 2] = n; f[i + 12 >> 2] = m; f[i + 8 >> 2] = m + 12; Pd(a, j, c, k, e, i, g); if (!(f[a >> 2] | 0)) { f[a >> 2] = 0; break } u = h; return } } while (0); f[a >> 2] = 0; u = h; return } function sf(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; d = u; u = u + 32 | 0; h = d + 24 | 0; i = d + 16 | 0; j = d; k = d + 8 | 0; l = a + 40 | 0; f[a + 44 >> 2] = g; g = a + 36 | 0; m = f[g >> 2] | 0; n = f[m + 4 >> 2] | 0; o = f[m >> 2] | 0; p = n - o | 0; if ((p | 0) <= 0) { u = d; return 1 } q = (p >>> 2) + -1 | 0; p = a + 8 | 0; r = a + 48 | 0; s = a + 52 | 0; a = i + 4 | 0; t = j + 4 | 0; v = h + 4 | 0; if (n - o >> 2 >>> 0 > q >>> 0) { w = q; x = o } else { y = m; mq(y) } while (1) { f[k >> 2] = f[x + (w << 2) >> 2]; f[h >> 2] = f[k >> 2]; sb(l, h, b, w) | 0; m = X(w, e) | 0; o = b + (m << 2) | 0; q = c + (m << 2) | 0; m = f[o + 4 >> 2] | 0; n = f[r >> 2] | 0; z = f[s >> 2] | 0; f[i >> 2] = f[o >> 2]; f[a >> 2] = m; f[j >> 2] = n; f[t >> 2] = z; Dd(h, p, i, j); f[q >> 2] = f[h >> 2]; f[q + 4 >> 2] = f[v >> 2]; w = w + -1 | 0; if ((w | 0) <= -1) { A = 3; break } q = f[g >> 2] | 0; x = f[q >> 2] | 0; if ((f[q + 4 >> 2] | 0) - x >> 2 >>> 0 <= w >>> 0) { y = q; A = 4; break } } if ((A | 0) == 3) { u = d; return 1 } else if ((A | 0) == 4) mq(y); return 0 } function tf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; d = f[b >> 2] | 0; b = f[c >> 2] | 0; e = b - d >> 2; g = a + 8 | 0; h = f[g >> 2] | 0; i = f[a >> 2] | 0; j = i; k = b; if (e >>> 0 <= h - i >> 2 >>> 0) { l = a + 4 | 0; m = (f[l >> 2] | 0) - i >> 2; n = e >>> 0 > m >>> 0; o = n ? d + (m << 2) | 0 : b; b = o - d | 0; m = b >> 2; if (m | 0) Xl(i | 0, d | 0, b | 0) | 0; b = j + (m << 2) | 0; if (!n) { n = f[l >> 2] | 0; if ((n | 0) == (b | 0)) return; f[l >> 2] = n + (~((n + -4 - b | 0) >>> 2) << 2); return } b = f[c >> 2] | 0; c = o; if ((b | 0) == (c | 0)) return; n = f[l >> 2] | 0; m = b + -4 - o | 0; o = c; c = n; while (1) { f[c >> 2] = f[o >> 2]; o = o + 4 | 0; if ((o | 0) == (b | 0)) break; else c = c + 4 | 0 } f[l >> 2] = n + ((m >>> 2) + 1 << 2); return } m = i; if (!i) p = h; else { h = a + 4 | 0; n = f[h >> 2] | 0; if ((n | 0) != (j | 0)) f[h >> 2] = n + (~((n + -4 - i | 0) >>> 2) << 2); br(m); f[g >> 2] = 0; f[h >> 2] = 0; f[a >> 2] = 0; p = 0 } if (e >>> 0 > 1073741823) mq(a); h = p >> 1; m = p >> 2 >>> 0 < 536870911 ? (h >>> 0 < e >>> 0 ? e : h) : 1073741823; if (m >>> 0 > 1073741823) mq(a); h = dn(m << 2) | 0; e = a + 4 | 0; f[e >> 2] = h; f[a >> 2] = h; f[g >> 2] = h + (m << 2); m = d; if ((k | 0) == (m | 0)) return; g = k + -4 - d | 0; d = m; m = h; while (1) { f[m >> 2] = f[d >> 2]; d = d + 4 | 0; if ((d | 0) == (k | 0)) break; else m = m + 4 | 0 } f[e >> 2] = h + ((g >>> 2) + 1 << 2); return } function uf(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; e = u; u = u + 112 | 0; g = e + 100 | 0; h = e; i = dn(120) | 0; j = f[c + 8 >> 2] | 0; f[i + 4 >> 2] = 0; f[i >> 2] = 3296; k = i + 8 | 0; l = i + 12 | 0; m = l + 44 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[k >> 2] = 3320; l = i + 56 | 0; m = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[i + 96 >> 2] = 0; f[i + 100 >> 2] = 0; f[i + 104 >> 2] = 0; f[i + 108 >> 2] = j; f[i + 112 >> 2] = d; k = i + 116 | 0; f[k >> 2] = 0; n = i; o = f[c + 12 >> 2] | 0; p = h + 4 | 0; l = p + 4 | 0; m = l + 40 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[h >> 2] = 3320; l = h + 48 | 0; m = l + 36 | 0; do { f[l >> 2] = 0; l = l + 4 | 0 } while ((l | 0) < (m | 0)); f[h + 88 >> 2] = 0; f[h + 92 >> 2] = 0; f[h + 96 >> 2] = 0; l = o; f[p >> 2] = l; m = ((f[l + 4 >> 2] | 0) - (f[o >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[g >> 0] = 0; Xg(h + 24 | 0, m, g); m = f[p >> 2] | 0; p = (f[m + 28 >> 2] | 0) - (f[m + 24 >> 2] | 0) >> 2; b[g >> 0] = 0; Xg(h + 36 | 0, p, g); f[h + 8 >> 2] = o; f[h + 12 >> 2] = d; f[h + 16 >> 2] = j; f[h + 20 >> 2] = i; f[k >> 2] = c + 72; fh(i, h); f[a >> 2] = n; Gi(h); u = e; return } function vf(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 4 | 0; g = f[e >> 2] | 0; h = g; if (((d - g | 0) / 12 | 0) >>> 0 >= b >>> 0) { hj(g | 0, 0, b * 12 | 0) | 0; f[e >> 2] = h + (b * 12 | 0); return } i = f[a >> 2] | 0; j = (g - i | 0) / 12 | 0; g = j + b | 0; k = i; if (g >>> 0 > 357913941) mq(a); l = (d - i | 0) / 12 | 0; d = l << 1; m = l >>> 0 < 178956970 ? (d >>> 0 < g >>> 0 ? g : d) : 357913941; do if (m) if (m >>> 0 > 357913941) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { n = dn(m * 12 | 0) | 0; break } else n = 0; while (0); d = n + (j * 12 | 0) | 0; j = d; g = n + (m * 12 | 0) | 0; hj(d | 0, 0, b * 12 | 0) | 0; m = d + (b * 12 | 0) | 0; if ((h | 0) == (k | 0)) { o = j; p = i; q = h } else { i = h; h = j; j = d; do { d = j + -12 | 0; b = i; i = i + -12 | 0; f[d >> 2] = 0; n = j + -8 | 0; f[n >> 2] = 0; f[j + -4 >> 2] = 0; f[d >> 2] = f[i >> 2]; d = b + -8 | 0; f[n >> 2] = f[d >> 2]; n = b + -4 | 0; f[j + -4 >> 2] = f[n >> 2]; f[n >> 2] = 0; f[d >> 2] = 0; f[i >> 2] = 0; j = h + -12 | 0; h = j } while ((i | 0) != (k | 0)); o = h; p = f[a >> 2] | 0; q = f[e >> 2] | 0 } f[a >> 2] = o; f[e >> 2] = m; f[c >> 2] = g; g = p; if ((q | 0) != (g | 0)) { c = q; do { q = c; c = c + -12 | 0; m = f[c >> 2] | 0; if (m | 0) { e = q + -8 | 0; q = f[e >> 2] | 0; if ((q | 0) != (m | 0)) f[e >> 2] = q + (~((q + -4 - m | 0) >>> 2) << 2); br(m) } } while ((c | 0) != (g | 0)) } if (!p) return; br(p); return } function wf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = f[a + 12 >> 2] | 0; e = a + 68 | 0; g = f[e >> 2] | 0; h = f[g + 80 >> 2] | 0; b[c + 84 >> 0] = 0; i = c + 68 | 0; j = c + 72 | 0; k = f[j >> 2] | 0; l = f[i >> 2] | 0; m = k - l >> 2; n = l; l = k; if (h >>> 0 <= m >>> 0) if (h >>> 0 < m >>> 0 ? (k = n + (h << 2) | 0, (k | 0) != (l | 0)) : 0) { f[j >> 2] = l + (~((l + -4 - k | 0) >>> 2) << 2); o = g; p = h } else { o = g; p = h } else { kh(i, h - m | 0, 3220); m = f[e >> 2] | 0; o = m; p = f[m + 80 >> 2] | 0 } m = (f[o + 100 >> 2] | 0) - (f[o + 96 >> 2] | 0) | 0; e = (m | 0) / 12 | 0; if (!m) { q = 1; return q | 0 } m = a + 72 | 0; a = c + 68 | 0; c = f[o + 96 >> 2] | 0; o = f[d + 28 >> 2] | 0; d = 0; while (1) { h = d * 3 | 0; i = f[o + (h << 2) >> 2] | 0; if ((i | 0) == -1) { q = 0; r = 11; break } g = f[(f[m >> 2] | 0) + 12 >> 2] | 0; k = f[g + (i << 2) >> 2] | 0; if (k >>> 0 >= p >>> 0) { q = 0; r = 11; break } i = f[a >> 2] | 0; f[i + (f[c + (d * 12 | 0) >> 2] << 2) >> 2] = k; k = f[o + (h + 1 << 2) >> 2] | 0; if ((k | 0) == -1) { q = 0; r = 11; break } l = f[g + (k << 2) >> 2] | 0; if (l >>> 0 >= p >>> 0) { q = 0; r = 11; break } f[i + (f[c + (d * 12 | 0) + 4 >> 2] << 2) >> 2] = l; l = f[o + (h + 2 << 2) >> 2] | 0; if ((l | 0) == -1) { q = 0; r = 11; break } h = f[g + (l << 2) >> 2] | 0; if (h >>> 0 >= p >>> 0) { q = 0; r = 11; break } f[i + (f[c + (d * 12 | 0) + 8 >> 2] << 2) >> 2] = h; d = d + 1 | 0; if (d >>> 0 >= e >>> 0) { q = 1; r = 11; break } } if ((r | 0) == 11) return q | 0; return 0 } function xf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -4194304 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -4177920 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 4194304 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1077936128 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function yf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -2097152 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -2080768 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 6291456 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1075838976 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function zf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -1048576 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1032192 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 7340032 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1074790400 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function Af(a, c, d, e, g, h, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; a = u; u = u + 96 | 0; j = a; if (!c) { k = -1; u = a; return k | 0 } Lm(j); yj(j, d, 0, g & 255, i, 0, g << 1, 0, 0, 0); i = uh(c, j, 1, e) | 0; d = f[(f[c + 8 >> 2] | 0) + (i << 2) >> 2] | 0; if (e | 0) { l = d + 84 | 0; m = d + 68 | 0; n = d + 40 | 0; o = d + 64 | 0; d = 0; do { if (!(b[l >> 0] | 0)) p = f[(f[m >> 2] | 0) + (d << 2) >> 2] | 0; else p = d; q = h + ((X(d, g) | 0) << 1) | 0; r = n; s = f[r >> 2] | 0; t = on(s | 0, f[r + 4 >> 2] | 0, p | 0, 0) | 0; Rg((f[f[o >> 2] >> 2] | 0) + t | 0, q | 0, s | 0) | 0; d = d + 1 | 0 } while ((d | 0) != (e | 0)) } d = c + 80 | 0; c = f[d >> 2] | 0; if (c) if ((c | 0) == (e | 0)) v = 10; else w = -1; else { f[d >> 2] = e; v = 10 } if ((v | 0) == 10) w = i; i = j + 88 | 0; v = f[i >> 2] | 0; f[i >> 2] = 0; if (v | 0) { i = f[v + 8 >> 2] | 0; if (i | 0) { e = v + 12 | 0; if ((f[e >> 2] | 0) != (i | 0)) f[e >> 2] = i; br(i) } br(v) } v = f[j + 68 >> 2] | 0; if (v | 0) { i = j + 72 | 0; e = f[i >> 2] | 0; if ((e | 0) != (v | 0)) f[i >> 2] = e + (~((e + -4 - v | 0) >>> 2) << 2); br(v) } v = j + 64 | 0; j = f[v >> 2] | 0; f[v >> 2] = 0; if (j | 0) { v = f[j >> 2] | 0; if (v | 0) { e = j + 4 | 0; if ((f[e >> 2] | 0) != (v | 0)) f[e >> 2] = v; br(v) } br(j) } k = w; u = a; return k | 0 } function Bf(a, c, d, e, g, h, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; a = u; u = u + 96 | 0; j = a; if (!c) { k = -1; u = a; return k | 0 } Lm(j); yj(j, d, 0, g & 255, i, 0, g << 2, 0, 0, 0); i = uh(c, j, 1, e) | 0; d = f[(f[c + 8 >> 2] | 0) + (i << 2) >> 2] | 0; if (e | 0) { l = d + 84 | 0; m = d + 68 | 0; n = d + 40 | 0; o = d + 64 | 0; d = 0; do { if (!(b[l >> 0] | 0)) p = f[(f[m >> 2] | 0) + (d << 2) >> 2] | 0; else p = d; q = h + ((X(d, g) | 0) << 2) | 0; r = n; s = f[r >> 2] | 0; t = on(s | 0, f[r + 4 >> 2] | 0, p | 0, 0) | 0; Rg((f[f[o >> 2] >> 2] | 0) + t | 0, q | 0, s | 0) | 0; d = d + 1 | 0 } while ((d | 0) != (e | 0)) } d = c + 80 | 0; c = f[d >> 2] | 0; if (c) if ((c | 0) == (e | 0)) v = 10; else w = -1; else { f[d >> 2] = e; v = 10 } if ((v | 0) == 10) w = i; i = j + 88 | 0; v = f[i >> 2] | 0; f[i >> 2] = 0; if (v | 0) { i = f[v + 8 >> 2] | 0; if (i | 0) { e = v + 12 | 0; if ((f[e >> 2] | 0) != (i | 0)) f[e >> 2] = i; br(i) } br(v) } v = f[j + 68 >> 2] | 0; if (v | 0) { i = j + 72 | 0; e = f[i >> 2] | 0; if ((e | 0) != (v | 0)) f[i >> 2] = e + (~((e + -4 - v | 0) >>> 2) << 2); br(v) } v = j + 64 | 0; j = f[v >> 2] | 0; f[v >> 2] = 0; if (j | 0) { v = f[j >> 2] | 0; if (v | 0) { e = j + 4 | 0; if ((f[e >> 2] | 0) != (v | 0)) f[e >> 2] = v; br(v) } br(j) } k = w; u = a; return k | 0 } function Cf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -262144 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -245760 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 8126464 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1074003968 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function Df(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -131072 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -114688 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 8257536 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1073872896 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function Ef(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -32768 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -16384 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; o = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; n = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + 8355840 | 0; b[n >> 0] = m; b[n + 1 >> 0] = m >>> 8; b[n + 2 >> 0] = m >>> 16; o = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; n = j + -1073774592 | 0; b[m >> 0] = n; b[m + 1 >> 0] = n >>> 8; b[m + 2 >> 0] = n >>> 16; b[m + 3 >> 0] = n >>> 24; o = (f[l >> 2] | 0) + 4 | 0; break } else { o = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; o = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((o | 0) < 0) << 31 >> 31; Cn(e); eh(o, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, o | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, o | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function Ff(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; c = f[b >> 2] | 0; d = f[b + 4 >> 2] | 0; e = f[b + 8 >> 2] | 0; g = f[b + 12 >> 2] | 0; b = (((c ^ 318) + 239 ^ d) + 239 ^ e) + 239 ^ g; h = f[a + 4 >> 2] | 0; if (!h) { i = 0; return i | 0 } j = h + -1 | 0; k = (j & h | 0) == 0; if (!k) if (b >>> 0 < h >>> 0) l = b; else l = (b >>> 0) % (h >>> 0) | 0; else l = b & j; m = f[(f[a >> 2] | 0) + (l << 2) >> 2] | 0; if (!m) { i = 0; return i | 0 } a = f[m >> 2] | 0; if (!a) { i = 0; return i | 0 } if (k) { k = a; while (1) { m = f[k + 4 >> 2] | 0; n = (m | 0) == (b | 0); if (!(n | (m & j | 0) == (l | 0))) { i = 0; o = 25; break } if ((((n ? (f[k + 8 >> 2] | 0) == (c | 0) : 0) ? (f[k + 12 >> 2] | 0) == (d | 0) : 0) ? (f[k + 16 >> 2] | 0) == (e | 0) : 0) ? (f[k + 20 >> 2] | 0) == (g | 0) : 0) { i = k; o = 25; break } k = f[k >> 2] | 0; if (!k) { i = 0; o = 25; break } } if ((o | 0) == 25) return i | 0 } else p = a; while (1) { a = f[p + 4 >> 2] | 0; if ((a | 0) == (b | 0)) { if ((((f[p + 8 >> 2] | 0) == (c | 0) ? (f[p + 12 >> 2] | 0) == (d | 0) : 0) ? (f[p + 16 >> 2] | 0) == (e | 0) : 0) ? (f[p + 20 >> 2] | 0) == (g | 0) : 0) { i = p; o = 25; break } } else { if (a >>> 0 < h >>> 0) q = a; else q = (a >>> 0) % (h >>> 0) | 0; if ((q | 0) != (l | 0)) { i = 0; o = 25; break } } p = f[p >> 2] | 0; if (!p) { i = 0; o = 25; break } } if ((o | 0) == 25) return i | 0; return 0 } function Gf(a, c, d, e, g, h, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; a = u; u = u + 96 | 0; j = a; if (!c) { k = -1; u = a; return k | 0 } Lm(j); yj(j, d, 0, g & 255, i, 0, g, 0, 0, 0); i = uh(c, j, 1, e) | 0; d = f[(f[c + 8 >> 2] | 0) + (i << 2) >> 2] | 0; if (e | 0) { l = d + 84 | 0; m = d + 68 | 0; n = d + 40 | 0; o = d + 64 | 0; d = 0; do { if (!(b[l >> 0] | 0)) p = f[(f[m >> 2] | 0) + (d << 2) >> 2] | 0; else p = d; q = h + (X(d, g) | 0) | 0; r = n; s = f[r >> 2] | 0; t = on(s | 0, f[r + 4 >> 2] | 0, p | 0, 0) | 0; Rg((f[f[o >> 2] >> 2] | 0) + t | 0, q | 0, s | 0) | 0; d = d + 1 | 0 } while ((d | 0) != (e | 0)) } d = c + 80 | 0; c = f[d >> 2] | 0; if (c) if ((c | 0) == (e | 0)) v = 10; else w = -1; else { f[d >> 2] = e; v = 10 } if ((v | 0) == 10) w = i; i = j + 88 | 0; v = f[i >> 2] | 0; f[i >> 2] = 0; if (v | 0) { i = f[v + 8 >> 2] | 0; if (i | 0) { e = v + 12 | 0; if ((f[e >> 2] | 0) != (i | 0)) f[e >> 2] = i; br(i) } br(v) } v = f[j + 68 >> 2] | 0; if (v | 0) { i = j + 72 | 0; e = f[i >> 2] | 0; if ((e | 0) != (v | 0)) f[i >> 2] = e + (~((e + -4 - v | 0) >>> 2) << 2); br(v) } v = j + 64 | 0; j = f[v >> 2] | 0; f[v >> 2] = 0; if (j | 0) { v = f[j >> 2] | 0; if (v | 0) { e = j + 4 | 0; if ((f[e >> 2] | 0) != (v | 0)) f[e >> 2] = v; br(v) } br(j) } k = w; u = a; return k | 0 } function Hf(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; h = u; u = u + 32 | 0; i = h; j = h + 16 | 0; k = f[(f[(f[b + 4 >> 2] | 0) + 8 >> 2] | 0) + (d << 2) >> 2] | 0; do if ((c + -1 | 0) >>> 0 < 6 & (Qa[f[(f[b >> 2] | 0) + 8 >> 2] & 127](b) | 0) == 1) { l = Qa[f[(f[b >> 2] | 0) + 52 >> 2] & 127](b) | 0; m = Ra[f[(f[b >> 2] | 0) + 60 >> 2] & 127](b, d) | 0; if ((l | 0) == 0 | (m | 0) == 0) { f[a >> 2] = 0; u = h; return } n = Ra[f[(f[b >> 2] | 0) + 56 >> 2] & 127](b, d) | 0; if (!n) { f[i >> 2] = f[b + 56 >> 2]; f[i + 4 >> 2] = l; f[i + 12 >> 2] = m; f[i + 8 >> 2] = m + 12; Od(a, j, c, k, e, i, g); if (!(f[a >> 2] | 0)) { f[a >> 2] = 0; break } u = h; return } else { f[i >> 2] = f[b + 56 >> 2]; f[i + 4 >> 2] = n; f[i + 12 >> 2] = m; f[i + 8 >> 2] = m + 12; Nd(a, j, c, k, e, i, g); if (!(f[a >> 2] | 0)) { f[a >> 2] = 0; break } u = h; return } } while (0); f[a >> 2] = 0; u = h; return } function If(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0; e = f[d >> 2] | 0; g = f[d + 4 >> 2] | 0; if ((e | 0) == (g | 0)) { h = 0; i = a + 12 | 0; j = a + 8 | 0 } else { d = f[c >> 2] | 0; c = a + 8 | 0; k = a + 12 | 0; a = 0; l = e; while (1) { e = f[l >> 2] | 0; m = f[d + (e << 2) >> 2] | 0; if (m >>> 0 < a >>> 0) n = a; else { o = f[c >> 2] | 0; p = (f[k >> 2] | 0) - o | 0; q = o; if ((p | 0) > 0) { o = p >>> 2; p = 0; do { r = f[q + (p << 2) >> 2] | 0; s = f[r + 68 >> 2] | 0; if (!(b[r + 84 >> 0] | 0)) t = f[s + (e << 2) >> 2] | 0; else t = e; f[s + (m << 2) >> 2] = t; p = p + 1 | 0 } while ((p | 0) < (o | 0)) } n = m + 1 | 0 } l = l + 4 | 0; if ((l | 0) == (g | 0)) { h = n; i = k; j = c; break } else a = n } } n = f[i >> 2] | 0; a = f[j >> 2] | 0; if ((n - a | 0) > 0) { u = 0; v = a; w = n } else return; while (1) { n = f[v + (u << 2) >> 2] | 0; b[n + 84 >> 0] = 0; a = n + 68 | 0; c = n + 72 | 0; n = f[c >> 2] | 0; k = f[a >> 2] | 0; g = n - k >> 2; l = k; k = n; if (h >>> 0 <= g >>> 0) if (h >>> 0 < g >>> 0 ? (n = l + (h << 2) | 0, (n | 0) != (k | 0)) : 0) { f[c >> 2] = k + (~((k + -4 - n | 0) >>> 2) << 2); x = v; y = w } else { x = v; y = w } else { kh(a, h - g | 0, 5908); x = f[j >> 2] | 0; y = f[i >> 2] | 0 } u = u + 1 | 0; if ((u | 0) >= (y - x >> 2 | 0)) break; else { v = x; w = y } } return } function Jf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = b; e = c - d >> 2; g = a + 8 | 0; h = f[g >> 2] | 0; i = f[a >> 2] | 0; j = i; if (e >>> 0 <= h - i >> 2 >>> 0) { k = a + 4 | 0; l = (f[k >> 2] | 0) - i >> 2; m = e >>> 0 > l >>> 0; n = b + (l << 2) | 0; l = m ? n : c; o = l; p = o - d | 0; q = p >> 2; if (q | 0) Xl(i | 0, b | 0, p | 0) | 0; p = j + (q << 2) | 0; if (!m) { m = f[k >> 2] | 0; if ((m | 0) == (p | 0)) return; f[k >> 2] = m + (~((m + -4 - p | 0) >>> 2) << 2); return } if ((l | 0) == (c | 0)) return; l = f[k >> 2] | 0; p = ((c + -4 - o | 0) >>> 2) + 1 | 0; o = n; n = l; while (1) { f[n >> 2] = f[o >> 2]; o = o + 4 | 0; if ((o | 0) == (c | 0)) break; else n = n + 4 | 0 } f[k >> 2] = l + (p << 2); return } p = i; if (!i) r = h; else { h = a + 4 | 0; l = f[h >> 2] | 0; if ((l | 0) != (j | 0)) f[h >> 2] = l + (~((l + -4 - i | 0) >>> 2) << 2); br(p); f[g >> 2] = 0; f[h >> 2] = 0; f[a >> 2] = 0; r = 0 } if (e >>> 0 > 1073741823) mq(a); h = r >> 1; p = r >> 2 >>> 0 < 536870911 ? (h >>> 0 < e >>> 0 ? e : h) : 1073741823; if (p >>> 0 > 1073741823) mq(a); h = dn(p << 2) | 0; e = a + 4 | 0; f[e >> 2] = h; f[a >> 2] = h; f[g >> 2] = h + (p << 2); if ((b | 0) == (c | 0)) return; p = ((c + -4 - d | 0) >>> 2) + 1 | 0; d = b; b = h; while (1) { f[b >> 2] = f[d >> 2]; d = d + 4 | 0; if ((d | 0) == (c | 0)) break; else b = b + 4 | 0 } f[e >> 2] = h + (p << 2); return } function Kf(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; c = u; u = u + 16 | 0; d = c; e = a + 76 | 0; g = f[e >> 2] | 0; h = a + 80 | 0; i = f[h >> 2] | 0; if ((i | 0) != (g | 0)) f[h >> 2] = i + (~((i + -4 - g | 0) >>> 2) << 2); f[e >> 2] = 0; f[h >> 2] = 0; f[a + 84 >> 2] = 0; if (g | 0) br(g); g = a + 64 | 0; h = f[g >> 2] | 0; e = a + 68 | 0; if ((f[e >> 2] | 0) != (h | 0)) f[e >> 2] = h; f[g >> 2] = 0; f[e >> 2] = 0; f[a + 72 >> 2] = 0; if (h | 0) br(h); h = b + 4 | 0; e = f[h >> 2] | 0; g = f[b >> 2] | 0; i = ((e - g | 0) / 12 | 0) * 3 | 0; j = a + 4 | 0; k = f[j >> 2] | 0; l = f[a >> 2] | 0; m = k - l >> 2; n = l; l = k; k = g; if (i >>> 0 <= m >>> 0) if (i >>> 0 < m >>> 0 ? (o = n + (i << 2) | 0, (o | 0) != (l | 0)) : 0) { f[j >> 2] = l + (~((l + -4 - o | 0) >>> 2) << 2); p = e; q = g; r = k } else { p = e; q = g; r = k } else { oi(a, i - m | 0); m = f[b >> 2] | 0; p = f[h >> 2] | 0; q = m; r = m } if ((p | 0) != (q | 0)) { q = f[a >> 2] | 0; m = (p - r | 0) / 12 | 0; p = 0; do { h = p * 3 | 0; f[q + (h << 2) >> 2] = f[r + (p * 12 | 0) >> 2]; f[q + (h + 1 << 2) >> 2] = f[r + (p * 12 | 0) + 4 >> 2]; f[q + (h + 2 << 2) >> 2] = f[r + (p * 12 | 0) + 8 >> 2]; p = p + 1 | 0 } while (p >>> 0 < m >>> 0) } f[d >> 2] = -1; if (!(oc(a, d) | 0)) { s = 0; u = c; return s | 0 } Gc(a) | 0; fb(a, f[d >> 2] | 0) | 0; s = 1; u = c; return s | 0 } function Lf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = u; u = u + 32 | 0; e = d; g = a + 40 | 0; h = (f[c >> 2] | 0) + (f[g >> 2] | 0) | 0; i = a + 24 | 0; j = f[a + 32 >> 2] | 0; k = j + -16384 | 0; do if (k >>> 0 >= 64) { if (k >>> 0 < 16384) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; b[m >> 0] = j; b[m + 1 >> 0] = j >>> 8; n = (f[l >> 2] | 0) + 2 | 0; break } if (k >>> 0 < 4194304) { l = a + 28 | 0; m = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; o = j + 8372224 | 0; b[m >> 0] = o; b[m + 1 >> 0] = o >>> 8; b[m + 2 >> 0] = o >>> 16; n = (f[l >> 2] | 0) + 3 | 0; break } if (k >>> 0 < 1073741824) { l = a + 28 | 0; o = (f[i >> 2] | 0) + (f[l >> 2] | 0) | 0; m = j + -1073758208 | 0; b[o >> 0] = m; b[o + 1 >> 0] = m >>> 8; b[o + 2 >> 0] = m >>> 16; b[o + 3 >> 0] = m >>> 24; n = (f[l >> 2] | 0) + 4 | 0; break } else { n = f[a + 28 >> 2] | 0; break } } else { l = a + 28 | 0; b[(f[i >> 2] | 0) + (f[l >> 2] | 0) >> 0] = k; n = (f[l >> 2] | 0) + 1 | 0 } while (0); k = ((n | 0) < 0) << 31 >> 31; Cn(e); eh(n, k, e) | 0; i = e + 4 | 0; a = (f[i >> 2] | 0) - (f[e >> 2] | 0) | 0; Xl(h + a | 0, h | 0, n | 0) | 0; Rg(h | 0, f[e >> 2] | 0, a | 0) | 0; h = g; g = f[h >> 2] | 0; j = f[h + 4 >> 2] | 0; h = Tn(a | 0, 0, n | 0, k | 0) | 0; k = Tn(h | 0, I | 0, g | 0, j | 0) | 0; vl(c, k, I); k = e + 12 | 0; c = f[k >> 2] | 0; f[k >> 2] = 0; if (c | 0) br(c); c = f[e >> 2] | 0; if (!c) { u = d; return } if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c); u = d; return } function Mf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = b; e = c - d >> 2; g = a + 8 | 0; h = f[g >> 2] | 0; i = f[a >> 2] | 0; j = i; if (e >>> 0 <= h - i >> 2 >>> 0) { k = a + 4 | 0; l = (f[k >> 2] | 0) - i >> 2; m = e >>> 0 > l >>> 0; n = b + (l << 2) | 0; l = m ? n : c; o = l; p = o - d | 0; q = p >> 2; if (q | 0) Xl(i | 0, b | 0, p | 0) | 0; p = j + (q << 2) | 0; if (!m) { m = f[k >> 2] | 0; if ((m | 0) == (p | 0)) return; f[k >> 2] = m + (~((m + -4 - p | 0) >>> 2) << 2); return } if ((l | 0) == (c | 0)) return; l = f[k >> 2] | 0; p = c + -4 - o | 0; o = n; n = l; while (1) { f[n >> 2] = f[o >> 2]; o = o + 4 | 0; if ((o | 0) == (c | 0)) break; else n = n + 4 | 0 } f[k >> 2] = l + ((p >>> 2) + 1 << 2); return } p = i; if (!i) r = h; else { h = a + 4 | 0; l = f[h >> 2] | 0; if ((l | 0) != (j | 0)) f[h >> 2] = l + (~((l + -4 - i | 0) >>> 2) << 2); br(p); f[g >> 2] = 0; f[h >> 2] = 0; f[a >> 2] = 0; r = 0 } if (e >>> 0 > 1073741823) mq(a); h = r >> 1; p = r >> 2 >>> 0 < 536870911 ? (h >>> 0 < e >>> 0 ? e : h) : 1073741823; if (p >>> 0 > 1073741823) mq(a); h = dn(p << 2) | 0; e = a + 4 | 0; f[e >> 2] = h; f[a >> 2] = h; f[g >> 2] = h + (p << 2); if ((b | 0) == (c | 0)) return; p = c + -4 - d | 0; d = b; b = h; while (1) { f[b >> 2] = f[d >> 2]; d = d + 4 | 0; if ((d | 0) == (c | 0)) break; else b = b + 4 | 0 } f[e >> 2] = h + ((p >>> 2) + 1 << 2); return } function Nf(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0; g = u; u = u + 80 | 0; h = g; i = g + 64 | 0; Al(h); j = f[(f[a + 8 >> 2] | 0) + 56 >> 2] | 0; k = X(Ll(5) | 0, d) | 0; yj(h, j, 0, d & 255, 5, 0, k, ((k | 0) < 0) << 31 >> 31, 0, 0); k = dn(96) | 0; nl(k, h); pj(k, c) | 0; f[i >> 2] = k; Wi(a, i); k = f[i >> 2] | 0; f[i >> 2] = 0; if (k | 0) { i = k + 88 | 0; c = f[i >> 2] | 0; f[i >> 2] = 0; if (c | 0) { i = f[c + 8 >> 2] | 0; if (i | 0) { h = c + 12 | 0; if ((f[h >> 2] | 0) != (i | 0)) f[h >> 2] = i; br(i) } br(c) } c = f[k + 68 >> 2] | 0; if (c | 0) { i = k + 72 | 0; h = f[i >> 2] | 0; if ((h | 0) != (c | 0)) f[i >> 2] = h + (~((h + -4 - c | 0) >>> 2) << 2); br(c) } c = k + 64 | 0; h = f[c >> 2] | 0; f[c >> 2] = 0; if (h | 0) { c = f[h >> 2] | 0; if (c | 0) { i = h + 4 | 0; if ((f[i >> 2] | 0) != (c | 0)) f[i >> 2] = c; br(c) } br(h) } br(k) } if (!e) { u = g; return } k = f[a + 32 >> 2] | 0; b[k + 84 >> 0] = 0; a = k + 68 | 0; h = k + 72 | 0; k = f[h >> 2] | 0; c = f[a >> 2] | 0; i = k - c >> 2; d = k; if (i >>> 0 < e >>> 0) { kh(a, e - i | 0, 1516); u = g; return } if (i >>> 0 <= e >>> 0) { u = g; return } i = c + (e << 2) | 0; if ((i | 0) == (d | 0)) { u = g; return } f[h >> 2] = d + (~((d + -4 - i | 0) >>> 2) << 2); u = g; return } function Of(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; c = u; u = u + 16 | 0; d = c + 4 | 0; e = c; g = a + 4 | 0; h = f[g >> 2] | 0; i = a + 8 | 0; j = f[i >> 2] | 0; if ((j | 0) == (h | 0)) k = h; else { l = j + (~((j + -4 - h | 0) >>> 2) << 2) | 0; f[i >> 2] = l; k = l } l = a + 16 | 0; h = f[l >> 2] | 0; j = a + 20 | 0; m = f[j >> 2] | 0; n = h; if ((m | 0) != (h | 0)) f[j >> 2] = m + (~((m + -4 - n | 0) >>> 2) << 2); m = f[b >> 2] | 0; h = f[b + 4 >> 2] | 0; if ((m | 0) == (h | 0)) { u = c; return } b = a + 12 | 0; a = m; m = k; k = n; while (1) { n = f[a >> 2] | 0; f[d >> 2] = n; if ((m | 0) == (f[b >> 2] | 0)) { Ci(g, d); o = f[l >> 2] | 0 } else { f[m >> 2] = n; f[i >> 2] = m + 4; o = k } n = f[d >> 2] | 0; p = f[j >> 2] | 0; q = p - o >> 2; r = o; if ((n | 0) < (q | 0)) { s = r; t = n; v = o } else { w = n + 1 | 0; f[e >> 2] = -1; x = p; if (w >>> 0 <= q >>> 0) if (w >>> 0 < q >>> 0 ? (p = r + (w << 2) | 0, (p | 0) != (x | 0)) : 0) { f[j >> 2] = x + (~((x + -4 - p | 0) >>> 2) << 2); y = n; z = r; A = o } else { y = n; z = r; A = o } else { kh(l, w - q | 0, e); q = f[l >> 2] | 0; y = f[d >> 2] | 0; z = q; A = q } s = z; t = y; v = A } m = f[i >> 2] | 0; f[s + (t << 2) >> 2] = (m - (f[g >> 2] | 0) >> 2) + -1; a = a + 4 | 0; if ((a | 0) == (h | 0)) break; else k = v } u = c; return } function Pf(a, b) { a = a | 0; b = b | 0; var c = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; c = d[b >> 1] | 0; e = d[b + 2 >> 1] | 0; g = d[b + 4 >> 1] | 0; b = (((c ^ 318) & 65535) + 239 ^ e & 65535) + 239 ^ g & 65535; h = f[a + 4 >> 2] | 0; if (!h) { i = 0; return i | 0 } j = h + -1 | 0; k = (j & h | 0) == 0; if (!k) if (b >>> 0 < h >>> 0) l = b; else l = (b >>> 0) % (h >>> 0) | 0; else l = b & j; m = f[(f[a >> 2] | 0) + (l << 2) >> 2] | 0; if (!m) { i = 0; return i | 0 } a = f[m >> 2] | 0; if (!a) { i = 0; return i | 0 } if (k) { k = a; while (1) { m = f[k + 4 >> 2] | 0; n = (m | 0) == (b | 0); if (!(n | (m & j | 0) == (l | 0))) { i = 0; o = 23; break } if (((n ? (n = k + 8 | 0, (d[n >> 1] | 0) == c << 16 >> 16) : 0) ? (d[n + 2 >> 1] | 0) == e << 16 >> 16 : 0) ? (d[k + 12 >> 1] | 0) == g << 16 >> 16 : 0) { i = k; o = 23; break } k = f[k >> 2] | 0; if (!k) { i = 0; o = 23; break } } if ((o | 0) == 23) return i | 0 } else p = a; while (1) { a = f[p + 4 >> 2] | 0; if ((a | 0) == (b | 0)) { k = p + 8 | 0; if (((d[k >> 1] | 0) == c << 16 >> 16 ? (d[k + 2 >> 1] | 0) == e << 16 >> 16 : 0) ? (d[p + 12 >> 1] | 0) == g << 16 >> 16 : 0) { i = p; o = 23; break } } else { if (a >>> 0 < h >>> 0) q = a; else q = (a >>> 0) % (h >>> 0) | 0; if ((q | 0) != (l | 0)) { i = 0; o = 23; break } } p = f[p >> 2] | 0; if (!p) { i = 0; o = 23; break } } if ((o | 0) == 23) return i | 0; return 0 } function Qf(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; c = u; u = u + 32 | 0; d = c; e = a + 16 | 0; g = e; h = f[g >> 2] | 0; i = f[g + 4 >> 2] | 0; if (!((i | 0) > 0 | (i | 0) == 0 & h >>> 0 > 0)) { u = c; return } g = Tn(f[(f[a + 12 >> 2] | 0) + 4 >> 2] | 0, 0, 7, 0) | 0; j = Wn(g | 0, I | 0, 3) | 0; g = I; if (!(b[a + 24 >> 0] | 0)) { k = a + 4 | 0; l = k; m = k; n = h; o = i } else { k = f[a >> 2] | 0; p = a + 4 | 0; q = k + ((f[p >> 2] | 0) - k) | 0; k = Tn(h | 0, i | 0, 8, 0) | 0; i = q + (0 - k) | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; b[d + 24 >> 0] = 0; eh(j, g, d) | 0; k = d + 4 | 0; q = (f[k >> 2] | 0) - (f[d >> 2] | 0) | 0; Xl(i + q | 0, i + 8 | 0, j | 0) | 0; Rg(i | 0, f[d >> 2] | 0, q | 0) | 0; i = e; h = Tn(f[i >> 2] | 0, f[i + 4 >> 2] | 0, 8 - q | 0, 0) | 0; q = e; f[q >> 2] = h; f[q + 4 >> 2] = I; q = d + 12 | 0; h = f[q >> 2] | 0; f[q >> 2] = 0; if (h | 0) br(h); h = f[d >> 2] | 0; if (h | 0) { if ((f[k >> 2] | 0) != (h | 0)) f[k >> 2] = h; br(h) } h = e; l = p; m = p; n = f[h >> 2] | 0; o = f[h + 4 >> 2] | 0 } h = f[l >> 2] | 0; l = f[a >> 2] | 0; p = h - l | 0; k = Vn(j | 0, g | 0, n | 0, o | 0) | 0; o = Tn(k | 0, I | 0, p | 0, 0) | 0; k = l; l = h; if (p >>> 0 >= o >>> 0) { if (p >>> 0 > o >>> 0 ? (h = k + o | 0, (h | 0) != (l | 0)) : 0) f[m >> 2] = h } else ri(a, o - p | 0); p = e; f[p >> 2] = 0; f[p + 4 >> 2] = 0; u = c; return } function Rf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; f[c >> 2] = 1; d = a + 4 | 0; e = c + 8 | 0; g = c + 12 | 0; c = f[e >> 2] | 0; i = (f[g >> 2] | 0) - c | 0; if (i >>> 0 < 4294967292) { Bk(e, i + 4 | 0, 0); j = f[e >> 2] | 0 } else j = c; c = j + i | 0; i = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; b[c >> 0] = i; b[c + 1 >> 0] = i >> 8; b[c + 2 >> 0] = i >> 16; b[c + 3 >> 0] = i >> 24; i = a + 8 | 0; c = a + 12 | 0; d = f[i >> 2] | 0; if ((f[c >> 2] | 0) != (d | 0)) { j = 0; k = d; do { d = k + (j << 2) | 0; l = f[e >> 2] | 0; m = (f[g >> 2] | 0) - l | 0; if (m >>> 0 < 4294967292) { Bk(e, m + 4 | 0, 0); n = f[e >> 2] | 0 } else n = l; l = n + m | 0; m = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; b[l >> 0] = m; b[l + 1 >> 0] = m >> 8; b[l + 2 >> 0] = m >> 16; b[l + 3 >> 0] = m >> 24; j = j + 1 | 0; k = f[i >> 2] | 0 } while (j >>> 0 < (f[c >> 2] | 0) - k >> 2 >>> 0) } k = a + 20 | 0; a = f[e >> 2] | 0; c = (f[g >> 2] | 0) - a | 0; if (c >>> 0 < 4294967292) { Bk(e, c + 4 | 0, 0); o = f[e >> 2] | 0; p = o + c | 0; q = h[k >> 0] | h[k + 1 >> 0] << 8 | h[k + 2 >> 0] << 16 | h[k + 3 >> 0] << 24; b[p >> 0] = q; b[p + 1 >> 0] = q >> 8; b[p + 2 >> 0] = q >> 16; b[p + 3 >> 0] = q >> 24; return } else { o = a; p = o + c | 0; q = h[k >> 0] | h[k + 1 >> 0] << 8 | h[k + 2 >> 0] << 16 | h[k + 3 >> 0] << 24; b[p >> 0] = q; b[p + 1 >> 0] = q >> 8; b[p + 2 >> 0] = q >> 16; b[p + 3 >> 0] = q >> 24; return } } function Sf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = f[a >> 2] | 0; h = g; do if (e - g >> 2 >>> 0 >= b >>> 0) { i = a + 4 | 0; j = f[i >> 2] | 0; k = j - g >> 2; l = k >>> 0 < b >>> 0; m = l ? k : b; n = j; if (m | 0) { j = m; m = h; while (1) { f[m >> 2] = f[c >> 2]; j = j + -1 | 0; if (!j) break; else m = m + 4 | 0 } } if (!l) { m = h + (b << 2) | 0; if ((m | 0) == (n | 0)) return; else { o = i; p = n + (~((n + -4 - m | 0) >>> 2) << 2) | 0; break } } else { m = b - k | 0; j = m; q = n; while (1) { f[q >> 2] = f[c >> 2]; j = j + -1 | 0; if (!j) break; else q = q + 4 | 0 } o = i; p = n + (m << 2) | 0; break } } else { q = g; if (!g) r = e; else { j = a + 4 | 0; k = f[j >> 2] | 0; if ((k | 0) != (h | 0)) f[j >> 2] = k + (~((k + -4 - g | 0) >>> 2) << 2); br(q); f[d >> 2] = 0; f[j >> 2] = 0; f[a >> 2] = 0; r = 0 } if (b >>> 0 > 1073741823) mq(a); j = r >> 1; q = r >> 2 >>> 0 < 536870911 ? (j >>> 0 < b >>> 0 ? b : j) : 1073741823; if (q >>> 0 > 1073741823) mq(a); j = dn(q << 2) | 0; k = a + 4 | 0; f[k >> 2] = j; f[a >> 2] = j; f[d >> 2] = j + (q << 2); q = b; l = j; while (1) { f[l >> 2] = f[c >> 2]; q = q + -1 | 0; if (!q) break; else l = l + 4 | 0 } o = k; p = j + (b << 2) | 0 } while (0); f[o >> 2] = p; return } function Tf(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; h = Qg(a, b, c, d, g) | 0; i = f[e >> 2] | 0; j = f[d >> 2] | 0; k = f[g >> 2] | 0; g = f[k >> 2] | 0; l = (f[k + 4 >> 2] | 0) - g >> 3; if (l >>> 0 <= i >>> 0) mq(k); m = g; if (l >>> 0 <= j >>> 0) mq(k); if ((f[m + (i << 3) >> 2] | 0) >>> 0 >= (f[m + (j << 3) >> 2] | 0) >>> 0) { n = h; return n | 0 } f[d >> 2] = i; f[e >> 2] = j; j = f[d >> 2] | 0; e = f[c >> 2] | 0; if (l >>> 0 <= j >>> 0) mq(k); if (l >>> 0 <= e >>> 0) mq(k); if ((f[m + (j << 3) >> 2] | 0) >>> 0 >= (f[m + (e << 3) >> 2] | 0) >>> 0) { n = h + 1 | 0; return n | 0 } f[c >> 2] = j; f[d >> 2] = e; e = f[c >> 2] | 0; d = f[b >> 2] | 0; if (l >>> 0 <= e >>> 0) mq(k); if (l >>> 0 <= d >>> 0) mq(k); if ((f[m + (e << 3) >> 2] | 0) >>> 0 >= (f[m + (d << 3) >> 2] | 0) >>> 0) { n = h + 2 | 0; return n | 0 } f[b >> 2] = e; f[c >> 2] = d; d = f[b >> 2] | 0; c = f[a >> 2] | 0; if (l >>> 0 <= d >>> 0) mq(k); if (l >>> 0 <= c >>> 0) mq(k); if ((f[m + (d << 3) >> 2] | 0) >>> 0 >= (f[m + (c << 3) >> 2] | 0) >>> 0) { n = h + 3 | 0; return n | 0 } f[a >> 2] = d; f[b >> 2] = c; n = h + 4 | 0; return n | 0 } function Uf(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; d = b[c >> 0] | 0; e = b[c + 1 >> 0] | 0; g = b[c + 2 >> 0] | 0; c = ((d & 255 ^ 318) + 239 ^ e & 255) + 239 ^ g & 255; h = f[a + 4 >> 2] | 0; if (!h) { i = 0; return i | 0 } j = h + -1 | 0; k = (j & h | 0) == 0; if (!k) if (c >>> 0 < h >>> 0) l = c; else l = (c >>> 0) % (h >>> 0) | 0; else l = c & j; m = f[(f[a >> 2] | 0) + (l << 2) >> 2] | 0; if (!m) { i = 0; return i | 0 } a = f[m >> 2] | 0; if (!a) { i = 0; return i | 0 } if (k) { k = a; while (1) { m = f[k + 4 >> 2] | 0; n = (m | 0) == (c | 0); if (!(n | (m & j | 0) == (l | 0))) { i = 0; o = 23; break } if (((n ? (n = k + 8 | 0, (b[n >> 0] | 0) == d << 24 >> 24) : 0) ? (b[n + 1 >> 0] | 0) == e << 24 >> 24 : 0) ? (b[n + 2 >> 0] | 0) == g << 24 >> 24 : 0) { i = k; o = 23; break } k = f[k >> 2] | 0; if (!k) { i = 0; o = 23; break } } if ((o | 0) == 23) return i | 0 } else p = a; while (1) { a = f[p + 4 >> 2] | 0; if ((a | 0) == (c | 0)) { k = p + 8 | 0; if (((b[k >> 0] | 0) == d << 24 >> 24 ? (b[k + 1 >> 0] | 0) == e << 24 >> 24 : 0) ? (b[k + 2 >> 0] | 0) == g << 24 >> 24 : 0) { i = p; o = 23; break } } else { if (a >>> 0 < h >>> 0) q = a; else q = (a >>> 0) % (h >>> 0) | 0; if ((q | 0) != (l | 0)) { i = 0; o = 23; break } } p = f[p >> 2] | 0; if (!p) { i = 0; o = 23; break } } if ((o | 0) == 23) return i | 0; return 0 } function Vf(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; b = u; u = u + 16 | 0; c = b; d = a + 36 | 0; e = a + 4 | 0; g = a + 8 | 0; h = (f[g >> 2] | 0) - (f[e >> 2] | 0) >> 2; i = a + 40 | 0; j = f[i >> 2] | 0; k = f[d >> 2] | 0; l = j - k >> 2; m = k; k = j; if (h >>> 0 <= l >>> 0) { if (h >>> 0 < l >>> 0 ? (j = m + (h << 2) | 0, (j | 0) != (k | 0)) : 0) { m = k; do { k = m + -4 | 0; f[i >> 2] = k; n = f[k >> 2] | 0; f[k >> 2] = 0; if (n | 0) Va[f[(f[n >> 2] | 0) + 4 >> 2] & 127](n); m = f[i >> 2] | 0 } while ((m | 0) != (j | 0)) } } else ng(d, h - l | 0); if ((f[g >> 2] | 0) == (f[e >> 2] | 0)) { o = 1; u = b; return o | 0 } l = a + 52 | 0; h = a + 48 | 0; j = 0; while (1) { Xa[f[(f[a >> 2] | 0) + 56 >> 2] & 15](c, a, j); m = (f[d >> 2] | 0) + (j << 2) | 0; i = f[c >> 2] | 0; f[c >> 2] = 0; n = f[m >> 2] | 0; f[m >> 2] = i; if (n | 0) Va[f[(f[n >> 2] | 0) + 4 >> 2] & 127](n); n = f[c >> 2] | 0; f[c >> 2] = 0; if (n | 0) Va[f[(f[n >> 2] | 0) + 4 >> 2] & 127](n); n = f[(f[d >> 2] | 0) + (j << 2) >> 2] | 0; if (!n) { o = 0; p = 19; break } if (j >>> 0 < (f[l >> 2] | 0) >>> 0 ? f[(f[h >> 2] | 0) + (j >>> 5 << 2) >> 2] & 1 << (j & 31) | 0 : 0) Pp(n); j = j + 1 | 0; if (j >>> 0 >= (f[g >> 2] | 0) - (f[e >> 2] | 0) >> 2 >>> 0) { o = 1; p = 19; break } } if ((p | 0) == 19) { u = b; return o | 0 } return 0 } function Wf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; Nh(f[c + 12 >> 2] | 0, b) | 0; h = f[c + 8 >> 2] | 0; a: do if (h | 0) { i = b + 16 | 0; j = b + 4 | 0; k = h; while (1) { l = k; if (!(nf(0, b, l + 8 | 0) | 0)) { m = 0; break } n = l + 20 | 0; o = (f[l + 24 >> 2] | 0) - (f[n >> 2] | 0) | 0; Nh(o, b) | 0; l = f[n >> 2] | 0; n = i; p = f[n + 4 >> 2] | 0; if (!((p | 0) > 0 | (p | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[j >> 2]; f[e >> 2] = f[g >> 2]; ye(b, e, l, l + o | 0) | 0 } k = f[k >> 2] | 0; if (!k) break a } u = d; return m | 0 } while (0); Nh(f[c + 32 >> 2] | 0, b) | 0; e = f[c + 28 >> 2] | 0; if (!e) { m = 1; u = d; return m | 0 } else q = e; while (1) { e = q; if (!(nf(0, b, e + 8 | 0) | 0)) { m = 0; r = 10; break } Wf(a, b, f[e + 20 >> 2] | 0) | 0; q = f[q >> 2] | 0; if (!q) { m = 1; r = 10; break } } if ((r | 0) == 10) { u = d; return m | 0 } return 0 } function Xf(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; h = a + 8 | 0; i = a + 12 | 0; j = f[h >> 2] | 0; if ((f[i >> 2] | 0) == (j | 0)) { k = dn(76) | 0; pn(k, b); l = k; f[g >> 2] = l; k = f[i >> 2] | 0; if (k >>> 0 < (f[a + 16 >> 2] | 0) >>> 0) { f[g >> 2] = 0; f[k >> 2] = l; f[i >> 2] = k + 4; m = g } else { yg(h, g); m = g } g = f[m >> 2] | 0; f[m >> 2] = 0; if (!g) { u = c; return 1 } Va[f[(f[g >> 2] | 0) + 4 >> 2] & 127](g); u = c; return 1 } g = f[j >> 2] | 0; f[d >> 2] = b; j = g + 4 | 0; m = g + 8 | 0; h = f[m >> 2] | 0; if ((h | 0) == (f[g + 12 >> 2] | 0)) Ci(j, d); else { f[h >> 2] = b; f[m >> 2] = h + 4 } h = f[d >> 2] | 0; b = g + 16 | 0; k = g + 20 | 0; g = f[k >> 2] | 0; i = f[b >> 2] | 0; l = g - i >> 2; a = i; if ((h | 0) < (l | 0)) { n = a; o = h } else { i = h + 1 | 0; f[e >> 2] = -1; p = g; if (i >>> 0 <= l >>> 0) if (i >>> 0 < l >>> 0 ? (g = a + (i << 2) | 0, (g | 0) != (p | 0)) : 0) { f[k >> 2] = p + (~((p + -4 - g | 0) >>> 2) << 2); q = h; r = a } else { q = h; r = a } else { kh(b, i - l | 0, e); q = f[d >> 2] | 0; r = f[b >> 2] | 0 } n = r; o = q } f[n + (o << 2) >> 2] = ((f[m >> 2] | 0) - (f[j >> 2] | 0) >> 2) + -1; u = c; return 1 } function Yf(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; d = c; e = b; g = d - e | 0; h = g >> 2; i = a + 8 | 0; j = f[i >> 2] | 0; k = f[a >> 2] | 0; l = k; if (h >>> 0 > j - k >> 2 >>> 0) { m = k; if (!k) n = j; else { j = a + 4 | 0; o = f[j >> 2] | 0; if ((o | 0) != (l | 0)) f[j >> 2] = o + (~((o + -4 - k | 0) >>> 2) << 2); br(m); f[i >> 2] = 0; f[j >> 2] = 0; f[a >> 2] = 0; n = 0 } if (h >>> 0 > 1073741823) mq(a); j = n >> 1; m = n >> 2 >>> 0 < 536870911 ? (j >>> 0 < h >>> 0 ? h : j) : 1073741823; if (m >>> 0 > 1073741823) mq(a); j = dn(m << 2) | 0; n = a + 4 | 0; f[n >> 2] = j; f[a >> 2] = j; f[i >> 2] = j + (m << 2); if ((g | 0) <= 0) return; Rg(j | 0, b | 0, g | 0) | 0; f[n >> 2] = j + (g >>> 2 << 2); return } g = a + 4 | 0; a = f[g >> 2] | 0; j = a - k >> 2; k = h >>> 0 > j >>> 0; h = k ? b + (j << 2) | 0 : c; c = a; j = a; if ((h | 0) == (b | 0)) p = l; else { a = h + -4 - e | 0; e = b; b = l; while (1) { f[b >> 2] = f[e >> 2]; e = e + 4 | 0; if ((e | 0) == (h | 0)) break; else b = b + 4 | 0 } p = l + ((a >>> 2) + 1 << 2) | 0 } if (k) { k = d - h | 0; if ((k | 0) <= 0) return; Rg(j | 0, h | 0, k | 0) | 0; f[g >> 2] = (f[g >> 2] | 0) + (k >>> 2 << 2); return } else { if ((p | 0) == (c | 0)) return; f[g >> 2] = c + (~((c + -4 - p | 0) >>> 2) << 2); return } } function Zf(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0; g = u; u = u + 96 | 0; h = g + 40 | 0; i = g; Gm(h, d); we(i, c, d); th(h, i); sj(i + 24 | 0, f[i + 28 >> 2] | 0); Dj(i + 12 | 0, f[i + 16 >> 2] | 0); sj(i, f[i + 4 >> 2] | 0); Si(a, h, e); if (!(f[a >> 2] | 0)) { e = a + 4 | 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); f[c + 40 >> 2] = f[h + 40 >> 2]; f[c + 44 >> 2] = f[h + 44 >> 2]; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0 } f[h >> 2] = 2968; sj(h + 28 | 0, f[h + 32 >> 2] | 0); Dj(h + 16 | 0, f[h + 20 >> 2] | 0); sj(h + 4 | 0, f[h + 8 >> 2] | 0); u = g; return } function _f(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; c = f[b >> 2] | 0; d = f[b + 4 >> 2] | 0; e = f[b + 8 >> 2] | 0; b = ((c ^ 318) + 239 ^ d) + 239 ^ e; g = f[a + 4 >> 2] | 0; if (!g) { h = 0; return h | 0 } i = g + -1 | 0; j = (i & g | 0) == 0; if (!j) if (b >>> 0 < g >>> 0) k = b; else k = (b >>> 0) % (g >>> 0) | 0; else k = b & i; l = f[(f[a >> 2] | 0) + (k << 2) >> 2] | 0; if (!l) { h = 0; return h | 0 } a = f[l >> 2] | 0; if (!a) { h = 0; return h | 0 } if (j) { j = a; while (1) { l = f[j + 4 >> 2] | 0; m = (l | 0) == (b | 0); if (!(m | (l & i | 0) == (k | 0))) { h = 0; n = 23; break } if (((m ? (f[j + 8 >> 2] | 0) == (c | 0) : 0) ? (f[j + 12 >> 2] | 0) == (d | 0) : 0) ? (f[j + 16 >> 2] | 0) == (e | 0) : 0) { h = j; n = 23; break } j = f[j >> 2] | 0; if (!j) { h = 0; n = 23; break } } if ((n | 0) == 23) return h | 0 } else o = a; while (1) { a = f[o + 4 >> 2] | 0; if ((a | 0) == (b | 0)) { if (((f[o + 8 >> 2] | 0) == (c | 0) ? (f[o + 12 >> 2] | 0) == (d | 0) : 0) ? (f[o + 16 >> 2] | 0) == (e | 0) : 0) { h = o; n = 23; break } } else { if (a >>> 0 < g >>> 0) p = a; else p = (a >>> 0) % (g >>> 0) | 0; if ((p | 0) != (k | 0)) { h = 0; n = 23; break } } o = f[o >> 2] | 0; if (!o) { h = 0; n = 23; break } } if ((n | 0) == 23) return h | 0; return 0 } function $f(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; e = u; u = u + 16 | 0; g = e; if (!(ih(a, c, d) | 0)) { h = 0; u = e; return h | 0 } if ((b[(f[a + 8 >> 2] | 0) + 24 >> 0] | 0) != 3) { h = 0; u = e; return h | 0 } i = f[c + 48 >> 2] | 0; c = dn(32) | 0; f[g >> 2] = c; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 17; j = c; k = 12932; l = j + 17 | 0; do { b[j >> 0] = b[k >> 0] | 0; j = j + 1 | 0; k = k + 1 | 0 } while ((j | 0) < (l | 0)); b[c + 17 >> 0] = 0; c = i + 16 | 0; k = f[c >> 2] | 0; if (k) { j = c; l = k; a: while (1) { k = l; while (1) { if ((f[k + 16 >> 2] | 0) >= (d | 0)) break; m = f[k + 4 >> 2] | 0; if (!m) { n = j; break a } else k = m } l = f[k >> 2] | 0; if (!l) { n = k; break } else j = k } if (((n | 0) != (c | 0) ? (f[n + 16 >> 2] | 0) <= (d | 0) : 0) ? (d = n + 20 | 0, (sh(d, g) | 0) != 0) : 0) o = yk(d, g, -1) | 0; else p = 12 } else p = 12; if ((p | 0) == 12) o = yk(i, g, -1) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); if ((o | 0) < 1) { h = 0; u = e; return h | 0 } tp(a + 40 | 0, o); h = 1; u = e; return h | 0 } function ag(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; e = c; g = d - e | 0; h = a + 8 | 0; i = f[h >> 2] | 0; j = f[a >> 2] | 0; k = j; if (g >>> 0 > (i - j | 0) >>> 0) { if (!j) l = i; else { i = a + 4 | 0; if ((f[i >> 2] | 0) != (k | 0)) f[i >> 2] = k; br(k); f[h >> 2] = 0; f[i >> 2] = 0; f[a >> 2] = 0; l = 0 } if ((g | 0) < 0) mq(a); i = l << 1; m = l >>> 0 < 1073741823 ? (i >>> 0 < g >>> 0 ? g : i) : 2147483647; if ((m | 0) < 0) mq(a); i = dn(m) | 0; l = a + 4 | 0; f[l >> 2] = i; f[a >> 2] = i; f[h >> 2] = i + m; if ((c | 0) == (d | 0)) return; else { n = c; o = i } do { b[o >> 0] = b[n >> 0] | 0; n = n + 1 | 0; o = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = o } while ((n | 0) != (d | 0)); return } n = a + 4 | 0; a = (f[n >> 2] | 0) - j | 0; j = g >>> 0 > a >>> 0; g = c + a | 0; a = j ? g : d; if ((a | 0) == (c | 0)) p = k; else { o = c; c = k; while (1) { b[c >> 0] = b[o >> 0] | 0; o = o + 1 | 0; if ((o | 0) == (a | 0)) break; else c = c + 1 | 0 } p = k + (a - e) | 0 } if (!j) { if ((f[n >> 2] | 0) == (p | 0)) return; f[n >> 2] = p; return } if ((a | 0) == (d | 0)) return; a = g; g = f[n >> 2] | 0; do { b[g >> 0] = b[a >> 0] | 0; a = a + 1 | 0; g = (f[n >> 2] | 0) + 1 | 0; f[n >> 2] = g } while ((a | 0) != (d | 0)); return } function bg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; d = c >>> 1 & 1431655765 | c << 1 & -1431655766; c = d >>> 2 & 858993459 | d << 2 & -858993460; d = c >>> 4 & 252645135 | c << 4 & -252645136; c = d >>> 8 & 16711935 | d << 8 & -16711936; d = 32 - b | 0; e = (c >>> 16 | c << 16) >>> d; c = e - (e >>> 1 & 1431655765) | 0; g = (c >>> 2 & 858993459) + (c & 858993459) | 0; c = (X((g >>> 4) + g & 252645135, 16843009) | 0) >>> 24; g = b - c | 0; h = f[a >> 2] | 0; i = h; j = Tn(f[i >> 2] | 0, f[i + 4 >> 2] | 0, g | 0, ((g | 0) < 0) << 31 >> 31 | 0) | 0; g = h; f[g >> 2] = j; f[g + 4 >> 2] = I; g = h + 8 | 0; h = g; j = Tn(f[h >> 2] | 0, f[h + 4 >> 2] | 0, c | 0, 0) | 0; c = g; f[c >> 2] = j; f[c + 4 >> 2] = I; c = a + 28 | 0; j = f[c >> 2] | 0; g = 32 - j | 0; h = a + 24 | 0; do if ((g | 0) >= (b | 0)) { i = -1 >>> d << j; k = f[h >> 2] & ~i | i & e << j; f[h >> 2] = k; i = j + b | 0; f[c >> 2] = i; if ((i | 0) != 32) return; i = a + 16 | 0; l = f[i >> 2] | 0; if ((l | 0) == (f[a + 20 >> 2] | 0)) { Ci(a + 12 | 0, h); m = 0; n = 0; break } else { f[l >> 2] = k; f[i >> 2] = l + 4; m = 0; n = 0; break } } else { l = -1 >>> j << j; i = f[h >> 2] & ~l | l & e << j; f[h >> 2] = i; l = a + 16 | 0; k = f[l >> 2] | 0; if ((k | 0) == (f[a + 20 >> 2] | 0)) Ci(a + 12 | 0, h); else { f[k >> 2] = i; f[l >> 2] = k + 4 } k = b - g | 0; m = k; n = -1 >>> (32 - k | 0) & e >>> g } while (0); f[h >> 2] = n; f[c >> 2] = m; return } function cg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0; e = c & 255; g = (d | 0) != 0; a: do if (g & (a & 3 | 0) != 0) { h = c & 255; i = a; j = d; while (1) { if ((b[i >> 0] | 0) == h << 24 >> 24) { k = i; l = j; m = 6; break a } n = i + 1 | 0; o = j + -1 | 0; p = (o | 0) != 0; if (p & (n & 3 | 0) != 0) { i = n; j = o } else { q = n; r = o; s = p; m = 5; break } } } else { q = a; r = d; s = g; m = 5 } while (0); if ((m | 0) == 5) if (s) { k = q; l = r; m = 6 } else { t = q; u = 0 } b: do if ((m | 0) == 6) { q = c & 255; if ((b[k >> 0] | 0) == q << 24 >> 24) { t = k; u = l } else { r = X(e, 16843009) | 0; c: do if (l >>> 0 > 3) { s = k; g = l; while (1) { d = f[s >> 2] ^ r; if ((d & -2139062144 ^ -2139062144) & d + -16843009 | 0) break; d = s + 4 | 0; a = g + -4 | 0; if (a >>> 0 > 3) { s = d; g = a } else { v = d; w = a; m = 11; break c } } x = s; y = g } else { v = k; w = l; m = 11 } while (0); if ((m | 0) == 11) if (!w) { t = v; u = 0; break } else { x = v; y = w } while (1) { if ((b[x >> 0] | 0) == q << 24 >> 24) { t = x; u = y; break b } r = x + 1 | 0; y = y + -1 | 0; if (!y) { t = r; u = 0; break } else x = r } } } while (0); return (u | 0 ? t : 0) | 0 } function dg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = f[a >> 2] | 0; g = e; do if ((d | 0) == (e | 0)) { h = a + 8 | 0; i = f[h >> 2] | 0; j = a + 12 | 0; k = f[j >> 2] | 0; l = k; if (i >>> 0 < k >>> 0) { k = i; m = ((l - k >> 2) + 1 | 0) / 2 | 0; n = i + (m << 2) | 0; o = k - d | 0; k = o >> 2; p = n + (0 - k << 2) | 0; if (!k) { q = n; r = i } else { Xl(p | 0, d | 0, o | 0) | 0; q = p; r = f[h >> 2] | 0 } f[c >> 2] = q; f[h >> 2] = r + (m << 2); s = q; break } m = l - g >> 1; l = (m | 0) == 0 ? 1 : m; if (l >>> 0 > 1073741823) { m = ra(8) | 0; Wo(m, 14941); f[m >> 2] = 6944; va(m | 0, 1080, 114) } m = dn(l << 2) | 0; p = m; o = m + ((l + 3 | 0) >>> 2 << 2) | 0; n = o; k = m + (l << 2) | 0; if ((d | 0) == (i | 0)) { t = n; u = d } else { l = o; m = n; v = d; do { f[l >> 2] = f[v >> 2]; l = m + 4 | 0; m = l; v = v + 4 | 0 } while ((v | 0) != (i | 0)); t = m; u = f[a >> 2] | 0 } f[a >> 2] = p; f[c >> 2] = n; f[h >> 2] = t; f[j >> 2] = k; if (!u) s = o; else { br(u); s = f[c >> 2] | 0 } } else s = d; while (0); f[s + -4 >> 2] = f[b >> 2]; f[c >> 2] = (f[c >> 2] | 0) + -4; return } function eg(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; i = a + 4 | 0; if ((f[i >> 2] | 0) == -1) { j = 0; u = d; return j | 0 } k = f[a + 8 >> 2] | 0; l = c + 16 | 0; m = l; n = f[m >> 2] | 0; o = f[m + 4 >> 2] | 0; if (!((o | 0) > 0 | (o | 0) == 0 & n >>> 0 > 0)) { m = (f[a + 12 >> 2] | 0) - k | 0; p = c + 4 | 0; f[g >> 2] = f[p >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, k, k + m | 0) | 0; m = l; k = f[m >> 2] | 0; q = f[m + 4 >> 2] | 0; m = a + 20 | 0; if ((q | 0) > 0 | (q | 0) == 0 & k >>> 0 > 0) { r = q; s = k; t = g } else { f[g >> 2] = f[p >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, m, m + 4 | 0) | 0; m = l; r = f[m + 4 >> 2] | 0; s = f[m >> 2] | 0; t = g } } else { r = o; s = n; t = g } b[h >> 0] = f[i >> 2]; if (!((r | 0) > 0 | (r | 0) == 0 & s >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0 } j = 1; u = d; return j | 0 } function fg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; i = a + 8 | 0; a = f[i >> 2] | 0; j = f[a + 40 >> 2] | 0; k = _q((j | 0) > -1 ? j : -1) | 0; l = c + 4 | 0; m = f[l >> 2] | 0; n = f[c >> 2] | 0; if ((m | 0) == (n | 0)) { $q(k); u = e; return 1 } o = d + 16 | 0; p = d + 4 | 0; q = k + j | 0; j = 0; r = n; n = a; s = a; a = m; while (1) { m = f[r + (j << 2) >> 2] | 0; if (!(b[n + 84 >> 0] | 0)) t = f[(f[n + 68 >> 2] | 0) + (m << 2) >> 2] | 0; else t = m; m = s + 48 | 0; v = f[m >> 2] | 0; w = f[m + 4 >> 2] | 0; m = s + 40 | 0; x = f[m >> 2] | 0; y = on(x | 0, f[m + 4 >> 2] | 0, t | 0, 0) | 0; m = Tn(y | 0, I | 0, v | 0, w | 0) | 0; Rg(k | 0, (f[f[s >> 2] >> 2] | 0) + m | 0, x | 0) | 0; x = o; m = f[x + 4 >> 2] | 0; if ((m | 0) > 0 | (m | 0) == 0 & (f[x >> 2] | 0) >>> 0 > 0) { z = r; A = a } else { f[h >> 2] = f[p >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, k, q) | 0; z = f[c >> 2] | 0; A = f[l >> 2] | 0 } x = j + 1 | 0; if (x >>> 0 >= A - z >> 2 >>> 0) break; m = f[i >> 2] | 0; j = x; r = z; n = m; s = m; a = A } $q(k); u = e; return 1 } function gg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; d = (f[b >> 2] | 0) * 3 | 0; if ((d | 0) == -1) { e = 0; g = -1; f[c >> 2] = g; return e | 0 } b = f[a + 12 >> 2] | 0; h = f[b + 12 >> 2] | 0; if ((f[h + (d << 2) >> 2] | 0) == -1) { e = 0; g = d; f[c >> 2] = g; return e | 0 } i = f[b >> 2] | 0; b = f[a + 152 >> 2] | 0; if ((f[b + (f[i + (d << 2) >> 2] << 2) >> 2] | 0) == -1) { a = d + 1 | 0; j = ((a >>> 0) % 3 | 0 | 0) == 0 ? d + -2 | 0 : a; if ((j | 0) == -1) { e = 0; g = -1; f[c >> 2] = g; return e | 0 } if ((f[h + (j << 2) >> 2] | 0) == -1) { e = 0; g = j; f[c >> 2] = g; return e | 0 } if ((f[b + (f[i + (j << 2) >> 2] << 2) >> 2] | 0) == -1) { a = j + 1 | 0; k = ((a >>> 0) % 3 | 0 | 0) == 0 ? j + -2 | 0 : a; if ((k | 0) == -1) { e = 0; g = -1; f[c >> 2] = g; return e | 0 } if ((f[h + (k << 2) >> 2] | 0) == -1) { e = 0; g = k; f[c >> 2] = g; return e | 0 } if ((f[b + (f[i + (k << 2) >> 2] << 2) >> 2] | 0) == -1) { i = k + 1 | 0; e = 1; g = ((i >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : i; f[c >> 2] = g; return e | 0 } else l = k } else l = j } else l = d; while (1) { d = (((l >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + l | 0; if ((d | 0) == -1) break; j = f[h + (d << 2) >> 2] | 0; if ((j | 0) == -1) break; d = j + (((j >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((d | 0) == -1) break; else l = d } e = 0; g = (((l >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + l | 0; f[c >> 2] = g; return e | 0 } function hg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; e = a + 4 | 0; g = f[e >> 2] | 0; if (!g) { f[c >> 2] = e; h = e; return h | 0 } e = b[d + 11 >> 0] | 0; i = e << 24 >> 24 < 0; j = i ? f[d + 4 >> 2] | 0 : e & 255; e = i ? f[d >> 2] | 0 : d; d = a + 4 | 0; a = g; while (1) { g = a + 16 | 0; i = b[g + 11 >> 0] | 0; k = i << 24 >> 24 < 0; l = k ? f[a + 20 >> 2] | 0 : i & 255; i = l >>> 0 < j >>> 0; m = i ? l : j; if ((m | 0) != 0 ? (n = Pk(e, k ? f[g >> 2] | 0 : g, m) | 0, (n | 0) != 0) : 0) if ((n | 0) < 0) o = 8; else o = 10; else if (j >>> 0 < l >>> 0) o = 8; else o = 10; if ((o | 0) == 8) { o = 0; n = f[a >> 2] | 0; if (!n) { o = 9; break } else { p = a; q = n } } else if ((o | 0) == 10) { o = 0; n = j >>> 0 < l >>> 0 ? j : l; if ((n | 0) != 0 ? (l = Pk(k ? f[g >> 2] | 0 : g, e, n) | 0, (l | 0) != 0) : 0) { if ((l | 0) >= 0) { o = 16; break } } else o = 12; if ((o | 0) == 12 ? (o = 0, !i) : 0) { o = 16; break } r = a + 4 | 0; i = f[r >> 2] | 0; if (!i) { o = 15; break } else { p = r; q = i } } d = p; a = q } if ((o | 0) == 9) { f[c >> 2] = a; h = a; return h | 0 } else if ((o | 0) == 15) { f[c >> 2] = a; h = r; return h | 0 } else if ((o | 0) == 16) { f[c >> 2] = a; h = d; return h | 0 } return 0 } function ig(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0; d = u; u = u + 32 | 0; e = d + 24 | 0; g = d + 16 | 0; h = d + 8 | 0; i = d; j = a + 4 | 0; k = f[j >> 2] | 0; l = f[b >> 2] | 0; m = f[b + 4 >> 2] | 0; b = f[c >> 2] | 0; n = f[c + 4 >> 2] | 0; c = b - l << 3; f[j >> 2] = k - m + n + c; j = (f[a >> 2] | 0) + (k >>> 5 << 2) | 0; a = k & 31; k = j; if ((m | 0) != (a | 0)) { f[e >> 2] = l; f[e + 4 >> 2] = m; f[g >> 2] = b; f[g + 4 >> 2] = n; f[h >> 2] = k; f[h + 4 >> 2] = a; ke(i, e, g, h); u = d; return } h = n - m + c | 0; c = l; if ((h | 0) > 0) { if (!m) { o = h; p = j; q = 0; r = l; s = c } else { l = 32 - m | 0; n = (h | 0) < (l | 0) ? h : l; g = -1 >>> (l - n | 0) & -1 << m; f[j >> 2] = f[j >> 2] & ~g | f[c >> 2] & g; g = n + m | 0; l = c + 4 | 0; o = h - n | 0; p = j + (g >>> 5 << 2) | 0; q = g & 31; r = l; s = l } l = (o | 0) / 32 | 0; Xl(p | 0, r | 0, l << 2 | 0) | 0; r = o - (l << 5) | 0; o = p + (l << 2) | 0; p = o; if ((r | 0) > 0) { g = -1 >>> (32 - r | 0); f[o >> 2] = f[o >> 2] & ~g | f[s + (l << 2) >> 2] & g; t = r; v = p } else { t = q; v = p } } else { t = m; v = k } f[i >> 2] = v; f[i + 4 >> 2] = t; u = d; return } function jg(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; g = u; u = u + 16 | 0; h = g; i = c + 4 | 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; j = dn(16) | 0; f[h >> 2] = j; f[h + 8 >> 2] = -2147483632; f[h + 4 >> 2] = 15; k = j; l = 12916; m = k + 15 | 0; do { b[k >> 0] = b[l >> 0] | 0; k = k + 1 | 0; l = l + 1 | 0 } while ((k | 0) < (m | 0)); b[j + 15 >> 0] = 0; j = yk(i, h, -1) | 0; if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); switch (j | 0) { case -1: { if ((Yh(i) | 0) == 10) n = 6; else n = 5; break } case 1: { n = 5; break } default: n = 6 }if ((n | 0) == 5) { j = dn(68) | 0; Xo(j); o = j } else if ((n | 0) == 6) { n = dn(64) | 0; Gp(n); o = n } vo(o, d); Ad(a, o, i, e); if (f[a >> 2] | 0) { p = f[o >> 2] | 0; q = p + 4 | 0; r = f[q >> 2] | 0; Va[r & 127](o); u = g; return } e = a + 4 | 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); f[c + 40 >> 2] = f[o + 52 >> 2]; f[c + 44 >> 2] = f[o + 60 >> 2]; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; p = f[o >> 2] | 0; q = p + 4 | 0; r = f[q >> 2] | 0; Va[r & 127](o); u = g; return } function kg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 12 | 0; g = f[e >> 2] | 0; h = g; do if ((d | 0) == (g | 0)) { i = a + 4 | 0; j = f[i >> 2] | 0; k = f[a >> 2] | 0; l = k; if (j >>> 0 > k >>> 0) { m = j; n = ((m - l >> 2) + 1 | 0) / -2 | 0; o = j + (n << 2) | 0; p = d - m | 0; m = p >> 2; if (!m) q = j; else { Xl(o | 0, j | 0, p | 0) | 0; q = f[i >> 2] | 0 } p = o + (m << 2) | 0; f[c >> 2] = p; f[i >> 2] = q + (n << 2); r = p; break } p = h - l >> 1; l = (p | 0) == 0 ? 1 : p; if (l >>> 0 > 1073741823) { p = ra(8) | 0; Wo(p, 14941); f[p >> 2] = 6944; va(p | 0, 1080, 114) } p = dn(l << 2) | 0; n = p; m = p + (l >>> 2 << 2) | 0; o = m; s = p + (l << 2) | 0; if ((j | 0) == (d | 0)) { t = o; u = k } else { k = m; m = o; l = j; do { f[k >> 2] = f[l >> 2]; k = m + 4 | 0; m = k; l = l + 4 | 0 } while ((l | 0) != (d | 0)); t = m; u = f[a >> 2] | 0 } f[a >> 2] = n; f[i >> 2] = o; f[c >> 2] = t; f[e >> 2] = s; if (!u) r = t; else { br(u); r = f[c >> 2] | 0 } } else r = d; while (0); f[r >> 2] = f[b >> 2]; f[c >> 2] = (f[c >> 2] | 0) + 4; return } function lg(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; e = a + 8 | 0; g = a + 12 | 0; h = f[g >> 2] | 0; $j(f[a + 4 >> 2] | 0, (f[h + 56 >> 2] | 0) - (f[h + 52 >> 2] | 0) >> 2); h = a + 76 | 0; a = f[h >> 2] | 0; if (!a) { i = f[(f[g >> 2] | 0) + 64 >> 2] | 0; g = (f[i + 4 >> 2] | 0) - (f[i >> 2] | 0) >> 2; i = (g >>> 0) / 3 | 0; if (g >>> 0 <= 2) { j = 1; u = b; return j | 0 } g = 0; while (1) { f[d >> 2] = g * 3; f[c >> 2] = f[d >> 2]; g = g + 1 | 0; if (!(Tb(e, c) | 0)) { j = 0; k = 10; break } if ((g | 0) >= (i | 0)) { j = 1; k = 10; break } } if ((k | 0) == 10) { u = b; return j | 0 } } else { i = f[a >> 2] | 0; if ((f[a + 4 >> 2] | 0) == (i | 0)) { j = 1; u = b; return j | 0 } a = 0; g = i; while (1) { f[d >> 2] = f[g + (a << 2) >> 2]; f[c >> 2] = f[d >> 2]; a = a + 1 | 0; if (!(Tb(e, c) | 0)) { j = 0; k = 10; break } i = f[h >> 2] | 0; g = f[i >> 2] | 0; if (a >>> 0 >= (f[i + 4 >> 2] | 0) - g >> 2 >>> 0) { j = 1; k = 10; break } } if ((k | 0) == 10) { u = b; return j | 0 } } return 0 } function mg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; h = a + 12 | 0; i = a + 4 | 0; j = f[i >> 2] | 0; if ((j | 0) == (f[a + 8 >> 2] | 0)) { Ci(a, h); k = f[i >> 2] | 0 } else { f[j >> 2] = f[h >> 2]; l = j + 4 | 0; f[i >> 2] = l; k = l } l = f[a >> 2] | 0; f[g >> 2] = k - l; k = b + 16 | 0; j = k; m = f[j + 4 >> 2] | 0; if (!((m | 0) > 0 | (m | 0) == 0 & (f[j >> 2] | 0) >>> 0 > 0)) { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; j = f[a >> 2] | 0; m = f[g >> 2] | 0; g = k; k = f[g + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & (f[g >> 2] | 0) >>> 0 > 0) { n = j; o = e } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, j, j + m | 0) | 0; n = f[a >> 2] | 0; o = e } } else { n = l; o = e } e = f[i >> 2] | 0; if ((e | 0) == (n | 0)) { f[h >> 2] = 0; p = a + 16 | 0; f[p >> 2] = 0; u = c; return } f[i >> 2] = e + (~((e + -4 - n | 0) >>> 2) << 2); f[h >> 2] = 0; p = a + 16 | 0; f[p >> 2] = 0; u = c; return } function ng(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 4 | 0; g = f[e >> 2] | 0; h = g; if (d - g >> 2 >>> 0 >= b >>> 0) { hj(g | 0, 0, b << 2 | 0) | 0; f[e >> 2] = g + (b << 2); return } i = f[a >> 2] | 0; j = g - i >> 2; g = j + b | 0; k = i; if (g >>> 0 > 1073741823) mq(a); l = d - i | 0; d = l >> 1; m = l >> 2 >>> 0 < 536870911 ? (d >>> 0 < g >>> 0 ? g : d) : 1073741823; do if (m) if (m >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { n = dn(m << 2) | 0; break } else n = 0; while (0); d = n + (j << 2) | 0; hj(d | 0, 0, b << 2 | 0) | 0; b = d; j = n + (m << 2) | 0; m = n + (g << 2) | 0; if ((h | 0) == (k | 0)) { o = b; p = i; q = h } else { i = h; h = b; b = d; do { i = i + -4 | 0; d = f[i >> 2] | 0; f[i >> 2] = 0; f[b + -4 >> 2] = d; b = h + -4 | 0; h = b } while ((i | 0) != (k | 0)); o = h; p = f[a >> 2] | 0; q = f[e >> 2] | 0 } f[a >> 2] = o; f[e >> 2] = m; f[c >> 2] = j; j = p; if ((q | 0) != (j | 0)) { c = q; do { c = c + -4 | 0; q = f[c >> 2] | 0; f[c >> 2] = 0; if (q | 0) Va[f[(f[q >> 2] | 0) + 4 >> 2] & 127](q) } while ((c | 0) != (j | 0)) } if (!p) return; br(p); return } function og(a) { a = a | 0; lk(a); lk(a + 32 | 0); lk(a + 64 | 0); lk(a + 96 | 0); lk(a + 128 | 0); lk(a + 160 | 0); lk(a + 192 | 0); lk(a + 224 | 0); lk(a + 256 | 0); lk(a + 288 | 0); lk(a + 320 | 0); lk(a + 352 | 0); lk(a + 384 | 0); lk(a + 416 | 0); lk(a + 448 | 0); lk(a + 480 | 0); lk(a + 512 | 0); lk(a + 544 | 0); lk(a + 576 | 0); lk(a + 608 | 0); lk(a + 640 | 0); lk(a + 672 | 0); lk(a + 704 | 0); lk(a + 736 | 0); lk(a + 768 | 0); lk(a + 800 | 0); lk(a + 832 | 0); lk(a + 864 | 0); lk(a + 896 | 0); lk(a + 928 | 0); lk(a + 960 | 0); lk(a + 992 | 0); lk(a + 1024 | 0); return } function pg(a, c, d, e, g, h) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = $(h); var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; i = u; u = u + 16 | 0; j = i; k = i + 4 | 0; f[j >> 2] = c; c = a + 4 | 0; a = dn(32) | 0; f[k >> 2] = a; f[k + 8 >> 2] = -2147483616; f[k + 4 >> 2] = 17; l = a; m = 12932; n = l + 17 | 0; do { b[l >> 0] = b[m >> 0] | 0; l = l + 1 | 0; m = m + 1 | 0 } while ((l | 0) < (n | 0)); b[a + 17 >> 0] = 0; Nj(wd(c, j) | 0, k, d); if ((b[k + 11 >> 0] | 0) < 0) br(f[k >> 2] | 0); d = dn(32) | 0; f[k >> 2] = d; f[k + 8 >> 2] = -2147483616; f[k + 4 >> 2] = 19; l = d; m = 13005; n = l + 19 | 0; do { b[l >> 0] = b[m >> 0] | 0; l = l + 1 | 0; m = m + 1 | 0 } while ((l | 0) < (n | 0)); b[d + 19 >> 0] = 0; ci(wd(c, j) | 0, k, g, e); if ((b[k + 11 >> 0] | 0) < 0) br(f[k >> 2] | 0); e = dn(32) | 0; f[k >> 2] = e; f[k + 8 >> 2] = -2147483616; f[k + 4 >> 2] = 18; l = e; m = 13025; n = l + 18 | 0; do { b[l >> 0] = b[m >> 0] | 0; l = l + 1 | 0; m = m + 1 | 0 } while ((l | 0) < (n | 0)); b[e + 18 >> 0] = 0; Lj(wd(c, j) | 0, k, h); if ((b[k + 11 >> 0] | 0) >= 0) { u = i; return } br(f[k >> 2] | 0); u = i; return } function qg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; d = c; e = b; g = d - e | 0; h = g >> 2; i = a + 8 | 0; j = f[i >> 2] | 0; k = f[a >> 2] | 0; l = k; if (h >>> 0 <= j - k >> 2 >>> 0) { m = a + 4 | 0; n = (f[m >> 2] | 0) - k >> 2; o = h >>> 0 > n >>> 0; p = o ? b + (n << 2) | 0 : c; c = p; n = c - e | 0; e = n >> 2; if (e | 0) Xl(k | 0, b | 0, n | 0) | 0; n = l + (e << 2) | 0; if (o) { o = d - c | 0; if ((o | 0) <= 0) return; Rg(f[m >> 2] | 0, p | 0, o | 0) | 0; f[m >> 2] = (f[m >> 2] | 0) + (o >>> 2 << 2); return } else { o = f[m >> 2] | 0; if ((o | 0) == (n | 0)) return; f[m >> 2] = o + (~((o + -4 - n | 0) >>> 2) << 2); return } } n = k; if (!k) q = j; else { j = a + 4 | 0; o = f[j >> 2] | 0; if ((o | 0) != (l | 0)) f[j >> 2] = o + (~((o + -4 - k | 0) >>> 2) << 2); br(n); f[i >> 2] = 0; f[j >> 2] = 0; f[a >> 2] = 0; q = 0 } if (h >>> 0 > 1073741823) mq(a); j = q >> 1; n = q >> 2 >>> 0 < 536870911 ? (j >>> 0 < h >>> 0 ? h : j) : 1073741823; if (n >>> 0 > 1073741823) mq(a); j = dn(n << 2) | 0; h = a + 4 | 0; f[h >> 2] = j; f[a >> 2] = j; f[i >> 2] = j + (n << 2); if ((g | 0) <= 0) return; Rg(j | 0, b | 0, g | 0) | 0; f[h >> 2] = j + (g >>> 2 << 2); return } function rg(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0.0, p = 0, q = 0.0, r = 0.0, s = 0.0, t = 0, v = 0.0; e = u; u = u + 16 | 0; g = e; h = c + 1 | 0; f[g >> 2] = 0; i = g + 4 | 0; f[i >> 2] = 0; f[g + 8 >> 2] = 0; do if (h) if (h >>> 0 > 1073741823) mq(g); else { j = dn(h << 2) | 0; f[g >> 2] = j; k = j + (h << 2) | 0; f[g + 8 >> 2] = k; hj(j | 0, 0, (c << 2) + 4 | 0) | 0; f[i >> 2] = k; l = j; m = k; n = j; break } else { l = 0; m = 0; n = 0 } while (0); if ((b | 0) > 0) { g = 0; do { j = l + (f[a + (g << 2) >> 2] << 2) | 0; f[j >> 2] = (f[j >> 2] | 0) + 1; g = g + 1 | 0 } while ((g | 0) != (b | 0)) } o = +(b | 0); if ((c | 0) < 0) { p = 0; q = 0.0 } else { c = 0; r = 0.0; b = 0; while (1) { g = f[l + (b << 2) >> 2] | 0; s = +(g | 0); if ((g | 0) > 0) { t = c + 1 | 0; v = r + +Fg(s / o) * s } else { t = c; v = r } b = b + 1 | 0; if ((b | 0) == (h | 0)) { p = t; q = v; break } else { c = t; r = v } } } if (d | 0) f[d >> 2] = p; v = -q; p = ~~v >>> 0; d = +K(v) >= 1.0 ? (v > 0.0 ? ~~+Y(+J(v / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((v - +(~~v >>> 0)) / 4294967296.0) >>> 0) : 0; if (!l) { I = d; u = e; return p | 0 } if ((m | 0) != (l | 0)) f[i >> 2] = m + (~((m + -4 - l | 0) >>> 2) << 2); br(n); I = d; u = e; return p | 0 } function sg(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; b = u; u = u + 16 | 0; c = b + 4 | 0; d = b; e = a + 8 | 0; g = a + 12 | 0; h = f[g >> 2] | 0; $j(f[a + 4 >> 2] | 0, (f[h + 28 >> 2] | 0) - (f[h + 24 >> 2] | 0) >> 2); h = a + 76 | 0; a = f[h >> 2] | 0; if (!a) { i = f[g >> 2] | 0; g = (f[i + 4 >> 2] | 0) - (f[i >> 2] | 0) >> 2; i = (g >>> 0) / 3 | 0; if (g >>> 0 <= 2) { j = 1; u = b; return j | 0 } g = 0; while (1) { f[d >> 2] = g * 3; f[c >> 2] = f[d >> 2]; g = g + 1 | 0; if (!(Wb(e, c) | 0)) { j = 0; k = 10; break } if ((g | 0) >= (i | 0)) { j = 1; k = 10; break } } if ((k | 0) == 10) { u = b; return j | 0 } } else { i = f[a >> 2] | 0; if ((f[a + 4 >> 2] | 0) == (i | 0)) { j = 1; u = b; return j | 0 } a = 0; g = i; while (1) { f[d >> 2] = f[g + (a << 2) >> 2]; f[c >> 2] = f[d >> 2]; a = a + 1 | 0; if (!(Wb(e, c) | 0)) { j = 0; k = 10; break } i = f[h >> 2] | 0; g = f[i >> 2] | 0; if (a >>> 0 >= (f[i + 4 >> 2] | 0) - g >> 2 >>> 0) { j = 1; k = 10; break } } if ((k | 0) == 10) { u = b; return j | 0 } } return 0 } function tg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; i = dn(32) | 0; f[a >> 2] = i; f[a + 4 >> 2] = c + 4; c = a + 8 | 0; b[c >> 0] = 0; f[i + 16 >> 2] = f[d >> 2]; a = i + 20 | 0; f[i + 24 >> 2] = 0; f[i + 28 >> 2] = 0; j = i + 24 | 0; f[a >> 2] = j; i = f[d + 4 >> 2] | 0; k = d + 8 | 0; if ((i | 0) == (k | 0)) { b[c >> 0] = 1; u = e; return } d = j; j = i; while (1) { i = j + 16 | 0; f[h >> 2] = d; f[g >> 2] = f[h >> 2]; Wg(a, g, i, i) | 0; i = f[j + 4 >> 2] | 0; if (!i) { l = j + 8 | 0; m = f[l >> 2] | 0; if ((f[m >> 2] | 0) == (j | 0)) n = m; else { m = l; do { l = f[m >> 2] | 0; m = l + 8 | 0; o = f[m >> 2] | 0 } while ((f[o >> 2] | 0) != (l | 0)); n = o } } else { m = i; while (1) { o = f[m >> 2] | 0; if (!o) break; else m = o } n = m } if ((n | 0) == (k | 0)) break; else j = n } b[c >> 0] = 1; u = e; return } function ug(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = u; u = u + 16 | 0; e = d; f[e >> 2] = b; g = a + 8 | 0; if (((f[a + 12 >> 2] | 0) - (f[g >> 2] | 0) >> 2 | 0) <= (b | 0)) jh(g, b + 1 | 0); h = f[(f[c >> 2] | 0) + 56 >> 2] | 0; do if ((h | 0) < 5) { i = a + 20 + (h * 12 | 0) + 4 | 0; j = f[i >> 2] | 0; if ((j | 0) == (f[a + 20 + (h * 12 | 0) + 8 >> 2] | 0)) { Ci(a + 20 + (h * 12 | 0) | 0, e); break } else { f[j >> 2] = b; f[i >> 2] = j + 4; break } } while (0); b = f[c >> 2] | 0; h = f[e >> 2] | 0; f[b + 60 >> 2] = h; e = (f[g >> 2] | 0) + (h << 2) | 0; f[c >> 2] = 0; c = f[e >> 2] | 0; f[e >> 2] = b; if (!c) { u = d; return } b = c + 88 | 0; e = f[b >> 2] | 0; f[b >> 2] = 0; if (e | 0) { b = f[e + 8 >> 2] | 0; if (b | 0) { h = e + 12 | 0; if ((f[h >> 2] | 0) != (b | 0)) f[h >> 2] = b; br(b) } br(e) } e = f[c + 68 >> 2] | 0; if (e | 0) { b = c + 72 | 0; h = f[b >> 2] | 0; if ((h | 0) != (e | 0)) f[b >> 2] = h + (~((h + -4 - e | 0) >>> 2) << 2); br(e) } e = c + 64 | 0; h = f[e >> 2] | 0; f[e >> 2] = 0; if (h | 0) { e = f[h >> 2] | 0; if (e | 0) { b = h + 4 | 0; if ((f[b >> 2] | 0) != (e | 0)) f[b >> 2] = e; br(e) } br(h) } br(c); u = d; return } function vg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0; d = u; u = u + 48 | 0; e = d + 16 | 0; g = d; h = d + 32 | 0; i = a + 28 | 0; j = f[i >> 2] | 0; f[h >> 2] = j; k = a + 20 | 0; l = (f[k >> 2] | 0) - j | 0; f[h + 4 >> 2] = l; f[h + 8 >> 2] = b; f[h + 12 >> 2] = c; b = l + c | 0; l = a + 60 | 0; f[g >> 2] = f[l >> 2]; f[g + 4 >> 2] = h; f[g + 8 >> 2] = 2; j = ro(Aa(146, g | 0) | 0) | 0; a: do if ((b | 0) != (j | 0)) { g = 2; m = b; n = h; o = j; while (1) { if ((o | 0) < 0) break; m = m - o | 0; p = f[n + 4 >> 2] | 0; q = o >>> 0 > p >>> 0; r = q ? n + 8 | 0 : n; s = g + (q << 31 >> 31) | 0; t = o - (q ? p : 0) | 0; f[r >> 2] = (f[r >> 2] | 0) + t; p = r + 4 | 0; f[p >> 2] = (f[p >> 2] | 0) - t; f[e >> 2] = f[l >> 2]; f[e + 4 >> 2] = r; f[e + 8 >> 2] = s; o = ro(Aa(146, e | 0) | 0) | 0; if ((m | 0) == (o | 0)) { v = 3; break a } else { g = s; n = r } } f[a + 16 >> 2] = 0; f[i >> 2] = 0; f[k >> 2] = 0; f[a >> 2] = f[a >> 2] | 32; if ((g | 0) == 2) w = 0; else w = c - (f[n + 4 >> 2] | 0) | 0 } else v = 3; while (0); if ((v | 0) == 3) { v = f[a + 44 >> 2] | 0; f[a + 16 >> 2] = v + (f[a + 48 >> 2] | 0); a = v; f[i >> 2] = a; f[k >> 2] = a; w = c } u = d; return w | 0 } function wg(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; f[a >> 2] = 5880; b = f[a + 68 >> 2] | 0; if (b | 0) { c = a + 72 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 56 >> 2] | 0; if (b | 0) { d = a + 60 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 44 >> 2] | 0; if (b | 0) { c = a + 48 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 32 >> 2] | 0; if (b | 0) { d = a + 36 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 20 >> 2] | 0; if (b | 0) { c = a + 24 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } Sh(a + 8 | 0); b = a + 4 | 0; a = f[b >> 2] | 0; f[b >> 2] = 0; if (!a) return; b = a + 40 | 0; d = f[b >> 2] | 0; if (d | 0) { c = a + 44 | 0; e = f[c >> 2] | 0; if ((e | 0) == (d | 0)) g = d; else { h = e; do { e = h + -4 | 0; f[c >> 2] = e; i = f[e >> 2] | 0; f[e >> 2] = 0; if (i | 0) { Qi(i); br(i) } h = f[c >> 2] | 0 } while ((h | 0) != (d | 0)); g = f[b >> 2] | 0 } br(g) } Qi(a); br(a); return } function xg(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; c = a + 12 | 0; d = f[a >> 2] | 0; e = a + 8 | 0; g = f[e >> 2] | 0; h = (g | 0) == -1; if (!(b[c >> 0] | 0)) { do if (((!h ? (i = (((g >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + g | 0, (i | 0) != -1) : 0) ? (f[(f[d >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) == 0 : 0) ? (j = f[(f[(f[d + 64 >> 2] | 0) + 12 >> 2] | 0) + (i << 2) >> 2] | 0, (j | 0) != -1) : 0) if (!((j >>> 0) % 3 | 0)) { k = j + 2 | 0; break } else { k = j + -1 | 0; break } else k = -1; while (0); f[e >> 2] = k; return } k = g + 1 | 0; if (((!h ? (h = ((k >>> 0) % 3 | 0 | 0) == 0 ? g + -2 | 0 : k, (h | 0) != -1) : 0) ? (f[(f[d >> 2] | 0) + (h >>> 5 << 2) >> 2] & 1 << (h & 31) | 0) == 0 : 0) ? (k = f[(f[(f[d + 64 >> 2] | 0) + 12 >> 2] | 0) + (h << 2) >> 2] | 0, h = k + 1 | 0, (k | 0) != -1) : 0) { g = ((h >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : h; f[e >> 2] = g; if ((g | 0) != -1) { if ((g | 0) != (f[a + 4 >> 2] | 0)) return; f[e >> 2] = -1; return } } else f[e >> 2] = -1; g = f[a + 4 >> 2] | 0; do if ((((g | 0) != -1 ? (a = (((g >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + g | 0, (a | 0) != -1) : 0) ? (f[(f[d >> 2] | 0) + (a >>> 5 << 2) >> 2] & 1 << (a & 31) | 0) == 0 : 0) ? (h = f[(f[(f[d + 64 >> 2] | 0) + 12 >> 2] | 0) + (a << 2) >> 2] | 0, (h | 0) != -1) : 0) if (!((h >>> 0) % 3 | 0)) { l = h + 2 | 0; break } else { l = h + -1 | 0; break } else l = -1; while (0); f[e >> 2] = l; b[c >> 0] = 0; return } function yg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = (f[c >> 2] | 0) - d >> 2; g = e + 1 | 0; if (g >>> 0 > 1073741823) mq(a); h = a + 8 | 0; i = (f[h >> 2] | 0) - d | 0; d = i >> 1; j = i >> 2 >>> 0 < 536870911 ? (d >>> 0 < g >>> 0 ? g : d) : 1073741823; do if (j) if (j >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { k = dn(j << 2) | 0; break } else k = 0; while (0); d = k + (e << 2) | 0; e = d; g = k + (j << 2) | 0; j = f[b >> 2] | 0; f[b >> 2] = 0; f[d >> 2] = j; j = d + 4 | 0; b = f[a >> 2] | 0; k = f[c >> 2] | 0; if ((k | 0) == (b | 0)) { l = e; m = b; n = b } else { i = k; k = e; e = d; do { i = i + -4 | 0; d = f[i >> 2] | 0; f[i >> 2] = 0; f[e + -4 >> 2] = d; e = k + -4 | 0; k = e } while ((i | 0) != (b | 0)); l = k; m = f[a >> 2] | 0; n = f[c >> 2] | 0 } f[a >> 2] = l; f[c >> 2] = j; f[h >> 2] = g; g = m; if ((n | 0) != (g | 0)) { h = n; do { h = h + -4 | 0; n = f[h >> 2] | 0; f[h >> 2] = 0; if (n | 0) Va[f[(f[n >> 2] | 0) + 4 >> 2] & 127](n) } while ((h | 0) != (g | 0)) } if (!m) return; br(m); return } function zg(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = a + 4 | 0; a = f[d >> 2] | 0; do if (a | 0) { e = b[c + 11 >> 0] | 0; g = e << 24 >> 24 < 0; h = g ? f[c + 4 >> 2] | 0 : e & 255; e = g ? f[c >> 2] | 0 : c; g = d; i = a; a: while (1) { j = i; while (1) { k = j + 16 | 0; l = b[k + 11 >> 0] | 0; m = l << 24 >> 24 < 0; n = m ? f[j + 20 >> 2] | 0 : l & 255; l = h >>> 0 < n >>> 0 ? h : n; if ((l | 0) != 0 ? (o = Pk(m ? f[k >> 2] | 0 : k, e, l) | 0, (o | 0) != 0) : 0) { if ((o | 0) >= 0) break } else p = 6; if ((p | 0) == 6 ? (p = 0, n >>> 0 >= h >>> 0) : 0) break; n = f[j + 4 >> 2] | 0; if (!n) { q = g; break a } else j = n } i = f[j >> 2] | 0; if (!i) { q = j; break } else g = j } if ((q | 0) != (d | 0)) { g = q + 16 | 0; i = b[g + 11 >> 0] | 0; n = i << 24 >> 24 < 0; o = n ? f[q + 20 >> 2] | 0 : i & 255; i = o >>> 0 < h >>> 0 ? o : h; if (i | 0 ? (l = Pk(e, n ? f[g >> 2] | 0 : g, i) | 0, l | 0) : 0) { if ((l | 0) < 0) break; else r = q; return r | 0 } if (h >>> 0 >= o >>> 0) { r = q; return r | 0 } } } while (0); r = d; return r | 0 } function Ag(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = a + 4 | 0; h = f[g >> 2] | 0; if (((e - h | 0) / 12 | 0) >>> 0 >= b >>> 0) { i = b; j = h; do { f[j >> 2] = f[c >> 2]; f[j + 4 >> 2] = f[c + 4 >> 2]; f[j + 8 >> 2] = f[c + 8 >> 2]; j = (f[g >> 2] | 0) + 12 | 0; f[g >> 2] = j; i = i + -1 | 0 } while ((i | 0) != 0); return } i = f[a >> 2] | 0; j = (h - i | 0) / 12 | 0; h = j + b | 0; if (h >>> 0 > 357913941) mq(a); k = (e - i | 0) / 12 | 0; i = k << 1; e = k >>> 0 < 178956970 ? (i >>> 0 < h >>> 0 ? h : i) : 357913941; do if (e) if (e >>> 0 > 357913941) { i = ra(8) | 0; Wo(i, 14941); f[i >> 2] = 6944; va(i | 0, 1080, 114) } else { l = dn(e * 12 | 0) | 0; break } else l = 0; while (0); i = l + (j * 12 | 0) | 0; j = l + (e * 12 | 0) | 0; e = b; b = i; l = i; do { f[b >> 2] = f[c >> 2]; f[b + 4 >> 2] = f[c + 4 >> 2]; f[b + 8 >> 2] = f[c + 8 >> 2]; b = l + 12 | 0; l = b; e = e + -1 | 0 } while ((e | 0) != 0); e = f[a >> 2] | 0; b = (f[g >> 2] | 0) - e | 0; c = i + (((b | 0) / -12 | 0) * 12 | 0) | 0; if ((b | 0) > 0) Rg(c | 0, e | 0, b | 0) | 0; f[a >> 2] = c; f[g >> 2] = l; f[d >> 2] = j; if (!e) return; br(e); return } function Bg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = (f[c >> 2] | 0) - d >> 2; g = e + 1 | 0; if (g >>> 0 > 1073741823) mq(a); h = a + 8 | 0; i = (f[h >> 2] | 0) - d | 0; d = i >> 1; j = i >> 2 >>> 0 < 536870911 ? (d >>> 0 < g >>> 0 ? g : d) : 1073741823; do if (j) if (j >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { k = dn(j << 2) | 0; break } else k = 0; while (0); d = k + (e << 2) | 0; e = d; g = k + (j << 2) | 0; j = f[b >> 2] | 0; f[b >> 2] = 0; f[d >> 2] = j; j = d + 4 | 0; b = f[a >> 2] | 0; k = f[c >> 2] | 0; if ((k | 0) == (b | 0)) { l = e; m = b; n = b } else { i = k; k = e; e = d; do { i = i + -4 | 0; d = f[i >> 2] | 0; f[i >> 2] = 0; f[e + -4 >> 2] = d; e = k + -4 | 0; k = e } while ((i | 0) != (b | 0)); l = k; m = f[a >> 2] | 0; n = f[c >> 2] | 0 } f[a >> 2] = l; f[c >> 2] = j; f[h >> 2] = g; g = m; if ((n | 0) != (g | 0)) { h = n; do { h = h + -4 | 0; n = f[h >> 2] | 0; f[h >> 2] = 0; if (n | 0) { Qi(n); br(n) } } while ((h | 0) != (g | 0)) } if (!m) return; br(m); return } function Cg(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; e = f[b >> 2] | 0; g = f[a >> 2] | 0; h = f[d >> 2] | 0; d = f[h >> 2] | 0; i = (f[h + 4 >> 2] | 0) - d >> 3; if (i >>> 0 <= e >>> 0) mq(h); j = d; if (i >>> 0 <= g >>> 0) mq(h); d = f[j + (e << 3) >> 2] | 0; k = f[c >> 2] | 0; if (i >>> 0 <= k >>> 0) mq(h); l = j + (g << 3) | 0; m = (f[j + (k << 3) >> 2] | 0) >>> 0 < d >>> 0; if (d >>> 0 < (f[l >> 2] | 0) >>> 0) { if (m) { f[a >> 2] = k; f[c >> 2] = g; n = 1; return n | 0 } f[a >> 2] = e; f[b >> 2] = g; d = f[c >> 2] | 0; if (i >>> 0 <= d >>> 0) mq(h); if ((f[j + (d << 3) >> 2] | 0) >>> 0 >= (f[l >> 2] | 0) >>> 0) { n = 1; return n | 0 } f[b >> 2] = d; f[c >> 2] = g; n = 2; return n | 0 } if (!m) { n = 0; return n | 0 } f[b >> 2] = k; f[c >> 2] = e; e = f[b >> 2] | 0; c = f[a >> 2] | 0; if (i >>> 0 <= e >>> 0) mq(h); if (i >>> 0 <= c >>> 0) mq(h); if ((f[j + (e << 3) >> 2] | 0) >>> 0 >= (f[j + (c << 3) >> 2] | 0) >>> 0) { n = 1; return n | 0 } f[a >> 2] = e; f[b >> 2] = c; n = 2; return n | 0 } function Dg(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0; e = u; u = u + 96 | 0; g = e + 40 | 0; h = e; Am(g, c); we(h, b, c); th(g, h); sj(h + 24 | 0, f[h + 28 >> 2] | 0); Dj(h + 12 | 0, f[h + 16 >> 2] | 0); sj(h, f[h + 4 >> 2] | 0); Si(a, g, d); f[g >> 2] = 2968; sj(g + 28 | 0, f[g + 32 >> 2] | 0); Dj(g + 16 | 0, f[g + 20 >> 2] | 0); sj(g + 4 | 0, f[g + 8 >> 2] | 0); u = e; return } function Eg(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; a = u; u = u + 16 | 0; e = a; if (!b) { g = 0; u = a; return g | 0 } h = b + 96 | 0; i = b + 100 | 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; b = f[i >> 2] | 0; j = f[h >> 2] | 0; k = (b - j | 0) / 12 | 0; l = j; j = b; if (k >>> 0 >= c >>> 0) { if (k >>> 0 > c >>> 0 ? (b = l + (c * 12 | 0) | 0, (b | 0) != (j | 0)) : 0) f[i >> 2] = j + (~(((j + -12 - b | 0) >>> 0) / 12 | 0) * 12 | 0); if (!c) { g = 1; u = a; return g | 0 } } else Ag(h, c - k | 0, e); k = 0; b = f[h >> 2] | 0; while (1) { j = k * 3 | 0; l = f[d + (j << 2) >> 2] | 0; m = f[d + (j + 1 << 2) >> 2] | 0; n = f[d + (j + 2 << 2) >> 2] | 0; j = ((f[i >> 2] | 0) - b | 0) / 12 | 0; o = k; k = k + 1 | 0; if (o >>> 0 < j >>> 0) { p = b; q = b } else { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; Ag(h, k - j | 0, e); j = f[h >> 2] | 0; p = j; q = j } f[p + (o * 12 | 0) >> 2] = l; f[p + (o * 12 | 0) + 4 >> 2] = m; f[p + (o * 12 | 0) + 8 >> 2] = n; if ((k | 0) == (c | 0)) { g = 1; break } else b = q } u = a; return g | 0 } function Fg(a) { a = +a; var b = 0, c = 0, d = 0, e = 0.0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0.0, n = 0.0, o = 0.0, q = 0.0, r = 0.0, t = 0.0; p[s >> 3] = a; b = f[s >> 2] | 0; c = f[s + 4 >> 2] | 0; d = (c | 0) < 0; do if (d | c >>> 0 < 1048576) { if ((b | 0) == 0 & (c & 2147483647 | 0) == 0) { e = -1.0 / (a * a); break } if (d) { e = (a - a) / 0.0; break } else { p[s >> 3] = a * 18014398509481984.0; g = f[s + 4 >> 2] | 0; h = -1077; i = g; j = f[s >> 2] | 0; k = g; l = 9; break } } else if (c >>> 0 <= 2146435071) if ((b | 0) == 0 & 0 == 0 & (c | 0) == 1072693248) e = 0.0; else { h = -1023; i = c; j = b; k = c; l = 9 } else e = a; while (0); if ((l | 0) == 9) { l = i + 614242 | 0; f[s >> 2] = j; f[s + 4 >> 2] = (l & 1048575) + 1072079006; a = +p[s >> 3] + -1.0; m = a * a * .5; n = a / (a + 2.0); o = n * n; q = o * o; p[s >> 3] = a - m; j = f[s + 4 >> 2] | 0; f[s >> 2] = 0; f[s + 4 >> 2] = j; r = +p[s >> 3]; t = a - r - m + n * (m + (q * (q * (q * .15313837699209373 + .22222198432149784) + .3999999999940942) + o * (q * (q * (q * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))); q = r * 1.4426950407214463; o = +(h + (l >>> 20) | 0); m = q + o; e = m + (q + (o - m) + (t * 1.4426950407214463 + (t + r) * 1.6751713164886512e-10)) } return +e } function Gg(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; d = u; u = u + 16 | 0; e = d; g = dn(32) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 17; h = g; i = 12804; j = h + 17 | 0; do { b[h >> 0] = b[i >> 0] | 0; h = h + 1 | 0; i = i + 1 | 0 } while ((h | 0) < (j | 0)); b[g + 17 >> 0] = 0; g = c + 16 | 0; i = f[g >> 2] | 0; if (i) { h = g; j = i; a: while (1) { i = j; while (1) { if ((f[i + 16 >> 2] | 0) >= (a | 0)) break; k = f[i + 4 >> 2] | 0; if (!k) { l = h; break a } else i = k } j = f[i >> 2] | 0; if (!j) { l = i; break } else h = i } if (((l | 0) != (g | 0) ? (f[l + 16 >> 2] | 0) <= (a | 0) : 0) ? (a = l + 20 | 0, (sh(a, e) | 0) != 0) : 0) m = a; else n = 10 } else n = 10; if ((n | 0) == 10) m = c; c = yk(m, e, -1) | 0; if ((b[e + 11 >> 0] | 0) >= 0) { o = (c | 0) == -1; p = c >>> 0 > 6; q = p ? -2 : c; r = o ? -1 : q; u = d; return r | 0 } br(f[e >> 2] | 0); o = (c | 0) == -1; p = c >>> 0 > 6; q = p ? -2 : c; r = o ? -1 : q; u = d; return r | 0 } function Hg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0; d = u; u = u + 16 | 0; e = d; g = f[c >> 2] | 0; f[c >> 2] = 0; f[e >> 2] = g; ug(a, b, e); g = f[e >> 2] | 0; f[e >> 2] = 0; if (g | 0) { e = g + 88 | 0; c = f[e >> 2] | 0; f[e >> 2] = 0; if (c | 0) { e = f[c + 8 >> 2] | 0; if (e | 0) { h = c + 12 | 0; if ((f[h >> 2] | 0) != (e | 0)) f[h >> 2] = e; br(e) } br(c) } c = f[g + 68 >> 2] | 0; if (c | 0) { e = g + 72 | 0; h = f[e >> 2] | 0; if ((h | 0) != (c | 0)) f[e >> 2] = h + (~((h + -4 - c | 0) >>> 2) << 2); br(c) } c = g + 64 | 0; h = f[c >> 2] | 0; f[c >> 2] = 0; if (h | 0) { c = f[h >> 2] | 0; if (c | 0) { e = h + 4 | 0; if ((f[e >> 2] | 0) != (c | 0)) f[e >> 2] = c; br(c) } br(h) } br(g) } g = a + 84 | 0; h = a + 88 | 0; a = f[h >> 2] | 0; c = f[g >> 2] | 0; e = a - c >> 2; if ((e | 0) > (b | 0)) { u = d; return } i = b + 1 | 0; b = a; if (i >>> 0 > e >>> 0) { nh(g, i - e | 0); u = d; return } if (i >>> 0 >= e >>> 0) { u = d; return } e = c + (i << 2) | 0; if ((e | 0) == (b | 0)) { u = d; return } f[h >> 2] = b + (~((b + -4 - e | 0) >>> 2) << 2); u = d; return } function Ig(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; g = a + 4 | 0; f[g >> 2] = c; f[a + 8 >> 2] = f[c + 56 >> 2]; h = f[a + 184 >> 2] | 0; i = a + 188 | 0; j = f[i >> 2] | 0; if ((j | 0) != (h | 0)) f[i >> 2] = j + (~((j + -4 - h | 0) >>> 2) << 2); h = f[c + 48 >> 2] | 0; c = dn(32) | 0; f[e >> 2] = c; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 19; j = c; i = 14285; k = j + 19 | 0; do { b[j >> 0] = b[i >> 0] | 0; j = j + 1 | 0; i = i + 1 | 0 } while ((j | 0) < (k | 0)); b[c + 19 >> 0] = 0; c = (sh(h, e) | 0) == 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); h = f[(f[g >> 2] | 0) + 48 >> 2] | 0; if (c) { c = (Yh(h) | 0) > 5 & 1; b[a + 352 >> 0] = c; u = d; return 1 } c = dn(32) | 0; f[e >> 2] = c; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 19; j = c; i = 14285; k = j + 19 | 0; do { b[j >> 0] = b[i >> 0] | 0; j = j + 1 | 0; i = i + 1 | 0 } while ((j | 0) < (k | 0)); b[c + 19 >> 0] = 0; c = (Oj(h, e, 0) | 0) & 1; b[a + 352 >> 0] = c; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return 1 } function Jg(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = a + 108 | 0; d = (f[a + 112 >> 2] | 0) - (f[c >> 2] | 0) | 0; e = (d | 0) / 12 | 0; g = a + 4 | 0; Nh(e, f[(f[g >> 2] | 0) + 44 >> 2] | 0) | 0; if (!d) return 1; d = 0; a = 0; while (1) { i = f[c >> 2] | 0; j = i + (d * 12 | 0) + 4 | 0; Nh((f[j >> 2] | 0) - a | 0, f[(f[g >> 2] | 0) + 44 >> 2] | 0) | 0; Nh((f[j >> 2] | 0) - (f[i + (d * 12 | 0) >> 2] | 0) | 0, f[(f[g >> 2] | 0) + 44 >> 2] | 0) | 0; d = d + 1 | 0; if (d >>> 0 >= e >>> 0) break; else a = f[j >> 2] | 0 } li(f[(f[g >> 2] | 0) + 44 >> 2] | 0, e, 0, 0) | 0; a = 0; do { d = f[(f[g >> 2] | 0) + 44 >> 2] | 0; j = d + 16 | 0; i = f[j + 4 >> 2] | 0; if ((i | 0) > 0 | (i | 0) == 0 & (f[j >> 2] | 0) >>> 0 > 0) { j = f[d + 12 >> 2] | 0; d = j + 4 | 0; i = f[d >> 2] | 0; k = b[(f[c >> 2] | 0) + (a * 12 | 0) + 8 >> 0] & 1; l = i >>> 3; m = i & 7; i = (f[j >> 2] | 0) + l | 0; b[i >> 0] = (1 << m ^ 255) & (h[i >> 0] | 0); i = (f[j >> 2] | 0) + l | 0; b[i >> 0] = k << m | (h[i >> 0] | 0); f[d >> 2] = (f[d >> 2] | 0) + 1 } a = a + 1 | 0 } while (a >>> 0 < e >>> 0); Qf(f[(f[g >> 2] | 0) + 44 >> 2] | 0); return 1 } function Kg(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; g = a + 4 | 0; f[g >> 2] = c; f[a + 8 >> 2] = f[c + 56 >> 2]; h = f[a + 184 >> 2] | 0; i = a + 188 | 0; j = f[i >> 2] | 0; if ((j | 0) != (h | 0)) f[i >> 2] = j + (~((j + -4 - h | 0) >>> 2) << 2); h = f[c + 48 >> 2] | 0; c = dn(32) | 0; f[e >> 2] = c; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 19; j = c; i = 14285; k = j + 19 | 0; do { b[j >> 0] = b[i >> 0] | 0; j = j + 1 | 0; i = i + 1 | 0 } while ((j | 0) < (k | 0)); b[c + 19 >> 0] = 0; c = (sh(h, e) | 0) == 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); h = f[(f[g >> 2] | 0) + 48 >> 2] | 0; if (c) { c = (Yh(h) | 0) > 5 & 1; b[a + 288 >> 0] = c; u = d; return 1 } c = dn(32) | 0; f[e >> 2] = c; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 19; j = c; i = 14285; k = j + 19 | 0; do { b[j >> 0] = b[i >> 0] | 0; j = j + 1 | 0; i = i + 1 | 0 } while ((j | 0) < (k | 0)); b[c + 19 >> 0] = 0; c = (Oj(h, e, 0) | 0) & 1; b[a + 288 >> 0] = c; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return 1 } function Lg(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; g = u; u = u + 32 | 0; h = g + 16 | 0; i = g + 8 | 0; j = g; k = d - e | 0; d = a + 8 | 0; if ((k | 0) > 0) { a = 0 - e | 0; l = i + 4 | 0; m = j + 4 | 0; n = h + 4 | 0; o = k; do { k = b + (o << 2) | 0; p = k + (a << 2) | 0; q = c + (o << 2) | 0; r = f[k + 4 >> 2] | 0; s = f[p >> 2] | 0; t = f[p + 4 >> 2] | 0; f[i >> 2] = f[k >> 2]; f[l >> 2] = r; f[j >> 2] = s; f[m >> 2] = t; Dd(h, d, i, j); f[q >> 2] = f[h >> 2]; f[q + 4 >> 2] = f[n >> 2]; o = o - e | 0 } while ((o | 0) > 0) } o = e >>> 0 > 1073741823 ? -1 : e << 2; e = _q(o) | 0; hj(e | 0, 0, o | 0) | 0; o = f[b + 4 >> 2] | 0; n = f[e >> 2] | 0; m = f[e + 4 >> 2] | 0; f[i >> 2] = f[b >> 2]; f[i + 4 >> 2] = o; f[j >> 2] = n; f[j + 4 >> 2] = m; Dd(h, d, i, j); f[c >> 2] = f[h >> 2]; f[c + 4 >> 2] = f[h + 4 >> 2]; $q(e); u = g; return 1 } function Mg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 32 | 0; d = c + 12 | 0; e = c; g = f[b + 100 >> 2] | 0; h = f[b + 96 >> 2] | 0; b = g - h | 0; i = (b | 0) / 12 | 0; f[d >> 2] = 0; j = d + 4 | 0; f[j >> 2] = 0; f[d + 8 >> 2] = 0; k = h; do if (b) if (i >>> 0 > 357913941) mq(d); else { l = dn(b) | 0; f[d >> 2] = l; f[d + 8 >> 2] = l + (i * 12 | 0); hj(l | 0, 0, b | 0) | 0; f[j >> 2] = l + b; m = l; break } else m = 0; while (0); f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; if ((g | 0) != (h | 0)) { h = e + 4 | 0; g = e + 8 | 0; b = 0; do { l = k + (b * 12 | 0) | 0; f[e >> 2] = f[l >> 2]; f[e + 4 >> 2] = f[l + 4 >> 2]; f[e + 8 >> 2] = f[l + 8 >> 2]; f[m + (b * 12 | 0) >> 2] = f[e >> 2]; f[m + (b * 12 | 0) + 4 >> 2] = f[h >> 2]; f[m + (b * 12 | 0) + 8 >> 2] = f[g >> 2]; b = b + 1 | 0 } while (b >>> 0 < i >>> 0) } Cj(a, d); a = f[d >> 2] | 0; if (!a) { u = c; return } d = f[j >> 2] | 0; if ((d | 0) != (a | 0)) f[j >> 2] = d + (~(((d + -12 - a | 0) >>> 0) / 12 | 0) * 12 | 0); br(a); u = c; return } function Ng(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; if (c >>> 0 > 4294967279) mq(a); d = a + 11 | 0; e = b[d >> 0] | 0; g = e << 24 >> 24 < 0; if (g) { h = f[a + 4 >> 2] | 0; i = (f[a + 8 >> 2] & 2147483647) + -1 | 0 } else { h = e & 255; i = 10 } j = h >>> 0 > c >>> 0 ? h : c; c = j >>> 0 < 11; k = c ? 10 : (j + 16 & -16) + -1 | 0; do if ((k | 0) != (i | 0)) { do if (c) { j = f[a >> 2] | 0; if (g) { l = 0; m = j; n = a; o = 13 } else { Lo(a, j, (e & 255) + 1 | 0) | 0; br(j); o = 16 } } else { j = k + 1 | 0; p = dn(j) | 0; if (g) { l = 1; m = f[a >> 2] | 0; n = p; o = 13; break } else { Lo(p, a, (e & 255) + 1 | 0) | 0; q = p; r = j; s = a + 4 | 0; o = 15; break } } while (0); if ((o | 0) == 13) { j = a + 4 | 0; Lo(n, m, (f[j >> 2] | 0) + 1 | 0) | 0; br(m); if (l) { q = n; r = k + 1 | 0; s = j; o = 15 } else o = 16 } if ((o | 0) == 15) { f[a + 8 >> 2] = r | -2147483648; f[s >> 2] = h; f[a >> 2] = q; break } else if ((o | 0) == 16) { b[d >> 0] = h; break } } while (0); return } function Og(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; c = f[b >> 2] | 0; if ((c | 0) == -1) { d = -1; return d | 0 } b = f[(f[a + 24 >> 2] | 0) + (c << 2) >> 2] | 0; if ((b | 0) == -1) { d = 0; return d | 0 } c = a + 12 | 0; a = 0; e = 0; g = b; a: while (1) { b: do if (e) { h = a + 1 | 0; i = (((g >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + g | 0; if ((i | 0) == -1) { d = h; j = 15; break a } k = f[(f[c >> 2] | 0) + (i << 2) >> 2] | 0; if ((k | 0) == -1) { d = h; j = 15; break a } if (!((k >>> 0) % 3 | 0)) { l = k + 2 | 0; m = h; break } else { l = k + -1 | 0; m = h; break } } else { h = a; k = g; while (1) { i = h + 1 | 0; n = k + 1 | 0; o = ((n >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : n; if ((o | 0) == -1) { l = b; m = i; break b } n = f[(f[c >> 2] | 0) + (o << 2) >> 2] | 0; o = n + 1 | 0; if ((n | 0) == -1) { l = b; m = i; break b } k = ((o >>> 0) % 3 | 0 | 0) == 0 ? n + -2 | 0 : o; if ((k | 0) == -1) { l = b; m = i; break b } if ((k | 0) == (b | 0)) { d = i; j = 15; break a } else h = i } } while (0); if ((l | 0) == -1) { d = m; j = 15; break } else { a = m; e = 1; g = l } } if ((j | 0) == 15) return d | 0; return 0 } function Pg(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; d = a + 8 | 0; Cg(a, a + 4 | 0, d, c) | 0; e = a + 12 | 0; if ((e | 0) == (b | 0)) return; g = f[c >> 2] | 0; c = f[g >> 2] | 0; h = (f[g + 4 >> 2] | 0) - c >> 3; i = c; c = e; e = d; a: while (1) { d = f[c >> 2] | 0; j = f[e >> 2] | 0; if (h >>> 0 <= d >>> 0) { k = 5; break } if (h >>> 0 <= j >>> 0) { k = 7; break } l = i + (d << 3) | 0; if ((f[l >> 2] | 0) >>> 0 < (f[i + (j << 3) >> 2] | 0) >>> 0) { m = e; n = c; o = j; while (1) { f[n >> 2] = o; if ((m | 0) == (a | 0)) { p = a; break } j = m + -4 | 0; o = f[j >> 2] | 0; if (h >>> 0 <= o >>> 0) { k = 11; break a } if ((f[l >> 2] | 0) >>> 0 >= (f[i + (o << 3) >> 2] | 0) >>> 0) { p = m; break } else { q = m; m = j; n = q } } f[p >> 2] = d } n = c + 4 | 0; if ((n | 0) == (b | 0)) { k = 3; break } else { m = c; c = n; e = m } } if ((k | 0) == 3) return; else if ((k | 0) == 5) mq(g); else if ((k | 0) == 7) mq(g); else if ((k | 0) == 11) mq(g) } function Qg(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = Cg(a, b, c, e) | 0; h = f[d >> 2] | 0; i = f[c >> 2] | 0; j = f[e >> 2] | 0; e = f[j >> 2] | 0; k = (f[j + 4 >> 2] | 0) - e >> 3; if (k >>> 0 <= h >>> 0) mq(j); l = e; if (k >>> 0 <= i >>> 0) mq(j); if ((f[l + (h << 3) >> 2] | 0) >>> 0 >= (f[l + (i << 3) >> 2] | 0) >>> 0) { m = g; return m | 0 } f[c >> 2] = h; f[d >> 2] = i; i = f[c >> 2] | 0; d = f[b >> 2] | 0; if (k >>> 0 <= i >>> 0) mq(j); if (k >>> 0 <= d >>> 0) mq(j); if ((f[l + (i << 3) >> 2] | 0) >>> 0 >= (f[l + (d << 3) >> 2] | 0) >>> 0) { m = g + 1 | 0; return m | 0 } f[b >> 2] = i; f[c >> 2] = d; d = f[b >> 2] | 0; c = f[a >> 2] | 0; if (k >>> 0 <= d >>> 0) mq(j); if (k >>> 0 <= c >>> 0) mq(j); if ((f[l + (d << 3) >> 2] | 0) >>> 0 >= (f[l + (c << 3) >> 2] | 0) >>> 0) { m = g + 2 | 0; return m | 0 } f[a >> 2] = d; f[b >> 2] = c; m = g + 3 | 0; return m | 0 } function Rg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0; if ((d | 0) >= 8192) return Da(a | 0, c | 0, d | 0) | 0; e = a | 0; g = a + d | 0; if ((a & 3) == (c & 3)) { while (a & 3) { if (!d) return e | 0; b[a >> 0] = b[c >> 0] | 0; a = a + 1 | 0; c = c + 1 | 0; d = d - 1 | 0 } h = g & -4 | 0; d = h - 64 | 0; while ((a | 0) <= (d | 0)) { f[a >> 2] = f[c >> 2]; f[a + 4 >> 2] = f[c + 4 >> 2]; f[a + 8 >> 2] = f[c + 8 >> 2]; f[a + 12 >> 2] = f[c + 12 >> 2]; f[a + 16 >> 2] = f[c + 16 >> 2]; f[a + 20 >> 2] = f[c + 20 >> 2]; f[a + 24 >> 2] = f[c + 24 >> 2]; f[a + 28 >> 2] = f[c + 28 >> 2]; f[a + 32 >> 2] = f[c + 32 >> 2]; f[a + 36 >> 2] = f[c + 36 >> 2]; f[a + 40 >> 2] = f[c + 40 >> 2]; f[a + 44 >> 2] = f[c + 44 >> 2]; f[a + 48 >> 2] = f[c + 48 >> 2]; f[a + 52 >> 2] = f[c + 52 >> 2]; f[a + 56 >> 2] = f[c + 56 >> 2]; f[a + 60 >> 2] = f[c + 60 >> 2]; a = a + 64 | 0; c = c + 64 | 0 } while ((a | 0) < (h | 0)) { f[a >> 2] = f[c >> 2]; a = a + 4 | 0; c = c + 4 | 0 } } else { h = g - 4 | 0; while ((a | 0) < (h | 0)) { b[a >> 0] = b[c >> 0] | 0; b[a + 1 >> 0] = b[c + 1 >> 0] | 0; b[a + 2 >> 0] = b[c + 2 >> 0] | 0; b[a + 3 >> 0] = b[c + 3 >> 0] | 0; a = a + 4 | 0; c = c + 4 | 0 } } while ((a | 0) < (g | 0)) { b[a >> 0] = b[c >> 0] | 0; a = a + 1 | 0; c = c + 1 | 0 } return e | 0 } function Sg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0; c = u; u = u + 16 | 0; d = c + 4 | 0; e = c; f[a >> 2] = 1216; g = a + 4 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; f[g + 16 >> 2] = 0; f[g + 20 >> 2] = 0; f[g + 24 >> 2] = 0; f[g + 28 >> 2] = 0; f[d >> 2] = b; b = a + 4 | 0; g = a + 8 | 0; Ci(b, d); h = f[d >> 2] | 0; i = a + 20 | 0; j = f[i >> 2] | 0; k = a + 16 | 0; a = f[k >> 2] | 0; l = j - a >> 2; m = a; if ((h | 0) < (l | 0)) { n = m; o = h; p = f[g >> 2] | 0; q = f[b >> 2] | 0; r = p - q | 0; s = r >> 2; t = s + -1 | 0; v = n + (o << 2) | 0; f[v >> 2] = t; u = c; return } a = h + 1 | 0; f[e >> 2] = -1; w = j; if (a >>> 0 <= l >>> 0) if (a >>> 0 < l >>> 0 ? (j = m + (a << 2) | 0, (j | 0) != (w | 0)) : 0) { f[i >> 2] = w + (~((w + -4 - j | 0) >>> 2) << 2); x = h; y = m } else { x = h; y = m } else { kh(k, a - l | 0, e); x = f[d >> 2] | 0; y = f[k >> 2] | 0 } n = y; o = x; p = f[g >> 2] | 0; q = f[b >> 2] | 0; r = p - q | 0; s = r >> 2; t = s + -1 | 0; v = n + (o << 2) | 0; f[v >> 2] = t; u = c; return } function Tg(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; b = a + 4 | 0; c = f[b >> 2] | 0; d = (f[c + 12 >> 2] | 0) - (f[c + 8 >> 2] | 0) | 0; c = d >> 2; a: do if ((d | 0) > 0) { e = 0; while (1) { if (!(Ra[f[(f[a >> 2] | 0) + 36 >> 2] & 127](a, e) | 0)) { g = 0; break } e = e + 1 | 0; h = f[b >> 2] | 0; i = (f[h + 12 >> 2] | 0) - (f[h + 8 >> 2] | 0) >> 2; if ((e | 0) >= (i | 0)) { j = i; break a } } return g | 0 } else j = c; while (0); c = a + 20 | 0; b = a + 24 | 0; d = f[b >> 2] | 0; e = f[c >> 2] | 0; i = d - e >> 2; h = e; e = d; if (j >>> 0 <= i >>> 0) { if (j >>> 0 < i >>> 0 ? (d = h + (j << 2) | 0, (d | 0) != (e | 0)) : 0) f[b >> 2] = e + (~((e + -4 - d | 0) >>> 2) << 2) } else oi(c, j - i | 0); i = f[a + 12 >> 2] | 0; j = f[a + 8 >> 2] | 0; a = j; if ((i | 0) == (j | 0)) { g = 1; return g | 0 } d = i - j >> 2; j = 0; do { i = f[a + (j << 2) >> 2] | 0; e = f[i + 8 >> 2] | 0; b = f[i + 4 >> 2] | 0; i = b; if ((e | 0) != (b | 0) ? (h = f[c >> 2] | 0, k = e - b >> 2, f[h + (f[i >> 2] << 2) >> 2] = j, k >>> 0 > 1) : 0) { b = 1; do { f[h + (f[i + (b << 2) >> 2] << 2) >> 2] = j; b = b + 1 | 0 } while (b >>> 0 < k >>> 0) } j = j + 1 | 0 } while (j >>> 0 < d >>> 0); g = 1; return g | 0 } function Ug(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; d = f[c + 88 >> 2] | 0; if (!d) { e = 0; return e | 0 } if ((f[d >> 2] | 0) != 1) { e = 0; return e | 0 } g = d + 8 | 0; d = f[g >> 2] | 0; f[a + 4 >> 2] = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; i = a + 8 | 0; j = c + 24 | 0; c = b[j >> 0] | 0; k = c << 24 >> 24; l = a + 12 | 0; m = f[l >> 2] | 0; n = f[i >> 2] | 0; o = m - n >> 2; p = n; n = m; if (o >>> 0 >= k >>> 0) if (o >>> 0 > k >>> 0 ? (m = p + (k << 2) | 0, (m | 0) != (n | 0)) : 0) { f[l >> 2] = n + (~((n + -4 - m | 0) >>> 2) << 2); q = c; r = d } else { q = c; r = d } else { oi(i, k - o | 0); q = b[j >> 0] | 0; r = f[g >> 2] | 0 } g = r + 4 | 0; j = h[g >> 0] | h[g + 1 >> 0] << 8 | h[g + 2 >> 0] << 16 | h[g + 3 >> 0] << 24; if (q << 24 >> 24 > 0) { g = f[i >> 2] | 0; i = q << 24 >> 24; q = j; o = 4; k = 0; while (1) { f[g + (k << 2) >> 2] = q; o = o + 4 | 0; k = k + 1 | 0; d = r + o | 0; c = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; if ((k | 0) >= (i | 0)) { s = c; break } else q = c } } else s = j; f[a + 20 >> 2] = s; e = 1; return e | 0 } function Vg(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; do if (!(qp(a, f[c + 8 >> 2] | 0, g) | 0)) { if (!(qp(a, f[c >> 2] | 0, g) | 0)) { h = f[a + 8 >> 2] | 0; Za[f[(f[h >> 2] | 0) + 24 >> 2] & 3](h, c, d, e, g); break } if ((f[c + 16 >> 2] | 0) != (d | 0) ? (h = c + 20 | 0, (f[h >> 2] | 0) != (d | 0)) : 0) { f[c + 32 >> 2] = e; i = c + 44 | 0; if ((f[i >> 2] | 0) == 4) break; j = c + 52 | 0; b[j >> 0] = 0; k = c + 53 | 0; b[k >> 0] = 0; l = f[a + 8 >> 2] | 0; _a[f[(f[l >> 2] | 0) + 20 >> 2] & 3](l, c, d, d, 1, g); if (b[k >> 0] | 0) if (!(b[j >> 0] | 0)) { m = 3; n = 11 } else o = 3; else { m = 4; n = 11 } if ((n | 0) == 11) { f[h >> 2] = d; h = c + 40 | 0; f[h >> 2] = (f[h >> 2] | 0) + 1; if ((f[c + 36 >> 2] | 0) == 1 ? (f[c + 24 >> 2] | 0) == 2 : 0) { b[c + 54 >> 0] = 1; o = m } else o = m } f[i >> 2] = o; break } if ((e | 0) == 1) f[c + 32 >> 2] = 1 } else Om(0, c, d, e); while (0); return } function Wg(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; e = u; u = u + 16 | 0; g = e + 12 | 0; h = e + 8 | 0; i = e; f[i >> 2] = f[b >> 2]; f[g >> 2] = f[i >> 2]; i = zd(a, g, h, e + 4 | 0, c) | 0; c = f[i >> 2] | 0; if (c | 0) { j = c; u = e; return j | 0 } c = dn(40) | 0; dj(c + 16 | 0, d); dj(c + 28 | 0, d + 12 | 0); d = f[h >> 2] | 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = d; f[i >> 2] = c; d = f[f[a >> 2] >> 2] | 0; if (!d) k = c; else { f[a >> 2] = d; k = f[i >> 2] | 0 } Ae(f[a + 4 >> 2] | 0, k); k = a + 8 | 0; f[k >> 2] = (f[k >> 2] | 0) + 1; j = c; u = e; return j | 0 } function Xg(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; e = u; u = u + 16 | 0; g = e; h = a + 4 | 0; f[h >> 2] = 0; if (!c) { u = e; return } i = a + 8 | 0; j = f[i >> 2] | 0; k = j << 5; if (k >>> 0 < c >>> 0) { f[g >> 2] = 0; l = g + 4 | 0; f[l >> 2] = 0; m = g + 8 | 0; f[m >> 2] = 0; if ((c | 0) < 0) mq(a); n = j << 6; j = c + 31 & -32; hi(g, k >>> 0 < 1073741823 ? (n >>> 0 < j >>> 0 ? j : n) : 2147483647); n = f[a >> 2] | 0; f[a >> 2] = f[g >> 2]; f[g >> 2] = n; g = f[h >> 2] | 0; f[h >> 2] = c; f[l >> 2] = g; g = f[i >> 2] | 0; f[i >> 2] = f[m >> 2]; f[m >> 2] = g; if (n | 0) br(n); o = a } else { f[h >> 2] = c; o = a } a = f[o >> 2] | 0; o = a; h = a; a = c >>> 5; n = a << 2; if (!(b[d >> 0] | 0)) { hj(h | 0, 0, n | 0) | 0; d = c & 31; g = o + (a << 2) | 0; if (!d) { u = e; return } f[g >> 2] = f[g >> 2] & ~(-1 >>> (32 - d | 0)); u = e; return } else { hj(h | 0, -1, n | 0) | 0; n = c & 31; c = o + (a << 2) | 0; if (!n) { u = e; return } f[c >> 2] = f[c >> 2] | -1 >>> (32 - n | 0); u = e; return } } function Yg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; f[g >> 2] = f[a + 12 >> 2]; h = b + 16 | 0; i = h; j = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & j >>> 0 > 0) { l = k; m = j } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; j = h; l = f[j + 4 >> 2] | 0; m = f[j >> 2] | 0 } f[g >> 2] = f[a + 20 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { n = a + 88 | 0; fd(n, b); u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; n = a + 88 | 0; fd(n, b); u = c; return 1 } function Zg(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; f[g >> 2] = f[a + 12 >> 2]; h = b + 16 | 0; i = h; j = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & j >>> 0 > 0) { l = k; m = j } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; j = h; l = f[j + 4 >> 2] | 0; m = f[j >> 2] | 0 } f[g >> 2] = f[a + 16 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { n = a + 108 | 0; fd(n, b); u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; n = a + 108 | 0; fd(n, b); u = c; return 1 } function _g(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; c = a + 32 | 0; d = f[a + 64 >> 2] | 0; e = (Qa[f[(f[d >> 2] | 0) + 40 >> 2] & 127](d) | 0) + 56 | 0; d = f[e >> 2] | 0; li(c, (((f[d + 100 >> 2] | 0) - (f[d + 96 >> 2] | 0) | 0) / 12 | 0) * 3 | 0, 0, 1) | 0; d = a + 68 | 0; e = f[d >> 2] | 0; g = (f[a + 72 >> 2] | 0) - e | 0; if ((g | 0) <= 0) { Qf(c); return } i = a + 48 | 0; j = a + 44 | 0; a = (g >>> 2) + -1 | 0; g = e; while (1) { e = f[g + (a << 2) >> 2] | 0; k = f[3124 + (e << 2) >> 2] | 0; l = i; m = f[l + 4 >> 2] | 0; if ((m | 0) > 0 | (m | 0) == 0 & (f[l >> 2] | 0) >>> 0 > 0 ? (l = f[j >> 2] | 0, 171 >>> e & 1 | 0) : 0) { m = l + 4 | 0; n = 0; o = f[m >> 2] | 0; do { p = o >>> 3; q = o & 7; r = (f[l >> 2] | 0) + p | 0; b[r >> 0] = (1 << q ^ 255) & (h[r >> 0] | 0); r = (f[l >> 2] | 0) + p | 0; b[r >> 0] = (e >>> n & 1) << q | (h[r >> 0] | 0); o = (f[m >> 2] | 0) + 1 | 0; f[m >> 2] = o; n = n + 1 | 0 } while ((n | 0) != (k | 0)) } k = a + -1 | 0; if ((k | 0) <= -1) break; a = k; g = f[d >> 2] | 0 } Qf(c); return } function $g(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; g = u; u = u + 48 | 0; h = g; i = g + 32 | 0; if (!c) { j = 0; u = g; return j | 0 } Cn(h); do if ((Tl(c, 0) | 0) != -1) { if (d) { if (!(Qa[f[(f[c >> 2] | 0) + 16 >> 2] & 127](c) | 0)) { k = 0; break } Va[f[(f[c >> 2] | 0) + 20 >> 2] & 127](c) } Dg(i, a, c, h); l = (f[i >> 2] | 0) == 0; m = i + 4 | 0; if ((b[m + 11 >> 0] | 0) < 0) br(f[m >> 2] | 0); if (l) { l = f[h >> 2] | 0; m = h + 4 | 0; ag(e, l, l + ((f[m >> 2] | 0) - l) | 0); k = (f[m >> 2] | 0) - (f[h >> 2] | 0) | 0 } else k = 0 } else k = 0; while (0); e = h + 12 | 0; i = f[e >> 2] | 0; f[e >> 2] = 0; if (i | 0) br(i); i = f[h >> 2] | 0; if (i | 0) { e = h + 4 | 0; if ((f[e >> 2] | 0) != (i | 0)) f[e >> 2] = i; br(i) } j = k; u = g; return j | 0 } function ah(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; c = u; u = u + 16 | 0; d = c; e = f[(f[a >> 2] | 0) + 8 >> 2] | 0; g = a + 8 | 0; h = a + 12 | 0; i = (f[h >> 2] | 0) - (f[g >> 2] | 0) >> 2; j = f[b >> 2] | 0; f[b >> 2] = 0; f[d >> 2] = j; Xa[e & 15](a, i, d); i = f[d >> 2] | 0; f[d >> 2] = 0; if (!i) { k = f[h >> 2] | 0; l = f[g >> 2] | 0; m = k - l | 0; n = m >> 2; o = n + -1 | 0; u = c; return o | 0 } d = i + 88 | 0; a = f[d >> 2] | 0; f[d >> 2] = 0; if (a | 0) { d = f[a + 8 >> 2] | 0; if (d | 0) { e = a + 12 | 0; if ((f[e >> 2] | 0) != (d | 0)) f[e >> 2] = d; br(d) } br(a) } a = f[i + 68 >> 2] | 0; if (a | 0) { d = i + 72 | 0; e = f[d >> 2] | 0; if ((e | 0) != (a | 0)) f[d >> 2] = e + (~((e + -4 - a | 0) >>> 2) << 2); br(a) } a = i + 64 | 0; e = f[a >> 2] | 0; f[a >> 2] = 0; if (e | 0) { a = f[e >> 2] | 0; if (a | 0) { d = e + 4 | 0; if ((f[d >> 2] | 0) != (a | 0)) f[d >> 2] = a; br(a) } br(e) } br(i); k = f[h >> 2] | 0; l = f[g >> 2] | 0; m = k - l | 0; n = m >> 2; o = n + -1 | 0; u = c; return o | 0 } function bh(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; if (b[a + 352 >> 0] | 0) return 1; c = a + 8 | 0; d = f[c >> 2] | 0; e = (f[d + 12 >> 2] | 0) - (f[d + 8 >> 2] | 0) | 0; d = e >> 2; g = a + 172 | 0; si(g, d + -1 | 0); if (!((d | 0) != 1 & (e | 0) > 0)) return 1; e = a + 12 | 0; a = 0; h = 0; while (1) { i = f[(f[(f[c >> 2] | 0) + 8 >> 2] | 0) + (a << 2) >> 2] | 0; if (!(f[i + 56 >> 2] | 0)) j = h; else { k = f[g >> 2] | 0; f[k + (h * 136 | 0) >> 2] = a; l = f[k + (h * 136 | 0) + 104 >> 2] | 0; m = k + (h * 136 | 0) + 108 | 0; n = f[m >> 2] | 0; if ((n | 0) != (l | 0)) f[m >> 2] = n + (~((n + -4 - l | 0) >>> 2) << 2); l = f[e >> 2] | 0; $j(k + (h * 136 | 0) + 104 | 0, (f[l + 4 >> 2] | 0) - (f[l >> 2] | 0) >> 2); l = f[g >> 2] | 0; f[l + (h * 136 | 0) + 128 >> 2] = 0; zc(l + (h * 136 | 0) + 4 | 0, f[c >> 2] | 0, f[e >> 2] | 0, i) | 0; j = h + 1 | 0 } a = a + 1 | 0; if ((a | 0) >= (d | 0)) break; else h = j } return 1 } function ch(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; if (b[a + 288 >> 0] | 0) return 1; c = a + 8 | 0; d = f[c >> 2] | 0; e = (f[d + 12 >> 2] | 0) - (f[d + 8 >> 2] | 0) | 0; d = e >> 2; g = a + 172 | 0; si(g, d + -1 | 0); if (!((d | 0) != 1 & (e | 0) > 0)) return 1; e = a + 12 | 0; a = 0; h = 0; while (1) { i = f[(f[(f[c >> 2] | 0) + 8 >> 2] | 0) + (a << 2) >> 2] | 0; if (!(f[i + 56 >> 2] | 0)) j = h; else { k = f[g >> 2] | 0; f[k + (h * 136 | 0) >> 2] = a; l = f[k + (h * 136 | 0) + 104 >> 2] | 0; m = k + (h * 136 | 0) + 108 | 0; n = f[m >> 2] | 0; if ((n | 0) != (l | 0)) f[m >> 2] = n + (~((n + -4 - l | 0) >>> 2) << 2); l = f[e >> 2] | 0; $j(k + (h * 136 | 0) + 104 | 0, (f[l + 4 >> 2] | 0) - (f[l >> 2] | 0) >> 2); l = f[g >> 2] | 0; f[l + (h * 136 | 0) + 128 >> 2] = 0; zc(l + (h * 136 | 0) + 4 | 0, f[c >> 2] | 0, f[e >> 2] | 0, i) | 0; j = h + 1 | 0 } a = a + 1 | 0; if ((a | 0) >= (d | 0)) break; else h = j } return 1 } function dh(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 4 | 0; g = f[e >> 2] | 0; if (d - g >> 3 >>> 0 >= b >>> 0) { h = b; i = g; do { j = i; f[j >> 2] = 0; f[j + 4 >> 2] = 0; i = (f[e >> 2] | 0) + 8 | 0; f[e >> 2] = i; h = h + -1 | 0 } while ((h | 0) != 0); return } h = f[a >> 2] | 0; i = g - h >> 3; g = i + b | 0; if (g >>> 0 > 536870911) mq(a); j = d - h | 0; h = j >> 2; d = j >> 3 >>> 0 < 268435455 ? (h >>> 0 < g >>> 0 ? g : h) : 536870911; do if (d) if (d >>> 0 > 536870911) { h = ra(8) | 0; Wo(h, 14941); f[h >> 2] = 6944; va(h | 0, 1080, 114) } else { k = dn(d << 3) | 0; break } else k = 0; while (0); h = k + (i << 3) | 0; i = k + (d << 3) | 0; d = b; b = h; k = h; do { g = b; f[g >> 2] = 0; f[g + 4 >> 2] = 0; b = k + 8 | 0; k = b; d = d + -1 | 0 } while ((d | 0) != 0); d = f[a >> 2] | 0; b = (f[e >> 2] | 0) - d | 0; g = h + (0 - (b >> 3) << 3) | 0; if ((b | 0) > 0) Rg(g | 0, d | 0, b | 0) | 0; f[a >> 2] = g; f[e >> 2] = k; f[c >> 2] = i; if (!d) return; br(d); return } function eh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; i = e + 8 | 0; j = a & 255; b[i >> 0] = j & 127; do if (c >>> 0 > 0 | (c | 0) == 0 & a >>> 0 > 127) { b[i >> 0] = j | -128; k = d + 16 | 0; l = f[k + 4 >> 2] | 0; if ((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) { m = 0; break } else { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, i, i + 1 | 0) | 0; k = Wn(a | 0, c | 0, 7) | 0; m = eh(k, I, d) | 0; break } } else { k = d + 16 | 0; l = f[k + 4 >> 2] | 0; if ((l | 0) > 0 | (l | 0) == 0 & (f[k >> 2] | 0) >>> 0 > 0) { m = 0; break } f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, i, i + 1 | 0) | 0; n = 1; u = e; return n | 0 } while (0); n = m; u = e; return n | 0 } function fh(a, b) { a = a | 0; b = b | 0; var c = 0; c = a + 8 | 0; ef(c, b) | 0; if ((c | 0) == (b | 0)) { f[a + 92 >> 2] = f[b + 84 >> 2]; return } else { Yf(a + 56 | 0, f[b + 48 >> 2] | 0, f[b + 52 >> 2] | 0); Yf(a + 68 | 0, f[b + 60 >> 2] | 0, f[b + 64 >> 2] | 0); Yf(a + 80 | 0, f[b + 72 >> 2] | 0, f[b + 76 >> 2] | 0); f[a + 92 >> 2] = f[b + 84 >> 2]; qg(a + 96 | 0, f[b + 88 >> 2] | 0, f[b + 92 >> 2] | 0); return } } function gh(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0; g = f[(f[(f[d + 4 >> 2] | 0) + 8 >> 2] | 0) + (c << 2) >> 2] | 0; if ((b | 0) == -1) h = Ki(c, d) | 0; else h = b; if ((h | 0) == -2) i = 0; else { do if ((Qa[f[(f[d >> 2] | 0) + 8 >> 2] & 127](d) | 0) == 1) { Hf(a, d, h, c, e, 514); if (!(f[a >> 2] | 0)) { f[a >> 2] = 0; break } else return } while (0); c = dn(44) | 0; f[c >> 2] = 1528; f[c + 4 >> 2] = g; g = c + 8 | 0; f[g >> 2] = f[e >> 2]; f[g + 4 >> 2] = f[e + 4 >> 2]; f[g + 8 >> 2] = f[e + 8 >> 2]; f[g + 12 >> 2] = f[e + 12 >> 2]; f[g + 16 >> 2] = f[e + 16 >> 2]; f[g + 20 >> 2] = f[e + 20 >> 2]; _j(c + 32 | 0, e + 24 | 0); f[c >> 2] = 1584; i = c } f[a >> 2] = i; return } function hh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; e = u; u = u + 224 | 0; g = e + 120 | 0; h = e + 80 | 0; i = e; j = e + 136 | 0; k = h; l = k + 40 | 0; do { f[k >> 2] = 0; k = k + 4 | 0 } while ((k | 0) < (l | 0)); f[g >> 2] = f[d >> 2]; if ((qb(0, c, g, i, h) | 0) < 0) m = -1; else { if ((f[a + 76 >> 2] | 0) > -1) n = gr(a) | 0; else n = 0; d = f[a >> 2] | 0; k = d & 32; if ((b[a + 74 >> 0] | 0) < 1) f[a >> 2] = d & -33; d = a + 48 | 0; if (!(f[d >> 2] | 0)) { l = a + 44 | 0; o = f[l >> 2] | 0; f[l >> 2] = j; p = a + 28 | 0; f[p >> 2] = j; q = a + 20 | 0; f[q >> 2] = j; f[d >> 2] = 80; r = a + 16 | 0; f[r >> 2] = j + 80; j = qb(a, c, g, i, h) | 0; if (!o) s = j; else { Sa[f[a + 36 >> 2] & 31](a, 0, 0) | 0; t = (f[q >> 2] | 0) == 0 ? -1 : j; f[l >> 2] = o; f[d >> 2] = 0; f[r >> 2] = 0; f[p >> 2] = 0; f[q >> 2] = 0; s = t } } else s = qb(a, c, g, i, h) | 0; h = f[a >> 2] | 0; f[a >> 2] = h | k; if (n | 0) fr(a); m = (h & 32 | 0) == 0 ? s : -1 } u = e; return m | 0 } function ih(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0; d = u; u = u + 16 | 0; e = d; if (!(fn(a, b, c) | 0)) { g = 0; u = d; return g | 0 } if ((Qa[f[(f[a >> 2] | 0) + 32 >> 2] & 127](a) | 0) << 24 >> 24 == 1 ? ((f[(f[a + 8 >> 2] | 0) + 28 >> 2] | 0) + -1 | 0) >>> 0 >= 6 : 0) { g = 0; u = d; return g | 0 } h = Gg(c, f[b + 48 >> 2] | 0) | 0; Xa[f[(f[a >> 2] | 0) + 48 >> 2] & 15](e, a, h); h = a + 36 | 0; b = f[e >> 2] | 0; f[e >> 2] = 0; c = f[h >> 2] | 0; f[h >> 2] = b; if (!c) { f[e >> 2] = 0; i = b } else { Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); c = f[e >> 2] | 0; f[e >> 2] = 0; if (c | 0) Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); i = f[h >> 2] | 0 } if (!i) { g = 1; u = d; return g | 0 } if (Ra[f[(f[a >> 2] | 0) + 36 >> 2] & 127](a, i) | 0) { g = 1; u = d; return g | 0 } i = f[h >> 2] | 0; f[h >> 2] = 0; if (!i) { g = 1; u = d; return g | 0 } Va[f[(f[i >> 2] | 0) + 4 >> 2] & 127](i); g = 1; u = d; return g | 0 } function jh(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = f[a >> 2] | 0; g = d - e >> 2; h = d; if (g >>> 0 < b >>> 0) { hf(a, b - g | 0); return } if (g >>> 0 <= b >>> 0) return; g = e + (b << 2) | 0; if ((g | 0) == (h | 0)) return; else i = h; do { h = i + -4 | 0; f[c >> 2] = h; b = f[h >> 2] | 0; f[h >> 2] = 0; if (b | 0) { h = b + 88 | 0; e = f[h >> 2] | 0; f[h >> 2] = 0; if (e | 0) { h = f[e + 8 >> 2] | 0; if (h | 0) { a = e + 12 | 0; if ((f[a >> 2] | 0) != (h | 0)) f[a >> 2] = h; br(h) } br(e) } e = f[b + 68 >> 2] | 0; if (e | 0) { h = b + 72 | 0; a = f[h >> 2] | 0; if ((a | 0) != (e | 0)) f[h >> 2] = a + (~((a + -4 - e | 0) >>> 2) << 2); br(e) } e = b + 64 | 0; a = f[e >> 2] | 0; f[e >> 2] = 0; if (a | 0) { e = f[a >> 2] | 0; if (e | 0) { h = a + 4 | 0; if ((f[h >> 2] | 0) != (e | 0)) f[h >> 2] = e; br(e) } br(a) } br(b) } i = f[c >> 2] | 0 } while ((i | 0) != (g | 0)); return } function kh(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = a + 4 | 0; h = f[g >> 2] | 0; i = h; if (e - h >> 2 >>> 0 >= b >>> 0) { j = b; k = i; while (1) { f[k >> 2] = f[c >> 2]; j = j + -1 | 0; if (!j) break; else k = k + 4 | 0 } f[g >> 2] = i + (b << 2); return } i = f[a >> 2] | 0; k = h - i | 0; h = k >> 2; j = h + b | 0; if (j >>> 0 > 1073741823) mq(a); l = e - i | 0; e = l >> 1; m = l >> 2 >>> 0 < 536870911 ? (e >>> 0 < j >>> 0 ? j : e) : 1073741823; do if (m) if (m >>> 0 > 1073741823) { e = ra(8) | 0; Wo(e, 14941); f[e >> 2] = 6944; va(e | 0, 1080, 114) } else { e = dn(m << 2) | 0; n = e; o = e; break } else { n = 0; o = 0 } while (0); e = n + (h << 2) | 0; h = n + (m << 2) | 0; m = b; j = e; while (1) { f[j >> 2] = f[c >> 2]; m = m + -1 | 0; if (!m) break; else j = j + 4 | 0 } if ((k | 0) > 0) Rg(o | 0, i | 0, k | 0) | 0; f[a >> 2] = n; f[g >> 2] = e + (b << 2); f[d >> 2] = h; if (!i) return; br(i); return } function lh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0; e = (f[a >> 2] | 0) + 1794895138 | 0; g = rp(f[a + 8 >> 2] | 0, e) | 0; h = rp(f[a + 12 >> 2] | 0, e) | 0; i = rp(f[a + 16 >> 2] | 0, e) | 0; a: do if ((g >>> 0 < c >>> 2 >>> 0 ? (j = c - (g << 2) | 0, h >>> 0 < j >>> 0 & i >>> 0 < j >>> 0) : 0) ? ((i | h) & 3 | 0) == 0 : 0) { j = h >>> 2; k = i >>> 2; l = 0; m = g; while (1) { n = m >>> 1; o = l + n | 0; p = o << 1; q = p + j | 0; r = rp(f[a + (q << 2) >> 2] | 0, e) | 0; s = rp(f[a + (q + 1 << 2) >> 2] | 0, e) | 0; if (!(s >>> 0 < c >>> 0 & r >>> 0 < (c - s | 0) >>> 0)) { t = 0; break a } if (b[a + (s + r) >> 0] | 0) { t = 0; break a } r = bl(d, a + s | 0) | 0; if (!r) break; s = (r | 0) < 0; if ((m | 0) == 1) { t = 0; break a } else { l = s ? l : o; m = s ? n : m - n | 0 } } m = p + k | 0; l = rp(f[a + (m << 2) >> 2] | 0, e) | 0; j = rp(f[a + (m + 1 << 2) >> 2] | 0, e) | 0; if (j >>> 0 < c >>> 0 & l >>> 0 < (c - j | 0) >>> 0) t = (b[a + (j + l) >> 0] | 0) == 0 ? a + j | 0 : 0; else t = 0 } else t = 0; while (0); return t | 0 } function mh(a, c, e, g) { a = a | 0; c = c | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; h = u; u = u + 64 | 0; i = h; j = f[a >> 2] | 0; k = a + (f[j + -8 >> 2] | 0) | 0; l = f[j + -4 >> 2] | 0; f[i >> 2] = e; f[i + 4 >> 2] = a; f[i + 8 >> 2] = c; f[i + 12 >> 2] = g; g = i + 16 | 0; c = i + 20 | 0; a = i + 24 | 0; j = i + 28 | 0; m = i + 32 | 0; n = i + 40 | 0; o = g; p = o + 36 | 0; do { f[o >> 2] = 0; o = o + 4 | 0 } while ((o | 0) < (p | 0)); d[g + 36 >> 1] = 0; b[g + 38 >> 0] = 0; a: do if (qp(l, e, 0) | 0) { f[i + 48 >> 2] = 1; _a[f[(f[l >> 2] | 0) + 20 >> 2] & 3](l, i, k, k, 1, 0); q = (f[a >> 2] | 0) == 1 ? k : 0 } else { Za[f[(f[l >> 2] | 0) + 24 >> 2] & 3](l, i, k, 1, 0); switch (f[i + 36 >> 2] | 0) { case 0: { q = (f[n >> 2] | 0) == 1 & (f[j >> 2] | 0) == 1 & (f[m >> 2] | 0) == 1 ? f[c >> 2] | 0 : 0; break a; break } case 1: break; default: { q = 0; break a } }if ((f[a >> 2] | 0) != 1 ? !((f[n >> 2] | 0) == 0 & (f[j >> 2] | 0) == 1 & (f[m >> 2] | 0) == 1) : 0) { q = 0; break } q = f[g >> 2] | 0 } while (0); u = h; return q | 0 } function nh(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 4 | 0; g = f[e >> 2] | 0; h = g; if (d - g >> 2 >>> 0 >= b >>> 0) { i = b; j = h; while (1) { f[j >> 2] = 1; i = i + -1 | 0; if (!i) break; else j = j + 4 | 0 } f[e >> 2] = h + (b << 2); return } h = f[a >> 2] | 0; j = g - h | 0; g = j >> 2; i = g + b | 0; if (i >>> 0 > 1073741823) mq(a); k = d - h | 0; d = k >> 1; l = k >> 2 >>> 0 < 536870911 ? (d >>> 0 < i >>> 0 ? i : d) : 1073741823; do if (l) if (l >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { d = dn(l << 2) | 0; m = d; n = d; break } else { m = 0; n = 0 } while (0); d = m + (g << 2) | 0; g = m + (l << 2) | 0; l = b; i = d; while (1) { f[i >> 2] = 1; l = l + -1 | 0; if (!l) break; else i = i + 4 | 0 } if ((j | 0) > 0) Rg(n | 0, h | 0, j | 0) | 0; f[a >> 2] = m; f[e >> 2] = d + (b << 2); f[c >> 2] = g; if (!h) return; br(h); return } function oh(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; if (!c) { g = 0; u = d; return g | 0 } h = a + 84 | 0; i = f[h >> 2] | 0; j = a + 88 | 0; k = f[j >> 2] | 0; if ((k | 0) != (i | 0)) f[j >> 2] = k + (~((k + -4 - i | 0) >>> 2) << 2); f[h >> 2] = 0; f[j >> 2] = 0; f[a + 92 >> 2] = 0; if (i | 0) br(i); i = a + 72 | 0; j = f[i >> 2] | 0; h = a + 76 | 0; if ((f[h >> 2] | 0) != (j | 0)) f[h >> 2] = j; f[i >> 2] = 0; f[h >> 2] = 0; f[a + 80 >> 2] = 0; if (j | 0) br(j); j = c + 4 | 0; h = (f[j >> 2] | 0) - (f[c >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(a, h, e); h = c + 24 | 0; i = c + 28 | 0; k = (f[i >> 2] | 0) - (f[h >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(a + 12 | 0, k, e); Sf(a + 28 | 0, (f[j >> 2] | 0) - (f[c >> 2] | 0) >> 2, 5868); $j(a + 52 | 0, (f[i >> 2] | 0) - (f[h >> 2] | 0) >> 2); $j(a + 40 | 0, (f[i >> 2] | 0) - (f[h >> 2] | 0) >> 2); f[a + 64 >> 2] = c; b[a + 24 >> 0] = 1; g = 1; u = d; return g | 0 } function ph(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; c = a + 12 | 0; d = f[a >> 2] | 0; e = a + 8 | 0; g = f[e >> 2] | 0; h = (g | 0) == -1; if (!(b[c >> 0] | 0)) { do if ((!h ? (i = (((g >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + g | 0, (i | 0) != -1) : 0) ? (j = f[(f[d + 12 >> 2] | 0) + (i << 2) >> 2] | 0, (j | 0) != -1) : 0) if (!((j >>> 0) % 3 | 0)) { k = j + 2 | 0; break } else { k = j + -1 | 0; break } else k = -1; while (0); f[e >> 2] = k; return } k = g + 1 | 0; if ((!h ? (h = ((k >>> 0) % 3 | 0 | 0) == 0 ? g + -2 | 0 : k, (h | 0) != -1) : 0) ? (k = f[(f[d + 12 >> 2] | 0) + (h << 2) >> 2] | 0, h = k + 1 | 0, (k | 0) != -1) : 0) { g = ((h >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : h; f[e >> 2] = g; if ((g | 0) != -1) { if ((g | 0) != (f[a + 4 >> 2] | 0)) return; f[e >> 2] = -1; return } } else f[e >> 2] = -1; g = f[a + 4 >> 2] | 0; do if (((g | 0) != -1 ? (a = (((g >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + g | 0, (a | 0) != -1) : 0) ? (h = f[(f[d + 12 >> 2] | 0) + (a << 2) >> 2] | 0, (h | 0) != -1) : 0) if (!((h >>> 0) % 3 | 0)) { l = h + 2 | 0; break } else { l = h + -1 | 0; break } else l = -1; while (0); f[e >> 2] = l; b[c >> 0] = 0; return } function qh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { Id(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 20 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; Id(a, e); return } function rh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; e = u; u = u + 48 | 0; g = e; h = e + 32 | 0; i = a + 4 | 0; j = f[i >> 2] | 0; if (!j) { k = 0; u = e; return k | 0 } do if (c) if (Qa[f[(f[j >> 2] | 0) + 16 >> 2] & 127](j) | 0) { l = f[i >> 2] | 0; Va[f[(f[l >> 2] | 0) + 20 >> 2] & 127](l); break } else { k = 0; u = e; return k | 0 } while (0); Cn(g); Si(h, f[a >> 2] | 0, g); a = (f[h >> 2] | 0) == 0; i = h + 4 | 0; if ((b[i + 11 >> 0] | 0) < 0) br(f[i >> 2] | 0); if (a) { a = f[g >> 2] | 0; i = g + 4 | 0; ag(d, a, a + ((f[i >> 2] | 0) - a) | 0); m = (f[i >> 2] | 0) - (f[g >> 2] | 0) | 0 } else m = 0; i = g + 12 | 0; a = f[i >> 2] | 0; f[i >> 2] = 0; if (a | 0) br(a); a = f[g >> 2] | 0; if (a | 0) { i = g + 4 | 0; if ((f[i >> 2] | 0) != (a | 0)) f[i >> 2] = a; br(a) } k = m; u = e; return k | 0 } function sh(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; d = f[a + 4 >> 2] | 0; if (!d) { e = 0; return e | 0 } a = b[c + 11 >> 0] | 0; g = a << 24 >> 24 < 0; h = g ? f[c + 4 >> 2] | 0 : a & 255; a = g ? f[c >> 2] | 0 : c; c = d; while (1) { d = c + 16 | 0; g = b[d + 11 >> 0] | 0; i = g << 24 >> 24 < 0; j = i ? f[c + 20 >> 2] | 0 : g & 255; g = j >>> 0 < h >>> 0; k = g ? j : h; if ((k | 0) != 0 ? (l = Pk(a, i ? f[d >> 2] | 0 : d, k) | 0, (l | 0) != 0) : 0) if ((l | 0) < 0) m = 7; else m = 8; else if (h >>> 0 < j >>> 0) m = 7; else m = 8; if ((m | 0) == 7) { m = 0; n = c } else if ((m | 0) == 8) { m = 0; l = h >>> 0 < j >>> 0 ? h : j; if ((l | 0) != 0 ? (j = Pk(i ? f[d >> 2] | 0 : d, a, l) | 0, (j | 0) != 0) : 0) { if ((j | 0) >= 0) { e = 1; m = 14; break } } else m = 10; if ((m | 0) == 10 ? (m = 0, !g) : 0) { e = 1; m = 14; break } n = c + 4 | 0 } c = f[n >> 2] | 0; if (!c) { e = 0; m = 14; break } } if ((m | 0) == 14) return e | 0; return 0 } function th(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; c = u; u = u + 16 | 0; d = c + 12 | 0; e = c + 8 | 0; g = c + 4 | 0; h = c; i = a + 4 | 0; j = (i | 0) == (b | 0); if (!j) { f[g >> 2] = f[b >> 2]; f[h >> 2] = b + 4; f[e >> 2] = f[g >> 2]; f[d >> 2] = f[h >> 2]; Hc(i, e, d) } if (!j) { f[g >> 2] = f[b + 12 >> 2]; f[h >> 2] = b + 16; f[e >> 2] = f[g >> 2]; f[d >> 2] = f[h >> 2]; Ac(a + 16 | 0, e, d) } if (j) { u = c; return } f[g >> 2] = f[b + 24 >> 2]; f[h >> 2] = b + 28; f[e >> 2] = f[g >> 2]; f[d >> 2] = f[h >> 2]; Hc(a + 28 | 0, e, d); u = c; return } function uh(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; di(g, a, b, c, d); d = f[g >> 2] | 0; if (!d) { i = -1; f[g >> 2] = 0; u = e; return i | 0 } f[g >> 2] = 0; f[h >> 2] = d; d = ah(a, h) | 0; a = f[h >> 2] | 0; f[h >> 2] = 0; if (!a) { i = d; f[g >> 2] = 0; u = e; return i | 0 } h = a + 88 | 0; c = f[h >> 2] | 0; f[h >> 2] = 0; if (c | 0) { h = f[c + 8 >> 2] | 0; if (h | 0) { b = c + 12 | 0; if ((f[b >> 2] | 0) != (h | 0)) f[b >> 2] = h; br(h) } br(c) } c = f[a + 68 >> 2] | 0; if (c | 0) { h = a + 72 | 0; b = f[h >> 2] | 0; if ((b | 0) != (c | 0)) f[h >> 2] = b + (~((b + -4 - c | 0) >>> 2) << 2); br(c) } c = a + 64 | 0; b = f[c >> 2] | 0; f[c >> 2] = 0; if (b | 0) { c = f[b >> 2] | 0; if (c | 0) { h = b + 4 | 0; if ((f[h >> 2] | 0) != (c | 0)) f[h >> 2] = c; br(c) } br(b) } br(a); i = d; f[g >> 2] = 0; u = e; return i | 0 } function vh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0; e = u; u = u + 16 | 0; g = e + 4 | 0; h = e; i = f[a + 8 >> 2] | 0; j = i + 24 | 0; k = b[j >> 0] | 0; l = c + 4 | 0; Nf(a, (f[l >> 2] | 0) - (f[c >> 2] | 0) >> 2, k, d); d = f[a + 32 >> 2] | 0; a = (f[f[d >> 2] >> 2] | 0) + (f[d + 48 >> 2] | 0) | 0; d = f[c >> 2] | 0; c = f[l >> 2] | 0; if ((d | 0) == (c | 0)) { m = 1; u = e; return m | 0 } l = i + 84 | 0; n = i + 68 | 0; o = 0; p = d; while (1) { d = f[p >> 2] | 0; if (!(b[l >> 0] | 0)) q = f[(f[n >> 2] | 0) + (d << 2) >> 2] | 0; else q = d; f[h >> 2] = q; d = b[j >> 0] | 0; f[g >> 2] = f[h >> 2]; if (!(Pb(i, g, d, a + (o << 2) | 0) | 0)) { m = 0; r = 7; break } p = p + 4 | 0; if ((p | 0) == (c | 0)) { m = 1; r = 7; break } else o = o + k | 0 } if ((r | 0) == 7) { u = e; return m | 0 } return 0 } function wh(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; f[a >> 2] = 1392; b = a + 72 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); c = f[a + 60 >> 2] | 0; if (c | 0) { b = a + 64 | 0; d = f[b >> 2] | 0; if ((d | 0) != (c | 0)) f[b >> 2] = d + (~((d + -4 - c | 0) >>> 2) << 2); br(c) } c = f[a + 48 >> 2] | 0; if (c | 0) br(c); c = a + 36 | 0; d = f[c >> 2] | 0; if (d | 0) { b = a + 40 | 0; e = f[b >> 2] | 0; if ((e | 0) == (d | 0)) g = d; else { h = e; do { e = h + -4 | 0; f[b >> 2] = e; i = f[e >> 2] | 0; f[e >> 2] = 0; if (i | 0) Va[f[(f[i >> 2] | 0) + 4 >> 2] & 127](i); h = f[b >> 2] | 0 } while ((h | 0) != (d | 0)); g = f[c >> 2] | 0 } br(g) } f[a >> 2] = 1216; g = f[a + 16 >> 2] | 0; if (g | 0) { c = a + 20 | 0; d = f[c >> 2] | 0; if ((d | 0) != (g | 0)) f[c >> 2] = d + (~((d + -4 - g | 0) >>> 2) << 2); br(g) } g = f[a + 4 >> 2] | 0; if (!g) return; d = a + 8 | 0; a = f[d >> 2] | 0; if ((a | 0) != (g | 0)) f[d >> 2] = a + (~((a + -4 - g | 0) >>> 2) << 2); br(g); return } function xh(a) { a = a | 0; tj(a + 992 | 0); tj(a + 960 | 0); tj(a + 928 | 0); tj(a + 896 | 0); tj(a + 864 | 0); tj(a + 832 | 0); tj(a + 800 | 0); tj(a + 768 | 0); tj(a + 736 | 0); tj(a + 704 | 0); tj(a + 672 | 0); tj(a + 640 | 0); tj(a + 608 | 0); tj(a + 576 | 0); tj(a + 544 | 0); tj(a + 512 | 0); tj(a + 480 | 0); tj(a + 448 | 0); tj(a + 416 | 0); tj(a + 384 | 0); tj(a + 352 | 0); tj(a + 320 | 0); tj(a + 288 | 0); tj(a + 256 | 0); tj(a + 224 | 0); tj(a + 192 | 0); tj(a + 160 | 0); tj(a + 128 | 0); tj(a + 96 | 0); tj(a + 64 | 0); tj(a + 32 | 0); tj(a); return } function yh(a) { a = a | 0; rn(a); rn(a + 32 | 0); rn(a + 64 | 0); rn(a + 96 | 0); rn(a + 128 | 0); rn(a + 160 | 0); rn(a + 192 | 0); rn(a + 224 | 0); rn(a + 256 | 0); rn(a + 288 | 0); rn(a + 320 | 0); rn(a + 352 | 0); rn(a + 384 | 0); rn(a + 416 | 0); rn(a + 448 | 0); rn(a + 480 | 0); rn(a + 512 | 0); rn(a + 544 | 0); rn(a + 576 | 0); rn(a + 608 | 0); rn(a + 640 | 0); rn(a + 672 | 0); rn(a + 704 | 0); rn(a + 736 | 0); rn(a + 768 | 0); rn(a + 800 | 0); rn(a + 832 | 0); rn(a + 864 | 0); rn(a + 896 | 0); rn(a + 928 | 0); rn(a + 960 | 0); rn(a + 992 | 0); return } function zh(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; a = u; u = u + 16 | 0; e = a; if ((c | 0) < 0 | ((b | 0) == 0 | (d | 0) == 0)) { g = 0; u = a; return g | 0 } h = f[b + 8 >> 2] | 0; if (((f[b + 12 >> 2] | 0) - h >> 2 | 0) <= (c | 0)) { g = 0; u = a; return g | 0 } i = b + 4 | 0; if (!(f[i >> 2] | 0)) { j = dn(52) | 0; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; f[j + 12 >> 2] = 0; n[j + 16 >> 2] = $(1.0); k = j + 20 | 0; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; n[j + 36 >> 2] = $(1.0); f[j + 40 >> 2] = 0; f[j + 44 >> 2] = 0; f[j + 48 >> 2] = 0; f[b + 4 >> 2] = j } j = f[(f[h + (c << 2) >> 2] | 0) + 60 >> 2] | 0; c = dn(44) | 0; Ub(c, d); f[c + 40 >> 2] = j; j = f[i >> 2] | 0; f[e >> 2] = c; gk(j, e) | 0; j = f[e >> 2] | 0; f[e >> 2] = 0; if (!j) { g = 1; u = a; return g | 0 } Qi(j); br(j); g = 1; u = a; return g | 0 } function Ah(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; f[a >> 2] = d; e = a + 24 | 0; g = a + 28 | 0; h = f[g >> 2] | 0; i = f[e >> 2] | 0; j = h - i >> 2; k = i; i = h; if (j >>> 0 >= d >>> 0) { if (j >>> 0 > d >>> 0 ? (h = k + (d << 2) | 0, (h | 0) != (i | 0)) : 0) f[g >> 2] = i + (~((i + -4 - h | 0) >>> 2) << 2) } else oi(e, d - j | 0); if (!c) return; j = f[b >> 2] | 0; if ((c | 0) > 1) { d = j; e = j; h = 1; while (1) { i = f[b + (h << 2) >> 2] | 0; g = (i | 0) < (e | 0); k = g ? i : e; l = g ? d : (i | 0) > (d | 0) ? i : d; h = h + 1 | 0; if ((h | 0) == (c | 0)) { m = l; n = k; break } else { d = l; e = k } } } else { m = j; n = j } f[a + 4 >> 2] = n; f[a + 8 >> 2] = m; j = Vn(m | 0, ((m | 0) < 0) << 31 >> 31 | 0, n | 0, ((n | 0) < 0) << 31 >> 31 | 0) | 0; n = I; if (!(n >>> 0 < 0 | (n | 0) == 0 & j >>> 0 < 2147483647)) return; n = j + 1 | 0; f[a + 12 >> 2] = n; j = (n | 0) / 2 | 0; m = a + 16 | 0; f[m >> 2] = j; f[a + 20 >> 2] = 0 - j; if (n & 1 | 0) return; f[m >> 2] = j + -1; return } function Bh(a, c, d, e, g, h, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; var j = 0, k = 0; c = u; u = u + 64 | 0; j = c; k = i ? 6 : 5; Al(j); i = f[h + 56 >> 2] | 0; h = X(Ll(k) | 0, e) | 0; yj(j, i, 0, e & 255, k, 0, h, ((h | 0) < 0) << 31 >> 31, 0, 0); h = dn(96) | 0; nl(h, j); f[a >> 2] = h; pj(h, d) | 0; d = h + 84 | 0; if (!g) { b[d >> 0] = 1; a = f[h + 68 >> 2] | 0; j = h + 72 | 0; k = f[j >> 2] | 0; if ((k | 0) == (a | 0)) { u = c; return } f[j >> 2] = k + (~((k + -4 - a | 0) >>> 2) << 2); u = c; return } b[d >> 0] = 0; d = h + 68 | 0; a = h + 72 | 0; h = f[a >> 2] | 0; k = f[d >> 2] | 0; j = h - k >> 2; e = h; if (j >>> 0 < g >>> 0) { kh(d, g - j | 0, 1200); u = c; return } if (j >>> 0 <= g >>> 0) { u = c; return } j = k + (g << 2) | 0; if ((j | 0) == (e | 0)) { u = c; return } f[a >> 2] = e + (~((e + -4 - j | 0) >>> 2) << 2); u = c; return } function Ch(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { jd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; jd(a, e); return } function Dh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { nd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; nd(a, e); return } function Eh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { ud(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; ud(a, e); return } function Fh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { Ed(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; Ed(a, e); return } function Gh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { ld(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; ld(a, e); return } function Hh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { qd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; qd(a, e); return } function Ih(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { yd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; yd(a, e); return } function Jh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { kd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; kd(a, e); return } function Kh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { od(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; od(a, e); return } function Lh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { vd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; vd(a, e); return } function Mh(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { Fd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; Fd(a, e); return } function Nh(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; b[h >> 0] = a & 127; do if (a >>> 0 > 127) { b[h >> 0] = a | 128; i = c + 16 | 0; j = f[i + 4 >> 2] | 0; if ((j | 0) > 0 | (j | 0) == 0 & (f[i >> 2] | 0) >>> 0 > 0) { k = 0; break } else { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0; k = Nh(a >>> 7, c) | 0; break } } else { i = c + 16 | 0; j = f[i + 4 >> 2] | 0; if ((j | 0) > 0 | (j | 0) == 0 & (f[i >> 2] | 0) >>> 0 > 0) { k = 0; break } f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0; l = 1; u = d; return l | 0 } while (0); l = k; u = d; return l | 0 } function Oh(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; d = u; u = u + 16 | 0; e = d; Be(e, a + 40 | 0, f[a + 8 >> 2] | 0, b, c); Wi(a, e); a = f[e >> 2] | 0; f[e >> 2] = 0; if (!a) { u = d; return 1 } e = a + 88 | 0; c = f[e >> 2] | 0; f[e >> 2] = 0; if (c | 0) { e = f[c + 8 >> 2] | 0; if (e | 0) { b = c + 12 | 0; if ((f[b >> 2] | 0) != (e | 0)) f[b >> 2] = e; br(e) } br(c) } c = f[a + 68 >> 2] | 0; if (c | 0) { e = a + 72 | 0; b = f[e >> 2] | 0; if ((b | 0) != (c | 0)) f[e >> 2] = b + (~((b + -4 - c | 0) >>> 2) << 2); br(c) } c = a + 64 | 0; b = f[c >> 2] | 0; f[c >> 2] = 0; if (b | 0) { c = f[b >> 2] | 0; if (c | 0) { e = b + 4 | 0; if ((f[e >> 2] | 0) != (c | 0)) f[e >> 2] = c; br(c) } br(b) } br(a); u = d; return 1 } function Ph(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { rd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; rd(a, e); return } function Qh(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0; e = u; u = u + 48 | 0; g = e; h = e + 32 | 0; if (!c) { i = 0; u = e; return i | 0 } Cn(g); if ((Tl(c, 0) | 0) != -1 ? Qa[f[(f[c >> 2] | 0) + 16 >> 2] & 127](c) | 0 : 0) { Va[f[(f[c >> 2] | 0) + 20 >> 2] & 127](c); Zf(h, a, c, g); c = (f[h >> 2] | 0) == 0; a = h + 4 | 0; if ((b[a + 11 >> 0] | 0) < 0) br(f[a >> 2] | 0); if (c) { c = f[g >> 2] | 0; a = g + 4 | 0; ag(d, c, c + ((f[a >> 2] | 0) - c) | 0); j = (f[a >> 2] | 0) - (f[g >> 2] | 0) | 0 } else j = 0 } else j = 0; a = g + 12 | 0; c = f[a >> 2] | 0; f[a >> 2] = 0; if (c | 0) br(c); c = f[g >> 2] | 0; if (c | 0) { a = g + 4 | 0; if ((f[a >> 2] | 0) != (c | 0)) f[a >> 2] = c; br(c) } i = j; u = e; return i | 0 } function Rh(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; d = u; u = u + 16 | 0; e = d; se(e, a + 40 | 0, f[a + 8 >> 2] | 0, b, c); Wi(a, e); a = f[e >> 2] | 0; f[e >> 2] = 0; if (!a) { u = d; return 1 } e = a + 88 | 0; c = f[e >> 2] | 0; f[e >> 2] = 0; if (c | 0) { e = f[c + 8 >> 2] | 0; if (e | 0) { b = c + 12 | 0; if ((f[b >> 2] | 0) != (e | 0)) f[b >> 2] = e; br(e) } br(c) } c = f[a + 68 >> 2] | 0; if (c | 0) { e = a + 72 | 0; b = f[e >> 2] | 0; if ((b | 0) != (c | 0)) f[e >> 2] = b + (~((b + -4 - c | 0) >>> 2) << 2); br(c) } c = a + 64 | 0; b = f[c >> 2] | 0; f[c >> 2] = 0; if (b | 0) { c = f[b >> 2] | 0; if (c | 0) { e = b + 4 | 0; if ((f[e >> 2] | 0) != (c | 0)) f[e >> 2] = c; br(c) } br(b) } br(a); u = d; return 1 } function Sh(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; b = f[a >> 2] | 0; if (!b) return; c = a + 4 | 0; d = f[c >> 2] | 0; if ((d | 0) == (b | 0)) e = b; else { g = d; do { d = g + -4 | 0; f[c >> 2] = d; h = f[d >> 2] | 0; f[d >> 2] = 0; if (h | 0) { d = h + 88 | 0; i = f[d >> 2] | 0; f[d >> 2] = 0; if (i | 0) { d = f[i + 8 >> 2] | 0; if (d | 0) { j = i + 12 | 0; if ((f[j >> 2] | 0) != (d | 0)) f[j >> 2] = d; br(d) } br(i) } i = f[h + 68 >> 2] | 0; if (i | 0) { d = h + 72 | 0; j = f[d >> 2] | 0; if ((j | 0) != (i | 0)) f[d >> 2] = j + (~((j + -4 - i | 0) >>> 2) << 2); br(i) } i = h + 64 | 0; j = f[i >> 2] | 0; f[i >> 2] = 0; if (j | 0) { i = f[j >> 2] | 0; if (i | 0) { d = j + 4 | 0; if ((f[d >> 2] | 0) != (i | 0)) f[d >> 2] = i; br(i) } br(j) } br(h) } g = f[c >> 2] | 0 } while ((g | 0) != (b | 0)); e = f[a >> 2] | 0 } br(e); return } function Th(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; e = (d | 0) < 0; do if (!b) { if (e) { g = 0; return g | 0 } h = a + 4 | 0; i = f[h >> 2] | 0; j = f[a >> 2] | 0; k = i - j | 0; if (k >>> 0 < c >>> 0) { ri(a, c - k | 0); break } if (k >>> 0 > c >>> 0 ? (k = j + c | 0, (k | 0) != (i | 0)) : 0) f[h >> 2] = k } else { if (e) { g = 0; return g | 0 } k = a + 4 | 0; h = f[k >> 2] | 0; i = f[a >> 2] | 0; j = h - i | 0; do if (0 < (d | 0) | 0 == (d | 0) & j >>> 0 < c >>> 0) { if (j >>> 0 < c >>> 0) { ri(a, c - j | 0); break } if (j >>> 0 > c >>> 0 ? (l = i + c | 0, (l | 0) != (h | 0)) : 0) { f[k >> 2] = l; m = 15 } else m = 15 } else m = 15; while (0); if ((m | 0) == 15 ? (c | 0) == 0 : 0) break; Xl(f[a >> 2] | 0, b | 0, c | 0) | 0 } while (0); c = a + 24 | 0; a = c; b = Tn(f[a >> 2] | 0, f[a + 4 >> 2] | 0, 1, 0) | 0; a = c; f[a >> 2] = b; f[a + 4 >> 2] = I; g = 1; return g | 0 } function Uh(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; if (!(ve(a, c) | 0)) { i = 0; u = d; return i | 0 } j = a + 36 | 0; k = a + 40 | 0; a = f[j >> 2] | 0; if ((f[k >> 2] | 0) == (a | 0)) { i = 1; u = d; return i | 0 } l = c + 16 | 0; m = c + 4 | 0; n = h + 1 | 0; o = 0; p = a; do { a = f[p + (o << 2) >> 2] | 0; q = Qa[f[(f[a >> 2] | 0) + 32 >> 2] & 127](a) | 0; b[h >> 0] = q; q = l; a = f[q + 4 >> 2] | 0; if (!((a | 0) > 0 | (a | 0) == 0 & (f[q >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[m >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, n) | 0 } o = o + 1 | 0; p = f[j >> 2] | 0 } while (o >>> 0 < (f[k >> 2] | 0) - p >> 2 >>> 0); i = 1; u = d; return i | 0 } function Vh(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = u; u = u + 16 | 0; d = c; wp(a); f[a + 16 >> 2] = 0; f[a + 20 >> 2] = 0; f[a + 12 >> 2] = a + 16; e = a + 24 | 0; wp(e); f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; a = dn(32) | 0; f[d >> 2] = a; f[d + 8 >> 2] = -2147483616; f[d + 4 >> 2] = 20; g = a; h = 13101; i = g + 20 | 0; do { b[g >> 0] = b[h >> 0] | 0; g = g + 1 | 0; h = h + 1 | 0 } while ((g | 0) < (i | 0)); b[a + 20 >> 0] = 0; Mj(e, d, 1); if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; a = dn(32) | 0; f[d >> 2] = a; f[d + 8 >> 2] = -2147483616; f[d + 4 >> 2] = 22; g = a; h = 13122; i = g + 22 | 0; do { b[g >> 0] = b[h >> 0] | 0; g = g + 1 | 0; h = h + 1 | 0 } while ((g | 0) < (i | 0)); b[a + 22 >> 0] = 0; Mj(e, d, 1); if ((b[d + 11 >> 0] | 0) >= 0) { u = c; return } br(f[d >> 2] | 0); u = c; return } function Wh(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; b = f[a + 4 >> 2] | 0; c = a + 8 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) { e = d; do { d = e + -4 | 0; f[c >> 2] = d; g = f[d >> 2] | 0; f[d >> 2] = 0; if (g | 0) { d = g + 88 | 0; h = f[d >> 2] | 0; f[d >> 2] = 0; if (h | 0) { d = f[h + 8 >> 2] | 0; if (d | 0) { i = h + 12 | 0; if ((f[i >> 2] | 0) != (d | 0)) f[i >> 2] = d; br(d) } br(h) } h = f[g + 68 >> 2] | 0; if (h | 0) { d = g + 72 | 0; i = f[d >> 2] | 0; if ((i | 0) != (h | 0)) f[d >> 2] = i + (~((i + -4 - h | 0) >>> 2) << 2); br(h) } h = g + 64 | 0; i = f[h >> 2] | 0; f[h >> 2] = 0; if (i | 0) { h = f[i >> 2] | 0; if (h | 0) { d = i + 4 | 0; if ((f[d >> 2] | 0) != (h | 0)) f[d >> 2] = h; br(h) } br(i) } br(g) } e = f[c >> 2] | 0 } while ((e | 0) != (b | 0)) } b = f[a >> 2] | 0; if (!b) return; br(b); return } function Xh(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; f[g >> 2] = f[a + 12 >> 2]; h = b + 16 | 0; i = h; j = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & j >>> 0 > 0) { l = k; m = j } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; j = h; l = f[j + 4 >> 2] | 0; m = f[j >> 2] | 0 } f[g >> 2] = f[a + 20 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; u = c; return 1 } function Yh(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = u; u = u + 16 | 0; d = c; e = dn(16) | 0; f[d >> 2] = e; f[d + 8 >> 2] = -2147483632; f[d + 4 >> 2] = 14; g = e; h = 12975; i = g + 14 | 0; do { b[g >> 0] = b[h >> 0] | 0; g = g + 1 | 0; h = h + 1 | 0 } while ((g | 0) < (i | 0)); b[e + 14 >> 0] = 0; e = yk(a, d, -1) | 0; if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); j = dn(16) | 0; f[d >> 2] = j; f[d + 8 >> 2] = -2147483632; f[d + 4 >> 2] = 14; g = j; h = 12990; i = g + 14 | 0; do { b[g >> 0] = b[h >> 0] | 0; g = g + 1 | 0; h = h + 1 | 0 } while ((g | 0) < (i | 0)); b[j + 14 >> 0] = 0; j = yk(a, d, -1) | 0; if ((b[d + 11 >> 0] | 0) >= 0) { k = (e | 0) < (j | 0); l = k ? j : e; m = (l | 0) == -1; n = m ? 5 : l; u = c; return n | 0 } br(f[d >> 2] | 0); k = (e | 0) < (j | 0); l = k ? j : e; m = (l | 0) == -1; n = m ? 5 : l; u = c; return n | 0 } function Zh(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; f[g >> 2] = f[a + 12 >> 2]; h = b + 16 | 0; i = h; j = f[i >> 2] | 0; k = f[i + 4 >> 2] | 0; if ((k | 0) > 0 | (k | 0) == 0 & j >>> 0 > 0) { l = k; m = j } else { f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; j = h; l = f[j + 4 >> 2] | 0; m = f[j >> 2] | 0 } f[g >> 2] = f[a + 16 >> 2]; if ((l | 0) > 0 | (l | 0) == 0 & m >>> 0 > 0) { u = c; return 1 } f[e >> 2] = f[b + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(b, d, g, g + 4 | 0) | 0; u = c; return 1 } function _h(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; g = dn(32) | 0; f[a >> 2] = g; f[a + 4 >> 2] = c + 8; c = a + 8 | 0; b[c >> 0] = 0; h = g + 8 | 0; f[h >> 2] = f[e >> 2]; f[h + 4 >> 2] = f[e + 4 >> 2]; f[h + 8 >> 2] = f[e + 8 >> 2]; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; h = g + 20 | 0; i = e + 12 | 0; f[h >> 2] = 0; f[g + 24 >> 2] = 0; f[g + 28 >> 2] = 0; g = e + 16 | 0; e = f[g >> 2] | 0; j = f[i >> 2] | 0; k = e - j | 0; if (!k) { l = j; m = e; n = 0 } else { ri(h, k); l = f[i >> 2] | 0; m = f[g >> 2] | 0; n = f[h >> 2] | 0 } Rg(n | 0, l | 0, m - l | 0) | 0; b[c >> 0] = 1; c = f[a >> 2] | 0; f[c + 4 >> 2] = d; f[c >> 2] = 0; return } function $h(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; b = a + 32 | 0; fd(a, b); c = a + 80 | 0; d = f[c >> 2] | 0; if ((d | 0 ? (e = a + 84 | 0, (f[e >> 2] | 0) > 0) : 0) ? (fd(d, b), (f[e >> 2] | 0) > 1) : 0) { d = 1; do { fd((f[c >> 2] | 0) + (d << 5) | 0, b); d = d + 1 | 0 } while ((d | 0) < (f[e >> 2] | 0)) } e = a + 136 | 0; d = a + 140 | 0; a = f[e >> 2] | 0; if ((f[d >> 2] | 0) == (a | 0)) return; c = 0; g = a; while (1) { a = g; Nh((f[a + (c * 12 | 0) + 4 >> 2] | 0) - (f[a + (c * 12 | 0) >> 2] | 0) >> 2, b) | 0; a = f[e >> 2] | 0; h = f[a + (c * 12 | 0) >> 2] | 0; i = (f[a + (c * 12 | 0) + 4 >> 2] | 0) - h >> 2; if (!i) j = a; else { Dc(h, i, 1, 0, b) | 0; j = f[e >> 2] | 0 } c = c + 1 | 0; if (c >>> 0 >= (((f[d >> 2] | 0) - j | 0) / 12 | 0) >>> 0) break; else g = j } return } function ai(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; e = d + 16 | 0; g = f[e >> 2] | 0; if (!g) if (!(pl(d) | 0)) { h = f[e >> 2] | 0; i = 5 } else j = 0; else { h = g; i = 5 } a: do if ((i | 0) == 5) { g = d + 20 | 0; e = f[g >> 2] | 0; k = e; if ((h - e | 0) >>> 0 < c >>> 0) { j = Sa[f[d + 36 >> 2] & 31](d, a, c) | 0; break } b: do if ((b[d + 75 >> 0] | 0) > -1) { e = c; while (1) { if (!e) { l = 0; m = a; n = c; o = k; break b } p = e + -1 | 0; if ((b[a + p >> 0] | 0) == 10) break; else e = p } p = Sa[f[d + 36 >> 2] & 31](d, a, e) | 0; if (p >>> 0 < e >>> 0) { j = p; break a } l = e; m = a + e | 0; n = c - e | 0; o = f[g >> 2] | 0 } else { l = 0; m = a; n = c; o = k } while (0); Rg(o | 0, m | 0, n | 0) | 0; f[g >> 2] = (f[g >> 2] | 0) + n; j = l + n | 0 } while (0); return j | 0 } function bi(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = a + 12 | 0; d = f[c >> 2] | 0; f[c >> 2] = 0; if (d | 0) { c = f[d + 28 >> 2] | 0; if (c | 0) { e = c; do { c = e; e = f[e >> 2] | 0; bi(c + 8 | 0); br(c) } while ((e | 0) != 0) } e = d + 20 | 0; c = f[e >> 2] | 0; f[e >> 2] = 0; if (c | 0) br(c); c = f[d + 8 >> 2] | 0; if (c | 0) { e = c; do { c = e; e = f[e >> 2] | 0; g = c + 8 | 0; h = f[c + 20 >> 2] | 0; if (h | 0) { i = c + 24 | 0; if ((f[i >> 2] | 0) != (h | 0)) f[i >> 2] = h; br(h) } if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); br(c) } while ((e | 0) != 0) } e = f[d >> 2] | 0; f[d >> 2] = 0; if (e | 0) br(e); br(d) } if ((b[a + 11 >> 0] | 0) >= 0) return; br(f[a >> 2] | 0); return } function ci(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0; g = u; u = u + 32 | 0; h = g + 12 | 0; i = g; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; if ((e | 0) > 0) { j = i + 11 | 0; k = i + 4 | 0; l = 0; do { if ((l | 0) > 0) vn(h, 12890) | 0; cl(i, $(n[d + (l << 2) >> 2])); m = b[j >> 0] | 0; o = m << 24 >> 24 < 0; $i(h, o ? f[i >> 2] | 0 : i, o ? f[k >> 2] | 0 : m & 255) | 0; if ((b[j >> 0] | 0) < 0) br(f[i >> 2] | 0); l = l + 1 | 0 } while ((l | 0) < (e | 0)) } Ql(mi(a, c) | 0, h) | 0; if ((b[h + 11 >> 0] | 0) >= 0) { u = g; return } br(f[h >> 2] | 0); u = g; return } function di(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; if ((f[d + 56 >> 2] | 0) == -1) { h = 0; f[a >> 2] = h; return } i = dn(96) | 0; nl(i, d); d = i; do if (!e) { j = f[c + 80 >> 2] | 0; b[i + 84 >> 0] = 0; k = i + 68 | 0; l = i + 72 | 0; m = f[l >> 2] | 0; n = f[k >> 2] | 0; o = m - n >> 2; p = m; if (j >>> 0 > o >>> 0) { kh(k, j - o | 0, 5908); break } if (j >>> 0 < o >>> 0 ? (o = n + (j << 2) | 0, (o | 0) != (p | 0)) : 0) f[l >> 2] = p + (~((p + -4 - o | 0) >>> 2) << 2) } else { b[i + 84 >> 0] = 1; o = f[i + 68 >> 2] | 0; p = i + 72 | 0; l = f[p >> 2] | 0; if ((l | 0) != (o | 0)) f[p >> 2] = l + (~((l + -4 - o | 0) >>> 2) << 2); f[i + 80 >> 2] = f[c + 80 >> 2] } while (0); if (!g) { h = d; f[a >> 2] = h; return } pj(i, g) | 0; h = d; f[a >> 2] = h; return } function ei(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = (f[c >> 2] | 0) - d | 0; g = e >> 3; h = g + 1 | 0; if (h >>> 0 > 536870911) mq(a); i = a + 8 | 0; j = (f[i >> 2] | 0) - d | 0; k = j >> 2; l = j >> 3 >>> 0 < 268435455 ? (k >>> 0 < h >>> 0 ? h : k) : 536870911; do if (l) if (l >>> 0 > 536870911) { k = ra(8) | 0; Wo(k, 14941); f[k >> 2] = 6944; va(k | 0, 1080, 114) } else { k = dn(l << 3) | 0; m = k; n = k; break } else { m = 0; n = 0 } while (0); k = m + (g << 3) | 0; g = b; b = f[g + 4 >> 2] | 0; h = k; f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = b; if ((e | 0) > 0) Rg(n | 0, d | 0, e | 0) | 0; f[a >> 2] = m; f[c >> 2] = k + 8; f[i >> 2] = m + (l << 3); if (!d) return; br(d); return } function fi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = u; u = u + 16 | 0; d = c; if ((Qa[f[(f[b >> 2] | 0) + 20 >> 2] & 127](b) | 0) <= 0) { e = 1; u = c; return e | 0 } g = a + 4 | 0; h = a + 20 | 0; i = a + 24 | 0; j = a + 16 | 0; a = 0; while (1) { k = f[(f[g >> 2] | 0) + 4 >> 2] | 0; l = Tl(k, Ra[f[(f[b >> 2] | 0) + 24 >> 2] & 127](b, a) | 0) | 0; f[d >> 2] = l; if ((l | 0) == -1) break; k = f[h >> 2] | 0; if ((k | 0) == (f[i >> 2] | 0)) Ci(j, d); else { f[k >> 2] = l; f[h >> 2] = k + 4 } al(f[g >> 2] | 0, f[d >> 2] | 0) | 0; a = a + 1 | 0; if ((a | 0) >= (Qa[f[(f[b >> 2] | 0) + 20 >> 2] & 127](b) | 0)) { e = 1; m = 9; break } } if ((m | 0) == 9) { u = c; return e | 0 } e = 0; u = c; return e | 0 } function gi(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; f[a >> 2] = 1276; Sh(a + 60 | 0); b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = a + 36 | 0; d = f[b >> 2] | 0; if (d | 0) { c = a + 40 | 0; e = f[c >> 2] | 0; if ((e | 0) == (d | 0)) g = d; else { h = e; do { e = h + -24 | 0; f[c >> 2] = e; Va[f[f[e >> 2] >> 2] & 127](e); h = f[c >> 2] | 0 } while ((h | 0) != (d | 0)); g = f[b >> 2] | 0 } br(g) } f[a >> 2] = 1216; g = f[a + 16 >> 2] | 0; if (g | 0) { b = a + 20 | 0; d = f[b >> 2] | 0; if ((d | 0) != (g | 0)) f[b >> 2] = d + (~((d + -4 - g | 0) >>> 2) << 2); br(g) } g = f[a + 4 >> 2] | 0; if (!g) return; d = a + 8 | 0; a = f[d >> 2] | 0; if ((a | 0) != (g | 0)) f[d >> 2] = a + (~((a + -4 - g | 0) >>> 2) << 2); br(g); return } function hi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; c = u; u = u + 32 | 0; d = c + 16 | 0; e = c + 8 | 0; g = c; h = a + 8 | 0; if (f[h >> 2] << 5 >>> 0 >= b >>> 0) { u = c; return } f[d >> 2] = 0; i = d + 4 | 0; f[i >> 2] = 0; j = d + 8 | 0; f[j >> 2] = 0; if ((b | 0) < 0) mq(d); k = ((b + -1 | 0) >>> 5) + 1 | 0; b = dn(k << 2) | 0; f[d >> 2] = b; f[i >> 2] = 0; f[j >> 2] = k; k = f[a >> 2] | 0; f[e >> 2] = k; f[e + 4 >> 2] = 0; b = a + 4 | 0; l = f[b >> 2] | 0; f[g >> 2] = k + (l >>> 5 << 2); f[g + 4 >> 2] = l & 31; ig(d, e, g); g = f[a >> 2] | 0; f[a >> 2] = f[d >> 2]; f[d >> 2] = g; d = f[b >> 2] | 0; f[b >> 2] = f[i >> 2]; f[i >> 2] = d; d = f[h >> 2] | 0; f[h >> 2] = f[j >> 2]; f[j >> 2] = d; if (g | 0) br(g); u = c; return } function ii(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; b = a + 136 | 0; c = f[b >> 2] | 0; if (c | 0) { d = a + 140 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) g = c; else { h = e; while (1) { e = h + -12 | 0; f[d >> 2] = e; i = f[e >> 2] | 0; if (!i) j = e; else { e = h + -8 | 0; k = f[e >> 2] | 0; if ((k | 0) != (i | 0)) f[e >> 2] = k + (~((k + -4 - i | 0) >>> 2) << 2); br(i); j = f[d >> 2] | 0 } if ((j | 0) == (c | 0)) break; else h = j } g = f[b >> 2] | 0 } br(g) } g = f[a + 104 >> 2] | 0; if (g | 0) { b = a + 108 | 0; j = f[b >> 2] | 0; if ((j | 0) != (g | 0)) f[b >> 2] = j + (~((j + -4 - g | 0) >>> 2) << 2); br(g) } g = f[a + 92 >> 2] | 0; if (!g) { jj(a); return } j = a + 96 | 0; b = f[j >> 2] | 0; if ((b | 0) != (g | 0)) f[j >> 2] = b + (~((b + -4 - g | 0) >>> 2) << 2); br(g); jj(a); return } function ji(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0; f[a >> 2] = 3340; c = a + 72 | 0; d = a + 136 | 0; e = a + 4 | 0; g = e + 64 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); e = c; g = e + 64 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); n[d >> 2] = $(1.0); d = a + 140 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; f[a + 164 >> 2] = -1; d = a + 168 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; f[d + 24 >> 2] = 0; rn(a + 200 | 0); Cn(a + 232 | 0); d = a + 316 | 0; e = a + 264 | 0; g = e + 52 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); f[d >> 2] = -1; f[a + 320 >> 2] = -1; f[a + 324 >> 2] = 0; f[a + 328 >> 2] = 2; f[a + 332 >> 2] = 7; f[a + 336 >> 2] = 0; f[a + 340 >> 2] = 0; f[a + 344 >> 2] = 0; b[a + 352 >> 0] = 0; return } function ki(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = (f[c >> 2] | 0) - d | 0; g = (e | 0) / 12 | 0; h = g + 1 | 0; if (h >>> 0 > 357913941) mq(a); i = a + 8 | 0; j = ((f[i >> 2] | 0) - d | 0) / 12 | 0; k = j << 1; l = j >>> 0 < 178956970 ? (k >>> 0 < h >>> 0 ? h : k) : 357913941; do if (l) if (l >>> 0 > 357913941) { k = ra(8) | 0; Wo(k, 14941); f[k >> 2] = 6944; va(k | 0, 1080, 114) } else { m = dn(l * 12 | 0) | 0; break } else m = 0; while (0); k = m + (g * 12 | 0) | 0; f[k >> 2] = f[b >> 2]; f[k + 4 >> 2] = f[b + 4 >> 2]; f[k + 8 >> 2] = f[b + 8 >> 2]; b = k + (((e | 0) / -12 | 0) * 12 | 0) | 0; if ((e | 0) > 0) Rg(b | 0, d | 0, e | 0) | 0; f[a >> 2] = b; f[c >> 2] = k + 12; f[i >> 2] = m + (l * 12 | 0); if (!d) return; br(d); return } function li(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; g = a + 16 | 0; h = g; i = f[h + 4 >> 2] | 0; if ((d | 0) < 0 | (d | 0) == 0 & c >>> 0 < 1 | ((i | 0) > 0 | (i | 0) == 0 & (f[h >> 2] | 0) >>> 0 > 0)) { j = 0; return j | 0 } b[a + 24 >> 0] = e & 1; h = Tn(c | 0, d | 0, 7, 0) | 0; d = zk(h | 0, I | 0, 8, 0) | 0; h = I; c = g; f[c >> 2] = d; f[c + 4 >> 2] = h; c = a + 4 | 0; g = f[c >> 2] | 0; i = f[a >> 2] | 0; k = g - i | 0; l = Tn(k | 0, 0, 8, 0) | 0; m = e ? l : k; l = Tn(m | 0, (e ? I : 0) | 0, d | 0, h | 0) | 0; h = i; i = g; if (k >>> 0 >= l >>> 0) if (k >>> 0 > l >>> 0 ? (g = h + l | 0, (g | 0) != (i | 0)) : 0) { f[c >> 2] = g; n = h } else n = h; else { ri(a, l - k | 0); n = f[a >> 2] | 0 } k = dn(8) | 0; f[k >> 2] = n + m; f[k + 4 >> 2] = 0; m = a + 12 | 0; a = f[m >> 2] | 0; f[m >> 2] = k; if (!a) { j = 1; return j | 0 } br(a); j = 1; return j | 0 } function mi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; c = u; u = u + 16 | 0; d = c; e = hg(a, d, b) | 0; g = f[e >> 2] | 0; if (g | 0) { h = g; i = h + 28 | 0; u = c; return i | 0 } g = dn(40) | 0; dj(g + 16 | 0, b); b = g + 28 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; b = f[d >> 2] | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = b; f[e >> 2] = g; b = f[f[a >> 2] >> 2] | 0; if (!b) j = g; else { f[a >> 2] = b; j = f[e >> 2] | 0 } Ae(f[a + 4 >> 2] | 0, j); j = a + 8 | 0; f[j >> 2] = (f[j >> 2] | 0) + 1; h = g; i = h + 28 | 0; u = c; return i | 0 } function ni(a, c, d, e, g, h, i, j) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; j = j | 0; var k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; k = u; u = u + 16 | 0; l = k; if ((-18 - c | 0) >>> 0 < d >>> 0) mq(a); if ((b[a + 11 >> 0] | 0) < 0) m = f[a >> 2] | 0; else m = a; if (c >>> 0 < 2147483623) { n = d + c | 0; d = c << 1; o = n >>> 0 < d >>> 0 ? d : n; p = o >>> 0 < 11 ? 11 : o + 16 & -16 } else p = -17; o = dn(p) | 0; if (g | 0) Lo(o, m, g) | 0; if (i | 0) Lo(o + g | 0, j, i) | 0; j = e - h | 0; e = j - g | 0; if (e | 0) Lo(o + g + i | 0, m + g + h | 0, e) | 0; if ((c | 0) != 10) br(m); f[a >> 2] = o; f[a + 8 >> 2] = p | -2147483648; p = j + i | 0; f[a + 4 >> 2] = p; b[l >> 0] = 0; Hp(o + p | 0, l); u = k; return } function oi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 8 | 0; d = f[c >> 2] | 0; e = a + 4 | 0; g = f[e >> 2] | 0; if (d - g >> 2 >>> 0 >= b >>> 0) { hj(g | 0, 0, b << 2 | 0) | 0; f[e >> 2] = g + (b << 2); return } h = f[a >> 2] | 0; i = g - h | 0; g = i >> 2; j = g + b | 0; if (j >>> 0 > 1073741823) mq(a); k = d - h | 0; d = k >> 1; l = k >> 2 >>> 0 < 536870911 ? (d >>> 0 < j >>> 0 ? j : d) : 1073741823; do if (l) if (l >>> 0 > 1073741823) { d = ra(8) | 0; Wo(d, 14941); f[d >> 2] = 6944; va(d | 0, 1080, 114) } else { d = dn(l << 2) | 0; m = d; n = d; break } else { m = 0; n = 0 } while (0); d = m + (g << 2) | 0; hj(d | 0, 0, b << 2 | 0) | 0; if ((i | 0) > 0) Rg(n | 0, h | 0, i | 0) | 0; f[a >> 2] = m; f[e >> 2] = d + (b << 2); f[c >> 2] = m + (l << 2); if (!h) return; br(h); return } function pi(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; g = dn(32) | 0; f[a >> 2] = g; f[a + 4 >> 2] = c + 8; c = a + 8 | 0; b[c >> 0] = 0; dj(g + 8 | 0, e); h = g + 20 | 0; i = e + 12 | 0; f[h >> 2] = 0; f[g + 24 >> 2] = 0; f[g + 28 >> 2] = 0; g = e + 16 | 0; e = f[g >> 2] | 0; j = f[i >> 2] | 0; k = e - j | 0; if (!k) { l = j; m = e; n = 0 } else { ri(h, k); l = f[i >> 2] | 0; m = f[g >> 2] | 0; n = f[h >> 2] | 0 } Rg(n | 0, l | 0, m - l | 0) | 0; b[c >> 0] = 1; c = f[a >> 2] | 0; f[c + 4 >> 2] = d; f[c >> 2] = 0; return } function qi(a, c, d) { a = a | 0; c = c | 0; d = $(d); var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0.0, l = 0, m = 0, n = 0, o = 0; e = u; u = u + 16 | 0; g = e; h = c + 11 | 0; i = b[h >> 0] | 0; if (i << 24 >> 24 < 0) j = f[c + 4 >> 2] | 0; else j = i & 255; k = +d; l = j; j = i; while (1) { if (j << 24 >> 24 < 0) m = f[c >> 2] | 0; else m = c; p[g >> 3] = k; n = wn(m, l + 1 | 0, 17468, g) | 0; if ((n | 0) > -1) if (n >>> 0 > l >>> 0) o = n; else break; else o = l << 1 | 1; wj(c, o, 0); l = o; j = b[h >> 0] | 0 } wj(c, n, 0); f[a >> 2] = f[c >> 2]; f[a + 4 >> 2] = f[c + 4 >> 2]; f[a + 8 >> 2] = f[c + 8 >> 2]; a = 0; while (1) { if ((a | 0) == 3) break; f[c + (a << 2) >> 2] = 0; a = a + 1 | 0 } u = e; return } function ri(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; d = a + 8 | 0; e = f[d >> 2] | 0; g = a + 4 | 0; h = f[g >> 2] | 0; if ((e - h | 0) >>> 0 >= c >>> 0) { i = c; j = h; do { b[j >> 0] = 0; j = (f[g >> 2] | 0) + 1 | 0; f[g >> 2] = j; i = i + -1 | 0 } while ((i | 0) != 0); return } i = f[a >> 2] | 0; j = h - i | 0; h = j + c | 0; if ((h | 0) < 0) mq(a); k = e - i | 0; i = k << 1; e = k >>> 0 < 1073741823 ? (i >>> 0 < h >>> 0 ? h : i) : 2147483647; if (!e) l = 0; else l = dn(e) | 0; i = l + j | 0; j = l + e | 0; e = c; c = i; l = i; do { b[l >> 0] = 0; l = c + 1 | 0; c = l; e = e + -1 | 0 } while ((e | 0) != 0); e = f[a >> 2] | 0; l = (f[g >> 2] | 0) - e | 0; h = i + (0 - l) | 0; if ((l | 0) > 0) Rg(h | 0, e | 0, l | 0) | 0; f[a >> 2] = h; f[g >> 2] = c; f[d >> 2] = j; if (!e) return; br(e); return } function si(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = f[a >> 2] | 0; g = (d - e | 0) / 136 | 0; h = d; if (g >>> 0 < b >>> 0) { te(a, b - g | 0); return } if (g >>> 0 <= b >>> 0) return; g = e + (b * 136 | 0) | 0; if ((g | 0) == (h | 0)) return; else i = h; do { f[c >> 2] = i + -136; h = f[i + -20 >> 2] | 0; if (h | 0) { b = i + -16 | 0; e = f[b >> 2] | 0; if ((e | 0) != (h | 0)) f[b >> 2] = e + (~((e + -4 - h | 0) >>> 2) << 2); br(h) } h = f[i + -32 >> 2] | 0; if (h | 0) { e = i + -28 | 0; b = f[e >> 2] | 0; if ((b | 0) != (h | 0)) f[e >> 2] = b + (~((b + -4 - h | 0) >>> 2) << 2); br(h) } yi(i + -132 | 0); i = f[c >> 2] | 0 } while ((i | 0) != (g | 0)); return } function ti(a, b) { a = a | 0; b = b | 0; var c = 0, d = Oa, e = 0, g = 0; if ((b | 0) != 1) if (!(b + -1 & b)) c = b; else c = cb(b) | 0; else c = 2; b = f[a + 4 >> 2] | 0; if (c >>> 0 > b >>> 0) { Hd(a, c); return } if (c >>> 0 >= b >>> 0) return; d = $((f[a + 12 >> 2] | 0) >>> 0); e = ~~$(W($(d / $(n[a + 16 >> 2])))) >>> 0; if (b >>> 0 > 2 & (b + -1 & b | 0) == 0) g = 1 << 32 - (_(e + -1 | 0) | 0); else g = cb(e) | 0; e = c >>> 0 < g >>> 0 ? g : c; if (e >>> 0 >= b >>> 0) return; Hd(a, e); return } function ui(a) { a = a | 0; var b = 0, c = 0, d = 0; b = f[a + 76 >> 2] | 0; if (b | 0) { c = a + 80 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 64 >> 2] | 0; if (b | 0) { d = a + 68 | 0; if ((f[d >> 2] | 0) != (b | 0)) f[d >> 2] = b; br(b) } b = f[a + 48 >> 2] | 0; if (b | 0) { d = a + 52 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 24 >> 2] | 0; if (b | 0) { c = a + 28 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 12 >> 2] | 0; if (b | 0) { d = a + 16 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a >> 2] | 0; if (!b) return; c = a + 4 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function vi(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; e = u; u = u + 16 | 0; g = e; h = c + 11 | 0; i = b[h >> 0] | 0; if (i << 24 >> 24 < 0) j = f[c + 4 >> 2] | 0; else j = i & 255; k = j; j = i; while (1) { if (j << 24 >> 24 < 0) l = f[c >> 2] | 0; else l = c; f[g >> 2] = d; m = wn(l, k + 1 | 0, 17465, g) | 0; if ((m | 0) > -1) if (m >>> 0 > k >>> 0) n = m; else break; else n = k << 1 | 1; wj(c, n, 0); k = n; j = b[h >> 0] | 0 } wj(c, m, 0); f[a >> 2] = f[c >> 2]; f[a + 4 >> 2] = f[c + 4 >> 2]; f[a + 8 >> 2] = f[c + 8 >> 2]; a = 0; while (1) { if ((a | 0) == 3) break; f[c + (a << 2) >> 2] = 0; a = a + 1 | 0 } u = e; return } function wi(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; b = a + 8 | 0; c = f[b >> 2] | 0; if ((c | 0) < 0) { d = 0; return d | 0 } e = a + 4 | 0; a = f[e >> 2] | 0; g = a + 4 | 0; h = f[g >> 2] | 0; i = f[a >> 2] | 0; j = h - i >> 2; k = i; i = h; if (c >>> 0 <= j >>> 0) if (c >>> 0 < j >>> 0 ? (h = k + (c << 2) | 0, (h | 0) != (i | 0)) : 0) { f[g >> 2] = i + (~((i + -4 - h | 0) >>> 2) << 2); l = c } else l = c; else { oi(a, c - j | 0); l = f[b >> 2] | 0 } if ((l | 0) <= 0) { d = 1; return d | 0 } b = f[e >> 2] | 0; e = f[b >> 2] | 0; j = (f[b + 4 >> 2] | 0) - e >> 2; c = e; e = 0; while (1) { if (j >>> 0 <= e >>> 0) { m = 10; break } f[c + (e << 2) >> 2] = e; e = e + 1 | 0; if ((e | 0) >= (l | 0)) { d = 1; m = 12; break } } if ((m | 0) == 10) mq(b); else if ((m | 0) == 12) return d | 0; return 0 } function xi(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = u; u = u + 16 | 0; e = d; g = dn(32) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 30; h = g; i = 14791; j = h + 30 | 0; do { b[h >> 0] = b[i >> 0] | 0; h = h + 1 | 0; i = i + 1 | 0 } while ((h | 0) < (j | 0)); b[g + 30 >> 0] = 0; g = a + 4 | 0; Mj(g, e, c); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); a = dn(32) | 0; f[e >> 2] = a; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; h = a; i = 14510; j = h + 29 | 0; do { b[h >> 0] = b[i >> 0] | 0; h = h + 1 | 0; i = i + 1 | 0 } while ((h | 0) < (j | 0)); b[a + 29 >> 0] = 0; Mj(g, e, c); if ((b[e + 11 >> 0] | 0) >= 0) { u = d; return } br(f[e >> 2] | 0); u = d; return } function yi(a) { a = a | 0; var b = 0, c = 0, d = 0; b = f[a + 84 >> 2] | 0; if (b | 0) { c = a + 88 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 72 >> 2] | 0; if (b | 0) { d = a + 76 | 0; if ((f[d >> 2] | 0) != (b | 0)) f[d >> 2] = b; br(b) } b = f[a + 52 >> 2] | 0; if (b | 0) { d = a + 56 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 40 >> 2] | 0; if (b | 0) { c = a + 44 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 28 >> 2] | 0; if (b | 0) { d = a + 32 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 12 >> 2] | 0; if (b | 0) br(b); b = f[a >> 2] | 0; if (!b) return; br(b); return } function zi(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; f[a >> 2] = 1336; b = a + 32 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) { b = c + 88 | 0; d = f[b >> 2] | 0; f[b >> 2] = 0; if (d | 0) { b = f[d + 8 >> 2] | 0; if (b | 0) { e = d + 12 | 0; if ((f[e >> 2] | 0) != (b | 0)) f[e >> 2] = b; br(b) } br(d) } d = f[c + 68 >> 2] | 0; if (d | 0) { b = c + 72 | 0; e = f[b >> 2] | 0; if ((e | 0) != (d | 0)) f[b >> 2] = e + (~((e + -4 - d | 0) >>> 2) << 2); br(d) } d = c + 64 | 0; e = f[d >> 2] | 0; f[d >> 2] = 0; if (e | 0) { d = f[e >> 2] | 0; if (d | 0) { b = e + 4 | 0; if ((f[b >> 2] | 0) != (d | 0)) f[b >> 2] = d; br(d) } br(e) } br(c) } c = f[a + 16 >> 2] | 0; if (!c) return; e = a + 20 | 0; a = f[e >> 2] | 0; if ((a | 0) != (c | 0)) f[e >> 2] = a + (~((a + -4 - c | 0) >>> 2) << 2); br(c); return } function Ai() { var a = 0, b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; a = u; u = u + 48 | 0; b = a + 32 | 0; c = a + 24 | 0; d = a + 16 | 0; e = a; g = a + 36 | 0; a = mn() | 0; if (a | 0 ? (h = f[a >> 2] | 0, h | 0) : 0) { a = h + 48 | 0; i = f[a >> 2] | 0; j = f[a + 4 >> 2] | 0; if (!((i & -256 | 0) == 1126902528 & (j | 0) == 1129074247)) { f[c >> 2] = 17607; Dn(17557, c) } if ((i | 0) == 1126902529 & (j | 0) == 1129074247) k = f[h + 44 >> 2] | 0; else k = h + 80 | 0; f[g >> 2] = k; k = f[h >> 2] | 0; h = f[k + 4 >> 2] | 0; if (Sa[f[(f[250] | 0) + 16 >> 2] & 31](1e3, k, g) | 0) { k = f[g >> 2] | 0; g = Qa[f[(f[k >> 2] | 0) + 8 >> 2] & 127](k) | 0; f[e >> 2] = 17607; f[e + 4 >> 2] = h; f[e + 8 >> 2] = g; Dn(17471, e) } else { f[d >> 2] = 17607; f[d + 4 >> 2] = h; Dn(17516, d) } } Dn(17595, b) } function Bi(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0; do if (a) { if (c >>> 0 < 128) { b[a >> 0] = c; e = 1; break } d = (Yq() | 0) + 188 | 0; if (!(f[f[d >> 2] >> 2] | 0)) if ((c & -128 | 0) == 57216) { b[a >> 0] = c; e = 1; break } else { d = ir() | 0; f[d >> 2] = 84; e = -1; break } if (c >>> 0 < 2048) { b[a >> 0] = c >>> 6 | 192; b[a + 1 >> 0] = c & 63 | 128; e = 2; break } if (c >>> 0 < 55296 | (c & -8192 | 0) == 57344) { b[a >> 0] = c >>> 12 | 224; b[a + 1 >> 0] = c >>> 6 & 63 | 128; b[a + 2 >> 0] = c & 63 | 128; e = 3; break } if ((c + -65536 | 0) >>> 0 < 1048576) { b[a >> 0] = c >>> 18 | 240; b[a + 1 >> 0] = c >>> 12 & 63 | 128; b[a + 2 >> 0] = c >>> 6 & 63 | 128; b[a + 3 >> 0] = c & 63 | 128; e = 4; break } else { d = ir() | 0; f[d >> 2] = 84; e = -1; break } } else e = 1; while (0); return e | 0 } function Ci(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; c = a + 4 | 0; d = f[a >> 2] | 0; e = (f[c >> 2] | 0) - d | 0; g = e >> 2; h = g + 1 | 0; if (h >>> 0 > 1073741823) mq(a); i = a + 8 | 0; j = (f[i >> 2] | 0) - d | 0; k = j >> 1; l = j >> 2 >>> 0 < 536870911 ? (k >>> 0 < h >>> 0 ? h : k) : 1073741823; do if (l) if (l >>> 0 > 1073741823) { k = ra(8) | 0; Wo(k, 14941); f[k >> 2] = 6944; va(k | 0, 1080, 114) } else { k = dn(l << 2) | 0; m = k; n = k; break } else { m = 0; n = 0 } while (0); k = m + (g << 2) | 0; f[k >> 2] = f[b >> 2]; if ((e | 0) > 0) Rg(n | 0, d | 0, e | 0) | 0; f[a >> 2] = m; f[c >> 2] = k + 4; f[i >> 2] = m + (l << 2); if (!d) return; br(d); return } function Di(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0; c = a + 104 | 0; d = f[c >> 2] | 0; if ((d | 0) != 0 ? (f[a + 108 >> 2] | 0) >= (d | 0) : 0) e = 4; else { d = Qm(a) | 0; if ((d | 0) >= 0) { g = f[c >> 2] | 0; c = a + 8 | 0; if (g) { i = f[c >> 2] | 0; j = f[a + 4 >> 2] | 0; k = g - (f[a + 108 >> 2] | 0) | 0; g = i; if ((i - j | 0) < (k | 0)) { l = g; m = g } else { l = j + (k + -1) | 0; m = g } } else { g = f[c >> 2] | 0; l = g; m = g } f[a + 100 >> 2] = l; l = a + 4 | 0; if (!m) n = f[l >> 2] | 0; else { g = f[l >> 2] | 0; l = a + 108 | 0; f[l >> 2] = m + 1 - g + (f[l >> 2] | 0); n = g } g = n + -1 | 0; if ((d | 0) == (h[g >> 0] | 0 | 0)) o = d; else { b[g >> 0] = d; o = d } } else e = 4 } if ((e | 0) == 4) { f[a + 100 >> 2] = 0; o = -1 } return o | 0 } function Ei(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; f[a >> 2] = 1528; f[a + 4 >> 2] = b; b = a + 8 | 0; f[b >> 2] = f[c >> 2]; f[b + 4 >> 2] = f[c + 4 >> 2]; f[b + 8 >> 2] = f[c + 8 >> 2]; f[b + 12 >> 2] = f[c + 12 >> 2]; f[b + 16 >> 2] = f[c + 16 >> 2]; f[b + 20 >> 2] = f[c + 20 >> 2]; _j(a + 32 | 0, c + 24 | 0); f[a >> 2] = 2144; c = a + 44 | 0; f[c >> 2] = f[d >> 2]; f[c + 4 >> 2] = f[d + 4 >> 2]; f[c + 8 >> 2] = f[d + 8 >> 2]; f[c + 12 >> 2] = f[d + 12 >> 2]; f[a >> 2] = 2200; d = a + 112 | 0; c = a + 60 | 0; b = c + 52 | 0; do { f[c >> 2] = 0; c = c + 4 | 0 } while ((c | 0) < (b | 0)); Sm(d); f[a + 152 >> 2] = 0; f[a + 156 >> 2] = 0; f[a + 160 >> 2] = 0; return } function Fi(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; e = u; u = u + 16 | 0; g = e; h = dn(16) | 0; f[g >> 2] = h; f[g + 8 >> 2] = -2147483632; f[g + 4 >> 2] = 14; i = h; j = 12975; k = i + 14 | 0; do { b[i >> 0] = b[j >> 0] | 0; i = i + 1 | 0; j = j + 1 | 0 } while ((i | 0) < (k | 0)); b[h + 14 >> 0] = 0; Nj(a, g, c); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); c = dn(16) | 0; f[g >> 2] = c; f[g + 8 >> 2] = -2147483632; f[g + 4 >> 2] = 14; i = c; j = 12990; k = i + 14 | 0; do { b[i >> 0] = b[j >> 0] | 0; i = i + 1 | 0; j = j + 1 | 0 } while ((i | 0) < (k | 0)); b[c + 14 >> 0] = 0; Nj(a, g, d); if ((b[g + 11 >> 0] | 0) >= 0) { u = e; return } br(f[g >> 2] | 0); u = e; return } function Gi(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3320; b = f[a + 88 >> 2] | 0; if (b | 0) { c = a + 92 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 72 >> 2] | 0; if (b | 0) { d = a + 76 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 60 >> 2] | 0; if (b | 0) { c = a + 64 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 48 >> 2] | 0; if (b | 0) { d = a + 52 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 3276; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) return; br(b); return } function Hi(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; f[a >> 2] = 1528; f[a + 4 >> 2] = b; b = a + 8 | 0; f[b >> 2] = f[c >> 2]; f[b + 4 >> 2] = f[c + 4 >> 2]; f[b + 8 >> 2] = f[c + 8 >> 2]; f[b + 12 >> 2] = f[c + 12 >> 2]; f[b + 16 >> 2] = f[c + 16 >> 2]; f[b + 20 >> 2] = f[c + 20 >> 2]; _j(a + 32 | 0, c + 24 | 0); f[a >> 2] = 1836; c = a + 44 | 0; f[c >> 2] = f[d >> 2]; f[c + 4 >> 2] = f[d + 4 >> 2]; f[c + 8 >> 2] = f[d + 8 >> 2]; f[c + 12 >> 2] = f[d + 12 >> 2]; f[a >> 2] = 1892; d = a + 112 | 0; c = a + 60 | 0; b = c + 52 | 0; do { f[c >> 2] = 0; c = c + 4 | 0 } while ((c | 0) < (b | 0)); Sm(d); f[a + 152 >> 2] = 0; f[a + 156 >> 2] = 0; f[a + 160 >> 2] = 0; return } function Ii(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2200; b = f[a + 152 >> 2] | 0; if (b | 0) { c = a + 156 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 112 >> 2] | 0; if (b | 0) { d = a + 116 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) br(b); b = f[a + 84 >> 2] | 0; if (b | 0) br(b); b = f[a + 72 >> 2] | 0; if (b | 0) br(b); b = f[a + 60 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Ji(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0; d = u; u = u + 16 | 0; e = d; g = f[(f[c + 4 >> 2] | 0) + 4 >> 2] | 0; if (!g) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = d; return } if (!(rj(d + 12 | 0, f[c + 44 >> 2] | 0, g) | 0)) { g = dn(32) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 26; c = g; h = 14822; i = c + 26 | 0; do { b[c >> 0] = b[h >> 0] | 0; c = c + 1 | 0; h = h + 1 | 0 } while ((c | 0) < (i | 0)); b[g + 26 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0) } else { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0 } u = d; return } function Ki(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0; c = b + 48 | 0; if ((Yh(f[c >> 2] | 0) | 0) > 9) { d = 0; return d | 0 } if ((Qa[f[(f[b >> 2] | 0) + 8 >> 2] & 127](b) | 0) != 1) { d = 0; return d | 0 } e = b + 4 | 0; b = (f[(f[(f[e >> 2] | 0) + 8 >> 2] | 0) + (a << 2) >> 2] | 0) + 56 | 0; a = f[b >> 2] | 0; do if ((a | 0) == 3) if ((Yh(f[c >> 2] | 0) | 0) < 4) { d = 5; return d | 0 } else { g = f[b >> 2] | 0; break } else g = a; while (0); a = Yh(f[c >> 2] | 0) | 0; if ((g | 0) == 1) { d = (a | 0) < 4 ? 6 : 0; return d | 0 } if ((a | 0) > 7) { d = 0; return d | 0 } if ((Yh(f[c >> 2] | 0) | 0) > 1) { d = 1; return d | 0 } else return ((f[(f[e >> 2] | 0) + 80 >> 2] | 0) >>> 0 < 40 ? 1 : 4) | 0; return 0 } function Li(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1892; b = f[a + 152 >> 2] | 0; if (b | 0) { c = a + 156 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 112 >> 2] | 0; if (b | 0) { d = a + 116 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) br(b); b = f[a + 84 >> 2] | 0; if (b | 0) br(b); b = f[a + 72 >> 2] | 0; if (b | 0) br(b); b = f[a + 60 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Mi(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0; g = u; u = u + 128 | 0; h = g + 124 | 0; i = g; j = i; k = 6284; l = j + 124 | 0; do { f[j >> 2] = f[k >> 2]; j = j + 4 | 0; k = k + 4 | 0 } while ((j | 0) < (l | 0)); if ((c + -1 | 0) >>> 0 > 2147483646) if (!c) { m = h; n = 1; o = 4 } else { h = ir() | 0; f[h >> 2] = 75; p = -1 } else { m = a; n = c; o = 4 } if ((o | 0) == 4) { o = -2 - m | 0; c = n >>> 0 > o >>> 0 ? o : n; f[i + 48 >> 2] = c; n = i + 20 | 0; f[n >> 2] = m; f[i + 44 >> 2] = m; o = m + c | 0; m = i + 16 | 0; f[m >> 2] = o; f[i + 28 >> 2] = o; o = hh(i, d, e) | 0; if (!c) p = o; else { c = f[n >> 2] | 0; b[c + (((c | 0) == (f[m >> 2] | 0)) << 31 >> 31) >> 0] = 0; p = o } } u = g; return p | 0 } function Ni(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0; f[a >> 2] = 3080; c = a + 72 | 0; d = a + 136 | 0; e = a + 4 | 0; g = e + 64 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); e = c; g = e + 64 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); n[d >> 2] = $(1.0); d = a + 140 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; f[a + 164 >> 2] = -1; d = a + 168 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; f[d + 24 >> 2] = 0; rn(a + 200 | 0); Cn(a + 232 | 0); d = a + 264 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; b[d + 24 >> 0] = 0; return } function Oi(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = +e; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; a = u; u = u + 16 | 0; g = a; if (!c) { h = 0; u = a; return h | 0 } f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; i = vj(d) | 0; if (i >>> 0 > 4294967279) mq(g); if (i >>> 0 < 11) { b[g + 11 >> 0] = i; if (!i) j = g; else { k = g; l = 7 } } else { m = i + 16 & -16; n = dn(m) | 0; f[g >> 2] = n; f[g + 8 >> 2] = m | -2147483648; f[g + 4 >> 2] = i; k = n; l = 7 } if ((l | 0) == 7) { Rg(k | 0, d | 0, i | 0) | 0; j = k } b[j + i >> 0] = 0; Ol(c, g, e); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); h = 1; u = a; return h | 0 } function Pi(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; a = u; u = u + 16 | 0; g = a; if (!c) { h = 0; u = a; return h | 0 } f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; i = vj(d) | 0; if (i >>> 0 > 4294967279) mq(g); if (i >>> 0 < 11) { b[g + 11 >> 0] = i; if (!i) j = g; else { k = g; l = 7 } } else { m = i + 16 & -16; n = dn(m) | 0; f[g >> 2] = n; f[g + 8 >> 2] = m | -2147483648; f[g + 4 >> 2] = i; k = n; l = 7 } if ((l | 0) == 7) { Rg(k | 0, d | 0, i | 0) | 0; j = k } b[j + i >> 0] = 0; Pl(c, g, e); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); h = 1; u = a; return h | 0 } function Qi(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; c = f[a + 28 >> 2] | 0; if (c | 0) { d = c; do { c = d; d = f[d >> 2] | 0; e = c + 8 | 0; g = c + 20 | 0; h = f[g >> 2] | 0; f[g >> 2] = 0; if (h | 0) { Qi(h); br(h) } if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); br(c) } while ((d | 0) != 0) } d = a + 20 | 0; c = f[d >> 2] | 0; f[d >> 2] = 0; if (c | 0) br(c); c = f[a + 8 >> 2] | 0; if (c | 0) { d = c; do { c = d; d = f[d >> 2] | 0; e = c + 8 | 0; h = f[c + 20 >> 2] | 0; if (h | 0) { g = c + 24 | 0; if ((f[g >> 2] | 0) != (h | 0)) f[g >> 2] = h; br(h) } if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); br(c) } while ((d | 0) != 0) } d = f[a >> 2] | 0; f[a >> 2] = 0; if (!d) return; br(d); return } function Ri(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; Wa[f[(f[c >> 2] | 0) + 64 >> 2] & 15](a, c); if (f[a >> 2] | 0) { u = d; return } g = a + 4 | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); g = f[c + 48 >> 2] | 0; h = dn(32) | 0; f[e >> 2] = h; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; i = h; j = 14510; k = i + 29 | 0; do { b[i >> 0] = b[j >> 0] | 0; i = i + 1 | 0; j = j + 1 | 0 } while ((i | 0) < (k | 0)); b[h + 29 >> 0] = 0; h = Oj(g, e, 0) | 0; if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); if (h) Va[f[(f[c >> 2] | 0) + 68 >> 2] & 127](c); f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = d; return } function Si(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; e = u; u = u + 16 | 0; g = e; h = f[c + 48 >> 2] | 0; if (!h) { i = dn(32) | 0; f[g >> 2] = i; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 23; j = i; k = 14670; l = j + 23 | 0; do { b[j >> 0] = b[k >> 0] | 0; j = j + 1 | 0; k = k + 1 | 0 } while ((j | 0) < (l | 0)); b[i + 23 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, g); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); u = e; return } g = f[c + 52 >> 2] | 0; if (!g) { Ic(a, c, h, d); u = e; return } else { jg(a, c, g, d); u = e; return } } function Ti(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; lk(a); b = a + 84 | 0; c = f[b >> 2] | 0; if ((c | 0) <= 0) return; d = c << 5; e = _q(c >>> 0 > 134217727 | d >>> 0 > 4294967291 ? -1 : d + 4 | 0) | 0; f[e >> 2] = c; d = e + 4 | 0; e = d + (c << 5) | 0; c = d; do { rn(c); c = c + 32 | 0 } while ((c | 0) != (e | 0)); e = a + 80 | 0; a = f[e >> 2] | 0; f[e >> 2] = d; if (a | 0) { d = a + -4 | 0; c = f[d >> 2] | 0; if (c | 0) { g = a + (c << 5) | 0; do { g = g + -32 | 0; tj(g) } while ((g | 0) != (a | 0)) } $q(d) } if ((f[b >> 2] | 0) > 0) h = 0; else return; do { lk((f[e >> 2] | 0) + (h << 5) | 0); h = h + 1 | 0 } while ((h | 0) < (f[b >> 2] | 0)); return } function Ui(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; if (!b) { d = 0; return d | 0 } if (f[b + 4 >> 2] | 0) { d = 0; return d | 0 } a = dn(52) | 0; Ub(a, c); f[a + 40 >> 2] = 0; f[a + 44 >> 2] = 0; f[a + 48 >> 2] = 0; c = b + 4 | 0; b = f[c >> 2] | 0; f[c >> 2] = a; if (!b) { d = 1; return d | 0 } a = b + 40 | 0; c = f[a >> 2] | 0; if (c | 0) { e = b + 44 | 0; g = f[e >> 2] | 0; if ((g | 0) == (c | 0)) h = c; else { i = g; do { g = i + -4 | 0; f[e >> 2] = g; j = f[g >> 2] | 0; f[g >> 2] = 0; if (j | 0) { Qi(j); br(j) } i = f[e >> 2] | 0 } while ((i | 0) != (c | 0)); h = f[a >> 2] | 0 } br(h) } Qi(b); br(b); d = 1; return d | 0 } function Vi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; c = f[a >> 2] | 0; if (b) { b = c + 8 | 0; d = b; e = Tn(f[d >> 2] | 0, f[d + 4 >> 2] | 0, 1, 0) | 0; d = b; f[d >> 2] = e; f[d + 4 >> 2] = I; d = a + 28 | 0; e = f[d >> 2] | 0; b = a + 24 | 0; f[b >> 2] = f[b >> 2] | 1 << e; g = d; h = e } else { e = c; d = Tn(f[e >> 2] | 0, f[e + 4 >> 2] | 0, 1, 0) | 0; e = c; f[e >> 2] = d; f[e + 4 >> 2] = I; e = a + 28 | 0; g = e; h = f[e >> 2] | 0 } e = h + 1 | 0; f[g >> 2] = e; if ((e | 0) != 32) return; e = a + 24 | 0; h = a + 16 | 0; d = f[h >> 2] | 0; if ((d | 0) == (f[a + 20 >> 2] | 0)) Ci(a + 12 | 0, e); else { f[d >> 2] = f[e >> 2]; f[h >> 2] = d + 4 } f[g >> 2] = 0; f[e >> 2] = 0; return } function Wi(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; c = a + 32 | 0; a = f[b >> 2] | 0; f[b >> 2] = 0; b = f[c >> 2] | 0; f[c >> 2] = a; if (!b) return; a = b + 88 | 0; c = f[a >> 2] | 0; f[a >> 2] = 0; if (c | 0) { a = f[c + 8 >> 2] | 0; if (a | 0) { d = c + 12 | 0; if ((f[d >> 2] | 0) != (a | 0)) f[d >> 2] = a; br(a) } br(c) } c = f[b + 68 >> 2] | 0; if (c | 0) { a = b + 72 | 0; d = f[a >> 2] | 0; if ((d | 0) != (c | 0)) f[a >> 2] = d + (~((d + -4 - c | 0) >>> 2) << 2); br(c) } c = b + 64 | 0; d = f[c >> 2] | 0; f[c >> 2] = 0; if (d | 0) { c = f[d >> 2] | 0; if (c | 0) { a = d + 4 | 0; if ((f[a >> 2] | 0) != (c | 0)) f[a >> 2] = c; br(c) } br(d) } br(b); return } function Xi(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; e = u; u = u + 16 | 0; g = e; if (c | 0) { h = a + 11 | 0; i = b[h >> 0] | 0; if (i << 24 >> 24 < 0) { j = f[a + 4 >> 2] | 0; k = (f[a + 8 >> 2] & 2147483647) + -1 | 0 } else { j = i & 255; k = 10 } if ((k - j | 0) >>> 0 < c >>> 0) { lj(a, k, c - k + j | 0, j, j, 0, 0); l = b[h >> 0] | 0 } else l = i; if (l << 24 >> 24 < 0) m = f[a >> 2] | 0; else m = a; On(m + j | 0, c, d) | 0; d = j + c | 0; if ((b[h >> 0] | 0) < 0) f[a + 4 >> 2] = d; else b[h >> 0] = d; b[g >> 0] = 0; Hp(m + d | 0, g) } u = e; return a | 0 } function Yi(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 48 | 0; e = d + 4 | 0; g = d; h = f[b + 12 >> 2] | 0; i = f[b + 4 >> 2] | 0; b = e; j = b + 36 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (j | 0)); gh(g, c, h, i, e); i = f[e + 24 >> 2] | 0; if (!i) { k = f[g >> 2] | 0; f[a >> 2] = k; u = d; return } h = e + 28 | 0; e = f[h >> 2] | 0; if ((e | 0) != (i | 0)) f[h >> 2] = e + (~((e + -4 - i | 0) >>> 2) << 2); br(i); k = f[g >> 2] | 0; f[a >> 2] = k; u = d; return } function Zi(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; e = u; u = u + 16 | 0; g = e; h = a + 11 | 0; i = b[h >> 0] | 0; j = i << 24 >> 24 < 0; if (j) k = (f[a + 8 >> 2] & 2147483647) + -1 | 0; else k = 10; do if (k >>> 0 >= d >>> 0) { if (j) l = f[a >> 2] | 0; else l = a; Jo(l, c, d) | 0; b[g >> 0] = 0; Hp(l + d | 0, g); if ((b[h >> 0] | 0) < 0) { f[a + 4 >> 2] = d; break } else { b[h >> 0] = d; break } } else { if (j) m = f[a + 4 >> 2] | 0; else m = i & 255; ni(a, k, d - k | 0, m, 0, m, d, c) } while (0); u = e; return a | 0 } function _i(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; b = f[a >> 2] | 0; if (!b) return; c = a + 4 | 0; d = f[c >> 2] | 0; if ((d | 0) == (b | 0)) e = b; else { g = d; do { f[c >> 2] = g + -136; d = f[g + -20 >> 2] | 0; if (d | 0) { h = g + -16 | 0; i = f[h >> 2] | 0; if ((i | 0) != (d | 0)) f[h >> 2] = i + (~((i + -4 - d | 0) >>> 2) << 2); br(d) } d = f[g + -32 >> 2] | 0; if (d | 0) { i = g + -28 | 0; h = f[i >> 2] | 0; if ((h | 0) != (d | 0)) f[i >> 2] = h + (~((h + -4 - d | 0) >>> 2) << 2); br(d) } yi(g + -132 | 0); g = f[c >> 2] | 0 } while ((g | 0) != (b | 0)); e = f[a >> 2] | 0 } br(e); return } function $i(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; e = u; u = u + 16 | 0; g = e; h = a + 11 | 0; i = b[h >> 0] | 0; j = i << 24 >> 24 < 0; if (j) { k = f[a + 4 >> 2] | 0; l = (f[a + 8 >> 2] & 2147483647) + -1 | 0 } else { k = i & 255; l = 10 } if ((l - k | 0) >>> 0 >= d >>> 0) { if (d | 0) { if (j) m = f[a >> 2] | 0; else m = a; Lo(m + k | 0, c, d) | 0; j = k + d | 0; if ((b[h >> 0] | 0) < 0) f[a + 4 >> 2] = j; else b[h >> 0] = j; b[g >> 0] = 0; Hp(m + j | 0, g) } } else ni(a, l, d - l + k | 0, k, k, 0, d, c); u = e; return a | 0 } function aj(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; f[a >> 2] = 3608; b = f[a + 32 >> 2] | 0; if (b | 0) { c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 20 >> 2] | 0; if (b | 0) { d = a + 24 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = a + 8 | 0; c = f[b >> 2] | 0; if (!c) return; d = a + 12 | 0; a = f[d >> 2] | 0; if ((a | 0) == (c | 0)) e = c; else { g = a; do { a = g + -4 | 0; f[d >> 2] = a; h = f[a >> 2] | 0; f[a >> 2] = 0; if (h | 0) Va[f[(f[h >> 2] | 0) + 4 >> 2] & 127](h); g = f[d >> 2] | 0 } while ((g | 0) != (c | 0)); e = f[b >> 2] | 0 } br(e); return } function bj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = a + 4 | 0; if ((Qa[f[(f[b >> 2] | 0) + 20 >> 2] & 127](b) | 0) <= 0) { d = 1; return d | 0 } a = 0; while (1) { e = f[(f[c >> 2] | 0) + 4 >> 2] | 0; g = Tl(e, Ra[f[(f[b >> 2] | 0) + 24 >> 2] & 127](b, a) | 0) | 0; if ((g | 0) == -1) { d = 0; h = 6; break } e = f[(f[b >> 2] | 0) + 28 >> 2] | 0; i = $k(f[c >> 2] | 0, g) | 0; a = a + 1 | 0; if (!(Ra[e & 127](b, i) | 0)) { d = 0; h = 6; break } if ((a | 0) >= (Qa[f[(f[b >> 2] | 0) + 20 >> 2] & 127](b) | 0)) { d = 1; h = 6; break } } if ((h | 0) == 6) return d | 0; return 0 } function cj(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; if (!(lo(a, b, c) | 0)) { d = 0; return d | 0 } if (!(Qa[f[(f[a >> 2] | 0) + 52 >> 2] & 127](a) | 0)) { d = 0; return d | 0 } c = a + 4 | 0; e = a + 8 | 0; g = f[c >> 2] | 0; if ((f[e >> 2] | 0) == (g | 0)) { d = 1; return d | 0 } h = a + 36 | 0; a = 0; i = g; while (1) { g = f[(f[h >> 2] | 0) + (a << 2) >> 2] | 0; if (!(Sa[f[(f[g >> 2] | 0) + 8 >> 2] & 31](g, b, f[i + (a << 2) >> 2] | 0) | 0)) { d = 0; j = 7; break } a = a + 1 | 0; i = f[c >> 2] | 0; if (a >>> 0 >= (f[e >> 2] | 0) - i >> 2 >>> 0) { d = 1; j = 7; break } } if ((j | 0) == 7) return d | 0; return 0 } function dj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; if ((b[c + 11 >> 0] | 0) < 0) { g = f[c >> 2] | 0; h = f[c + 4 >> 2] | 0; if (h >>> 0 > 4294967279) mq(a); if (h >>> 0 < 11) { b[a + 11 >> 0] = h; i = a } else { j = h + 16 & -16; k = dn(j) | 0; f[a >> 2] = k; f[a + 8 >> 2] = j | -2147483648; f[a + 4 >> 2] = h; i = k } Lo(i, g, h) | 0; b[e >> 0] = 0; Hp(i + h | 0, e) } else { f[a >> 2] = f[c >> 2]; f[a + 4 >> 2] = f[c + 4 >> 2]; f[a + 8 >> 2] = f[c + 8 >> 2] } u = d; return } function ej(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c + 4 | 0; g = c; f[g >> 2] = f[(f[b + 4 >> 2] | 0) + 80 >> 2]; h = f[b + 44 >> 2] | 0; b = h + 16 | 0; i = f[b + 4 >> 2] | 0; if ((i | 0) > 0 | (i | 0) == 0 & (f[b >> 2] | 0) >>> 0 > 0) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = c; return } f[e >> 2] = f[h + 4 >> 2]; f[d >> 2] = f[e >> 2]; ye(h, d, g, g + 4 | 0) | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = c; return } function fj(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0; b[c + 53 >> 0] = 1; do if ((f[c + 4 >> 2] | 0) == (e | 0)) { b[c + 52 >> 0] = 1; a = c + 16 | 0; h = f[a >> 2] | 0; if (!h) { f[a >> 2] = d; f[c + 24 >> 2] = g; f[c + 36 >> 2] = 1; if (!((g | 0) == 1 ? (f[c + 48 >> 2] | 0) == 1 : 0)) break; b[c + 54 >> 0] = 1; break } if ((h | 0) != (d | 0)) { h = c + 36 | 0; f[h >> 2] = (f[h >> 2] | 0) + 1; b[c + 54 >> 0] = 1; break } h = c + 24 | 0; a = f[h >> 2] | 0; if ((a | 0) == 2) { f[h >> 2] = g; i = g } else i = a; if ((i | 0) == 1 ? (f[c + 48 >> 2] | 0) == 1 : 0) b[c + 54 >> 0] = 1 } while (0); return } function gj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; c = a + 36 | 0; d = a + 40 | 0; e = f[c >> 2] | 0; if ((f[d >> 2] | 0) != (e | 0)) { g = 0; h = e; do { eg(h + (g * 24 | 0) | 0, b) | 0; g = g + 1 | 0; h = f[c >> 2] | 0 } while (g >>> 0 < (((f[d >> 2] | 0) - h | 0) / 24 | 0) >>> 0) } h = a + 48 | 0; d = a + 52 | 0; a = f[h >> 2] | 0; if ((f[d >> 2] | 0) == (a | 0)) return 1; else { i = 0; j = a } do { a = f[j + (i << 2) >> 2] | 0; Nh(a << 1 ^ a >> 31, b) | 0; i = i + 1 | 0; j = f[h >> 2] | 0 } while (i >>> 0 < (f[d >> 2] | 0) - j >> 2 >>> 0); return 1 } function hj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0; e = a + d | 0; c = c & 255; if ((d | 0) >= 67) { while (a & 3) { b[a >> 0] = c; a = a + 1 | 0 } g = e & -4 | 0; h = g - 64 | 0; i = c | c << 8 | c << 16 | c << 24; while ((a | 0) <= (h | 0)) { f[a >> 2] = i; f[a + 4 >> 2] = i; f[a + 8 >> 2] = i; f[a + 12 >> 2] = i; f[a + 16 >> 2] = i; f[a + 20 >> 2] = i; f[a + 24 >> 2] = i; f[a + 28 >> 2] = i; f[a + 32 >> 2] = i; f[a + 36 >> 2] = i; f[a + 40 >> 2] = i; f[a + 44 >> 2] = i; f[a + 48 >> 2] = i; f[a + 52 >> 2] = i; f[a + 56 >> 2] = i; f[a + 60 >> 2] = i; a = a + 64 | 0 } while ((a | 0) < (g | 0)) { f[a >> 2] = i; a = a + 4 | 0 } } while ((a | 0) < (e | 0)) { b[a >> 0] = c; a = a + 1 | 0 } return e - d | 0 } function ij(a, c, d, e, g) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0; do if (!(qp(a, f[c + 8 >> 2] | 0, g) | 0)) { if (qp(a, f[c >> 2] | 0, g) | 0) { if ((f[c + 16 >> 2] | 0) != (d | 0) ? (h = c + 20 | 0, (f[h >> 2] | 0) != (d | 0)) : 0) { f[c + 32 >> 2] = e; f[h >> 2] = d; h = c + 40 | 0; f[h >> 2] = (f[h >> 2] | 0) + 1; if ((f[c + 36 >> 2] | 0) == 1 ? (f[c + 24 >> 2] | 0) == 2 : 0) b[c + 54 >> 0] = 1; f[c + 44 >> 2] = 4; break } if ((e | 0) == 1) f[c + 32 >> 2] = 1 } } else Om(0, c, d, e); while (0); return } function jj(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; b = a + 80 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) { b = c + -4 | 0; d = f[b >> 2] | 0; if (d | 0) { e = c + (d << 5) | 0; do { e = e + -32 | 0; tj(e) } while ((e | 0) != (c | 0)) } $q(b) } b = f[a + 68 >> 2] | 0; if (b | 0) { c = a + 72 | 0; e = f[c >> 2] | 0; if ((e | 0) != (b | 0)) f[c >> 2] = e + (~((e + -4 - b | 0) >>> 2) << 2); br(b) } b = a + 44 | 0; e = f[b >> 2] | 0; f[b >> 2] = 0; if (e | 0) br(e); e = f[a + 32 >> 2] | 0; if (!e) { tj(a); return } b = a + 36 | 0; if ((f[b >> 2] | 0) != (e | 0)) f[b >> 2] = e; br(e); tj(a); return } function kj(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2684; b = f[a + 136 >> 2] | 0; if (b | 0) { c = a + 140 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) { d = a + 100 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 76 >> 2] | 0; if (b | 0) br(b); b = f[a + 64 >> 2] | 0; if (b | 0) br(b); b = f[a + 52 >> 2] | 0; if (b | 0) br(b); b = f[a + 40 >> 2] | 0; if (!b) return; br(b); return } function lj(a, c, d, e, g, h, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0; if ((-17 - c | 0) >>> 0 < d >>> 0) mq(a); if ((b[a + 11 >> 0] | 0) < 0) j = f[a >> 2] | 0; else j = a; if (c >>> 0 < 2147483623) { k = d + c | 0; d = c << 1; l = k >>> 0 < d >>> 0 ? d : k; m = l >>> 0 < 11 ? 11 : l + 16 & -16 } else m = -17; l = dn(m) | 0; if (g | 0) Lo(l, j, g) | 0; k = e - h - g | 0; if (k | 0) Lo(l + g + i | 0, j + g + h | 0, k) | 0; if ((c | 0) != 10) br(j); f[a >> 2] = l; f[a + 8 >> 2] = m | -2147483648; return } function mj(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2432; b = f[a + 136 >> 2] | 0; if (b | 0) { c = a + 140 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 96 >> 2] | 0; if (b | 0) { d = a + 100 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 76 >> 2] | 0; if (b | 0) br(b); b = f[a + 64 >> 2] | 0; if (b | 0) br(b); b = f[a + 52 >> 2] | 0; if (b | 0) br(b); b = f[a + 40 >> 2] | 0; if (!b) return; br(b); return } function nj(a, b) { a = a | 0; b = b | 0; if (!b) return; else { nj(a, f[b >> 2] | 0); nj(a, f[b + 4 >> 2] | 0); sj(b + 20 | 0, f[b + 24 >> 2] | 0); br(b); return } } function oj(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; If(a, b, c); c = f[a + 100 >> 2] | 0; d = f[a + 96 >> 2] | 0; a = d; if ((c | 0) == (d | 0)) return; e = f[b >> 2] | 0; b = (c - d | 0) / 12 | 0; d = 0; do { c = a + (d * 12 | 0) | 0; f[c >> 2] = f[e + (f[c >> 2] << 2) >> 2]; c = a + (d * 12 | 0) + 4 | 0; f[c >> 2] = f[e + (f[c >> 2] << 2) >> 2]; c = a + (d * 12 | 0) + 8 | 0; f[c >> 2] = f[e + (f[c >> 2] << 2) >> 2]; d = d + 1 | 0 } while (d >>> 0 < b >>> 0); return } function pj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = a + 64 | 0; if ((f[d >> 2] | 0) == 0 ? (e = dn(32) | 0, tn(e), g = f[d >> 2] | 0, f[d >> 2] = e, g | 0) : 0) { e = f[g >> 2] | 0; if (e | 0) { h = g + 4 | 0; if ((f[h >> 2] | 0) != (e | 0)) f[h >> 2] = e; br(e) } br(g) } g = Ll(f[a + 28 >> 2] | 0) | 0; e = X(g, b[a + 24 >> 0] | 0) | 0; g = ((e | 0) < 0) << 31 >> 31; h = f[d >> 2] | 0; i = on(e | 0, g | 0, c | 0, 0) | 0; if (!(Th(h, 0, i, I) | 0)) { j = 0; return j | 0 } Ak(a, f[d >> 2] | 0, e, g, 0, 0); f[a + 80 >> 2] = c; j = 1; return j | 0 } function qj(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = u; u = u + 64 | 0; e = d; if (!(qp(a, b, 0) | 0)) if ((b | 0) != 0 ? (g = mh(b, 1024, 1008, 0) | 0, (g | 0) != 0) : 0) { b = e + 4 | 0; h = b + 52 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (h | 0)); f[e >> 2] = g; f[e + 8 >> 2] = a; f[e + 12 >> 2] = -1; f[e + 48 >> 2] = 1; Ya[f[(f[g >> 2] | 0) + 28 >> 2] & 7](g, e, f[c >> 2] | 0, 1); if ((f[e + 24 >> 2] | 0) == 1) { f[c >> 2] = f[e + 16 >> 2]; i = 1 } else i = 0; j = i } else j = 0; else j = 1; u = d; return j | 0 } function rj(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0; if (!c) { d = 0; return d | 0 } e = c + 40 | 0; g = c + 44 | 0; Nh((f[g >> 2] | 0) - (f[e >> 2] | 0) >> 2, b) | 0; h = f[e >> 2] | 0; e = f[g >> 2] | 0; if ((h | 0) != (e | 0)) { g = h; do { h = f[g >> 2] | 0; if (h | 0) { Nh(f[h + 40 >> 2] | 0, b) | 0; Wf(a, b, h) | 0 } g = g + 4 | 0 } while ((g | 0) != (e | 0)) } Wf(a, b, c) | 0; d = 1; return d | 0 } function sj(a, c) { a = a | 0; c = c | 0; var d = 0; if (!c) return; sj(a, f[c >> 2] | 0); sj(a, f[c + 4 >> 2] | 0); a = c + 16 | 0; d = c + 28 | 0; if ((b[d + 11 >> 0] | 0) < 0) br(f[d >> 2] | 0); if ((b[a + 11 >> 0] | 0) < 0) br(f[a >> 2] | 0); br(c); return } function tj(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; b = u; u = u + 16 | 0; c = b; d = c; f[d >> 2] = 0; f[d + 4 >> 2] = 0; cf(a, 2, c); c = f[a + 12 >> 2] | 0; d = a + 16 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) g = c; else { h = e + (~((e + -4 - c | 0) >>> 2) << 2) | 0; f[d >> 2] = h; g = h } f[a + 24 >> 2] = 0; f[a + 28 >> 2] = 0; if (c | 0) { if ((g | 0) != (c | 0)) f[d >> 2] = g + (~((g + -4 - c | 0) >>> 2) << 2); br(c) } c = f[a >> 2] | 0; if (!c) { u = b; return } g = a + 4 | 0; a = f[g >> 2] | 0; if ((a | 0) != (c | 0)) f[g >> 2] = a + (~((a + -8 - c | 0) >>> 3) << 3); br(c); u = b; return }
    function $a(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0; b = u; u = u + 16 | 0; c = b; do if (a >>> 0 < 245) { d = a >>> 0 < 11 ? 16 : a + 11 & -8; e = d >>> 3; g = f[4512] | 0; h = g >>> e; if (h & 3 | 0) { i = (h & 1 ^ 1) + e | 0; j = 18088 + (i << 1 << 2) | 0; k = j + 8 | 0; l = f[k >> 2] | 0; m = l + 8 | 0; n = f[m >> 2] | 0; if ((n | 0) == (j | 0)) f[4512] = g & ~(1 << i); else { f[n + 12 >> 2] = j; f[k >> 2] = n } n = i << 3; f[l + 4 >> 2] = n | 3; i = l + n + 4 | 0; f[i >> 2] = f[i >> 2] | 1; o = m; u = b; return o | 0 } m = f[4514] | 0; if (d >>> 0 > m >>> 0) { if (h | 0) { i = 2 << e; n = h << e & (i | 0 - i); i = (n & 0 - n) + -1 | 0; n = i >>> 12 & 16; e = i >>> n; i = e >>> 5 & 8; h = e >>> i; e = h >>> 2 & 4; l = h >>> e; h = l >>> 1 & 2; k = l >>> h; l = k >>> 1 & 1; j = (i | n | e | h | l) + (k >>> l) | 0; l = 18088 + (j << 1 << 2) | 0; k = l + 8 | 0; h = f[k >> 2] | 0; e = h + 8 | 0; n = f[e >> 2] | 0; if ((n | 0) == (l | 0)) { i = g & ~(1 << j); f[4512] = i; p = i } else { f[n + 12 >> 2] = l; f[k >> 2] = n; p = g } n = j << 3; j = n - d | 0; f[h + 4 >> 2] = d | 3; k = h + d | 0; f[k + 4 >> 2] = j | 1; f[h + n >> 2] = j; if (m | 0) { n = f[4517] | 0; h = m >>> 3; l = 18088 + (h << 1 << 2) | 0; i = 1 << h; if (!(p & i)) { f[4512] = p | i; q = l; r = l + 8 | 0 } else { i = l + 8 | 0; q = f[i >> 2] | 0; r = i } f[r >> 2] = n; f[q + 12 >> 2] = n; f[n + 8 >> 2] = q; f[n + 12 >> 2] = l } f[4514] = j; f[4517] = k; o = e; u = b; return o | 0 } e = f[4513] | 0; if (e) { k = (e & 0 - e) + -1 | 0; j = k >>> 12 & 16; l = k >>> j; k = l >>> 5 & 8; n = l >>> k; l = n >>> 2 & 4; i = n >>> l; n = i >>> 1 & 2; h = i >>> n; i = h >>> 1 & 1; s = f[18352 + ((k | j | l | n | i) + (h >>> i) << 2) >> 2] | 0; i = (f[s + 4 >> 2] & -8) - d | 0; h = f[s + 16 + (((f[s + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0; if (!h) { t = s; v = i } else { n = s; s = i; i = h; while (1) { h = (f[i + 4 >> 2] & -8) - d | 0; l = h >>> 0 < s >>> 0; j = l ? h : s; h = l ? i : n; i = f[i + 16 + (((f[i + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0; if (!i) { t = h; v = j; break } else { n = h; s = j } } } s = t + d | 0; if (s >>> 0 > t >>> 0) { n = f[t + 24 >> 2] | 0; i = f[t + 12 >> 2] | 0; do if ((i | 0) == (t | 0)) { j = t + 20 | 0; h = f[j >> 2] | 0; if (!h) { l = t + 16 | 0; k = f[l >> 2] | 0; if (!k) { w = 0; break } else { x = k; y = l } } else { x = h; y = j } while (1) { j = x + 20 | 0; h = f[j >> 2] | 0; if (h | 0) { x = h; y = j; continue } j = x + 16 | 0; h = f[j >> 2] | 0; if (!h) break; else { x = h; y = j } } f[y >> 2] = 0; w = x } else { j = f[t + 8 >> 2] | 0; f[j + 12 >> 2] = i; f[i + 8 >> 2] = j; w = i } while (0); do if (n | 0) { i = f[t + 28 >> 2] | 0; j = 18352 + (i << 2) | 0; if ((t | 0) == (f[j >> 2] | 0)) { f[j >> 2] = w; if (!w) { f[4513] = e & ~(1 << i); break } } else { f[n + 16 + (((f[n + 16 >> 2] | 0) != (t | 0) & 1) << 2) >> 2] = w; if (!w) break } f[w + 24 >> 2] = n; i = f[t + 16 >> 2] | 0; if (i | 0) { f[w + 16 >> 2] = i; f[i + 24 >> 2] = w } i = f[t + 20 >> 2] | 0; if (i | 0) { f[w + 20 >> 2] = i; f[i + 24 >> 2] = w } } while (0); if (v >>> 0 < 16) { n = v + d | 0; f[t + 4 >> 2] = n | 3; e = t + n + 4 | 0; f[e >> 2] = f[e >> 2] | 1 } else { f[t + 4 >> 2] = d | 3; f[s + 4 >> 2] = v | 1; f[s + v >> 2] = v; if (m | 0) { e = f[4517] | 0; n = m >>> 3; i = 18088 + (n << 1 << 2) | 0; j = 1 << n; if (!(g & j)) { f[4512] = g | j; z = i; A = i + 8 | 0 } else { j = i + 8 | 0; z = f[j >> 2] | 0; A = j } f[A >> 2] = e; f[z + 12 >> 2] = e; f[e + 8 >> 2] = z; f[e + 12 >> 2] = i } f[4514] = v; f[4517] = s } o = t + 8 | 0; u = b; return o | 0 } else B = d } else B = d } else B = d } else if (a >>> 0 <= 4294967231) { i = a + 11 | 0; e = i & -8; j = f[4513] | 0; if (j) { n = 0 - e | 0; h = i >>> 8; if (h) if (e >>> 0 > 16777215) C = 31; else { i = (h + 1048320 | 0) >>> 16 & 8; l = h << i; h = (l + 520192 | 0) >>> 16 & 4; k = l << h; l = (k + 245760 | 0) >>> 16 & 2; D = 14 - (h | i | l) + (k << l >>> 15) | 0; C = e >>> (D + 7 | 0) & 1 | D << 1 } else C = 0; D = f[18352 + (C << 2) >> 2] | 0; a: do if (!D) { E = 0; F = 0; G = n; H = 57 } else { l = 0; k = n; i = D; h = e << ((C | 0) == 31 ? 0 : 25 - (C >>> 1) | 0); I = 0; while (1) { J = (f[i + 4 >> 2] & -8) - e | 0; if (J >>> 0 < k >>> 0) if (!J) { K = 0; L = i; M = i; H = 61; break a } else { N = i; O = J } else { N = l; O = k } J = f[i + 20 >> 2] | 0; i = f[i + 16 + (h >>> 31 << 2) >> 2] | 0; P = (J | 0) == 0 | (J | 0) == (i | 0) ? I : J; J = (i | 0) == 0; if (J) { E = P; F = N; G = O; H = 57; break } else { l = N; k = O; h = h << ((J ^ 1) & 1); I = P } } } while (0); if ((H | 0) == 57) { if ((E | 0) == 0 & (F | 0) == 0) { D = 2 << C; n = j & (D | 0 - D); if (!n) { B = e; break } D = (n & 0 - n) + -1 | 0; n = D >>> 12 & 16; d = D >>> n; D = d >>> 5 & 8; s = d >>> D; d = s >>> 2 & 4; g = s >>> d; s = g >>> 1 & 2; m = g >>> s; g = m >>> 1 & 1; Q = 0; R = f[18352 + ((D | n | d | s | g) + (m >>> g) << 2) >> 2] | 0 } else { Q = F; R = E } if (!R) { S = Q; T = G } else { K = G; L = R; M = Q; H = 61 } } if ((H | 0) == 61) while (1) { H = 0; g = (f[L + 4 >> 2] & -8) - e | 0; m = g >>> 0 < K >>> 0; s = m ? g : K; g = m ? L : M; L = f[L + 16 + (((f[L + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0; if (!L) { S = g; T = s; break } else { K = s; M = g; H = 61 } } if ((S | 0) != 0 ? T >>> 0 < ((f[4514] | 0) - e | 0) >>> 0 : 0) { g = S + e | 0; if (g >>> 0 <= S >>> 0) { o = 0; u = b; return o | 0 } s = f[S + 24 >> 2] | 0; m = f[S + 12 >> 2] | 0; do if ((m | 0) == (S | 0)) { d = S + 20 | 0; n = f[d >> 2] | 0; if (!n) { D = S + 16 | 0; I = f[D >> 2] | 0; if (!I) { U = 0; break } else { V = I; W = D } } else { V = n; W = d } while (1) { d = V + 20 | 0; n = f[d >> 2] | 0; if (n | 0) { V = n; W = d; continue } d = V + 16 | 0; n = f[d >> 2] | 0; if (!n) break; else { V = n; W = d } } f[W >> 2] = 0; U = V } else { d = f[S + 8 >> 2] | 0; f[d + 12 >> 2] = m; f[m + 8 >> 2] = d; U = m } while (0); do if (s) { m = f[S + 28 >> 2] | 0; d = 18352 + (m << 2) | 0; if ((S | 0) == (f[d >> 2] | 0)) { f[d >> 2] = U; if (!U) { d = j & ~(1 << m); f[4513] = d; X = d; break } } else { f[s + 16 + (((f[s + 16 >> 2] | 0) != (S | 0) & 1) << 2) >> 2] = U; if (!U) { X = j; break } } f[U + 24 >> 2] = s; d = f[S + 16 >> 2] | 0; if (d | 0) { f[U + 16 >> 2] = d; f[d + 24 >> 2] = U } d = f[S + 20 >> 2] | 0; if (d) { f[U + 20 >> 2] = d; f[d + 24 >> 2] = U; X = j } else X = j } else X = j; while (0); do if (T >>> 0 >= 16) { f[S + 4 >> 2] = e | 3; f[g + 4 >> 2] = T | 1; f[g + T >> 2] = T; j = T >>> 3; if (T >>> 0 < 256) { s = 18088 + (j << 1 << 2) | 0; d = f[4512] | 0; m = 1 << j; if (!(d & m)) { f[4512] = d | m; Y = s; Z = s + 8 | 0 } else { m = s + 8 | 0; Y = f[m >> 2] | 0; Z = m } f[Z >> 2] = g; f[Y + 12 >> 2] = g; f[g + 8 >> 2] = Y; f[g + 12 >> 2] = s; break } s = T >>> 8; if (s) if (T >>> 0 > 16777215) _ = 31; else { m = (s + 1048320 | 0) >>> 16 & 8; d = s << m; s = (d + 520192 | 0) >>> 16 & 4; j = d << s; d = (j + 245760 | 0) >>> 16 & 2; n = 14 - (s | m | d) + (j << d >>> 15) | 0; _ = T >>> (n + 7 | 0) & 1 | n << 1 } else _ = 0; n = 18352 + (_ << 2) | 0; f[g + 28 >> 2] = _; d = g + 16 | 0; f[d + 4 >> 2] = 0; f[d >> 2] = 0; d = 1 << _; if (!(X & d)) { f[4513] = X | d; f[n >> 2] = g; f[g + 24 >> 2] = n; f[g + 12 >> 2] = g; f[g + 8 >> 2] = g; break } d = T << ((_ | 0) == 31 ? 0 : 25 - (_ >>> 1) | 0); j = f[n >> 2] | 0; while (1) { if ((f[j + 4 >> 2] & -8 | 0) == (T | 0)) { H = 97; break } $ = j + 16 + (d >>> 31 << 2) | 0; n = f[$ >> 2] | 0; if (!n) { H = 96; break } else { d = d << 1; j = n } } if ((H | 0) == 96) { f[$ >> 2] = g; f[g + 24 >> 2] = j; f[g + 12 >> 2] = g; f[g + 8 >> 2] = g; break } else if ((H | 0) == 97) { d = j + 8 | 0; n = f[d >> 2] | 0; f[n + 12 >> 2] = g; f[d >> 2] = g; f[g + 8 >> 2] = n; f[g + 12 >> 2] = j; f[g + 24 >> 2] = 0; break } } else { n = T + e | 0; f[S + 4 >> 2] = n | 3; d = S + n + 4 | 0; f[d >> 2] = f[d >> 2] | 1 } while (0); o = S + 8 | 0; u = b; return o | 0 } else B = e } else B = e } else B = -1; while (0); S = f[4514] | 0; if (S >>> 0 >= B >>> 0) { T = S - B | 0; $ = f[4517] | 0; if (T >>> 0 > 15) { _ = $ + B | 0; f[4517] = _; f[4514] = T; f[_ + 4 >> 2] = T | 1; f[$ + S >> 2] = T; f[$ + 4 >> 2] = B | 3 } else { f[4514] = 0; f[4517] = 0; f[$ + 4 >> 2] = S | 3; T = $ + S + 4 | 0; f[T >> 2] = f[T >> 2] | 1 } o = $ + 8 | 0; u = b; return o | 0 } $ = f[4515] | 0; if ($ >>> 0 > B >>> 0) { T = $ - B | 0; f[4515] = T; S = f[4518] | 0; _ = S + B | 0; f[4518] = _; f[_ + 4 >> 2] = T | 1; f[S + 4 >> 2] = B | 3; o = S + 8 | 0; u = b; return o | 0 } if (!(f[4630] | 0)) { f[4632] = 4096; f[4631] = 4096; f[4633] = -1; f[4634] = -1; f[4635] = 0; f[4623] = 0; f[4630] = c & -16 ^ 1431655768; aa = 4096 } else aa = f[4632] | 0; c = B + 48 | 0; S = B + 47 | 0; T = aa + S | 0; _ = 0 - aa | 0; aa = T & _; if (aa >>> 0 <= B >>> 0) { o = 0; u = b; return o | 0 } X = f[4622] | 0; if (X | 0 ? (Y = f[4620] | 0, Z = Y + aa | 0, Z >>> 0 <= Y >>> 0 | Z >>> 0 > X >>> 0) : 0) { o = 0; u = b; return o | 0 } b: do if (!(f[4623] & 4)) { X = f[4518] | 0; c: do if (X) { Z = 18496; while (1) { Y = f[Z >> 2] | 0; if (Y >>> 0 <= X >>> 0 ? (ba = Z + 4 | 0, (Y + (f[ba >> 2] | 0) | 0) >>> 0 > X >>> 0) : 0) break; Y = f[Z + 8 >> 2] | 0; if (!Y) { H = 118; break c } else Z = Y } j = T - $ & _; if (j >>> 0 < 2147483647) { Y = Fl(j | 0) | 0; if ((Y | 0) == ((f[Z >> 2] | 0) + (f[ba >> 2] | 0) | 0)) if ((Y | 0) == (-1 | 0)) ca = j; else { da = j; ea = Y; H = 135; break b } else { fa = Y; ga = j; H = 126 } } else ca = 0 } else H = 118; while (0); do if ((H | 0) == 118) { X = Fl(0) | 0; if ((X | 0) != (-1 | 0) ? (e = X, j = f[4631] | 0, Y = j + -1 | 0, U = ((Y & e | 0) == 0 ? 0 : (Y + e & 0 - j) - e | 0) + aa | 0, e = f[4620] | 0, j = U + e | 0, U >>> 0 > B >>> 0 & U >>> 0 < 2147483647) : 0) { Y = f[4622] | 0; if (Y | 0 ? j >>> 0 <= e >>> 0 | j >>> 0 > Y >>> 0 : 0) { ca = 0; break } Y = Fl(U | 0) | 0; if ((Y | 0) == (X | 0)) { da = U; ea = X; H = 135; break b } else { fa = Y; ga = U; H = 126 } } else ca = 0 } while (0); do if ((H | 0) == 126) { U = 0 - ga | 0; if (!(c >>> 0 > ga >>> 0 & (ga >>> 0 < 2147483647 & (fa | 0) != (-1 | 0)))) if ((fa | 0) == (-1 | 0)) { ca = 0; break } else { da = ga; ea = fa; H = 135; break b } Y = f[4632] | 0; X = S - ga + Y & 0 - Y; if (X >>> 0 >= 2147483647) { da = ga; ea = fa; H = 135; break b } if ((Fl(X | 0) | 0) == (-1 | 0)) { Fl(U | 0) | 0; ca = 0; break } else { da = X + ga | 0; ea = fa; H = 135; break b } } while (0); f[4623] = f[4623] | 4; ha = ca; H = 133 } else { ha = 0; H = 133 } while (0); if (((H | 0) == 133 ? aa >>> 0 < 2147483647 : 0) ? (ca = Fl(aa | 0) | 0, aa = Fl(0) | 0, fa = aa - ca | 0, ga = fa >>> 0 > (B + 40 | 0) >>> 0, !((ca | 0) == (-1 | 0) | ga ^ 1 | ca >>> 0 < aa >>> 0 & ((ca | 0) != (-1 | 0) & (aa | 0) != (-1 | 0)) ^ 1)) : 0) { da = ga ? fa : ha; ea = ca; H = 135 } if ((H | 0) == 135) { ca = (f[4620] | 0) + da | 0; f[4620] = ca; if (ca >>> 0 > (f[4621] | 0) >>> 0) f[4621] = ca; ca = f[4518] | 0; do if (ca) { ha = 18496; while (1) { ia = f[ha >> 2] | 0; ja = ha + 4 | 0; ka = f[ja >> 2] | 0; if ((ea | 0) == (ia + ka | 0)) { H = 143; break } fa = f[ha + 8 >> 2] | 0; if (!fa) break; else ha = fa } if (((H | 0) == 143 ? (f[ha + 12 >> 2] & 8 | 0) == 0 : 0) ? ea >>> 0 > ca >>> 0 & ia >>> 0 <= ca >>> 0 : 0) { f[ja >> 2] = ka + da; fa = (f[4515] | 0) + da | 0; ga = ca + 8 | 0; aa = (ga & 7 | 0) == 0 ? 0 : 0 - ga & 7; ga = ca + aa | 0; S = fa - aa | 0; f[4518] = ga; f[4515] = S; f[ga + 4 >> 2] = S | 1; f[ca + fa + 4 >> 2] = 40; f[4519] = f[4634]; break } if (ea >>> 0 < (f[4516] | 0) >>> 0) f[4516] = ea; fa = ea + da | 0; S = 18496; while (1) { if ((f[S >> 2] | 0) == (fa | 0)) { H = 151; break } ga = f[S + 8 >> 2] | 0; if (!ga) { la = 18496; break } else S = ga } if ((H | 0) == 151) if (!(f[S + 12 >> 2] & 8)) { f[S >> 2] = ea; ha = S + 4 | 0; f[ha >> 2] = (f[ha >> 2] | 0) + da; ha = ea + 8 | 0; ga = ea + ((ha & 7 | 0) == 0 ? 0 : 0 - ha & 7) | 0; ha = fa + 8 | 0; aa = fa + ((ha & 7 | 0) == 0 ? 0 : 0 - ha & 7) | 0; ha = ga + B | 0; c = aa - ga - B | 0; f[ga + 4 >> 2] = B | 3; do if ((ca | 0) != (aa | 0)) { if ((f[4517] | 0) == (aa | 0)) { ba = (f[4514] | 0) + c | 0; f[4514] = ba; f[4517] = ha; f[ha + 4 >> 2] = ba | 1; f[ha + ba >> 2] = ba; break } ba = f[aa + 4 >> 2] | 0; if ((ba & 3 | 0) == 1) { _ = ba & -8; $ = ba >>> 3; d: do if (ba >>> 0 < 256) { T = f[aa + 8 >> 2] | 0; X = f[aa + 12 >> 2] | 0; if ((X | 0) == (T | 0)) { f[4512] = f[4512] & ~(1 << $); break } else { f[T + 12 >> 2] = X; f[X + 8 >> 2] = T; break } } else { T = f[aa + 24 >> 2] | 0; X = f[aa + 12 >> 2] | 0; do if ((X | 0) == (aa | 0)) { U = aa + 16 | 0; Y = U + 4 | 0; j = f[Y >> 2] | 0; if (!j) { e = f[U >> 2] | 0; if (!e) { ma = 0; break } else { na = e; oa = U } } else { na = j; oa = Y } while (1) { Y = na + 20 | 0; j = f[Y >> 2] | 0; if (j | 0) { na = j; oa = Y; continue } Y = na + 16 | 0; j = f[Y >> 2] | 0; if (!j) break; else { na = j; oa = Y } } f[oa >> 2] = 0; ma = na } else { Y = f[aa + 8 >> 2] | 0; f[Y + 12 >> 2] = X; f[X + 8 >> 2] = Y; ma = X } while (0); if (!T) break; X = f[aa + 28 >> 2] | 0; Y = 18352 + (X << 2) | 0; do if ((f[Y >> 2] | 0) != (aa | 0)) { f[T + 16 + (((f[T + 16 >> 2] | 0) != (aa | 0) & 1) << 2) >> 2] = ma; if (!ma) break d } else { f[Y >> 2] = ma; if (ma | 0) break; f[4513] = f[4513] & ~(1 << X); break d } while (0); f[ma + 24 >> 2] = T; X = aa + 16 | 0; Y = f[X >> 2] | 0; if (Y | 0) { f[ma + 16 >> 2] = Y; f[Y + 24 >> 2] = ma } Y = f[X + 4 >> 2] | 0; if (!Y) break; f[ma + 20 >> 2] = Y; f[Y + 24 >> 2] = ma } while (0); pa = aa + _ | 0; qa = _ + c | 0 } else { pa = aa; qa = c } $ = pa + 4 | 0; f[$ >> 2] = f[$ >> 2] & -2; f[ha + 4 >> 2] = qa | 1; f[ha + qa >> 2] = qa; $ = qa >>> 3; if (qa >>> 0 < 256) { ba = 18088 + ($ << 1 << 2) | 0; Z = f[4512] | 0; Y = 1 << $; if (!(Z & Y)) { f[4512] = Z | Y; ra = ba; sa = ba + 8 | 0 } else { Y = ba + 8 | 0; ra = f[Y >> 2] | 0; sa = Y } f[sa >> 2] = ha; f[ra + 12 >> 2] = ha; f[ha + 8 >> 2] = ra; f[ha + 12 >> 2] = ba; break } ba = qa >>> 8; do if (!ba) ta = 0; else { if (qa >>> 0 > 16777215) { ta = 31; break } Y = (ba + 1048320 | 0) >>> 16 & 8; Z = ba << Y; $ = (Z + 520192 | 0) >>> 16 & 4; X = Z << $; Z = (X + 245760 | 0) >>> 16 & 2; j = 14 - ($ | Y | Z) + (X << Z >>> 15) | 0; ta = qa >>> (j + 7 | 0) & 1 | j << 1 } while (0); ba = 18352 + (ta << 2) | 0; f[ha + 28 >> 2] = ta; _ = ha + 16 | 0; f[_ + 4 >> 2] = 0; f[_ >> 2] = 0; _ = f[4513] | 0; j = 1 << ta; if (!(_ & j)) { f[4513] = _ | j; f[ba >> 2] = ha; f[ha + 24 >> 2] = ba; f[ha + 12 >> 2] = ha; f[ha + 8 >> 2] = ha; break } j = qa << ((ta | 0) == 31 ? 0 : 25 - (ta >>> 1) | 0); _ = f[ba >> 2] | 0; while (1) { if ((f[_ + 4 >> 2] & -8 | 0) == (qa | 0)) { H = 192; break } ua = _ + 16 + (j >>> 31 << 2) | 0; ba = f[ua >> 2] | 0; if (!ba) { H = 191; break } else { j = j << 1; _ = ba } } if ((H | 0) == 191) { f[ua >> 2] = ha; f[ha + 24 >> 2] = _; f[ha + 12 >> 2] = ha; f[ha + 8 >> 2] = ha; break } else if ((H | 0) == 192) { j = _ + 8 | 0; ba = f[j >> 2] | 0; f[ba + 12 >> 2] = ha; f[j >> 2] = ha; f[ha + 8 >> 2] = ba; f[ha + 12 >> 2] = _; f[ha + 24 >> 2] = 0; break } } else { ba = (f[4515] | 0) + c | 0; f[4515] = ba; f[4518] = ha; f[ha + 4 >> 2] = ba | 1 } while (0); o = ga + 8 | 0; u = b; return o | 0 } else la = 18496; while (1) { ha = f[la >> 2] | 0; if (ha >>> 0 <= ca >>> 0 ? (va = ha + (f[la + 4 >> 2] | 0) | 0, va >>> 0 > ca >>> 0) : 0) break; la = f[la + 8 >> 2] | 0 } ga = va + -47 | 0; ha = ga + 8 | 0; c = ga + ((ha & 7 | 0) == 0 ? 0 : 0 - ha & 7) | 0; ha = ca + 16 | 0; ga = c >>> 0 < ha >>> 0 ? ca : c; c = ga + 8 | 0; aa = da + -40 | 0; fa = ea + 8 | 0; S = (fa & 7 | 0) == 0 ? 0 : 0 - fa & 7; fa = ea + S | 0; ba = aa - S | 0; f[4518] = fa; f[4515] = ba; f[fa + 4 >> 2] = ba | 1; f[ea + aa + 4 >> 2] = 40; f[4519] = f[4634]; aa = ga + 4 | 0; f[aa >> 2] = 27; f[c >> 2] = f[4624]; f[c + 4 >> 2] = f[4625]; f[c + 8 >> 2] = f[4626]; f[c + 12 >> 2] = f[4627]; f[4624] = ea; f[4625] = da; f[4627] = 0; f[4626] = c; c = ga + 24 | 0; do { ba = c; c = c + 4 | 0; f[c >> 2] = 7 } while ((ba + 8 | 0) >>> 0 < va >>> 0); if ((ga | 0) != (ca | 0)) { c = ga - ca | 0; f[aa >> 2] = f[aa >> 2] & -2; f[ca + 4 >> 2] = c | 1; f[ga >> 2] = c; ba = c >>> 3; if (c >>> 0 < 256) { fa = 18088 + (ba << 1 << 2) | 0; S = f[4512] | 0; j = 1 << ba; if (!(S & j)) { f[4512] = S | j; wa = fa; xa = fa + 8 | 0 } else { j = fa + 8 | 0; wa = f[j >> 2] | 0; xa = j } f[xa >> 2] = ca; f[wa + 12 >> 2] = ca; f[ca + 8 >> 2] = wa; f[ca + 12 >> 2] = fa; break } fa = c >>> 8; if (fa) if (c >>> 0 > 16777215) ya = 31; else { j = (fa + 1048320 | 0) >>> 16 & 8; S = fa << j; fa = (S + 520192 | 0) >>> 16 & 4; ba = S << fa; S = (ba + 245760 | 0) >>> 16 & 2; Z = 14 - (fa | j | S) + (ba << S >>> 15) | 0; ya = c >>> (Z + 7 | 0) & 1 | Z << 1 } else ya = 0; Z = 18352 + (ya << 2) | 0; f[ca + 28 >> 2] = ya; f[ca + 20 >> 2] = 0; f[ha >> 2] = 0; S = f[4513] | 0; ba = 1 << ya; if (!(S & ba)) { f[4513] = S | ba; f[Z >> 2] = ca; f[ca + 24 >> 2] = Z; f[ca + 12 >> 2] = ca; f[ca + 8 >> 2] = ca; break } ba = c << ((ya | 0) == 31 ? 0 : 25 - (ya >>> 1) | 0); S = f[Z >> 2] | 0; while (1) { if ((f[S + 4 >> 2] & -8 | 0) == (c | 0)) { H = 213; break } za = S + 16 + (ba >>> 31 << 2) | 0; Z = f[za >> 2] | 0; if (!Z) { H = 212; break } else { ba = ba << 1; S = Z } } if ((H | 0) == 212) { f[za >> 2] = ca; f[ca + 24 >> 2] = S; f[ca + 12 >> 2] = ca; f[ca + 8 >> 2] = ca; break } else if ((H | 0) == 213) { ba = S + 8 | 0; c = f[ba >> 2] | 0; f[c + 12 >> 2] = ca; f[ba >> 2] = ca; f[ca + 8 >> 2] = c; f[ca + 12 >> 2] = S; f[ca + 24 >> 2] = 0; break } } } else { c = f[4516] | 0; if ((c | 0) == 0 | ea >>> 0 < c >>> 0) f[4516] = ea; f[4624] = ea; f[4625] = da; f[4627] = 0; f[4521] = f[4630]; f[4520] = -1; f[4525] = 18088; f[4524] = 18088; f[4527] = 18096; f[4526] = 18096; f[4529] = 18104; f[4528] = 18104; f[4531] = 18112; f[4530] = 18112; f[4533] = 18120; f[4532] = 18120; f[4535] = 18128; f[4534] = 18128; f[4537] = 18136; f[4536] = 18136; f[4539] = 18144; f[4538] = 18144; f[4541] = 18152; f[4540] = 18152; f[4543] = 18160; f[4542] = 18160; f[4545] = 18168; f[4544] = 18168; f[4547] = 18176; f[4546] = 18176; f[4549] = 18184; f[4548] = 18184; f[4551] = 18192; f[4550] = 18192; f[4553] = 18200; f[4552] = 18200; f[4555] = 18208; f[4554] = 18208; f[4557] = 18216; f[4556] = 18216; f[4559] = 18224; f[4558] = 18224; f[4561] = 18232; f[4560] = 18232; f[4563] = 18240; f[4562] = 18240; f[4565] = 18248; f[4564] = 18248; f[4567] = 18256; f[4566] = 18256; f[4569] = 18264; f[4568] = 18264; f[4571] = 18272; f[4570] = 18272; f[4573] = 18280; f[4572] = 18280; f[4575] = 18288; f[4574] = 18288; f[4577] = 18296; f[4576] = 18296; f[4579] = 18304; f[4578] = 18304; f[4581] = 18312; f[4580] = 18312; f[4583] = 18320; f[4582] = 18320; f[4585] = 18328; f[4584] = 18328; f[4587] = 18336; f[4586] = 18336; c = da + -40 | 0; ba = ea + 8 | 0; ha = (ba & 7 | 0) == 0 ? 0 : 0 - ba & 7; ba = ea + ha | 0; ga = c - ha | 0; f[4518] = ba; f[4515] = ga; f[ba + 4 >> 2] = ga | 1; f[ea + c + 4 >> 2] = 40; f[4519] = f[4634] } while (0); ea = f[4515] | 0; if (ea >>> 0 > B >>> 0) { da = ea - B | 0; f[4515] = da; ea = f[4518] | 0; ca = ea + B | 0; f[4518] = ca; f[ca + 4 >> 2] = da | 1; f[ea + 4 >> 2] = B | 3; o = ea + 8 | 0; u = b; return o | 0 } } ea = ir() | 0; f[ea >> 2] = 12; o = 0; u = b; return o | 0 } function ab(a, c, d, e, g, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0, Ua = 0, Va = 0.0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0, kb = 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = 0, yb = 0, zb = 0, Ab = 0, Bb = 0, Cb = 0, Db = 0, Eb = 0, Fb = 0, Gb = 0, Hb = 0, Ib = 0, Jb = 0, Kb = 0; i = u; u = u + 240 | 0; j = i + 104 | 0; k = i + 224 | 0; l = i + 176 | 0; m = i + 160 | 0; n = i + 228 | 0; o = i + 72 | 0; p = i + 40 | 0; q = i + 132 | 0; r = i; s = i + 172 | 0; t = i + 156 | 0; v = i + 152 | 0; w = i + 148 | 0; x = i + 144 | 0; y = i + 128 | 0; z = a + 8 | 0; Ah(z, c, e, g); e = f[a + 48 >> 2] | 0; A = f[a + 52 >> 2] | 0; B = l; C = B + 48 | 0; do { f[B >> 2] = 0; B = B + 4 | 0 } while ((B | 0) < (C | 0)); if (!g) { D = 0; E = 0 } else { oi(l, g); D = f[l + 12 >> 2] | 0; E = f[l + 16 >> 2] | 0 } B = l + 16 | 0; C = E - D >> 2; F = D; D = E; if (C >>> 0 >= g >>> 0) { if (C >>> 0 > g >>> 0 ? (E = F + (g << 2) | 0, (E | 0) != (D | 0)) : 0) f[B >> 2] = D + (~((D + -4 - E | 0) >>> 2) << 2) } else oi(l + 12 | 0, g - C | 0); C = l + 24 | 0; E = l + 28 | 0; D = f[E >> 2] | 0; B = f[C >> 2] | 0; F = D - B >> 2; G = B; B = D; if (F >>> 0 >= g >>> 0) { if (F >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[E >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(C, g - F | 0); F = l + 36 | 0; C = l + 40 | 0; D = f[C >> 2] | 0; B = f[F >> 2] | 0; E = D - B >> 2; G = B; B = D; if (E >>> 0 >= g >>> 0) { if (E >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[C >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(F, g - E | 0); f[m >> 2] = 0; E = m + 4 | 0; f[E >> 2] = 0; f[m + 8 >> 2] = 0; F = (g | 0) == 0; do if (!F) if (g >>> 0 > 1073741823) mq(m); else { D = g << 2; B = dn(D) | 0; f[m >> 2] = B; C = B + (g << 2) | 0; f[m + 8 >> 2] = C; hj(B | 0, 0, D | 0) | 0; f[E >> 2] = C; break } while (0); C = a + 152 | 0; D = a + 156 | 0; B = f[D >> 2] | 0; G = f[C >> 2] | 0; H = B - G >> 2; L = G; G = B; if (H >>> 0 >= g >>> 0) { if (H >>> 0 > g >>> 0 ? (B = L + (g << 2) | 0, (B | 0) != (G | 0)) : 0) f[D >> 2] = G + (~((G + -4 - B | 0) >>> 2) << 2) } else oi(C, g - H | 0); f[o >> 2] = 0; f[o + 4 >> 2] = 0; f[o + 8 >> 2] = 0; f[o + 12 >> 2] = 0; f[o + 16 >> 2] = 0; f[o + 20 >> 2] = 0; f[o + 24 >> 2] = 0; f[o + 28 >> 2] = 0; f[p >> 2] = 0; f[p + 4 >> 2] = 0; f[p + 8 >> 2] = 0; f[p + 12 >> 2] = 0; f[p + 16 >> 2] = 0; f[p + 20 >> 2] = 0; f[p + 24 >> 2] = 0; f[p + 28 >> 2] = 0; f[q >> 2] = 0; H = q + 4 | 0; f[H >> 2] = 0; f[q + 8 >> 2] = 0; if (F) { M = 0; N = 0; O = 0; P = 0 } else { F = g << 2; B = dn(F) | 0; f[q >> 2] = B; G = B + (g << 2) | 0; f[q + 8 >> 2] = G; hj(B | 0, 0, F | 0) | 0; f[H >> 2] = G; M = B; N = G; O = G; P = B } B = a + 56 | 0; G = f[B >> 2] | 0; F = f[G + 4 >> 2] | 0; D = f[G >> 2] | 0; L = F - D | 0; a: do if ((L | 0) > 4) { Q = L >>> 2; R = e + 64 | 0; S = e + 28 | 0; T = (g | 0) > 0; U = r + 4 | 0; V = r + 8 | 0; Z = r + 12 | 0; _ = a + 152 | 0; $ = a + 112 | 0; aa = r + 16 | 0; ba = r + 28 | 0; ca = a + 16 | 0; da = a + 32 | 0; ea = a + 12 | 0; fa = a + 28 | 0; ga = a + 20 | 0; ha = a + 24 | 0; ia = r + 28 | 0; ja = r + 16 | 0; ka = r + 20 | 0; la = r + 32 | 0; ma = n + 1 | 0; na = g << 2; oa = (g | 0) == 1; pa = Q + -1 | 0; if (F - D >> 2 >>> 0 > pa >>> 0) { qa = Q; ra = pa; sa = D; ta = M; ua = P; va = O; wa = M; xa = N; ya = M; za = N } else { Aa = G; mq(Aa) } b: while (1) { pa = f[sa + (ra << 2) >> 2] | 0; Q = (((pa >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + pa | 0; Ba = Q >>> 5; Ca = 1 << (Q & 31); Da = (pa | 0) == -1 | (Q | 0) == -1; Ea = 1; Fa = 0; Ga = pa; c: while (1) { Ha = Ea ^ 1; Ia = Fa; Ja = Ga; while (1) { if ((Ja | 0) == -1) { Ka = Ia; break c } La = f[l + (Ia * 12 | 0) >> 2] | 0; if (((f[(f[e >> 2] | 0) + (Ja >>> 5 << 2) >> 2] & 1 << (Ja & 31) | 0) == 0 ? (Ma = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ja << 2) >> 2] | 0, (Ma | 0) != -1) : 0) ? (Na = f[S >> 2] | 0, Oa = f[A >> 2] | 0, Pa = f[Oa + (f[Na + (Ma << 2) >> 2] << 2) >> 2] | 0, Qa = Ma + 1 | 0, Ra = f[Oa + (f[Na + ((((Qa >>> 0) % 3 | 0 | 0) == 0 ? Ma + -2 | 0 : Qa) << 2) >> 2] << 2) >> 2] | 0, Qa = f[Oa + (f[Na + ((((Ma >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ma << 2) >> 2] << 2) >> 2] | 0, (Pa | 0) < (ra | 0) & (Ra | 0) < (ra | 0) & (Qa | 0) < (ra | 0)) : 0) { Ma = X(Pa, g) | 0; Pa = X(Ra, g) | 0; Ra = X(Qa, g) | 0; if (T) { Qa = 0; do { f[La + (Qa << 2) >> 2] = (f[c + (Qa + Ra << 2) >> 2] | 0) + (f[c + (Qa + Pa << 2) >> 2] | 0) - (f[c + (Qa + Ma << 2) >> 2] | 0); Qa = Qa + 1 | 0 } while ((Qa | 0) != (g | 0)) } Qa = Ia + 1 | 0; if ((Qa | 0) == 4) { Ka = 4; break c } else Sa = Qa } else Sa = Ia; do if (Ea) { Qa = Ja + 1 | 0; Ma = ((Qa >>> 0) % 3 | 0 | 0) == 0 ? Ja + -2 | 0 : Qa; if (((Ma | 0) != -1 ? (f[(f[e >> 2] | 0) + (Ma >>> 5 << 2) >> 2] & 1 << (Ma & 31) | 0) == 0 : 0) ? (Qa = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ma << 2) >> 2] | 0, Ma = Qa + 1 | 0, (Qa | 0) != -1) : 0) Ta = ((Ma >>> 0) % 3 | 0 | 0) == 0 ? Qa + -2 | 0 : Ma; else Ta = -1 } else { Ma = (((Ja >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ja | 0; if (((Ma | 0) != -1 ? (f[(f[e >> 2] | 0) + (Ma >>> 5 << 2) >> 2] & 1 << (Ma & 31) | 0) == 0 : 0) ? (Qa = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ma << 2) >> 2] | 0, (Qa | 0) != -1) : 0) if (!((Qa >>> 0) % 3 | 0)) { Ta = Qa + 2 | 0; break } else { Ta = Qa + -1 | 0; break } else Ta = -1 } while (0); if ((Ta | 0) == (pa | 0)) { Ka = Sa; break c } if ((Ta | 0) != -1 | Ha) { Ia = Sa; Ja = Ta } else break } if (Da) { Ea = 0; Fa = Sa; Ga = -1; continue } if (f[(f[e >> 2] | 0) + (Ba << 2) >> 2] & Ca | 0) { Ea = 0; Fa = Sa; Ga = -1; continue } Ja = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Q << 2) >> 2] | 0; if ((Ja | 0) == -1) { Ea = 0; Fa = Sa; Ga = -1; continue } if (!((Ja >>> 0) % 3 | 0)) { Ea = 0; Fa = Sa; Ga = Ja + 2 | 0; continue } else { Ea = 0; Fa = Sa; Ga = Ja + -1 | 0; continue } } Ga = X(ra, g) | 0; f[r >> 2] = 0; f[U >> 2] = 0; b[V >> 0] = 0; f[Z >> 2] = 0; f[Z + 4 >> 2] = 0; f[Z + 8 >> 2] = 0; f[Z + 12 >> 2] = 0; f[Z + 16 >> 2] = 0; f[Z + 20 >> 2] = 0; f[Z + 24 >> 2] = 0; Fa = c + ((X(qa + -2 | 0, g) | 0) << 2) | 0; Ea = c + (Ga << 2) | 0; Q = f[_ >> 2] | 0; if (T) { Ca = 0; Ba = 0; while (1) { Da = (f[Fa + (Ca << 2) >> 2] | 0) - (f[Ea + (Ca << 2) >> 2] | 0) | 0; pa = ((Da | 0) > -1 ? Da : 0 - Da | 0) + Ba | 0; f[ta + (Ca << 2) >> 2] = Da; f[Q + (Ca << 2) >> 2] = Da << 1 ^ Da >> 31; Ca = Ca + 1 | 0; if ((Ca | 0) == (g | 0)) { Ua = pa; break } else Ba = pa } } else Ua = 0; ho(j, $, Q, g); Ba = Tk(j) | 0; Ca = I; pa = om(j) | 0; Da = Tn(pa | 0, I | 0, Ba | 0, Ca | 0) | 0; Ca = I; Ba = (Ka | 0) > 0; if (Ba) { pa = Ka + -1 | 0; Ja = p + (pa << 3) | 0; Ia = Ja; Ha = Tn(f[Ia >> 2] | 0, f[Ia + 4 >> 2] | 0, Ka | 0, ((Ka | 0) < 0) << 31 >> 31 | 0) | 0; Ia = I; Qa = Ja; f[Qa >> 2] = Ha; f[Qa + 4 >> 2] = Ia; Va = +W(+(+jm(Ha, f[o + (pa << 3) >> 2] | 0) * (+(Ha >>> 0) + 4294967296.0 * +(Ia | 0)))); Ia = Tn(Da | 0, Ca | 0, ~~Va >>> 0 | 0, (+K(Va) >= 1.0 ? (Va > 0.0 ? ~~+Y(+J(Va / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Va - +(~~Va >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; Wa = Ia } else Wa = Da; Da = r; f[Da >> 2] = Wa; f[Da + 4 >> 2] = Ua; b[V >> 0] = 0; f[Z >> 2] = 0; Mf(aa, Fa, Fa + (g << 2) | 0); f[s >> 2] = ua; f[t >> 2] = va; f[k >> 2] = f[s >> 2]; f[j >> 2] = f[t >> 2]; tf(ba, k, j); if ((Ka | 0) < 1) { Xa = za; Ya = ya; Za = xa; _a = wa; $a = va; ab = ua; bb = ua } else { Da = n + Ka | 0; Ia = f[q >> 2] | 0; Ca = Ka + -1 | 0; Ha = o + (Ca << 3) | 0; pa = p + (Ca << 3) | 0; Ca = Ia; Qa = f[H >> 2] | 0; Ja = Da + -1 | 0; Ma = (Ja | 0) == (n | 0); Pa = Da + -2 | 0; Ra = ma >>> 0 < Pa >>> 0; La = ~Ka; Na = Ka + 2 + ((La | 0) > -2 ? La : -2) | 0; La = Qa; Oa = Ja >>> 0 > n >>> 0; cb = 0; db = 1; while (1) { cb = cb + 1 | 0; hj(n | 0, 1, Na | 0) | 0; hj(n | 0, 0, cb | 0) | 0; d: while (1) { if (T) { hj(f[m >> 2] | 0, 0, na | 0) | 0; eb = f[m >> 2] | 0; fb = 0; gb = 0; while (1) { if (!(b[n + fb >> 0] | 0)) { hb = f[l + (fb * 12 | 0) >> 2] | 0; ib = 0; do { jb = eb + (ib << 2) | 0; f[jb >> 2] = (f[jb >> 2] | 0) + (f[hb + (ib << 2) >> 2] | 0); ib = ib + 1 | 0 } while ((ib | 0) != (g | 0)); kb = (1 << fb | gb & 255) & 255 } else kb = gb; fb = fb + 1 | 0; if ((fb | 0) == (Ka | 0)) { lb = kb; break } else gb = kb } } else { gb = 0; fb = 0; while (1) { if (!(b[n + gb >> 0] | 0)) mb = (1 << gb | fb & 255) & 255; else mb = fb; gb = gb + 1 | 0; if ((gb | 0) == (Ka | 0)) { lb = mb; break } else fb = mb } } fb = f[m >> 2] | 0; do if (T) { f[fb >> 2] = (f[fb >> 2] | 0) / (db | 0) | 0; if (!oa) { gb = 1; do { eb = fb + (gb << 2) | 0; f[eb >> 2] = (f[eb >> 2] | 0) / (db | 0) | 0; gb = gb + 1 | 0 } while ((gb | 0) != (g | 0)); gb = f[_ >> 2] | 0; if (T) nb = gb; else { ob = 0; pb = gb; break } } else nb = f[_ >> 2] | 0; gb = 0; eb = 0; while (1) { ib = (f[fb + (gb << 2) >> 2] | 0) - (f[Ea + (gb << 2) >> 2] | 0) | 0; hb = ((ib | 0) > -1 ? ib : 0 - ib | 0) + eb | 0; f[Ia + (gb << 2) >> 2] = ib; f[nb + (gb << 2) >> 2] = ib << 1 ^ ib >> 31; gb = gb + 1 | 0; if ((gb | 0) == (g | 0)) { ob = hb; pb = nb; break } else eb = hb } } else { ob = 0; pb = f[_ >> 2] | 0 } while (0); ho(j, $, pb, g); fb = Tk(j) | 0; eb = I; gb = om(j) | 0; hb = Tn(gb | 0, I | 0, fb | 0, eb | 0) | 0; eb = I; if (Ba) { fb = Ha; gb = Tn(f[fb >> 2] | 0, f[fb + 4 >> 2] | 0, db | 0, 0) | 0; fb = pa; ib = f[fb >> 2] | 0; jb = f[fb + 4 >> 2] | 0; Va = +W(+(+jm(ib, gb) * (+(ib >>> 0) + 4294967296.0 * +(jb | 0)))); jb = Tn(hb | 0, eb | 0, ~~Va >>> 0 | 0, (+K(Va) >= 1.0 ? (Va > 0.0 ? ~~+Y(+J(Va / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Va - +(~~Va >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; qb = jb } else qb = hb; hb = f[r >> 2] | 0; if (!((qb | 0) >= (hb | 0) ? !((qb | 0) <= (hb | 0) ? (ob | 0) < (f[U >> 2] | 0) : 0) : 0)) { hb = r; f[hb >> 2] = qb; f[hb + 4 >> 2] = ob; b[V >> 0] = lb; f[Z >> 2] = db; f[v >> 2] = f[m >> 2]; f[w >> 2] = f[E >> 2]; f[k >> 2] = f[v >> 2]; f[j >> 2] = f[w >> 2]; tf(aa, k, j); f[x >> 2] = Ca; f[y >> 2] = Qa; f[k >> 2] = f[x >> 2]; f[j >> 2] = f[y >> 2]; tf(ba, k, j) } if (Ma) break; rb = b[Ja >> 0] | 0; hb = -1; jb = rb; while (1) { eb = hb + -1 | 0; sb = Da + eb | 0; ib = jb; jb = b[sb >> 0] | 0; if ((jb & 255) < (ib & 255)) break; if ((sb | 0) == (n | 0)) { tb = 86; break d } else hb = eb } eb = Da + hb | 0; if ((jb & 255) < (rb & 255)) { ub = Ja; vb = rb } else { ib = Da; gb = Ja; while (1) { fb = gb + -1 | 0; if ((jb & 255) < (h[ib + -2 >> 0] | 0)) { ub = fb; vb = 1; break } else { wb = gb; gb = fb; ib = wb } } } b[sb >> 0] = vb; b[ub >> 0] = jb; if ((hb | 0) < -1) { xb = eb; yb = Ja } else continue; while (1) { ib = b[xb >> 0] | 0; b[xb >> 0] = b[yb >> 0] | 0; b[yb >> 0] = ib; ib = xb + 1 | 0; gb = yb + -1 | 0; if (ib >>> 0 < gb >>> 0) { xb = ib; yb = gb } else continue d } } if (((tb | 0) == 86 ? (tb = 0, Oa) : 0) ? (eb = b[n >> 0] | 0, b[n >> 0] = rb, b[Ja >> 0] = eb, Ra) : 0) { eb = Pa; hb = ma; do { jb = b[hb >> 0] | 0; b[hb >> 0] = b[eb >> 0] | 0; b[eb >> 0] = jb; hb = hb + 1 | 0; eb = eb + -1 | 0 } while (hb >>> 0 < eb >>> 0) } if ((db | 0) >= (Ka | 0)) { Xa = La; Ya = Ia; Za = La; _a = Ia; $a = Qa; ab = Ca; bb = Ia; break } else db = db + 1 | 0 } } if (Ba) { db = f[Z >> 2] | 0; Ia = o + (Ka + -1 << 3) | 0; Ca = Ia; Qa = Tn(f[Ca >> 2] | 0, f[Ca + 4 >> 2] | 0, db | 0, ((db | 0) < 0) << 31 >> 31 | 0) | 0; db = Ia; f[db >> 2] = Qa; f[db + 4 >> 2] = I } if (T) { db = f[ba >> 2] | 0; Qa = f[C >> 2] | 0; Ia = 0; do { Ca = f[db + (Ia << 2) >> 2] | 0; f[Qa + (Ia << 2) >> 2] = Ca << 1 ^ Ca >> 31; Ia = Ia + 1 | 0 } while ((Ia | 0) != (g | 0)); zb = Qa } else zb = f[C >> 2] | 0; go(j, $, zb, g); if (Ba) { Qa = Ka + -1 | 0; Ab = a + 60 + (Qa * 12 | 0) | 0; Ia = a + 60 + (Qa * 12 | 0) + 4 | 0; db = a + 60 + (Qa * 12 | 0) + 8 | 0; Qa = 0; do { Ca = f[Ia >> 2] | 0; La = f[db >> 2] | 0; Pa = (Ca | 0) == (La << 5 | 0); if (!(1 << Qa & h[V >> 0])) { if (Pa) { if ((Ca + 1 | 0) < 0) { tb = 114; break b } Ra = La << 6; Ja = Ca + 32 & -32; hi(Ab, Ca >>> 0 < 1073741823 ? (Ra >>> 0 < Ja >>> 0 ? Ja : Ra) : 2147483647); Bb = f[Ia >> 2] | 0 } else Bb = Ca; f[Ia >> 2] = Bb + 1; Ra = (f[Ab >> 2] | 0) + (Bb >>> 5 << 2) | 0; f[Ra >> 2] = f[Ra >> 2] | 1 << (Bb & 31) } else { if (Pa) { if ((Ca + 1 | 0) < 0) { tb = 119; break b } Pa = La << 6; La = Ca + 32 & -32; hi(Ab, Ca >>> 0 < 1073741823 ? (Pa >>> 0 < La >>> 0 ? La : Pa) : 2147483647); Cb = f[Ia >> 2] | 0 } else Cb = Ca; f[Ia >> 2] = Cb + 1; Ca = (f[Ab >> 2] | 0) + (Cb >>> 5 << 2) | 0; f[Ca >> 2] = f[Ca >> 2] & ~(1 << (Cb & 31)) } Qa = Qa + 1 | 0 } while ((Qa | 0) < (Ka | 0)) } Qa = d + (Ga << 2) | 0; Ia = f[z >> 2] | 0; if ((Ia | 0) > 0) { db = 0; Ba = f[aa >> 2] | 0; Ca = Ia; while (1) { if ((Ca | 0) > 0) { Ia = 0; do { Pa = f[Ba + (Ia << 2) >> 2] | 0; La = f[ca >> 2] | 0; if ((Pa | 0) > (La | 0)) { Ra = f[da >> 2] | 0; f[Ra + (Ia << 2) >> 2] = La; Db = Ra } else { Ra = f[ea >> 2] | 0; La = f[da >> 2] | 0; f[La + (Ia << 2) >> 2] = (Pa | 0) < (Ra | 0) ? Ra : Pa; Db = La } Ia = Ia + 1 | 0 } while ((Ia | 0) < (f[z >> 2] | 0)); Eb = Db } else Eb = f[da >> 2] | 0; Ia = (f[Ea + (db << 2) >> 2] | 0) - (f[Eb + (db << 2) >> 2] | 0) | 0; La = Qa + (db << 2) | 0; f[La >> 2] = Ia; do if ((Ia | 0) < (f[fa >> 2] | 0)) { Fb = (f[ga >> 2] | 0) + Ia | 0; tb = 109 } else { if ((Ia | 0) <= (f[ha >> 2] | 0)) break; Fb = Ia - (f[ga >> 2] | 0) | 0; tb = 109 } while (0); if ((tb | 0) == 109) { tb = 0; f[La >> 2] = Fb } db = db + 1 | 0; Ca = f[z >> 2] | 0; if ((db | 0) >= (Ca | 0)) break; else Ba = Eb } } Ba = f[ia >> 2] | 0; if (Ba | 0) { Ca = f[la >> 2] | 0; if ((Ca | 0) != (Ba | 0)) f[la >> 2] = Ca + (~((Ca + -4 - Ba | 0) >>> 2) << 2); br(Ba) } Ba = f[ja >> 2] | 0; if (Ba | 0) { Ca = f[ka >> 2] | 0; if ((Ca | 0) != (Ba | 0)) f[ka >> 2] = Ca + (~((Ca + -4 - Ba | 0) >>> 2) << 2); br(Ba) } if ((qa | 0) <= 2) { Gb = _a; Hb = Za; break a } Ba = f[B >> 2] | 0; sa = f[Ba >> 2] | 0; Ca = ra + -1 | 0; if ((f[Ba + 4 >> 2] | 0) - sa >> 2 >>> 0 <= Ca >>> 0) { Aa = Ba; tb = 18; break } else { Ba = ra; ra = Ca; ta = bb; ua = ab; va = $a; wa = _a; xa = Za; ya = Ya; za = Xa; qa = Ba } } if ((tb | 0) == 18) mq(Aa); else if ((tb | 0) == 114) mq(Ab); else if ((tb | 0) == 119) mq(Ab) } else { Gb = M; Hb = N } while (0); N = f[l >> 2] | 0; if ((g | 0) > 0 ? (f[N >> 2] = 0, (g | 0) != 1) : 0) { M = 1; do { f[N + (M << 2) >> 2] = 0; M = M + 1 | 0 } while ((M | 0) != (g | 0)) } g = f[z >> 2] | 0; if ((g | 0) > 0) { M = a + 16 | 0; Ab = a + 32 | 0; Aa = a + 12 | 0; qa = a + 28 | 0; Xa = a + 20 | 0; za = a + 24 | 0; a = 0; Ya = N; N = g; while (1) { if ((N | 0) > 0) { g = 0; do { ya = f[Ya + (g << 2) >> 2] | 0; Za = f[M >> 2] | 0; if ((ya | 0) > (Za | 0)) { xa = f[Ab >> 2] | 0; f[xa + (g << 2) >> 2] = Za; Ib = xa } else { xa = f[Aa >> 2] | 0; Za = f[Ab >> 2] | 0; f[Za + (g << 2) >> 2] = (ya | 0) < (xa | 0) ? xa : ya; Ib = Za } g = g + 1 | 0 } while ((g | 0) < (f[z >> 2] | 0)); Jb = Ib } else Jb = f[Ab >> 2] | 0; g = (f[c + (a << 2) >> 2] | 0) - (f[Jb + (a << 2) >> 2] | 0) | 0; Za = d + (a << 2) | 0; f[Za >> 2] = g; if ((g | 0) >= (f[qa >> 2] | 0)) { if ((g | 0) > (f[za >> 2] | 0)) { Kb = g - (f[Xa >> 2] | 0) | 0; tb = 145 } } else { Kb = (f[Xa >> 2] | 0) + g | 0; tb = 145 } if ((tb | 0) == 145) { tb = 0; f[Za >> 2] = Kb } a = a + 1 | 0; N = f[z >> 2] | 0; if ((a | 0) >= (N | 0)) break; else Ya = Jb } } if (Gb | 0) { if ((Hb | 0) != (Gb | 0)) f[H >> 2] = Hb + (~((Hb + -4 - Gb | 0) >>> 2) << 2); br(Gb) } Gb = f[m >> 2] | 0; if (Gb | 0) { m = f[E >> 2] | 0; if ((m | 0) != (Gb | 0)) f[E >> 2] = m + (~((m + -4 - Gb | 0) >>> 2) << 2); br(Gb) } Gb = f[l + 36 >> 2] | 0; if (Gb | 0) { m = l + 40 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Gb | 0)) f[m >> 2] = E + (~((E + -4 - Gb | 0) >>> 2) << 2); br(Gb) } Gb = f[l + 24 >> 2] | 0; if (Gb | 0) { E = l + 28 | 0; m = f[E >> 2] | 0; if ((m | 0) != (Gb | 0)) f[E >> 2] = m + (~((m + -4 - Gb | 0) >>> 2) << 2); br(Gb) } Gb = f[l + 12 >> 2] | 0; if (Gb | 0) { m = l + 16 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Gb | 0)) f[m >> 2] = E + (~((E + -4 - Gb | 0) >>> 2) << 2); br(Gb) } Gb = f[l >> 2] | 0; if (!Gb) { u = i; return 1 } E = l + 4 | 0; l = f[E >> 2] | 0; if ((l | 0) != (Gb | 0)) f[E >> 2] = l + (~((l + -4 - Gb | 0) >>> 2) << 2); br(Gb); u = i; return 1 } function bb(a, c, d, e, g, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0, Ua = 0, Va = 0.0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0, kb = 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = 0, yb = 0, zb = 0, Ab = 0, Bb = 0, Cb = 0, Db = 0, Eb = 0, Fb = 0, Gb = 0, Hb = 0, Ib = 0, Jb = 0, Kb = 0, Lb = 0, Mb = 0; i = u; u = u + 240 | 0; j = i + 104 | 0; k = i + 224 | 0; l = i + 176 | 0; m = i + 160 | 0; n = i + 228 | 0; o = i + 72 | 0; p = i + 40 | 0; q = i + 132 | 0; r = i; s = i + 172 | 0; t = i + 156 | 0; v = i + 152 | 0; w = i + 148 | 0; x = i + 144 | 0; y = i + 128 | 0; z = a + 8 | 0; Ah(z, c, e, g); e = f[a + 48 >> 2] | 0; A = f[a + 52 >> 2] | 0; B = l; C = B + 48 | 0; do { f[B >> 2] = 0; B = B + 4 | 0 } while ((B | 0) < (C | 0)); if (!g) { D = 0; E = 0 } else { oi(l, g); D = f[l + 12 >> 2] | 0; E = f[l + 16 >> 2] | 0 } B = l + 16 | 0; C = E - D >> 2; F = D; D = E; if (C >>> 0 >= g >>> 0) { if (C >>> 0 > g >>> 0 ? (E = F + (g << 2) | 0, (E | 0) != (D | 0)) : 0) f[B >> 2] = D + (~((D + -4 - E | 0) >>> 2) << 2) } else oi(l + 12 | 0, g - C | 0); C = l + 24 | 0; E = l + 28 | 0; D = f[E >> 2] | 0; B = f[C >> 2] | 0; F = D - B >> 2; G = B; B = D; if (F >>> 0 >= g >>> 0) { if (F >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[E >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(C, g - F | 0); F = l + 36 | 0; C = l + 40 | 0; D = f[C >> 2] | 0; B = f[F >> 2] | 0; E = D - B >> 2; G = B; B = D; if (E >>> 0 >= g >>> 0) { if (E >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[C >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(F, g - E | 0); f[m >> 2] = 0; E = m + 4 | 0; f[E >> 2] = 0; f[m + 8 >> 2] = 0; F = (g | 0) == 0; do if (!F) if (g >>> 0 > 1073741823) mq(m); else { D = g << 2; B = dn(D) | 0; f[m >> 2] = B; C = B + (g << 2) | 0; f[m + 8 >> 2] = C; hj(B | 0, 0, D | 0) | 0; f[E >> 2] = C; break } while (0); C = a + 152 | 0; D = a + 156 | 0; B = f[D >> 2] | 0; G = f[C >> 2] | 0; H = B - G >> 2; L = G; G = B; if (H >>> 0 >= g >>> 0) { if (H >>> 0 > g >>> 0 ? (B = L + (g << 2) | 0, (B | 0) != (G | 0)) : 0) f[D >> 2] = G + (~((G + -4 - B | 0) >>> 2) << 2) } else oi(C, g - H | 0); f[o >> 2] = 0; f[o + 4 >> 2] = 0; f[o + 8 >> 2] = 0; f[o + 12 >> 2] = 0; f[o + 16 >> 2] = 0; f[o + 20 >> 2] = 0; f[o + 24 >> 2] = 0; f[o + 28 >> 2] = 0; f[p >> 2] = 0; f[p + 4 >> 2] = 0; f[p + 8 >> 2] = 0; f[p + 12 >> 2] = 0; f[p + 16 >> 2] = 0; f[p + 20 >> 2] = 0; f[p + 24 >> 2] = 0; f[p + 28 >> 2] = 0; f[q >> 2] = 0; H = q + 4 | 0; f[H >> 2] = 0; f[q + 8 >> 2] = 0; if (F) { M = 0; N = 0; O = 0; P = 0 } else { F = g << 2; B = dn(F) | 0; f[q >> 2] = B; G = B + (g << 2) | 0; f[q + 8 >> 2] = G; hj(B | 0, 0, F | 0) | 0; f[H >> 2] = G; M = B; N = G; O = G; P = B } B = a + 56 | 0; G = f[B >> 2] | 0; F = f[G + 4 >> 2] | 0; D = f[G >> 2] | 0; L = F - D | 0; a: do if ((L | 0) > 4) { Q = L >>> 2; R = e + 12 | 0; S = (g | 0) > 0; T = r + 4 | 0; U = r + 8 | 0; V = r + 12 | 0; Z = a + 152 | 0; _ = a + 112 | 0; $ = r + 16 | 0; aa = r + 28 | 0; ba = a + 16 | 0; ca = a + 32 | 0; da = a + 12 | 0; ea = a + 28 | 0; fa = a + 20 | 0; ga = a + 24 | 0; ha = r + 28 | 0; ia = r + 16 | 0; ja = r + 20 | 0; ka = r + 32 | 0; la = n + 1 | 0; ma = g << 2; na = (g | 0) == 1; oa = Q + -1 | 0; if (F - D >> 2 >>> 0 > oa >>> 0) { pa = Q; qa = oa; ra = D; sa = M; ta = P; ua = O; va = M; wa = N; xa = M; ya = N } else { za = G; mq(za) } b: while (1) { oa = f[ra + (qa << 2) >> 2] | 0; Q = (((oa >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + oa | 0; Aa = (oa | 0) == -1 | (Q | 0) == -1; Ba = 1; Ca = 0; Da = oa; c: while (1) { Ea = Ba ^ 1; Fa = Ca; Ga = Da; while (1) { if ((Ga | 0) == -1) { Ha = Fa; break c } Ia = f[l + (Fa * 12 | 0) >> 2] | 0; Ja = f[R >> 2] | 0; Ka = f[Ja + (Ga << 2) >> 2] | 0; if ((Ka | 0) != -1) { La = f[e >> 2] | 0; Ma = f[A >> 2] | 0; Na = f[Ma + (f[La + (Ka << 2) >> 2] << 2) >> 2] | 0; Oa = Ka + 1 | 0; Pa = ((Oa >>> 0) % 3 | 0 | 0) == 0 ? Ka + -2 | 0 : Oa; if ((Pa | 0) == -1) Qa = -1; else Qa = f[La + (Pa << 2) >> 2] | 0; Pa = f[Ma + (Qa << 2) >> 2] | 0; Oa = (((Ka >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ka | 0; if ((Oa | 0) == -1) Ra = -1; else Ra = f[La + (Oa << 2) >> 2] | 0; Oa = f[Ma + (Ra << 2) >> 2] | 0; if ((Na | 0) < (qa | 0) & (Pa | 0) < (qa | 0) & (Oa | 0) < (qa | 0)) { Ma = X(Na, g) | 0; Na = X(Pa, g) | 0; Pa = X(Oa, g) | 0; if (S) { Oa = 0; do { f[Ia + (Oa << 2) >> 2] = (f[c + (Oa + Pa << 2) >> 2] | 0) + (f[c + (Oa + Na << 2) >> 2] | 0) - (f[c + (Oa + Ma << 2) >> 2] | 0); Oa = Oa + 1 | 0 } while ((Oa | 0) != (g | 0)) } Oa = Fa + 1 | 0; if ((Oa | 0) == 4) { Ha = 4; break c } else Sa = Oa } else Sa = Fa } else Sa = Fa; do if (Ba) { Oa = Ga + 1 | 0; Ma = ((Oa >>> 0) % 3 | 0 | 0) == 0 ? Ga + -2 | 0 : Oa; if ((Ma | 0) != -1 ? (Oa = f[Ja + (Ma << 2) >> 2] | 0, Ma = Oa + 1 | 0, (Oa | 0) != -1) : 0) Ta = ((Ma >>> 0) % 3 | 0 | 0) == 0 ? Oa + -2 | 0 : Ma; else Ta = -1 } else { Ma = (((Ga >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ga | 0; if ((Ma | 0) != -1 ? (Oa = f[Ja + (Ma << 2) >> 2] | 0, (Oa | 0) != -1) : 0) if (!((Oa >>> 0) % 3 | 0)) { Ta = Oa + 2 | 0; break } else { Ta = Oa + -1 | 0; break } else Ta = -1 } while (0); if ((Ta | 0) == (oa | 0)) { Ha = Sa; break c } if ((Ta | 0) != -1 | Ea) { Fa = Sa; Ga = Ta } else break } if (Aa) { Ba = 0; Ca = Sa; Da = -1; continue } Ga = f[Ja + (Q << 2) >> 2] | 0; if ((Ga | 0) == -1) { Ba = 0; Ca = Sa; Da = -1; continue } if (!((Ga >>> 0) % 3 | 0)) { Ba = 0; Ca = Sa; Da = Ga + 2 | 0; continue } else { Ba = 0; Ca = Sa; Da = Ga + -1 | 0; continue } } Da = X(qa, g) | 0; f[r >> 2] = 0; f[T >> 2] = 0; b[U >> 0] = 0; f[V >> 2] = 0; f[V + 4 >> 2] = 0; f[V + 8 >> 2] = 0; f[V + 12 >> 2] = 0; f[V + 16 >> 2] = 0; f[V + 20 >> 2] = 0; f[V + 24 >> 2] = 0; Ca = c + ((X(pa + -2 | 0, g) | 0) << 2) | 0; Ba = c + (Da << 2) | 0; Q = f[Z >> 2] | 0; if (S) { Aa = 0; oa = 0; while (1) { Ga = (f[Ca + (Aa << 2) >> 2] | 0) - (f[Ba + (Aa << 2) >> 2] | 0) | 0; Fa = ((Ga | 0) > -1 ? Ga : 0 - Ga | 0) + oa | 0; f[sa + (Aa << 2) >> 2] = Ga; f[Q + (Aa << 2) >> 2] = Ga << 1 ^ Ga >> 31; Aa = Aa + 1 | 0; if ((Aa | 0) == (g | 0)) { Ua = Fa; break } else oa = Fa } } else Ua = 0; ho(j, _, Q, g); oa = Tk(j) | 0; Aa = I; Fa = om(j) | 0; Ga = Tn(Fa | 0, I | 0, oa | 0, Aa | 0) | 0; Aa = I; oa = (Ha | 0) > 0; if (oa) { Fa = Ha + -1 | 0; Ea = p + (Fa << 3) | 0; Oa = Ea; Ma = Tn(f[Oa >> 2] | 0, f[Oa + 4 >> 2] | 0, Ha | 0, ((Ha | 0) < 0) << 31 >> 31 | 0) | 0; Oa = I; Na = Ea; f[Na >> 2] = Ma; f[Na + 4 >> 2] = Oa; Va = +W(+(+jm(Ma, f[o + (Fa << 3) >> 2] | 0) * (+(Ma >>> 0) + 4294967296.0 * +(Oa | 0)))); Oa = Tn(Ga | 0, Aa | 0, ~~Va >>> 0 | 0, (+K(Va) >= 1.0 ? (Va > 0.0 ? ~~+Y(+J(Va / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Va - +(~~Va >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; Wa = Oa } else Wa = Ga; Ga = r; f[Ga >> 2] = Wa; f[Ga + 4 >> 2] = Ua; b[U >> 0] = 0; f[V >> 2] = 0; Mf($, Ca, Ca + (g << 2) | 0); f[s >> 2] = ta; f[t >> 2] = ua; f[k >> 2] = f[s >> 2]; f[j >> 2] = f[t >> 2]; tf(aa, k, j); if ((Ha | 0) < 1) { Xa = ya; Ya = xa; Za = wa; _a = va; $a = ua; ab = ta; bb = ta } else { Ga = n + Ha | 0; Oa = f[q >> 2] | 0; Aa = Ha + -1 | 0; Ma = o + (Aa << 3) | 0; Fa = p + (Aa << 3) | 0; Aa = Oa; Na = f[H >> 2] | 0; Ea = Ga + -1 | 0; Pa = (Ea | 0) == (n | 0); Ia = Ga + -2 | 0; La = la >>> 0 < Ia >>> 0; Ka = ~Ha; cb = Ha + 2 + ((Ka | 0) > -2 ? Ka : -2) | 0; Ka = Na; db = Ea >>> 0 > n >>> 0; eb = 0; fb = 1; while (1) { eb = eb + 1 | 0; hj(n | 0, 1, cb | 0) | 0; hj(n | 0, 0, eb | 0) | 0; d: while (1) { if (S) { hj(f[m >> 2] | 0, 0, ma | 0) | 0; gb = f[m >> 2] | 0; hb = 0; ib = 0; while (1) { if (!(b[n + hb >> 0] | 0)) { jb = f[l + (hb * 12 | 0) >> 2] | 0; kb = 0; do { lb = gb + (kb << 2) | 0; f[lb >> 2] = (f[lb >> 2] | 0) + (f[jb + (kb << 2) >> 2] | 0); kb = kb + 1 | 0 } while ((kb | 0) != (g | 0)); mb = (1 << hb | ib & 255) & 255 } else mb = ib; hb = hb + 1 | 0; if ((hb | 0) == (Ha | 0)) { nb = mb; break } else ib = mb } } else { ib = 0; hb = 0; while (1) { if (!(b[n + ib >> 0] | 0)) ob = (1 << ib | hb & 255) & 255; else ob = hb; ib = ib + 1 | 0; if ((ib | 0) == (Ha | 0)) { nb = ob; break } else hb = ob } } hb = f[m >> 2] | 0; do if (S) { f[hb >> 2] = (f[hb >> 2] | 0) / (fb | 0) | 0; if (!na) { ib = 1; do { gb = hb + (ib << 2) | 0; f[gb >> 2] = (f[gb >> 2] | 0) / (fb | 0) | 0; ib = ib + 1 | 0 } while ((ib | 0) != (g | 0)); ib = f[Z >> 2] | 0; if (S) pb = ib; else { qb = 0; rb = ib; break } } else pb = f[Z >> 2] | 0; ib = 0; gb = 0; while (1) { kb = (f[hb + (ib << 2) >> 2] | 0) - (f[Ba + (ib << 2) >> 2] | 0) | 0; jb = ((kb | 0) > -1 ? kb : 0 - kb | 0) + gb | 0; f[Oa + (ib << 2) >> 2] = kb; f[pb + (ib << 2) >> 2] = kb << 1 ^ kb >> 31; ib = ib + 1 | 0; if ((ib | 0) == (g | 0)) { qb = jb; rb = pb; break } else gb = jb } } else { qb = 0; rb = f[Z >> 2] | 0 } while (0); ho(j, _, rb, g); hb = Tk(j) | 0; gb = I; ib = om(j) | 0; jb = Tn(ib | 0, I | 0, hb | 0, gb | 0) | 0; gb = I; if (oa) { hb = Ma; ib = Tn(f[hb >> 2] | 0, f[hb + 4 >> 2] | 0, fb | 0, 0) | 0; hb = Fa; kb = f[hb >> 2] | 0; lb = f[hb + 4 >> 2] | 0; Va = +W(+(+jm(kb, ib) * (+(kb >>> 0) + 4294967296.0 * +(lb | 0)))); lb = Tn(jb | 0, gb | 0, ~~Va >>> 0 | 0, (+K(Va) >= 1.0 ? (Va > 0.0 ? ~~+Y(+J(Va / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Va - +(~~Va >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; sb = lb } else sb = jb; jb = f[r >> 2] | 0; if (!((sb | 0) >= (jb | 0) ? !((sb | 0) <= (jb | 0) ? (qb | 0) < (f[T >> 2] | 0) : 0) : 0)) { jb = r; f[jb >> 2] = sb; f[jb + 4 >> 2] = qb; b[U >> 0] = nb; f[V >> 2] = fb; f[v >> 2] = f[m >> 2]; f[w >> 2] = f[E >> 2]; f[k >> 2] = f[v >> 2]; f[j >> 2] = f[w >> 2]; tf($, k, j); f[x >> 2] = Aa; f[y >> 2] = Na; f[k >> 2] = f[x >> 2]; f[j >> 2] = f[y >> 2]; tf(aa, k, j) } if (Pa) break; tb = b[Ea >> 0] | 0; jb = -1; lb = tb; while (1) { gb = jb + -1 | 0; ub = Ga + gb | 0; kb = lb; lb = b[ub >> 0] | 0; if ((lb & 255) < (kb & 255)) break; if ((ub | 0) == (n | 0)) { vb = 86; break d } else jb = gb } gb = Ga + jb | 0; if ((lb & 255) < (tb & 255)) { wb = Ea; xb = tb } else { kb = Ga; ib = Ea; while (1) { hb = ib + -1 | 0; if ((lb & 255) < (h[kb + -2 >> 0] | 0)) { wb = hb; xb = 1; break } else { yb = ib; ib = hb; kb = yb } } } b[ub >> 0] = xb; b[wb >> 0] = lb; if ((jb | 0) < -1) { zb = gb; Ab = Ea } else continue; while (1) { kb = b[zb >> 0] | 0; b[zb >> 0] = b[Ab >> 0] | 0; b[Ab >> 0] = kb; kb = zb + 1 | 0; ib = Ab + -1 | 0; if (kb >>> 0 < ib >>> 0) { zb = kb; Ab = ib } else continue d } } if (((vb | 0) == 86 ? (vb = 0, db) : 0) ? (gb = b[n >> 0] | 0, b[n >> 0] = tb, b[Ea >> 0] = gb, La) : 0) { gb = Ia; jb = la; do { lb = b[jb >> 0] | 0; b[jb >> 0] = b[gb >> 0] | 0; b[gb >> 0] = lb; jb = jb + 1 | 0; gb = gb + -1 | 0 } while (jb >>> 0 < gb >>> 0) } if ((fb | 0) >= (Ha | 0)) { Xa = Ka; Ya = Oa; Za = Ka; _a = Oa; $a = Na; ab = Aa; bb = Oa; break } else fb = fb + 1 | 0 } } if (oa) { fb = f[V >> 2] | 0; Oa = o + (Ha + -1 << 3) | 0; Aa = Oa; Na = Tn(f[Aa >> 2] | 0, f[Aa + 4 >> 2] | 0, fb | 0, ((fb | 0) < 0) << 31 >> 31 | 0) | 0; fb = Oa; f[fb >> 2] = Na; f[fb + 4 >> 2] = I } if (S) { fb = f[aa >> 2] | 0; Na = f[C >> 2] | 0; Oa = 0; do { Aa = f[fb + (Oa << 2) >> 2] | 0; f[Na + (Oa << 2) >> 2] = Aa << 1 ^ Aa >> 31; Oa = Oa + 1 | 0 } while ((Oa | 0) != (g | 0)); Bb = Na } else Bb = f[C >> 2] | 0; go(j, _, Bb, g); if (oa) { Na = Ha + -1 | 0; Cb = a + 60 + (Na * 12 | 0) | 0; Oa = a + 60 + (Na * 12 | 0) + 4 | 0; fb = a + 60 + (Na * 12 | 0) + 8 | 0; Na = 0; do { Aa = f[Oa >> 2] | 0; Ka = f[fb >> 2] | 0; Ia = (Aa | 0) == (Ka << 5 | 0); if (!(1 << Na & h[U >> 0])) { if (Ia) { if ((Aa + 1 | 0) < 0) { vb = 114; break b } La = Ka << 6; Ea = Aa + 32 & -32; hi(Cb, Aa >>> 0 < 1073741823 ? (La >>> 0 < Ea >>> 0 ? Ea : La) : 2147483647); Db = f[Oa >> 2] | 0 } else Db = Aa; f[Oa >> 2] = Db + 1; La = (f[Cb >> 2] | 0) + (Db >>> 5 << 2) | 0; f[La >> 2] = f[La >> 2] | 1 << (Db & 31) } else { if (Ia) { if ((Aa + 1 | 0) < 0) { vb = 119; break b } Ia = Ka << 6; Ka = Aa + 32 & -32; hi(Cb, Aa >>> 0 < 1073741823 ? (Ia >>> 0 < Ka >>> 0 ? Ka : Ia) : 2147483647); Eb = f[Oa >> 2] | 0 } else Eb = Aa; f[Oa >> 2] = Eb + 1; Aa = (f[Cb >> 2] | 0) + (Eb >>> 5 << 2) | 0; f[Aa >> 2] = f[Aa >> 2] & ~(1 << (Eb & 31)) } Na = Na + 1 | 0 } while ((Na | 0) < (Ha | 0)) } Na = d + (Da << 2) | 0; Oa = f[z >> 2] | 0; if ((Oa | 0) > 0) { fb = 0; oa = f[$ >> 2] | 0; Aa = Oa; while (1) { if ((Aa | 0) > 0) { Oa = 0; do { Ia = f[oa + (Oa << 2) >> 2] | 0; Ka = f[ba >> 2] | 0; if ((Ia | 0) > (Ka | 0)) { La = f[ca >> 2] | 0; f[La + (Oa << 2) >> 2] = Ka; Fb = La } else { La = f[da >> 2] | 0; Ka = f[ca >> 2] | 0; f[Ka + (Oa << 2) >> 2] = (Ia | 0) < (La | 0) ? La : Ia; Fb = Ka } Oa = Oa + 1 | 0 } while ((Oa | 0) < (f[z >> 2] | 0)); Gb = Fb } else Gb = f[ca >> 2] | 0; Oa = (f[Ba + (fb << 2) >> 2] | 0) - (f[Gb + (fb << 2) >> 2] | 0) | 0; Ka = Na + (fb << 2) | 0; f[Ka >> 2] = Oa; do if ((Oa | 0) < (f[ea >> 2] | 0)) { Hb = (f[fa >> 2] | 0) + Oa | 0; vb = 109 } else { if ((Oa | 0) <= (f[ga >> 2] | 0)) break; Hb = Oa - (f[fa >> 2] | 0) | 0; vb = 109 } while (0); if ((vb | 0) == 109) { vb = 0; f[Ka >> 2] = Hb } fb = fb + 1 | 0; Aa = f[z >> 2] | 0; if ((fb | 0) >= (Aa | 0)) break; else oa = Gb } } oa = f[ha >> 2] | 0; if (oa | 0) { Aa = f[ka >> 2] | 0; if ((Aa | 0) != (oa | 0)) f[ka >> 2] = Aa + (~((Aa + -4 - oa | 0) >>> 2) << 2); br(oa) } oa = f[ia >> 2] | 0; if (oa | 0) { Aa = f[ja >> 2] | 0; if ((Aa | 0) != (oa | 0)) f[ja >> 2] = Aa + (~((Aa + -4 - oa | 0) >>> 2) << 2); br(oa) } if ((pa | 0) <= 2) { Ib = _a; Jb = Za; break a } oa = f[B >> 2] | 0; ra = f[oa >> 2] | 0; Aa = qa + -1 | 0; if ((f[oa + 4 >> 2] | 0) - ra >> 2 >>> 0 <= Aa >>> 0) { za = oa; vb = 18; break } else { oa = qa; qa = Aa; sa = bb; ta = ab; ua = $a; va = _a; wa = Za; xa = Ya; ya = Xa; pa = oa } } if ((vb | 0) == 18) mq(za); else if ((vb | 0) == 114) mq(Cb); else if ((vb | 0) == 119) mq(Cb) } else { Ib = M; Jb = N } while (0); N = f[l >> 2] | 0; if ((g | 0) > 0 ? (f[N >> 2] = 0, (g | 0) != 1) : 0) { M = 1; do { f[N + (M << 2) >> 2] = 0; M = M + 1 | 0 } while ((M | 0) != (g | 0)) } g = f[z >> 2] | 0; if ((g | 0) > 0) { M = a + 16 | 0; Cb = a + 32 | 0; za = a + 12 | 0; pa = a + 28 | 0; Xa = a + 20 | 0; ya = a + 24 | 0; a = 0; Ya = N; N = g; while (1) { if ((N | 0) > 0) { g = 0; do { xa = f[Ya + (g << 2) >> 2] | 0; Za = f[M >> 2] | 0; if ((xa | 0) > (Za | 0)) { wa = f[Cb >> 2] | 0; f[wa + (g << 2) >> 2] = Za; Kb = wa } else { wa = f[za >> 2] | 0; Za = f[Cb >> 2] | 0; f[Za + (g << 2) >> 2] = (xa | 0) < (wa | 0) ? wa : xa; Kb = Za } g = g + 1 | 0 } while ((g | 0) < (f[z >> 2] | 0)); Lb = Kb } else Lb = f[Cb >> 2] | 0; g = (f[c + (a << 2) >> 2] | 0) - (f[Lb + (a << 2) >> 2] | 0) | 0; Za = d + (a << 2) | 0; f[Za >> 2] = g; if ((g | 0) >= (f[pa >> 2] | 0)) { if ((g | 0) > (f[ya >> 2] | 0)) { Mb = g - (f[Xa >> 2] | 0) | 0; vb = 145 } } else { Mb = (f[Xa >> 2] | 0) + g | 0; vb = 145 } if ((vb | 0) == 145) { vb = 0; f[Za >> 2] = Mb } a = a + 1 | 0; N = f[z >> 2] | 0; if ((a | 0) >= (N | 0)) break; else Ya = Lb } } if (Ib | 0) { if ((Jb | 0) != (Ib | 0)) f[H >> 2] = Jb + (~((Jb + -4 - Ib | 0) >>> 2) << 2); br(Ib) } Ib = f[m >> 2] | 0; if (Ib | 0) { m = f[E >> 2] | 0; if ((m | 0) != (Ib | 0)) f[E >> 2] = m + (~((m + -4 - Ib | 0) >>> 2) << 2); br(Ib) } Ib = f[l + 36 >> 2] | 0; if (Ib | 0) { m = l + 40 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Ib | 0)) f[m >> 2] = E + (~((E + -4 - Ib | 0) >>> 2) << 2); br(Ib) } Ib = f[l + 24 >> 2] | 0; if (Ib | 0) { E = l + 28 | 0; m = f[E >> 2] | 0; if ((m | 0) != (Ib | 0)) f[E >> 2] = m + (~((m + -4 - Ib | 0) >>> 2) << 2); br(Ib) } Ib = f[l + 12 >> 2] | 0; if (Ib | 0) { m = l + 16 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Ib | 0)) f[m >> 2] = E + (~((E + -4 - Ib | 0) >>> 2) << 2); br(Ib) } Ib = f[l >> 2] | 0; if (!Ib) { u = i; return 1 } E = l + 4 | 0; l = f[E >> 2] | 0; if ((l | 0) != (Ib | 0)) f[E >> 2] = l + (~((l + -4 - Ib | 0) >>> 2) << 2); br(Ib); u = i; return 1 } function cb(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; b = u; u = u + 16 | 0; c = b; d = b + 8 | 0; e = b + 4 | 0; f[d >> 2] = a; do if (a >>> 0 >= 212) { g = (a >>> 0) / 210 | 0; h = g * 210 | 0; f[e >> 2] = a - h; i = 0; j = g; g = (zl(6640, 6832, e, c) | 0) - 6640 >> 2; k = h; a: while (1) { l = (f[6640 + (g << 2) >> 2] | 0) + k | 0; h = 5; while (1) { if (h >>> 0 >= 47) { m = 211; n = i; o = 8; break } p = f[6448 + (h << 2) >> 2] | 0; q = (l >>> 0) / (p >>> 0) | 0; if (q >>> 0 < p >>> 0) { o = 106; break a } if ((l | 0) == (X(q, p) | 0)) { r = i; break } else h = h + 1 | 0 } b: do if ((o | 0) == 8) { c: while (1) { o = 0; h = (l >>> 0) / (m >>> 0) | 0; do if (h >>> 0 >= m >>> 0) if ((l | 0) != (X(h, m) | 0)) { p = m + 10 | 0; q = (l >>> 0) / (p >>> 0) | 0; if (q >>> 0 >= p >>> 0) if ((l | 0) != (X(q, p) | 0)) { q = m + 12 | 0; s = (l >>> 0) / (q >>> 0) | 0; if (s >>> 0 >= q >>> 0) if ((l | 0) != (X(s, q) | 0)) { s = m + 16 | 0; t = (l >>> 0) / (s >>> 0) | 0; if (t >>> 0 >= s >>> 0) if ((l | 0) != (X(t, s) | 0)) { t = m + 18 | 0; v = (l >>> 0) / (t >>> 0) | 0; if (v >>> 0 >= t >>> 0) if ((l | 0) != (X(v, t) | 0)) { v = m + 22 | 0; w = (l >>> 0) / (v >>> 0) | 0; if (w >>> 0 >= v >>> 0) if ((l | 0) != (X(w, v) | 0)) { w = m + 28 | 0; x = (l >>> 0) / (w >>> 0) | 0; if (x >>> 0 >= w >>> 0) if ((l | 0) == (X(x, w) | 0)) { y = w; z = 9; A = n } else { x = m + 30 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 36 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 40 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 42 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 46 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 52 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 58 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 60 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 66 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 70 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 72 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 78 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 82 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 88 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 96 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 100 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 102 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 106 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 108 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 112 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 120 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 126 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 130 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 136 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 138 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 142 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 148 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 150 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 156 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 162 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 166 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 168 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 172 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 178 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 180 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 186 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 190 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 192 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 196 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 198 | 0; B = (l >>> 0) / (x >>> 0) | 0; if (B >>> 0 < x >>> 0) { y = x; z = 1; A = l; break } if ((l | 0) == (X(B, x) | 0)) { y = x; z = 9; A = n; break } x = m + 208 | 0; B = (l >>> 0) / (x >>> 0) | 0; C = B >>> 0 < x >>> 0; D = (l | 0) == (X(B, x) | 0); y = C | D ? x : m + 210 | 0; z = C ? 1 : D ? 9 : 0; A = C ? l : n } else { y = w; z = 1; A = l } } else { y = v; z = 9; A = n } else { y = v; z = 1; A = l } } else { y = t; z = 9; A = n } else { y = t; z = 1; A = l } } else { y = s; z = 9; A = n } else { y = s; z = 1; A = l } } else { y = q; z = 9; A = n } else { y = q; z = 1; A = l } } else { y = p; z = 9; A = n } else { y = p; z = 1; A = l } } else { y = m; z = 9; A = n } else { y = m; z = 1; A = l } while (0); switch (z & 15) { case 9: { r = A; break b; break } case 0: { m = y; n = A; o = 8; break } default: break c } } if (!z) r = A; else { o = 107; break a } } while (0); h = g + 1 | 0; p = (h | 0) == 48; q = j + (p & 1) | 0; i = r; j = q; g = p ? 0 : h; k = q * 210 | 0 } if ((o | 0) == 106) { f[d >> 2] = l; E = l; break } else if ((o | 0) == 107) { f[d >> 2] = l; E = A; break } } else { k = zl(6448, 6640, d, c) | 0; E = f[k >> 2] | 0 } while (0); u = b; return E | 0 } function db(a, c, d, e, g, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0.0, Ua = 0, Va = 0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0, kb = 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = 0, yb = 0, zb = 0, Ab = 0, Bb = 0, Cb = 0; i = u; u = u + 256 | 0; e = i + 104 | 0; j = i + 240 | 0; k = i + 224 | 0; l = i + 160 | 0; m = i + 140 | 0; n = i + 248 | 0; o = i + 72 | 0; p = i + 40 | 0; q = i + 128 | 0; r = i; s = i + 232 | 0; t = i + 220 | 0; v = i + 216 | 0; w = i + 212 | 0; x = i + 208 | 0; y = i + 152 | 0; z = f[a + 28 >> 2] | 0; A = f[a + 32 >> 2] | 0; B = l; C = B + 48 | 0; do { f[B >> 2] = 0; B = B + 4 | 0 } while ((B | 0) < (C | 0)); if (!g) { D = 0; E = 0 } else { oi(l, g); D = f[l + 12 >> 2] | 0; E = f[l + 16 >> 2] | 0 } B = l + 16 | 0; C = E - D >> 2; F = D; D = E; if (C >>> 0 >= g >>> 0) { if (C >>> 0 > g >>> 0 ? (E = F + (g << 2) | 0, (E | 0) != (D | 0)) : 0) f[B >> 2] = D + (~((D + -4 - E | 0) >>> 2) << 2) } else oi(l + 12 | 0, g - C | 0); C = l + 24 | 0; E = l + 28 | 0; D = f[E >> 2] | 0; B = f[C >> 2] | 0; F = D - B >> 2; G = B; B = D; if (F >>> 0 >= g >>> 0) { if (F >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[E >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(C, g - F | 0); F = l + 36 | 0; C = l + 40 | 0; D = f[C >> 2] | 0; B = f[F >> 2] | 0; E = D - B >> 2; G = B; B = D; if (E >>> 0 >= g >>> 0) { if (E >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[C >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(F, g - E | 0); f[m >> 2] = 0; E = m + 4 | 0; f[E >> 2] = 0; f[m + 8 >> 2] = 0; F = (g | 0) == 0; do if (!F) if (g >>> 0 > 1073741823) mq(m); else { D = g << 2; B = dn(D) | 0; f[m >> 2] = B; C = B + (g << 2) | 0; f[m + 8 >> 2] = C; hj(B | 0, 0, D | 0) | 0; f[E >> 2] = C; break } while (0); C = a + 136 | 0; D = a + 140 | 0; B = f[D >> 2] | 0; G = f[C >> 2] | 0; H = B - G >> 2; L = G; G = B; if (H >>> 0 >= g >>> 0) { if (H >>> 0 > g >>> 0 ? (B = L + (g << 2) | 0, (B | 0) != (G | 0)) : 0) f[D >> 2] = G + (~((G + -4 - B | 0) >>> 2) << 2) } else oi(C, g - H | 0); f[o >> 2] = 0; f[o + 4 >> 2] = 0; f[o + 8 >> 2] = 0; f[o + 12 >> 2] = 0; f[o + 16 >> 2] = 0; f[o + 20 >> 2] = 0; f[o + 24 >> 2] = 0; f[o + 28 >> 2] = 0; f[p >> 2] = 0; f[p + 4 >> 2] = 0; f[p + 8 >> 2] = 0; f[p + 12 >> 2] = 0; f[p + 16 >> 2] = 0; f[p + 20 >> 2] = 0; f[p + 24 >> 2] = 0; f[p + 28 >> 2] = 0; f[q >> 2] = 0; H = q + 4 | 0; f[H >> 2] = 0; f[q + 8 >> 2] = 0; if (F) { M = 0; N = 0; O = 0; P = 0 } else { F = g << 2; B = dn(F) | 0; f[q >> 2] = B; G = B + (g << 2) | 0; f[q + 8 >> 2] = G; hj(B | 0, 0, F | 0) | 0; f[H >> 2] = G; M = B; N = G; O = G; P = B } B = a + 36 | 0; G = f[B >> 2] | 0; F = f[G + 4 >> 2] | 0; D = f[G >> 2] | 0; L = F - D | 0; a: do if ((L | 0) > 4) { Q = L >>> 2; R = z + 64 | 0; S = z + 28 | 0; T = (g | 0) > 0; U = r + 4 | 0; V = r + 8 | 0; Z = r + 12 | 0; _ = a + 136 | 0; $ = a + 96 | 0; aa = r + 16 | 0; ba = r + 28 | 0; ca = a + 8 | 0; da = j + 4 | 0; ea = k + 4 | 0; fa = e + 4 | 0; ga = r + 28 | 0; ha = r + 16 | 0; ia = r + 20 | 0; ja = r + 32 | 0; ka = n + 1 | 0; la = g << 2; ma = (g | 0) == 1; na = Q + -1 | 0; if (F - D >> 2 >>> 0 > na >>> 0) { oa = Q; pa = na; qa = D; ra = M; sa = P; ta = O; ua = M; va = N; wa = M; xa = N } else { ya = G; mq(ya) } b: while (1) { na = f[qa + (pa << 2) >> 2] | 0; Q = (((na >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + na | 0; za = Q >>> 5; Aa = 1 << (Q & 31); Ba = (na | 0) == -1 | (Q | 0) == -1; Ca = 1; Da = 0; Ea = na; c: while (1) { Fa = Ca ^ 1; Ga = Da; Ha = Ea; while (1) { if ((Ha | 0) == -1) { Ia = Ga; break c } Ja = f[l + (Ga * 12 | 0) >> 2] | 0; if (((f[(f[z >> 2] | 0) + (Ha >>> 5 << 2) >> 2] & 1 << (Ha & 31) | 0) == 0 ? (Ka = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ha << 2) >> 2] | 0, (Ka | 0) != -1) : 0) ? (La = f[S >> 2] | 0, Ma = f[A >> 2] | 0, Na = f[Ma + (f[La + (Ka << 2) >> 2] << 2) >> 2] | 0, Oa = Ka + 1 | 0, Pa = f[Ma + (f[La + ((((Oa >>> 0) % 3 | 0 | 0) == 0 ? Ka + -2 | 0 : Oa) << 2) >> 2] << 2) >> 2] | 0, Oa = f[Ma + (f[La + ((((Ka >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ka << 2) >> 2] << 2) >> 2] | 0, (Na | 0) < (pa | 0) & (Pa | 0) < (pa | 0) & (Oa | 0) < (pa | 0)) : 0) { Ka = X(Na, g) | 0; Na = X(Pa, g) | 0; Pa = X(Oa, g) | 0; if (T) { Oa = 0; do { f[Ja + (Oa << 2) >> 2] = (f[c + (Oa + Pa << 2) >> 2] | 0) + (f[c + (Oa + Na << 2) >> 2] | 0) - (f[c + (Oa + Ka << 2) >> 2] | 0); Oa = Oa + 1 | 0 } while ((Oa | 0) != (g | 0)) } Oa = Ga + 1 | 0; if ((Oa | 0) == 4) { Ia = 4; break c } else Qa = Oa } else Qa = Ga; do if (Ca) { Oa = Ha + 1 | 0; Ka = ((Oa >>> 0) % 3 | 0 | 0) == 0 ? Ha + -2 | 0 : Oa; if (((Ka | 0) != -1 ? (f[(f[z >> 2] | 0) + (Ka >>> 5 << 2) >> 2] & 1 << (Ka & 31) | 0) == 0 : 0) ? (Oa = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ka << 2) >> 2] | 0, Ka = Oa + 1 | 0, (Oa | 0) != -1) : 0) Ra = ((Ka >>> 0) % 3 | 0 | 0) == 0 ? Oa + -2 | 0 : Ka; else Ra = -1 } else { Ka = (((Ha >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ha | 0; if (((Ka | 0) != -1 ? (f[(f[z >> 2] | 0) + (Ka >>> 5 << 2) >> 2] & 1 << (Ka & 31) | 0) == 0 : 0) ? (Oa = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Ka << 2) >> 2] | 0, (Oa | 0) != -1) : 0) if (!((Oa >>> 0) % 3 | 0)) { Ra = Oa + 2 | 0; break } else { Ra = Oa + -1 | 0; break } else Ra = -1 } while (0); if ((Ra | 0) == (na | 0)) { Ia = Qa; break c } if ((Ra | 0) != -1 | Fa) { Ga = Qa; Ha = Ra } else break } if (Ba) { Ca = 0; Da = Qa; Ea = -1; continue } if (f[(f[z >> 2] | 0) + (za << 2) >> 2] & Aa | 0) { Ca = 0; Da = Qa; Ea = -1; continue } Ha = f[(f[(f[R >> 2] | 0) + 12 >> 2] | 0) + (Q << 2) >> 2] | 0; if ((Ha | 0) == -1) { Ca = 0; Da = Qa; Ea = -1; continue } if (!((Ha >>> 0) % 3 | 0)) { Ca = 0; Da = Qa; Ea = Ha + 2 | 0; continue } else { Ca = 0; Da = Qa; Ea = Ha + -1 | 0; continue } } Ea = X(pa, g) | 0; f[r >> 2] = 0; f[U >> 2] = 0; b[V >> 0] = 0; f[Z >> 2] = 0; f[Z + 4 >> 2] = 0; f[Z + 8 >> 2] = 0; f[Z + 12 >> 2] = 0; f[Z + 16 >> 2] = 0; f[Z + 20 >> 2] = 0; f[Z + 24 >> 2] = 0; Da = c + ((X(oa + -2 | 0, g) | 0) << 2) | 0; Ca = c + (Ea << 2) | 0; Q = f[_ >> 2] | 0; if (T) { Aa = 0; za = 0; while (1) { Ba = (f[Da + (Aa << 2) >> 2] | 0) - (f[Ca + (Aa << 2) >> 2] | 0) | 0; na = ((Ba | 0) > -1 ? Ba : 0 - Ba | 0) + za | 0; f[ra + (Aa << 2) >> 2] = Ba; f[Q + (Aa << 2) >> 2] = Ba << 1 ^ Ba >> 31; Aa = Aa + 1 | 0; if ((Aa | 0) == (g | 0)) { Sa = na; break } else za = na } } else Sa = 0; ho(e, $, Q, g); za = Tk(e) | 0; Aa = I; na = om(e) | 0; Ba = Tn(na | 0, I | 0, za | 0, Aa | 0) | 0; Aa = I; za = (Ia | 0) > 0; if (za) { na = Ia + -1 | 0; Ha = p + (na << 3) | 0; Ga = Ha; Fa = Tn(f[Ga >> 2] | 0, f[Ga + 4 >> 2] | 0, Ia | 0, ((Ia | 0) < 0) << 31 >> 31 | 0) | 0; Ga = I; Oa = Ha; f[Oa >> 2] = Fa; f[Oa + 4 >> 2] = Ga; Ta = +W(+(+jm(Fa, f[o + (na << 3) >> 2] | 0) * (+(Fa >>> 0) + 4294967296.0 * +(Ga | 0)))); Ga = Tn(Ba | 0, Aa | 0, ~~Ta >>> 0 | 0, (+K(Ta) >= 1.0 ? (Ta > 0.0 ? ~~+Y(+J(Ta / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Ta - +(~~Ta >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; Ua = Ga } else Ua = Ba; Ba = r; f[Ba >> 2] = Ua; f[Ba + 4 >> 2] = Sa; b[V >> 0] = 0; f[Z >> 2] = 0; Mf(aa, Da, Da + (g << 2) | 0); f[s >> 2] = sa; f[t >> 2] = ta; f[j >> 2] = f[s >> 2]; f[e >> 2] = f[t >> 2]; tf(ba, j, e); if ((Ia | 0) < 1) { Va = xa; Wa = wa; Xa = va; Ya = ua; Za = ta; _a = sa; $a = sa } else { Ba = n + Ia | 0; Ga = f[q >> 2] | 0; Aa = Ia + -1 | 0; Fa = o + (Aa << 3) | 0; na = p + (Aa << 3) | 0; Aa = Ga; Oa = f[H >> 2] | 0; Ha = Ba + -1 | 0; Ka = (Ha | 0) == (n | 0); Na = Ba + -2 | 0; Pa = ka >>> 0 < Na >>> 0; Ja = ~Ia; La = Ia + 2 + ((Ja | 0) > -2 ? Ja : -2) | 0; Ja = Oa; Ma = Ha >>> 0 > n >>> 0; ab = 0; bb = 1; while (1) { ab = ab + 1 | 0; hj(n | 0, 1, La | 0) | 0; hj(n | 0, 0, ab | 0) | 0; d: while (1) { if (T) { hj(f[m >> 2] | 0, 0, la | 0) | 0; cb = f[m >> 2] | 0; db = 0; eb = 0; while (1) { if (!(b[n + db >> 0] | 0)) { fb = f[l + (db * 12 | 0) >> 2] | 0; gb = 0; do { hb = cb + (gb << 2) | 0; f[hb >> 2] = (f[hb >> 2] | 0) + (f[fb + (gb << 2) >> 2] | 0); gb = gb + 1 | 0 } while ((gb | 0) != (g | 0)); ib = (1 << db | eb & 255) & 255 } else ib = eb; db = db + 1 | 0; if ((db | 0) == (Ia | 0)) { jb = ib; break } else eb = ib } } else { eb = 0; db = 0; while (1) { if (!(b[n + eb >> 0] | 0)) kb = (1 << eb | db & 255) & 255; else kb = db; eb = eb + 1 | 0; if ((eb | 0) == (Ia | 0)) { jb = kb; break } else db = kb } } db = f[m >> 2] | 0; do if (T) { f[db >> 2] = (f[db >> 2] | 0) / (bb | 0) | 0; if (!ma) { eb = 1; do { cb = db + (eb << 2) | 0; f[cb >> 2] = (f[cb >> 2] | 0) / (bb | 0) | 0; eb = eb + 1 | 0 } while ((eb | 0) != (g | 0)); eb = f[_ >> 2] | 0; if (T) lb = eb; else { mb = 0; nb = eb; break } } else lb = f[_ >> 2] | 0; eb = 0; cb = 0; while (1) { gb = (f[db + (eb << 2) >> 2] | 0) - (f[Ca + (eb << 2) >> 2] | 0) | 0; fb = ((gb | 0) > -1 ? gb : 0 - gb | 0) + cb | 0; f[Ga + (eb << 2) >> 2] = gb; f[lb + (eb << 2) >> 2] = gb << 1 ^ gb >> 31; eb = eb + 1 | 0; if ((eb | 0) == (g | 0)) { mb = fb; nb = lb; break } else cb = fb } } else { mb = 0; nb = f[_ >> 2] | 0 } while (0); ho(e, $, nb, g); db = Tk(e) | 0; cb = I; eb = om(e) | 0; fb = Tn(eb | 0, I | 0, db | 0, cb | 0) | 0; cb = I; if (za) { db = Fa; eb = Tn(f[db >> 2] | 0, f[db + 4 >> 2] | 0, bb | 0, 0) | 0; db = na; gb = f[db >> 2] | 0; hb = f[db + 4 >> 2] | 0; Ta = +W(+(+jm(gb, eb) * (+(gb >>> 0) + 4294967296.0 * +(hb | 0)))); hb = Tn(fb | 0, cb | 0, ~~Ta >>> 0 | 0, (+K(Ta) >= 1.0 ? (Ta > 0.0 ? ~~+Y(+J(Ta / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Ta - +(~~Ta >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; ob = hb } else ob = fb; fb = f[r >> 2] | 0; if (!((ob | 0) >= (fb | 0) ? !((ob | 0) <= (fb | 0) ? (mb | 0) < (f[U >> 2] | 0) : 0) : 0)) { fb = r; f[fb >> 2] = ob; f[fb + 4 >> 2] = mb; b[V >> 0] = jb; f[Z >> 2] = bb; f[v >> 2] = f[m >> 2]; f[w >> 2] = f[E >> 2]; f[j >> 2] = f[v >> 2]; f[e >> 2] = f[w >> 2]; tf(aa, j, e); f[x >> 2] = Aa; f[y >> 2] = Oa; f[j >> 2] = f[x >> 2]; f[e >> 2] = f[y >> 2]; tf(ba, j, e) } if (Ka) break; pb = b[Ha >> 0] | 0; fb = -1; hb = pb; while (1) { cb = fb + -1 | 0; qb = Ba + cb | 0; gb = hb; hb = b[qb >> 0] | 0; if ((hb & 255) < (gb & 255)) break; if ((qb | 0) == (n | 0)) { rb = 86; break d } else fb = cb } cb = Ba + fb | 0; if ((hb & 255) < (pb & 255)) { sb = Ha; tb = pb } else { gb = Ba; eb = Ha; while (1) { db = eb + -1 | 0; if ((hb & 255) < (h[gb + -2 >> 0] | 0)) { sb = db; tb = 1; break } else { ub = eb; eb = db; gb = ub } } } b[qb >> 0] = tb; b[sb >> 0] = hb; if ((fb | 0) < -1) { vb = cb; wb = Ha } else continue; while (1) { gb = b[vb >> 0] | 0; b[vb >> 0] = b[wb >> 0] | 0; b[wb >> 0] = gb; gb = vb + 1 | 0; eb = wb + -1 | 0; if (gb >>> 0 < eb >>> 0) { vb = gb; wb = eb } else continue d } } if (((rb | 0) == 86 ? (rb = 0, Ma) : 0) ? (cb = b[n >> 0] | 0, b[n >> 0] = pb, b[Ha >> 0] = cb, Pa) : 0) { cb = Na; fb = ka; do { hb = b[fb >> 0] | 0; b[fb >> 0] = b[cb >> 0] | 0; b[cb >> 0] = hb; fb = fb + 1 | 0; cb = cb + -1 | 0 } while (fb >>> 0 < cb >>> 0) } if ((bb | 0) >= (Ia | 0)) { Va = Ja; Wa = Ga; Xa = Ja; Ya = Ga; Za = Oa; _a = Aa; $a = Ga; break } else bb = bb + 1 | 0 } } if (za) { bb = f[Z >> 2] | 0; Ga = o + (Ia + -1 << 3) | 0; Aa = Ga; Oa = Tn(f[Aa >> 2] | 0, f[Aa + 4 >> 2] | 0, bb | 0, ((bb | 0) < 0) << 31 >> 31 | 0) | 0; bb = Ga; f[bb >> 2] = Oa; f[bb + 4 >> 2] = I } if (T) { bb = f[ba >> 2] | 0; Oa = f[C >> 2] | 0; Ga = 0; do { Aa = f[bb + (Ga << 2) >> 2] | 0; f[Oa + (Ga << 2) >> 2] = Aa << 1 ^ Aa >> 31; Ga = Ga + 1 | 0 } while ((Ga | 0) != (g | 0)); xb = Oa } else xb = f[C >> 2] | 0; go(e, $, xb, g); if (za) { Oa = Ia + -1 | 0; yb = a + 40 + (Oa * 12 | 0) | 0; Ga = a + 40 + (Oa * 12 | 0) + 4 | 0; bb = a + 40 + (Oa * 12 | 0) + 8 | 0; Oa = 0; do { Aa = f[Ga >> 2] | 0; Ja = f[bb >> 2] | 0; Na = (Aa | 0) == (Ja << 5 | 0); if (!(1 << Oa & h[V >> 0])) { if (Na) { if ((Aa + 1 | 0) < 0) { rb = 101; break b } Pa = Ja << 6; Ha = Aa + 32 & -32; hi(yb, Aa >>> 0 < 1073741823 ? (Pa >>> 0 < Ha >>> 0 ? Ha : Pa) : 2147483647); zb = f[Ga >> 2] | 0 } else zb = Aa; f[Ga >> 2] = zb + 1; Pa = (f[yb >> 2] | 0) + (zb >>> 5 << 2) | 0; f[Pa >> 2] = f[Pa >> 2] | 1 << (zb & 31) } else { if (Na) { if ((Aa + 1 | 0) < 0) { rb = 106; break b } Na = Ja << 6; Ja = Aa + 32 & -32; hi(yb, Aa >>> 0 < 1073741823 ? (Na >>> 0 < Ja >>> 0 ? Ja : Na) : 2147483647); Ab = f[Ga >> 2] | 0 } else Ab = Aa; f[Ga >> 2] = Ab + 1; Aa = (f[yb >> 2] | 0) + (Ab >>> 5 << 2) | 0; f[Aa >> 2] = f[Aa >> 2] & ~(1 << (Ab & 31)) } Oa = Oa + 1 | 0 } while ((Oa | 0) < (Ia | 0)) } Oa = f[aa >> 2] | 0; Ga = d + (Ea << 2) | 0; bb = f[Ca + 4 >> 2] | 0; za = f[Oa >> 2] | 0; Aa = f[Oa + 4 >> 2] | 0; f[j >> 2] = f[Ca >> 2]; f[da >> 2] = bb; f[k >> 2] = za; f[ea >> 2] = Aa; Dd(e, ca, j, k); f[Ga >> 2] = f[e >> 2]; f[Ga + 4 >> 2] = f[fa >> 2]; Ga = f[ga >> 2] | 0; if (Ga | 0) { Aa = f[ja >> 2] | 0; if ((Aa | 0) != (Ga | 0)) f[ja >> 2] = Aa + (~((Aa + -4 - Ga | 0) >>> 2) << 2); br(Ga) } Ga = f[ha >> 2] | 0; if (Ga | 0) { Aa = f[ia >> 2] | 0; if ((Aa | 0) != (Ga | 0)) f[ia >> 2] = Aa + (~((Aa + -4 - Ga | 0) >>> 2) << 2); br(Ga) } if ((oa | 0) <= 2) { Bb = Ya; Cb = Xa; break a } Ga = f[B >> 2] | 0; qa = f[Ga >> 2] | 0; Aa = pa + -1 | 0; if ((f[Ga + 4 >> 2] | 0) - qa >> 2 >>> 0 <= Aa >>> 0) { ya = Ga; rb = 18; break } else { Ga = pa; pa = Aa; ra = $a; sa = _a; ta = Za; ua = Ya; va = Xa; wa = Wa; xa = Va; oa = Ga } } if ((rb | 0) == 18) mq(ya); else if ((rb | 0) == 101) mq(yb); else if ((rb | 0) == 106) mq(yb) } else { Bb = M; Cb = N } while (0); if ((g | 0) > 0) hj(f[l >> 2] | 0, 0, g << 2 | 0) | 0; g = f[l >> 2] | 0; N = f[c + 4 >> 2] | 0; M = f[g >> 2] | 0; yb = f[g + 4 >> 2] | 0; f[j >> 2] = f[c >> 2]; f[j + 4 >> 2] = N; f[k >> 2] = M; f[k + 4 >> 2] = yb; Dd(e, a + 8 | 0, j, k); f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; if (Bb | 0) { if ((Cb | 0) != (Bb | 0)) f[H >> 2] = Cb + (~((Cb + -4 - Bb | 0) >>> 2) << 2); br(Bb) } Bb = f[m >> 2] | 0; if (Bb | 0) { m = f[E >> 2] | 0; if ((m | 0) != (Bb | 0)) f[E >> 2] = m + (~((m + -4 - Bb | 0) >>> 2) << 2); br(Bb) } Bb = f[l + 36 >> 2] | 0; if (Bb | 0) { m = l + 40 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Bb | 0)) f[m >> 2] = E + (~((E + -4 - Bb | 0) >>> 2) << 2); br(Bb) } Bb = f[l + 24 >> 2] | 0; if (Bb | 0) { E = l + 28 | 0; m = f[E >> 2] | 0; if ((m | 0) != (Bb | 0)) f[E >> 2] = m + (~((m + -4 - Bb | 0) >>> 2) << 2); br(Bb) } Bb = f[l + 12 >> 2] | 0; if (Bb | 0) { m = l + 16 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Bb | 0)) f[m >> 2] = E + (~((E + -4 - Bb | 0) >>> 2) << 2); br(Bb) } Bb = f[l >> 2] | 0; if (!Bb) { u = i; return 1 } E = l + 4 | 0; l = f[E >> 2] | 0; if ((l | 0) != (Bb | 0)) f[E >> 2] = l + (~((l + -4 - Bb | 0) >>> 2) << 2); br(Bb); u = i; return 1 } function eb(a, c, d, e, g, i) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0.0, Ua = 0, Va = 0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0, kb = 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = 0, yb = 0, zb = 0, Ab = 0, Bb = 0, Cb = 0, Db = 0, Eb = 0; i = u; u = u + 256 | 0; e = i + 104 | 0; j = i + 240 | 0; k = i + 224 | 0; l = i + 160 | 0; m = i + 140 | 0; n = i + 248 | 0; o = i + 72 | 0; p = i + 40 | 0; q = i + 128 | 0; r = i; s = i + 232 | 0; t = i + 220 | 0; v = i + 216 | 0; w = i + 212 | 0; x = i + 208 | 0; y = i + 152 | 0; z = f[a + 28 >> 2] | 0; A = f[a + 32 >> 2] | 0; B = l; C = B + 48 | 0; do { f[B >> 2] = 0; B = B + 4 | 0 } while ((B | 0) < (C | 0)); if (!g) { D = 0; E = 0 } else { oi(l, g); D = f[l + 12 >> 2] | 0; E = f[l + 16 >> 2] | 0 } B = l + 16 | 0; C = E - D >> 2; F = D; D = E; if (C >>> 0 >= g >>> 0) { if (C >>> 0 > g >>> 0 ? (E = F + (g << 2) | 0, (E | 0) != (D | 0)) : 0) f[B >> 2] = D + (~((D + -4 - E | 0) >>> 2) << 2) } else oi(l + 12 | 0, g - C | 0); C = l + 24 | 0; E = l + 28 | 0; D = f[E >> 2] | 0; B = f[C >> 2] | 0; F = D - B >> 2; G = B; B = D; if (F >>> 0 >= g >>> 0) { if (F >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[E >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(C, g - F | 0); F = l + 36 | 0; C = l + 40 | 0; D = f[C >> 2] | 0; B = f[F >> 2] | 0; E = D - B >> 2; G = B; B = D; if (E >>> 0 >= g >>> 0) { if (E >>> 0 > g >>> 0 ? (D = G + (g << 2) | 0, (D | 0) != (B | 0)) : 0) f[C >> 2] = B + (~((B + -4 - D | 0) >>> 2) << 2) } else oi(F, g - E | 0); f[m >> 2] = 0; E = m + 4 | 0; f[E >> 2] = 0; f[m + 8 >> 2] = 0; F = (g | 0) == 0; do if (!F) if (g >>> 0 > 1073741823) mq(m); else { D = g << 2; B = dn(D) | 0; f[m >> 2] = B; C = B + (g << 2) | 0; f[m + 8 >> 2] = C; hj(B | 0, 0, D | 0) | 0; f[E >> 2] = C; break } while (0); C = a + 136 | 0; D = a + 140 | 0; B = f[D >> 2] | 0; G = f[C >> 2] | 0; H = B - G >> 2; L = G; G = B; if (H >>> 0 >= g >>> 0) { if (H >>> 0 > g >>> 0 ? (B = L + (g << 2) | 0, (B | 0) != (G | 0)) : 0) f[D >> 2] = G + (~((G + -4 - B | 0) >>> 2) << 2) } else oi(C, g - H | 0); f[o >> 2] = 0; f[o + 4 >> 2] = 0; f[o + 8 >> 2] = 0; f[o + 12 >> 2] = 0; f[o + 16 >> 2] = 0; f[o + 20 >> 2] = 0; f[o + 24 >> 2] = 0; f[o + 28 >> 2] = 0; f[p >> 2] = 0; f[p + 4 >> 2] = 0; f[p + 8 >> 2] = 0; f[p + 12 >> 2] = 0; f[p + 16 >> 2] = 0; f[p + 20 >> 2] = 0; f[p + 24 >> 2] = 0; f[p + 28 >> 2] = 0; f[q >> 2] = 0; H = q + 4 | 0; f[H >> 2] = 0; f[q + 8 >> 2] = 0; if (F) { M = 0; N = 0; O = 0; P = 0 } else { F = g << 2; B = dn(F) | 0; f[q >> 2] = B; G = B + (g << 2) | 0; f[q + 8 >> 2] = G; hj(B | 0, 0, F | 0) | 0; f[H >> 2] = G; M = B; N = G; O = G; P = B } B = a + 36 | 0; G = f[B >> 2] | 0; F = f[G + 4 >> 2] | 0; D = f[G >> 2] | 0; L = F - D | 0; a: do if ((L | 0) > 4) { Q = L >>> 2; R = z + 12 | 0; S = (g | 0) > 0; T = r + 4 | 0; U = r + 8 | 0; V = r + 12 | 0; Z = a + 136 | 0; _ = a + 96 | 0; $ = r + 16 | 0; aa = r + 28 | 0; ba = a + 8 | 0; ca = j + 4 | 0; da = k + 4 | 0; ea = e + 4 | 0; fa = r + 28 | 0; ga = r + 16 | 0; ha = r + 20 | 0; ia = r + 32 | 0; ja = n + 1 | 0; ka = g << 2; la = (g | 0) == 1; ma = Q + -1 | 0; if (F - D >> 2 >>> 0 > ma >>> 0) { na = Q; oa = ma; pa = M; qa = P; ra = O; sa = M; ta = N; ua = M; va = N; wa = D } else { xa = G; mq(xa) } b: while (1) { ma = f[wa + (oa << 2) >> 2] | 0; Q = (((ma >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + ma | 0; ya = (ma | 0) == -1 | (Q | 0) == -1; za = 1; Aa = 0; Ba = ma; c: while (1) { Ca = za ^ 1; Da = Aa; Ea = Ba; while (1) { if ((Ea | 0) == -1) { Fa = Da; break c } Ga = f[l + (Da * 12 | 0) >> 2] | 0; Ha = f[R >> 2] | 0; Ia = f[Ha + (Ea << 2) >> 2] | 0; if ((Ia | 0) != -1) { Ja = f[z >> 2] | 0; Ka = f[A >> 2] | 0; La = f[Ka + (f[Ja + (Ia << 2) >> 2] << 2) >> 2] | 0; Ma = Ia + 1 | 0; Na = ((Ma >>> 0) % 3 | 0 | 0) == 0 ? Ia + -2 | 0 : Ma; if ((Na | 0) == -1) Oa = -1; else Oa = f[Ja + (Na << 2) >> 2] | 0; Na = f[Ka + (Oa << 2) >> 2] | 0; Ma = (((Ia >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ia | 0; if ((Ma | 0) == -1) Pa = -1; else Pa = f[Ja + (Ma << 2) >> 2] | 0; Ma = f[Ka + (Pa << 2) >> 2] | 0; if ((La | 0) < (oa | 0) & (Na | 0) < (oa | 0) & (Ma | 0) < (oa | 0)) { Ka = X(La, g) | 0; La = X(Na, g) | 0; Na = X(Ma, g) | 0; if (S) { Ma = 0; do { f[Ga + (Ma << 2) >> 2] = (f[c + (Ma + Na << 2) >> 2] | 0) + (f[c + (Ma + La << 2) >> 2] | 0) - (f[c + (Ma + Ka << 2) >> 2] | 0); Ma = Ma + 1 | 0 } while ((Ma | 0) != (g | 0)) } Ma = Da + 1 | 0; if ((Ma | 0) == 4) { Fa = 4; break c } else Qa = Ma } else Qa = Da } else Qa = Da; do if (za) { Ma = Ea + 1 | 0; Ka = ((Ma >>> 0) % 3 | 0 | 0) == 0 ? Ea + -2 | 0 : Ma; if ((Ka | 0) != -1 ? (Ma = f[Ha + (Ka << 2) >> 2] | 0, Ka = Ma + 1 | 0, (Ma | 0) != -1) : 0) Ra = ((Ka >>> 0) % 3 | 0 | 0) == 0 ? Ma + -2 | 0 : Ka; else Ra = -1 } else { Ka = (((Ea >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Ea | 0; if ((Ka | 0) != -1 ? (Ma = f[Ha + (Ka << 2) >> 2] | 0, (Ma | 0) != -1) : 0) if (!((Ma >>> 0) % 3 | 0)) { Ra = Ma + 2 | 0; break } else { Ra = Ma + -1 | 0; break } else Ra = -1 } while (0); if ((Ra | 0) == (ma | 0)) { Fa = Qa; break c } if ((Ra | 0) != -1 | Ca) { Da = Qa; Ea = Ra } else break } if (ya) { za = 0; Aa = Qa; Ba = -1; continue } Ea = f[Ha + (Q << 2) >> 2] | 0; if ((Ea | 0) == -1) { za = 0; Aa = Qa; Ba = -1; continue } if (!((Ea >>> 0) % 3 | 0)) { za = 0; Aa = Qa; Ba = Ea + 2 | 0; continue } else { za = 0; Aa = Qa; Ba = Ea + -1 | 0; continue } } Ba = X(oa, g) | 0; f[r >> 2] = 0; f[T >> 2] = 0; b[U >> 0] = 0; f[V >> 2] = 0; f[V + 4 >> 2] = 0; f[V + 8 >> 2] = 0; f[V + 12 >> 2] = 0; f[V + 16 >> 2] = 0; f[V + 20 >> 2] = 0; f[V + 24 >> 2] = 0; Aa = c + ((X(na + -2 | 0, g) | 0) << 2) | 0; za = c + (Ba << 2) | 0; Q = f[Z >> 2] | 0; if (S) { ya = 0; ma = 0; while (1) { Ea = (f[Aa + (ya << 2) >> 2] | 0) - (f[za + (ya << 2) >> 2] | 0) | 0; Da = ((Ea | 0) > -1 ? Ea : 0 - Ea | 0) + ma | 0; f[pa + (ya << 2) >> 2] = Ea; f[Q + (ya << 2) >> 2] = Ea << 1 ^ Ea >> 31; ya = ya + 1 | 0; if ((ya | 0) == (g | 0)) { Sa = Da; break } else ma = Da } } else Sa = 0; ho(e, _, Q, g); ma = Tk(e) | 0; ya = I; Da = om(e) | 0; Ea = Tn(Da | 0, I | 0, ma | 0, ya | 0) | 0; ya = I; ma = (Fa | 0) > 0; if (ma) { Da = Fa + -1 | 0; Ca = p + (Da << 3) | 0; Ma = Ca; Ka = Tn(f[Ma >> 2] | 0, f[Ma + 4 >> 2] | 0, Fa | 0, ((Fa | 0) < 0) << 31 >> 31 | 0) | 0; Ma = I; La = Ca; f[La >> 2] = Ka; f[La + 4 >> 2] = Ma; Ta = +W(+(+jm(Ka, f[o + (Da << 3) >> 2] | 0) * (+(Ka >>> 0) + 4294967296.0 * +(Ma | 0)))); Ma = Tn(Ea | 0, ya | 0, ~~Ta >>> 0 | 0, (+K(Ta) >= 1.0 ? (Ta > 0.0 ? ~~+Y(+J(Ta / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Ta - +(~~Ta >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; Ua = Ma } else Ua = Ea; Ea = r; f[Ea >> 2] = Ua; f[Ea + 4 >> 2] = Sa; b[U >> 0] = 0; f[V >> 2] = 0; Mf($, Aa, Aa + (g << 2) | 0); f[s >> 2] = qa; f[t >> 2] = ra; f[j >> 2] = f[s >> 2]; f[e >> 2] = f[t >> 2]; tf(aa, j, e); if ((Fa | 0) < 1) { Va = va; Wa = ua; Xa = ta; Ya = sa; Za = ra; _a = qa; $a = qa } else { Ea = n + Fa | 0; Ma = f[q >> 2] | 0; ya = Fa + -1 | 0; Ka = o + (ya << 3) | 0; Da = p + (ya << 3) | 0; ya = Ma; La = f[H >> 2] | 0; Ca = Ea + -1 | 0; Na = (Ca | 0) == (n | 0); Ga = Ea + -2 | 0; Ja = ja >>> 0 < Ga >>> 0; Ia = ~Fa; ab = Fa + 2 + ((Ia | 0) > -2 ? Ia : -2) | 0; Ia = La; bb = Ca >>> 0 > n >>> 0; cb = 0; db = 1; while (1) { cb = cb + 1 | 0; hj(n | 0, 1, ab | 0) | 0; hj(n | 0, 0, cb | 0) | 0; d: while (1) { if (S) { hj(f[m >> 2] | 0, 0, ka | 0) | 0; eb = f[m >> 2] | 0; fb = 0; gb = 0; while (1) { if (!(b[n + fb >> 0] | 0)) { hb = f[l + (fb * 12 | 0) >> 2] | 0; ib = 0; do { jb = eb + (ib << 2) | 0; f[jb >> 2] = (f[jb >> 2] | 0) + (f[hb + (ib << 2) >> 2] | 0); ib = ib + 1 | 0 } while ((ib | 0) != (g | 0)); kb = (1 << fb | gb & 255) & 255 } else kb = gb; fb = fb + 1 | 0; if ((fb | 0) == (Fa | 0)) { lb = kb; break } else gb = kb } } else { gb = 0; fb = 0; while (1) { if (!(b[n + gb >> 0] | 0)) mb = (1 << gb | fb & 255) & 255; else mb = fb; gb = gb + 1 | 0; if ((gb | 0) == (Fa | 0)) { lb = mb; break } else fb = mb } } fb = f[m >> 2] | 0; do if (S) { f[fb >> 2] = (f[fb >> 2] | 0) / (db | 0) | 0; if (!la) { gb = 1; do { eb = fb + (gb << 2) | 0; f[eb >> 2] = (f[eb >> 2] | 0) / (db | 0) | 0; gb = gb + 1 | 0 } while ((gb | 0) != (g | 0)); gb = f[Z >> 2] | 0; if (S) nb = gb; else { ob = 0; pb = gb; break } } else nb = f[Z >> 2] | 0; gb = 0; eb = 0; while (1) { ib = (f[fb + (gb << 2) >> 2] | 0) - (f[za + (gb << 2) >> 2] | 0) | 0; hb = ((ib | 0) > -1 ? ib : 0 - ib | 0) + eb | 0; f[Ma + (gb << 2) >> 2] = ib; f[nb + (gb << 2) >> 2] = ib << 1 ^ ib >> 31; gb = gb + 1 | 0; if ((gb | 0) == (g | 0)) { ob = hb; pb = nb; break } else eb = hb } } else { ob = 0; pb = f[Z >> 2] | 0 } while (0); ho(e, _, pb, g); fb = Tk(e) | 0; eb = I; gb = om(e) | 0; hb = Tn(gb | 0, I | 0, fb | 0, eb | 0) | 0; eb = I; if (ma) { fb = Ka; gb = Tn(f[fb >> 2] | 0, f[fb + 4 >> 2] | 0, db | 0, 0) | 0; fb = Da; ib = f[fb >> 2] | 0; jb = f[fb + 4 >> 2] | 0; Ta = +W(+(+jm(ib, gb) * (+(ib >>> 0) + 4294967296.0 * +(jb | 0)))); jb = Tn(hb | 0, eb | 0, ~~Ta >>> 0 | 0, (+K(Ta) >= 1.0 ? (Ta > 0.0 ? ~~+Y(+J(Ta / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((Ta - +(~~Ta >>> 0)) / 4294967296.0) >>> 0) : 0) | 0) | 0; qb = jb } else qb = hb; hb = f[r >> 2] | 0; if (!((qb | 0) >= (hb | 0) ? !((qb | 0) <= (hb | 0) ? (ob | 0) < (f[T >> 2] | 0) : 0) : 0)) { hb = r; f[hb >> 2] = qb; f[hb + 4 >> 2] = ob; b[U >> 0] = lb; f[V >> 2] = db; f[v >> 2] = f[m >> 2]; f[w >> 2] = f[E >> 2]; f[j >> 2] = f[v >> 2]; f[e >> 2] = f[w >> 2]; tf($, j, e); f[x >> 2] = ya; f[y >> 2] = La; f[j >> 2] = f[x >> 2]; f[e >> 2] = f[y >> 2]; tf(aa, j, e) } if (Na) break; rb = b[Ca >> 0] | 0; hb = -1; jb = rb; while (1) { eb = hb + -1 | 0; sb = Ea + eb | 0; ib = jb; jb = b[sb >> 0] | 0; if ((jb & 255) < (ib & 255)) break; if ((sb | 0) == (n | 0)) { tb = 86; break d } else hb = eb } eb = Ea + hb | 0; if ((jb & 255) < (rb & 255)) { ub = Ca; vb = rb } else { ib = Ea; gb = Ca; while (1) { fb = gb + -1 | 0; if ((jb & 255) < (h[ib + -2 >> 0] | 0)) { ub = fb; vb = 1; break } else { wb = gb; gb = fb; ib = wb } } } b[sb >> 0] = vb; b[ub >> 0] = jb; if ((hb | 0) < -1) { xb = eb; yb = Ca } else continue; while (1) { ib = b[xb >> 0] | 0; b[xb >> 0] = b[yb >> 0] | 0; b[yb >> 0] = ib; ib = xb + 1 | 0; gb = yb + -1 | 0; if (ib >>> 0 < gb >>> 0) { xb = ib; yb = gb } else continue d } } if (((tb | 0) == 86 ? (tb = 0, bb) : 0) ? (eb = b[n >> 0] | 0, b[n >> 0] = rb, b[Ca >> 0] = eb, Ja) : 0) { eb = Ga; hb = ja; do { jb = b[hb >> 0] | 0; b[hb >> 0] = b[eb >> 0] | 0; b[eb >> 0] = jb; hb = hb + 1 | 0; eb = eb + -1 | 0 } while (hb >>> 0 < eb >>> 0) } if ((db | 0) >= (Fa | 0)) { Va = Ia; Wa = Ma; Xa = Ia; Ya = Ma; Za = La; _a = ya; $a = Ma; break } else db = db + 1 | 0 } } if (ma) { db = f[V >> 2] | 0; Ma = o + (Fa + -1 << 3) | 0; ya = Ma; La = Tn(f[ya >> 2] | 0, f[ya + 4 >> 2] | 0, db | 0, ((db | 0) < 0) << 31 >> 31 | 0) | 0; db = Ma; f[db >> 2] = La; f[db + 4 >> 2] = I } if (S) { db = f[aa >> 2] | 0; La = f[C >> 2] | 0; Ma = 0; do { ya = f[db + (Ma << 2) >> 2] | 0; f[La + (Ma << 2) >> 2] = ya << 1 ^ ya >> 31; Ma = Ma + 1 | 0 } while ((Ma | 0) != (g | 0)); zb = La } else zb = f[C >> 2] | 0; go(e, _, zb, g); if (ma) { La = Fa + -1 | 0; Ab = a + 40 + (La * 12 | 0) | 0; Ma = a + 40 + (La * 12 | 0) + 4 | 0; db = a + 40 + (La * 12 | 0) + 8 | 0; La = 0; do { ya = f[Ma >> 2] | 0; Ia = f[db >> 2] | 0; Ga = (ya | 0) == (Ia << 5 | 0); if (!(1 << La & h[U >> 0])) { if (Ga) { if ((ya + 1 | 0) < 0) { tb = 101; break b } Ja = Ia << 6; Ca = ya + 32 & -32; hi(Ab, ya >>> 0 < 1073741823 ? (Ja >>> 0 < Ca >>> 0 ? Ca : Ja) : 2147483647); Bb = f[Ma >> 2] | 0 } else Bb = ya; f[Ma >> 2] = Bb + 1; Ja = (f[Ab >> 2] | 0) + (Bb >>> 5 << 2) | 0; f[Ja >> 2] = f[Ja >> 2] | 1 << (Bb & 31) } else { if (Ga) { if ((ya + 1 | 0) < 0) { tb = 106; break b } Ga = Ia << 6; Ia = ya + 32 & -32; hi(Ab, ya >>> 0 < 1073741823 ? (Ga >>> 0 < Ia >>> 0 ? Ia : Ga) : 2147483647); Cb = f[Ma >> 2] | 0 } else Cb = ya; f[Ma >> 2] = Cb + 1; ya = (f[Ab >> 2] | 0) + (Cb >>> 5 << 2) | 0; f[ya >> 2] = f[ya >> 2] & ~(1 << (Cb & 31)) } La = La + 1 | 0 } while ((La | 0) < (Fa | 0)) } La = f[$ >> 2] | 0; Ma = d + (Ba << 2) | 0; db = f[za + 4 >> 2] | 0; ma = f[La >> 2] | 0; ya = f[La + 4 >> 2] | 0; f[j >> 2] = f[za >> 2]; f[ca >> 2] = db; f[k >> 2] = ma; f[da >> 2] = ya; Dd(e, ba, j, k); f[Ma >> 2] = f[e >> 2]; f[Ma + 4 >> 2] = f[ea >> 2]; Ma = f[fa >> 2] | 0; if (Ma | 0) { ya = f[ia >> 2] | 0; if ((ya | 0) != (Ma | 0)) f[ia >> 2] = ya + (~((ya + -4 - Ma | 0) >>> 2) << 2); br(Ma) } Ma = f[ga >> 2] | 0; if (Ma | 0) { ya = f[ha >> 2] | 0; if ((ya | 0) != (Ma | 0)) f[ha >> 2] = ya + (~((ya + -4 - Ma | 0) >>> 2) << 2); br(Ma) } if ((na | 0) <= 2) { Db = Ya; Eb = Xa; break a } Ma = f[B >> 2] | 0; wa = f[Ma >> 2] | 0; ya = oa + -1 | 0; if ((f[Ma + 4 >> 2] | 0) - wa >> 2 >>> 0 <= ya >>> 0) { xa = Ma; tb = 18; break } else { Ma = oa; oa = ya; pa = $a; qa = _a; ra = Za; sa = Ya; ta = Xa; ua = Wa; va = Va; na = Ma } } if ((tb | 0) == 18) mq(xa); else if ((tb | 0) == 101) mq(Ab); else if ((tb | 0) == 106) mq(Ab) } else { Db = M; Eb = N } while (0); if ((g | 0) > 0) hj(f[l >> 2] | 0, 0, g << 2 | 0) | 0; g = f[l >> 2] | 0; N = f[c + 4 >> 2] | 0; M = f[g >> 2] | 0; Ab = f[g + 4 >> 2] | 0; f[j >> 2] = f[c >> 2]; f[j + 4 >> 2] = N; f[k >> 2] = M; f[k + 4 >> 2] = Ab; Dd(e, a + 8 | 0, j, k); f[d >> 2] = f[e >> 2]; f[d + 4 >> 2] = f[e + 4 >> 2]; if (Db | 0) { if ((Eb | 0) != (Db | 0)) f[H >> 2] = Eb + (~((Eb + -4 - Db | 0) >>> 2) << 2); br(Db) } Db = f[m >> 2] | 0; if (Db | 0) { m = f[E >> 2] | 0; if ((m | 0) != (Db | 0)) f[E >> 2] = m + (~((m + -4 - Db | 0) >>> 2) << 2); br(Db) } Db = f[l + 36 >> 2] | 0; if (Db | 0) { m = l + 40 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Db | 0)) f[m >> 2] = E + (~((E + -4 - Db | 0) >>> 2) << 2); br(Db) } Db = f[l + 24 >> 2] | 0; if (Db | 0) { E = l + 28 | 0; m = f[E >> 2] | 0; if ((m | 0) != (Db | 0)) f[E >> 2] = m + (~((m + -4 - Db | 0) >>> 2) << 2); br(Db) } Db = f[l + 12 >> 2] | 0; if (Db | 0) { m = l + 16 | 0; E = f[m >> 2] | 0; if ((E | 0) != (Db | 0)) f[m >> 2] = E + (~((E + -4 - Db | 0) >>> 2) << 2); br(Db) } Db = f[l >> 2] | 0; if (!Db) { u = i; return 1 } E = l + 4 | 0; l = f[E >> 2] | 0; if ((l | 0) != (Db | 0)) f[E >> 2] = l + (~((l + -4 - Db | 0) >>> 2) << 2); br(Db); u = i; return 1 } function fb(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0, Ua = 0, Va = 0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0, kb = 0, lb = 0, mb = 0, nb = 0, ob = 0, pb = 0, qb = 0, rb = 0, sb = 0, tb = 0, ub = 0, vb = 0, wb = 0, xb = 0, yb = 0, zb = 0, Ab = 0, Bb = 0, Cb = 0, Db = 0, Eb = 0, Fb = 0, Gb = 0, Hb = 0, Ib = 0, Jb = 0, Kb = 0, Lb = 0, Mb = 0, Nb = 0, Ob = 0, Pb = 0, Qb = 0, Rb = 0, Sb = 0, Tb = 0, Ub = 0, Vb = 0, Wb = 0, Xb = 0, Yb = 0, Zb = 0, _b = 0; c = u; u = u + 32 | 0; d = c + 16 | 0; e = c + 4 | 0; g = c; f[a + 36 >> 2] = b; h = a + 24 | 0; i = a + 28 | 0; j = f[i >> 2] | 0; k = f[h >> 2] | 0; l = j - k >> 2; m = k; k = j; if (l >>> 0 >= b >>> 0) { if (l >>> 0 > b >>> 0 ? (j = m + (b << 2) | 0, (j | 0) != (k | 0)) : 0) f[i >> 2] = k + (~((k + -4 - j | 0) >>> 2) << 2) } else kh(h, b - l | 0, 5828); f[d >> 2] = 0; l = d + 4 | 0; f[l >> 2] = 0; j = d + 8 | 0; f[j >> 2] = 0; if (b) { if ((b | 0) < 0) mq(d); k = ((b + -1 | 0) >>> 5) + 1 | 0; m = dn(k << 2) | 0; f[d >> 2] = m; f[j >> 2] = k; f[l >> 2] = b; k = b >>> 5; hj(m | 0, 0, k << 2 | 0) | 0; n = b & 31; o = m + (k << 2) | 0; k = m; if (!n) { p = b; q = k; r = m } else { f[o >> 2] = f[o >> 2] & ~(-1 >>> (32 - n | 0)); p = b; q = k; r = m } } else { p = 0; q = 0; r = 0 } m = a + 4 | 0; k = f[a >> 2] | 0; n = (f[m >> 2] | 0) - k | 0; o = n >> 2; f[e >> 2] = 0; s = e + 4 | 0; f[s >> 2] = 0; t = e + 8 | 0; f[t >> 2] = 0; do if (o) { if ((n | 0) < 0) mq(e); v = ((o + -1 | 0) >>> 5) + 1 | 0; w = dn(v << 2) | 0; f[e >> 2] = w; f[t >> 2] = v; f[s >> 2] = o; v = o >>> 5; hj(w | 0, 0, v << 2 | 0) | 0; x = o & 31; y = w + (v << 2) | 0; if (x | 0) f[y >> 2] = f[y >> 2] & ~(-1 >>> (32 - x | 0)); if (o >>> 0 > 2) { x = a + 12 | 0; y = a + 32 | 0; v = a + 52 | 0; w = a + 56 | 0; z = a + 48 | 0; A = b; B = k; C = 0; D = q; E = r; a: while (1) { F = B; G = C * 3 | 0; if ((G | 0) != -1) { H = f[F + (G << 2) >> 2] | 0; I = G + 1 | 0; J = ((I >>> 0) % 3 | 0 | 0) == 0 ? G + -2 | 0 : I; if ((J | 0) == -1) K = -1; else K = f[F + (J << 2) >> 2] | 0; J = (((G >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + G | 0; if ((J | 0) == -1) L = -1; else L = f[F + (J << 2) >> 2] | 0; if ((H | 0) != (K | 0) ? !((H | 0) == (L | 0) | (K | 0) == (L | 0)) : 0) { H = 0; J = A; F = E; I = D; while (1) { M = H + G | 0; if (!(f[(f[e >> 2] | 0) + (M >>> 5 << 2) >> 2] & 1 << (M & 31))) { N = f[(f[a >> 2] | 0) + (M << 2) >> 2] | 0; f[g >> 2] = N; if (!(f[F + (N >>> 5 << 2) >> 2] & 1 << (N & 31))) { O = 0; P = J; Q = N } else { N = f[i >> 2] | 0; if ((N | 0) == (f[y >> 2] | 0)) Ci(h, 5828); else { f[N >> 2] = -1; f[i >> 2] = N + 4 } N = f[v >> 2] | 0; if ((N | 0) == (f[w >> 2] | 0)) Ci(z, g); else { f[N >> 2] = f[g >> 2]; f[v >> 2] = N + 4 } N = f[l >> 2] | 0; R = f[j >> 2] | 0; if ((N | 0) == (R << 5 | 0)) { if ((N + 1 | 0) < 0) { S = 50; break a } T = R << 6; R = N + 32 & -32; hi(d, N >>> 0 < 1073741823 ? (T >>> 0 < R >>> 0 ? R : T) : 2147483647); U = f[l >> 2] | 0 } else U = N; f[l >> 2] = U + 1; N = (f[d >> 2] | 0) + (U >>> 5 << 2) | 0; f[N >> 2] = f[N >> 2] & ~(1 << (U & 31)); f[g >> 2] = J; O = 1; P = J + 1 | 0; Q = J } N = f[d >> 2] | 0; T = N + (Q >>> 5 << 2) | 0; f[T >> 2] = f[T >> 2] | 1 << (Q & 31); T = N; b: do if (O) { R = M; while (1) { if ((R | 0) == -1) { S = 64; break b } V = (f[e >> 2] | 0) + (R >>> 5 << 2) | 0; f[V >> 2] = f[V >> 2] | 1 << (R & 31); V = f[g >> 2] | 0; f[(f[h >> 2] | 0) + (V << 2) >> 2] = R; f[(f[a >> 2] | 0) + (R << 2) >> 2] = V; V = R + 1 | 0; W = ((V >>> 0) % 3 | 0 | 0) == 0 ? R + -2 | 0 : V; do if ((W | 0) == -1) X = -1; else { V = f[(f[x >> 2] | 0) + (W << 2) >> 2] | 0; Y = V + 1 | 0; if ((V | 0) == -1) { X = -1; break } X = ((Y >>> 0) % 3 | 0 | 0) == 0 ? V + -2 | 0 : Y } while (0); if ((X | 0) == (M | 0)) break; else R = X } } else { R = M; while (1) { if ((R | 0) == -1) { S = 64; break b } W = (f[e >> 2] | 0) + (R >>> 5 << 2) | 0; f[W >> 2] = f[W >> 2] | 1 << (R & 31); f[(f[h >> 2] | 0) + (f[g >> 2] << 2) >> 2] = R; W = R + 1 | 0; Y = ((W >>> 0) % 3 | 0 | 0) == 0 ? R + -2 | 0 : W; do if ((Y | 0) == -1) Z = -1; else { W = f[(f[x >> 2] | 0) + (Y << 2) >> 2] | 0; V = W + 1 | 0; if ((W | 0) == -1) { Z = -1; break } Z = ((V >>> 0) % 3 | 0 | 0) == 0 ? W + -2 | 0 : V } while (0); if ((Z | 0) == (M | 0)) break; else R = Z } } while (0); c: do if ((S | 0) == 64) { S = 0; if ((M | 0) == -1) break; R = (((M >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + M | 0; if ((R | 0) == -1) break; Y = f[(f[x >> 2] | 0) + (R << 2) >> 2] | 0; if ((Y | 0) == -1) break; R = Y + (((Y >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((R | 0) == -1) break; if (!O) { Y = R; while (1) { V = (f[e >> 2] | 0) + (Y >>> 5 << 2) | 0; f[V >> 2] = f[V >> 2] | 1 << (Y & 31); V = (((Y >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Y | 0; if ((V | 0) == -1) break c; W = f[(f[x >> 2] | 0) + (V << 2) >> 2] | 0; if ((W | 0) == -1) break c; Y = W + (((W >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0; if ((Y | 0) == -1) break c } } Y = f[a >> 2] | 0; W = R; do { V = (f[e >> 2] | 0) + (W >>> 5 << 2) | 0; f[V >> 2] = f[V >> 2] | 1 << (W & 31); f[Y + (W << 2) >> 2] = f[g >> 2]; V = (((W >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + W | 0; if ((V | 0) == -1) break c; _ = f[(f[x >> 2] | 0) + (V << 2) >> 2] | 0; if ((_ | 0) == -1) break c; W = _ + (((_ >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) | 0 } while ((W | 0) != -1) } while (0); $ = P; aa = T; ba = N } else { $ = J; aa = I; ba = F } if ((H | 0) < 2) { H = H + 1 | 0; J = $; F = ba; I = aa } else { ca = $; da = aa; ea = ba; break } } } else { ca = A; da = D; ea = E } } else { ca = A; da = D; ea = E } C = C + 1 | 0; B = f[a >> 2] | 0; if (C >>> 0 >= (((f[m >> 2] | 0) - B >> 2 >>> 0) / 3 | 0) >>> 0) { S = 18; break } else { A = ca; D = da; E = ea } } if ((S | 0) == 18) { fa = da; ga = f[l >> 2] | 0; break } else if ((S | 0) == 50) mq(d) } else { fa = q; ga = p } } else { fa = q; ga = p } while (0); p = a + 44 | 0; f[p >> 2] = 0; a = fa; fa = ga >>> 5; q = a + (fa << 2) | 0; S = ga & 31; ga = (fa | 0) != 0; d: do if (fa | S | 0) if (!S) { l = a; da = 0; ea = ga; while (1) { e: do if (ea) { if (!(f[l >> 2] & 1)) { ca = da + 1 | 0; f[p >> 2] = ca; ha = ca } else ha = da; if (!(f[l >> 2] & 2)) { ca = ha + 1 | 0; f[p >> 2] = ca; ia = ca } else ia = ha; if (!(f[l >> 2] & 4)) { ca = ia + 1 | 0; f[p >> 2] = ca; ja = ca } else ja = ia; if (!(f[l >> 2] & 8)) { ca = ja + 1 | 0; f[p >> 2] = ca; ka = ca } else ka = ja; if (!(f[l >> 2] & 16)) { ca = ka + 1 | 0; f[p >> 2] = ca; la = ca } else la = ka; if (!(f[l >> 2] & 32)) { ca = la + 1 | 0; f[p >> 2] = ca; ma = ca } else ma = la; if (!(f[l >> 2] & 64)) { ca = ma + 1 | 0; f[p >> 2] = ca; na = ca } else na = ma; if (!(f[l >> 2] & 128)) { ca = na + 1 | 0; f[p >> 2] = ca; oa = ca } else oa = na; if (!(f[l >> 2] & 256)) { ca = oa + 1 | 0; f[p >> 2] = ca; pa = ca } else pa = oa; if (!(f[l >> 2] & 512)) { ca = pa + 1 | 0; f[p >> 2] = ca; qa = ca } else qa = pa; if (!(f[l >> 2] & 1024)) { ca = qa + 1 | 0; f[p >> 2] = ca; ra = ca } else ra = qa; if (!(f[l >> 2] & 2048)) { ca = ra + 1 | 0; f[p >> 2] = ca; sa = ca } else sa = ra; if (!(f[l >> 2] & 4096)) { ca = sa + 1 | 0; f[p >> 2] = ca; ta = ca } else ta = sa; if (!(f[l >> 2] & 8192)) { ca = ta + 1 | 0; f[p >> 2] = ca; ua = ca } else ua = ta; if (!(f[l >> 2] & 16384)) { ca = ua + 1 | 0; f[p >> 2] = ca; va = ca } else va = ua; if (!(f[l >> 2] & 32768)) { ca = va + 1 | 0; f[p >> 2] = ca; wa = ca } else wa = va; if (!(f[l >> 2] & 65536)) { ca = wa + 1 | 0; f[p >> 2] = ca; xa = ca } else xa = wa; if (!(f[l >> 2] & 131072)) { ca = xa + 1 | 0; f[p >> 2] = ca; ya = ca } else ya = xa; if (!(f[l >> 2] & 262144)) { ca = ya + 1 | 0; f[p >> 2] = ca; za = ca } else za = ya; if (!(f[l >> 2] & 524288)) { ca = za + 1 | 0; f[p >> 2] = ca; Aa = ca } else Aa = za; if (!(f[l >> 2] & 1048576)) { ca = Aa + 1 | 0; f[p >> 2] = ca; Ba = ca } else Ba = Aa; if (!(f[l >> 2] & 2097152)) { ca = Ba + 1 | 0; f[p >> 2] = ca; Ca = ca } else Ca = Ba; if (!(f[l >> 2] & 4194304)) { ca = Ca + 1 | 0; f[p >> 2] = ca; Da = ca } else Da = Ca; if (!(f[l >> 2] & 8388608)) { ca = Da + 1 | 0; f[p >> 2] = ca; Ea = ca } else Ea = Da; if (!(f[l >> 2] & 16777216)) { ca = Ea + 1 | 0; f[p >> 2] = ca; Fa = ca } else Fa = Ea; if (!(f[l >> 2] & 33554432)) { ca = Fa + 1 | 0; f[p >> 2] = ca; Ga = ca } else Ga = Fa; if (!(f[l >> 2] & 67108864)) { ca = Ga + 1 | 0; f[p >> 2] = ca; Ha = ca } else Ha = Ga; if (!(f[l >> 2] & 134217728)) { ca = Ha + 1 | 0; f[p >> 2] = ca; Ia = ca } else Ia = Ha; if (!(f[l >> 2] & 268435456)) { ca = Ia + 1 | 0; f[p >> 2] = ca; Ja = ca } else Ja = Ia; if (!(f[l >> 2] & 536870912)) { ca = Ja + 1 | 0; f[p >> 2] = ca; Ka = ca } else Ka = Ja; if (!(f[l >> 2] & 1073741824)) { ca = Ka + 1 | 0; f[p >> 2] = ca; La = ca } else La = Ka; if ((f[l >> 2] | 0) <= -1) { Ma = La; break } ca = La + 1 | 0; f[p >> 2] = ca; Ma = ca } else { ca = 0; m = da; while (1) { if (!(f[l >> 2] & 1 << ca)) { ba = m + 1 | 0; f[p >> 2] = ba; Na = ba } else Na = m; if ((ca | 0) == 31) { Ma = Na; break e } ca = ca + 1 | 0; if (!ca) break d; else m = Na } } while (0); l = l + 4 | 0; if ((q | 0) == (l | 0)) break; else { da = Ma; ea = 1 } } } else { if (ga) { ea = 0; da = a; l = 0; while (1) { if (!(f[da >> 2] & 1)) { m = l + 1 | 0; f[p >> 2] = m; Oa = m; Pa = m } else { Oa = l; Pa = ea } if (!(f[da >> 2] & 2)) { m = Oa + 1 | 0; f[p >> 2] = m; Qa = m; Ra = m } else { Qa = Oa; Ra = Pa } if (!(f[da >> 2] & 4)) { m = Qa + 1 | 0; f[p >> 2] = m; Sa = m; Ta = m } else { Sa = Qa; Ta = Ra } if (!(f[da >> 2] & 8)) { m = Sa + 1 | 0; f[p >> 2] = m; Ua = m; Va = m } else { Ua = Sa; Va = Ta } if (!(f[da >> 2] & 16)) { m = Ua + 1 | 0; f[p >> 2] = m; Wa = m; Xa = m } else { Wa = Ua; Xa = Va } if (!(f[da >> 2] & 32)) { m = Wa + 1 | 0; f[p >> 2] = m; Ya = m; Za = m } else { Ya = Wa; Za = Xa } if (!(f[da >> 2] & 64)) { m = Ya + 1 | 0; f[p >> 2] = m; _a = m; $a = m } else { _a = Ya; $a = Za } if (!(f[da >> 2] & 128)) { m = _a + 1 | 0; f[p >> 2] = m; ab = m; bb = m } else { ab = _a; bb = $a } if (!(f[da >> 2] & 256)) { m = ab + 1 | 0; f[p >> 2] = m; cb = m; db = m } else { cb = ab; db = bb } if (!(f[da >> 2] & 512)) { m = cb + 1 | 0; f[p >> 2] = m; eb = m; fb = m } else { eb = cb; fb = db } if (!(f[da >> 2] & 1024)) { m = eb + 1 | 0; f[p >> 2] = m; gb = m; hb = m } else { gb = eb; hb = fb } if (!(f[da >> 2] & 2048)) { m = gb + 1 | 0; f[p >> 2] = m; ib = m; jb = m } else { ib = gb; jb = hb } if (!(f[da >> 2] & 4096)) { m = ib + 1 | 0; f[p >> 2] = m; kb = m; lb = m } else { kb = ib; lb = jb } if (!(f[da >> 2] & 8192)) { m = kb + 1 | 0; f[p >> 2] = m; mb = m; nb = m } else { mb = kb; nb = lb } if (!(f[da >> 2] & 16384)) { m = mb + 1 | 0; f[p >> 2] = m; ob = m; pb = m } else { ob = mb; pb = nb } if (!(f[da >> 2] & 32768)) { m = ob + 1 | 0; f[p >> 2] = m; qb = m; rb = m } else { qb = ob; rb = pb } if (!(f[da >> 2] & 65536)) { m = qb + 1 | 0; f[p >> 2] = m; sb = m; tb = m } else { sb = qb; tb = rb } if (!(f[da >> 2] & 131072)) { m = sb + 1 | 0; f[p >> 2] = m; ub = m; vb = m } else { ub = sb; vb = tb } if (!(f[da >> 2] & 262144)) { m = ub + 1 | 0; f[p >> 2] = m; wb = m; xb = m } else { wb = ub; xb = vb } if (!(f[da >> 2] & 524288)) { m = wb + 1 | 0; f[p >> 2] = m; yb = m; zb = m } else { yb = wb; zb = xb } if (!(f[da >> 2] & 1048576)) { m = yb + 1 | 0; f[p >> 2] = m; Ab = m; Bb = m } else { Ab = yb; Bb = zb } if (!(f[da >> 2] & 2097152)) { m = Ab + 1 | 0; f[p >> 2] = m; Cb = m; Db = m } else { Cb = Ab; Db = Bb } if (!(f[da >> 2] & 4194304)) { m = Cb + 1 | 0; f[p >> 2] = m; Eb = m; Fb = m } else { Eb = Cb; Fb = Db } if (!(f[da >> 2] & 8388608)) { m = Eb + 1 | 0; f[p >> 2] = m; Gb = m; Hb = m } else { Gb = Eb; Hb = Fb } if (!(f[da >> 2] & 16777216)) { m = Gb + 1 | 0; f[p >> 2] = m; Ib = m; Jb = m } else { Ib = Gb; Jb = Hb } if (!(f[da >> 2] & 33554432)) { m = Ib + 1 | 0; f[p >> 2] = m; Kb = m; Lb = m } else { Kb = Ib; Lb = Jb } if (!(f[da >> 2] & 67108864)) { m = Kb + 1 | 0; f[p >> 2] = m; Mb = m; Nb = m } else { Mb = Kb; Nb = Lb } if (!(f[da >> 2] & 134217728)) { m = Mb + 1 | 0; f[p >> 2] = m; Ob = m; Pb = m } else { Ob = Mb; Pb = Nb } if (!(f[da >> 2] & 268435456)) { m = Ob + 1 | 0; f[p >> 2] = m; Qb = m; Rb = m } else { Qb = Ob; Rb = Pb } if (!(f[da >> 2] & 536870912)) { m = Qb + 1 | 0; f[p >> 2] = m; Sb = m; Tb = m } else { Sb = Qb; Tb = Rb } if (!(f[da >> 2] & 1073741824)) { m = Sb + 1 | 0; f[p >> 2] = m; Ub = m; Vb = m } else { Ub = Sb; Vb = Tb } if ((f[da >> 2] | 0) > -1) { m = Ub + 1 | 0; f[p >> 2] = m; Wb = m; Xb = m } else { Wb = Ub; Xb = Vb } m = da + 4 | 0; if ((q | 0) == (m | 0)) { Yb = m; Zb = Xb; break } else { ea = Xb; da = m; l = Wb } } } else { Yb = a; Zb = 0 } l = 0; da = Zb; while (1) { if (!(f[Yb >> 2] & 1 << l)) { ea = da + 1 | 0; f[p >> 2] = ea; _b = ea } else _b = da; l = l + 1 | 0; if ((l | 0) == (S | 0)) break; else da = _b } } while (0); _b = f[e >> 2] | 0; if (_b | 0) br(_b); _b = f[d >> 2] | 0; if (!_b) { u = c; return 1 } br(_b); u = c; return 1 } function gb(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = Oa, La = 0, Ma = 0, Na = 0, Pa = 0, Qa = Oa, Ra = 0, Sa = 0, Ta = 0, Ua = 0, Va = 0; c = u; u = u + 80 | 0; d = c + 60 | 0; e = c + 48 | 0; g = c + 24 | 0; h = c + 12 | 0; i = c; j = a + 28 | 0; k = f[j >> 2] | 0; l = f[k + 4 >> 2] | 0; m = f[l + 80 >> 2] | 0; o = a + 4 | 0; p = a + 8 | 0; q = f[p >> 2] | 0; r = f[o >> 2] | 0; s = (q | 0) == (r | 0); t = r; if (s) { f[a + 72 >> 2] = 0; v = 1; u = c; return v | 0 } w = f[l + 8 >> 2] | 0; x = q - r >> 2; r = 0; q = 0; do { r = r + (b[(f[w + (f[t + (q << 2) >> 2] << 2) >> 2] | 0) + 24 >> 0] | 0) | 0; q = q + 1 | 0 } while (q >>> 0 < x >>> 0); f[a + 72 >> 2] = r; if (s) { v = 1; u = c; return v | 0 } s = g + 4 | 0; r = g + 8 | 0; x = d + 8 | 0; q = d + 4 | 0; w = d + 11 | 0; y = g + 12 | 0; z = d + 8 | 0; A = d + 4 | 0; B = d + 11 | 0; C = h + 4 | 0; D = h + 8 | 0; E = i + 8 | 0; F = i + 4 | 0; G = d + 11 | 0; H = d + 4 | 0; I = i + 11 | 0; J = d + 8 | 0; K = d + 4 | 0; L = d + 11 | 0; M = d + 11 | 0; N = d + 4 | 0; O = h + 8 | 0; P = a + 40 | 0; Q = a + 44 | 0; R = a + 36 | 0; S = a + 64 | 0; T = a + 68 | 0; U = a + 60 | 0; V = g + 8 | 0; W = g + 20 | 0; X = e + 8 | 0; Y = e + 4 | 0; Z = e + 11 | 0; _ = g + 4 | 0; aa = g + 8 | 0; ba = h + 4 | 0; ca = h + 8 | 0; da = h + 8 | 0; ea = a + 52 | 0; fa = a + 56 | 0; ga = a + 48 | 0; a = g + 8 | 0; ha = 0; ia = t; t = l; l = k; a: while (1) { k = f[ia + (ha << 2) >> 2] | 0; ja = f[(f[t + 8 >> 2] | 0) + (k << 2) >> 2] | 0; switch (f[ja + 28 >> 2] | 0) { case 9: { f[g >> 2] = 1180; f[s >> 2] = -1; f[r >> 2] = 0; f[r + 4 >> 2] = 0; f[r + 8 >> 2] = 0; f[r + 12 >> 2] = 0; ka = f[l + 48 >> 2] | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; la = dn(32) | 0; f[d >> 2] = la; f[x >> 2] = -2147483616; f[q >> 2] = 17; ma = la; na = 12932; oa = ma + 17 | 0; do { b[ma >> 0] = b[na >> 0] | 0; ma = ma + 1 | 0; na = na + 1 | 0 } while ((ma | 0) < (oa | 0)); b[la + 17 >> 0] = 0; pa = ka + 16 | 0; qa = f[pa >> 2] | 0; if (qa) { ra = pa; sa = qa; b: while (1) { qa = sa; while (1) { if ((f[qa + 16 >> 2] | 0) >= (k | 0)) break; ta = f[qa + 4 >> 2] | 0; if (!ta) { ua = ra; break b } else qa = ta } sa = f[qa >> 2] | 0; if (!sa) { ua = qa; break } else ra = qa } if (((ua | 0) != (pa | 0) ? (k | 0) >= (f[ua + 16 >> 2] | 0) : 0) ? (ra = ua + 20 | 0, (sh(ra, d) | 0) != 0) : 0) va = yk(ra, d, -1) | 0; else wa = 17 } else wa = 17; if ((wa | 0) == 17) { wa = 0; va = yk(ka, d, -1) | 0 } if ((b[w >> 0] | 0) < 0) br(f[d >> 2] | 0); if ((va | 0) < 1) xa = 1; else { ra = f[(f[j >> 2] | 0) + 48 >> 2] | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; sa = dn(32) | 0; f[d >> 2] = sa; f[z >> 2] = -2147483616; f[A >> 2] = 19; ma = sa; na = 13005; oa = ma + 19 | 0; do { b[ma >> 0] = b[na >> 0] | 0; ma = ma + 1 | 0; na = na + 1 | 0 } while ((ma | 0) < (oa | 0)); b[sa + 19 >> 0] = 0; ka = ra + 16 | 0; pa = f[ka >> 2] | 0; if (pa) { la = ka; ta = pa; c: while (1) { pa = ta; while (1) { if ((f[pa + 16 >> 2] | 0) >= (k | 0)) break; ya = f[pa + 4 >> 2] | 0; if (!ya) { za = la; break c } else pa = ya } ta = f[pa >> 2] | 0; if (!ta) { za = pa; break } else la = pa } if ((za | 0) != (ka | 0) ? (k | 0) >= (f[za + 16 >> 2] | 0) : 0) Aa = za + 20 | 0; else wa = 29 } else wa = 29; if ((wa | 0) == 29) { wa = 0; Aa = ra } if (!(sh(Aa, d) | 0)) Ba = 0; else { la = f[(f[j >> 2] | 0) + 48 >> 2] | 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; ta = dn(32) | 0; f[e >> 2] = ta; f[X >> 2] = -2147483616; f[Y >> 2] = 18; ma = ta; na = 13025; oa = ma + 18 | 0; do { b[ma >> 0] = b[na >> 0] | 0; ma = ma + 1 | 0; na = na + 1 | 0 } while ((ma | 0) < (oa | 0)); b[ta + 18 >> 0] = 0; ra = la + 16 | 0; ka = f[ra >> 2] | 0; if (ka) { sa = ra; qa = ka; d: while (1) { ka = qa; while (1) { if ((f[ka + 16 >> 2] | 0) >= (k | 0)) break; ya = f[ka + 4 >> 2] | 0; if (!ya) { Ca = sa; break d } else ka = ya } qa = f[ka >> 2] | 0; if (!qa) { Ca = ka; break } else sa = ka } if ((Ca | 0) != (ra | 0) ? (k | 0) >= (f[Ca + 16 >> 2] | 0) : 0) Da = Ca + 20 | 0; else wa = 39 } else wa = 39; if ((wa | 0) == 39) { wa = 0; Da = la } sa = (sh(Da, e) | 0) != 0; if ((b[Z >> 0] | 0) < 0) br(f[e >> 2] | 0); Ba = sa } if ((b[B >> 0] | 0) < 0) br(f[d >> 2] | 0); if (Ba) { sa = ja + 24 | 0; qa = b[sa >> 0] | 0; ta = qa << 24 >> 24; f[h >> 2] = 0; f[C >> 2] = 0; f[D >> 2] = 0; if (!(qa << 24 >> 24)) Ea = 0; else { if (qa << 24 >> 24 < 0) { wa = 48; break a } qa = ta << 2; pa = dn(qa) | 0; f[h >> 2] = pa; ya = pa + (ta << 2) | 0; f[O >> 2] = ya; hj(pa | 0, 0, qa | 0) | 0; f[C >> 2] = ya; Ea = pa } pa = f[(f[j >> 2] | 0) + 48 >> 2] | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; ya = dn(32) | 0; f[i >> 2] = ya; f[E >> 2] = -2147483616; f[F >> 2] = 19; ma = ya; na = 13005; oa = ma + 19 | 0; do { b[ma >> 0] = b[na >> 0] | 0; ma = ma + 1 | 0; na = na + 1 | 0 } while ((ma | 0) < (oa | 0)); b[ya + 19 >> 0] = 0; la = b[sa >> 0] | 0; ra = la << 24 >> 24; qa = pa + 16 | 0; ta = f[qa >> 2] | 0; if (ta) { Fa = qa; Ga = ta; e: while (1) { ta = Ga; while (1) { if ((f[ta + 16 >> 2] | 0) >= (k | 0)) break; Ha = f[ta + 4 >> 2] | 0; if (!Ha) { Ia = Fa; break e } else ta = Ha } Ga = f[ta >> 2] | 0; if (!Ga) { Ia = ta; break } else Fa = ta } if (((Ia | 0) != (qa | 0) ? (k | 0) >= (f[Ia + 16 >> 2] | 0) : 0) ? (Fa = Ia + 20 | 0, (sh(Fa, i) | 0) != 0) : 0) { Ga = zg(Fa, i) | 0; if ((Ga | 0) != (Ia + 24 | 0)) { dj(d, Ga + 28 | 0); Ga = b[M >> 0] | 0; Fa = Ga << 24 >> 24 < 0; if (!((Fa ? f[N >> 2] | 0 : Ga & 255) | 0)) Ja = Ga; else { if (la << 24 >> 24 > 0) { ya = Fa ? f[d >> 2] | 0 : d; Fa = 0; do { Ka = $(pq(ya, e)); ka = ya; ya = f[e >> 2] | 0; if ((ka | 0) == (ya | 0)) break; n[Ea + (Fa << 2) >> 2] = Ka; Fa = Fa + 1 | 0 } while ((Fa | 0) < (ra | 0)); La = b[M >> 0] | 0 } else La = Ga; Ja = La } if (Ja << 24 >> 24 < 0) br(f[d >> 2] | 0) } } else wa = 69 } else wa = 69; if ((wa | 0) == 69 ? (wa = 0, Fa = zg(pa, i) | 0, (Fa | 0) != (pa + 4 | 0)) : 0) { dj(d, Fa + 28 | 0); Fa = b[G >> 0] | 0; ya = Fa << 24 >> 24 < 0; if (!((ya ? f[H >> 2] | 0 : Fa & 255) | 0)) Ma = Fa; else { if (la << 24 >> 24 > 0) { qa = ya ? f[d >> 2] | 0 : d; ya = 0; do { Ka = $(pq(qa, e)); ka = qa; qa = f[e >> 2] | 0; if ((ka | 0) == (qa | 0)) break; n[Ea + (ya << 2) >> 2] = Ka; ya = ya + 1 | 0 } while ((ya | 0) < (ra | 0)); Na = b[G >> 0] | 0 } else Na = Fa; Ma = Na } if (Ma << 24 >> 24 < 0) br(f[d >> 2] | 0) } if ((b[I >> 0] | 0) < 0) br(f[i >> 2] | 0); ra = f[(f[j >> 2] | 0) + 48 >> 2] | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; ya = dn(32) | 0; f[d >> 2] = ya; f[J >> 2] = -2147483616; f[K >> 2] = 18; ma = ya; na = 13025; oa = ma + 18 | 0; do { b[ma >> 0] = b[na >> 0] | 0; ma = ma + 1 | 0; na = na + 1 | 0 } while ((ma | 0) < (oa | 0)); b[ya + 18 >> 0] = 0; na = ra + 16 | 0; ma = f[na >> 2] | 0; do if (ma) { oa = na; Fa = ma; f: while (1) { qa = Fa; while (1) { if ((f[qa + 16 >> 2] | 0) >= (k | 0)) break; la = f[qa + 4 >> 2] | 0; if (!la) { Pa = oa; break f } else qa = la } Fa = f[qa >> 2] | 0; if (!Fa) { Pa = qa; break } else oa = qa } if ((Pa | 0) != (na | 0) ? (k | 0) >= (f[Pa + 16 >> 2] | 0) : 0) { oa = Pa + 20 | 0; if (!(sh(oa, d) | 0)) { wa = 91; break } Qa = $(kk(oa, d, $(1.0))) } else wa = 91 } else wa = 91; while (0); if ((wa | 0) == 91) { wa = 0; Qa = $(kk(ra, d, $(1.0))) } if ((b[L >> 0] | 0) < 0) br(f[d >> 2] | 0); wl(g, va, f[h >> 2] | 0, b[sa >> 0] | 0, Qa); k = f[h >> 2] | 0; if (k | 0) { na = f[C >> 2] | 0; if ((na | 0) != (k | 0)) f[C >> 2] = na + (~((na + -4 - k | 0) >>> 2) << 2); br(k) } } else Kd(g, ja, va) | 0; k = f[P >> 2] | 0; if ((k | 0) == (f[Q >> 2] | 0)) of(R, g); else { f[k >> 2] = 1180; f[k + 4 >> 2] = f[s >> 2]; Ra = k + 8 | 0; f[Ra >> 2] = 0; na = k + 12 | 0; f[na >> 2] = 0; f[k + 16 >> 2] = 0; ma = (f[y >> 2] | 0) - (f[V >> 2] | 0) | 0; ya = ma >> 2; if (ya | 0) { if (ya >>> 0 > 1073741823) { wa = 103; break a } oa = dn(ma) | 0; f[na >> 2] = oa; f[Ra >> 2] = oa; f[k + 16 >> 2] = oa + (ya << 2); ya = f[V >> 2] | 0; ma = (f[y >> 2] | 0) - ya | 0; if ((ma | 0) > 0) { Rg(oa | 0, ya | 0, ma | 0) | 0; f[na >> 2] = oa + (ma >>> 2 << 2) } } f[k + 20 >> 2] = f[W >> 2]; f[P >> 2] = (f[P >> 2] | 0) + 24 } Re(d, g, ja, m); k = f[S >> 2] | 0; if (k >>> 0 < (f[T >> 2] | 0) >>> 0) { ma = f[d >> 2] | 0; f[d >> 2] = 0; f[k >> 2] = ma; f[S >> 2] = k + 4 } else Me(U, d); k = f[d >> 2] | 0; f[d >> 2] = 0; if (k | 0) { ma = k + 88 | 0; oa = f[ma >> 2] | 0; f[ma >> 2] = 0; if (oa | 0) { ma = f[oa + 8 >> 2] | 0; if (ma | 0) { na = oa + 12 | 0; if ((f[na >> 2] | 0) != (ma | 0)) f[na >> 2] = ma; br(ma) } br(oa) } oa = f[k + 68 >> 2] | 0; if (oa | 0) { ma = k + 72 | 0; na = f[ma >> 2] | 0; if ((na | 0) != (oa | 0)) f[ma >> 2] = na + (~((na + -4 - oa | 0) >>> 2) << 2); br(oa) } oa = k + 64 | 0; na = f[oa >> 2] | 0; f[oa >> 2] = 0; if (na | 0) { oa = f[na >> 2] | 0; if (oa | 0) { ma = na + 4 | 0; if ((f[ma >> 2] | 0) != (oa | 0)) f[ma >> 2] = oa; br(oa) } br(na) } br(k) } xa = 0 } f[g >> 2] = 1180; k = f[r >> 2] | 0; if (k | 0) { na = f[y >> 2] | 0; if ((na | 0) != (k | 0)) f[y >> 2] = na + (~((na + -4 - k | 0) >>> 2) << 2); br(k) } if (xa | 0) { v = 0; wa = 169; break a } break } case 1: case 3: case 5: { k = ja + 24 | 0; na = b[k >> 0] | 0; oa = na << 24 >> 24; f[g >> 2] = 0; f[_ >> 2] = 0; f[aa >> 2] = 0; if (!(na << 24 >> 24)) Sa = 0; else { if (na << 24 >> 24 < 0) { wa = 137; break a } na = dn(oa << 2) | 0; f[_ >> 2] = na; f[g >> 2] = na; ma = na + (oa << 2) | 0; f[a >> 2] = ma; ya = oa; oa = na; while (1) { f[oa >> 2] = 2147483647; ya = ya + -1 | 0; if (!ya) break; else oa = oa + 4 | 0 } f[_ >> 2] = ma; Sa = b[k >> 0] | 0 } oa = Sa << 24 >> 24; f[h >> 2] = 0; f[ba >> 2] = 0; f[ca >> 2] = 0; if (!(Sa << 24 >> 24)) Ta = 0; else { if (Sa << 24 >> 24 < 0) { wa = 144; break a } ya = oa << 2; sa = dn(ya) | 0; f[h >> 2] = sa; ra = sa + (oa << 2) | 0; f[da >> 2] = ra; hj(sa | 0, 0, ya | 0) | 0; f[ba >> 2] = ra; Ta = sa } sa = ja + 80 | 0; ra = b[k >> 0] | 0; g: do if (!(f[sa >> 2] | 0)) Ua = ra; else { ya = 0; oa = ra; na = Ta; while (1) { f[e >> 2] = ya; f[d >> 2] = f[e >> 2]; Pb(ja, d, oa, na) | 0; Fa = b[k >> 0] | 0; if (Fa << 24 >> 24 > 0) { ta = f[g >> 2] | 0; la = f[h >> 2] | 0; pa = Fa << 24 >> 24; Ga = 0; do { ka = ta + (Ga << 2) | 0; Ha = f[la + (Ga << 2) >> 2] | 0; if ((f[ka >> 2] | 0) > (Ha | 0)) f[ka >> 2] = Ha; Ga = Ga + 1 | 0 } while ((Ga | 0) < (pa | 0)) } pa = ya + 1 | 0; if (pa >>> 0 >= (f[sa >> 2] | 0) >>> 0) { Ua = Fa; break g } ya = pa; oa = Fa; na = f[h >> 2] | 0 } } while (0); if (Ua << 24 >> 24 > 0) { sa = 0; ja = Ua; while (1) { ra = (f[g >> 2] | 0) + (sa << 2) | 0; ma = f[ea >> 2] | 0; if ((ma | 0) == (f[fa >> 2] | 0)) { Ci(ga, ra); Va = b[k >> 0] | 0 } else { f[ma >> 2] = f[ra >> 2]; f[ea >> 2] = ma + 4; Va = ja } sa = sa + 1 | 0; if ((sa | 0) >= (Va << 24 >> 24 | 0)) break; else ja = Va } } ja = f[h >> 2] | 0; if (ja | 0) { sa = f[ba >> 2] | 0; if ((sa | 0) != (ja | 0)) f[ba >> 2] = sa + (~((sa + -4 - ja | 0) >>> 2) << 2); br(ja) } ja = f[g >> 2] | 0; if (ja | 0) { sa = f[_ >> 2] | 0; if ((sa | 0) != (ja | 0)) f[_ >> 2] = sa + (~((sa + -4 - ja | 0) >>> 2) << 2); br(ja) } break } default: { } }ja = ha + 1 | 0; sa = f[o >> 2] | 0; if (ja >>> 0 >= (f[p >> 2] | 0) - sa >> 2 >>> 0) { v = 1; wa = 169; break } k = f[j >> 2] | 0; ha = ja; ia = sa; t = f[k + 4 >> 2] | 0; l = k } if ((wa | 0) == 48) mq(h); else if ((wa | 0) == 103) mq(Ra); else if ((wa | 0) == 137) mq(g); else if ((wa | 0) == 144) mq(h); else if ((wa | 0) == 169) { u = c; return v | 0 } return 0 } function hb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0; d = u; u = u + 32 | 0; e = d; g = a + 8 | 0; h = f[g >> 2] | 0; f[e >> 2] = 0; i = e + 4 | 0; f[i >> 2] = 0; f[e + 8 >> 2] = 0; do if (h) if (h >>> 0 > 1073741823) mq(e); else { j = h << 2; k = dn(j) | 0; f[e >> 2] = k; l = k + (h << 2) | 0; f[e + 8 >> 2] = l; hj(k | 0, 0, j | 0) | 0; f[i >> 2] = l; m = l; n = k; break } else { m = 0; n = 0 } while (0); k = a + 128 | 0; l = f[k >> 2] | 0; j = f[l >> 2] | 0; o = l + 4 | 0; if (!j) { p = l + 8 | 0; q = n; r = m; s = h } else { h = f[o >> 2] | 0; if ((h | 0) != (j | 0)) f[o >> 2] = h + (~((h + -4 - j | 0) >>> 2) << 2); br(j); j = l + 8 | 0; f[j >> 2] = 0; f[o >> 2] = 0; f[l >> 2] = 0; p = j; q = f[e >> 2] | 0; r = f[i >> 2] | 0; s = f[g >> 2] | 0 } f[l >> 2] = q; f[o >> 2] = r; f[p >> 2] = f[e + 8 >> 2]; f[e >> 2] = 0; p = e + 4 | 0; f[p >> 2] = 0; f[e + 8 >> 2] = 0; do if (s) if (s >>> 0 > 1073741823) mq(e); else { r = s << 2; o = dn(r) | 0; f[e >> 2] = o; q = o + (s << 2) | 0; f[e + 8 >> 2] = q; hj(o | 0, 0, r | 0) | 0; f[p >> 2] = q; t = q; v = o; break } else { t = 0; v = 0 } while (0); s = a + 140 | 0; o = f[s >> 2] | 0; q = f[o >> 2] | 0; r = o + 4 | 0; if (!q) { w = o + 8 | 0; x = v; y = t } else { t = f[r >> 2] | 0; if ((t | 0) != (q | 0)) f[r >> 2] = t + (~((t + -4 - q | 0) >>> 2) << 2); br(q); q = o + 8 | 0; f[q >> 2] = 0; f[r >> 2] = 0; f[o >> 2] = 0; w = q; x = f[e >> 2] | 0; y = f[p >> 2] | 0 } f[o >> 2] = x; f[r >> 2] = y; f[w >> 2] = f[e + 8 >> 2]; w = f[b >> 2] | 0; y = b + 4 | 0; r = f[y >> 2] | 0; x = f[y + 4 >> 2] | 0; y = f[c >> 2] | 0; o = c + 4 | 0; p = f[o >> 2] | 0; q = f[o + 4 >> 2] | 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; f[e + 12 >> 2] = 0; f[e + 16 >> 2] = 0; f[e + 20 >> 2] = 0; o = e + 8 | 0; t = e + 4 | 0; v = e + 16 | 0; l = e + 20 | 0; i = r; Jc(e); j = f[t >> 2] | 0; h = (f[l >> 2] | 0) + (f[v >> 2] | 0) | 0; if ((f[o >> 2] | 0) == (j | 0)) z = 0; else z = (f[j + (((h >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((h >>> 0) % 113 | 0) * 36 | 0) | 0; f[z >> 2] = w; h = z + 4 | 0; f[h >> 2] = r; f[h + 4 >> 2] = x; f[z + 12 >> 2] = y; h = z + 16 | 0; f[h >> 2] = p; f[h + 4 >> 2] = q; f[z + 24 >> 2] = 0; f[z + 28 >> 2] = y - w; f[z + 32 >> 2] = 0; z = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = z; if (z | 0) { w = a + 116 | 0; y = a + 48 | 0; h = a + 44 | 0; j = a + 36 | 0; m = a + 40 | 0; n = a + 32 | 0; A = b + 8 | 0; B = c + 8 | 0; C = a + 28 | 0; D = a + 24 | 0; E = a + 16 | 0; F = a + 20 | 0; G = a + 12 | 0; H = a + 88 | 0; I = a + 84 | 0; J = a + 76 | 0; K = a + 80 | 0; L = a + 72 | 0; M = i + 4 | 0; N = i + 24 | 0; O = i + 24 | 0; P = p + 24 | 0; Q = z; while (1) { z = f[v >> 2] | 0; R = Q + -1 | 0; S = R + z | 0; T = f[t >> 2] | 0; U = f[T + (((S >>> 0) / 113 | 0) << 2) >> 2] | 0; V = (S >>> 0) % 113 | 0; S = f[U + (V * 36 | 0) >> 2] | 0; W = f[U + (V * 36 | 0) + 12 >> 2] | 0; Y = f[U + (V * 36 | 0) + 24 >> 2] | 0; Z = f[U + (V * 36 | 0) + 32 >> 2] | 0; f[l >> 2] = R; R = f[o >> 2] | 0; V = R - T >> 2; if ((1 - Q - z + ((V | 0) == 0 ? 0 : (V * 113 | 0) + -1 | 0) | 0) >>> 0 > 225) { br(f[R + -4 >> 2] | 0); f[o >> 2] = (f[o >> 2] | 0) + -4 } f[b >> 2] = S; f[c >> 2] = W; R = f[k >> 2] | 0; V = ((f[g >> 2] | 0) + -1 | 0) == (Y | 0) ? 0 : Y + 1 | 0; Y = (f[s >> 2] | 0) + (Z * 12 | 0) | 0; z = W - S | 0; T = (f[a >> 2] | 0) - (f[(f[Y >> 2] | 0) + (V << 2) >> 2] | 0) | 0; a: do if (T) { if (z >>> 0 < 3) { U = f[w >> 2] | 0; f[U >> 2] = V; $ = f[g >> 2] | 0; if ($ >>> 0 > 1) { aa = 1; ba = $; ca = V; while (1) { ca = (ca | 0) == (ba + -1 | 0) ? 0 : ca + 1 | 0; f[U + (aa << 2) >> 2] = ca; aa = aa + 1 | 0; da = f[g >> 2] | 0; if (aa >>> 0 >= da >>> 0) { ea = da; break } else ba = da } } else ea = $; if (!z) { fa = 99; break } else { ga = 0; ha = ea } while (1) { ba = (f[N >> 2] | 0) + ((X(f[M >> 2] | 0, S + ga | 0) | 0) << 2) | 0; if (!ha) ia = 0; else { aa = 0; do { ca = f[(f[w >> 2] | 0) + (aa << 2) >> 2] | 0; U = (f[a >> 2] | 0) - (f[(f[Y >> 2] | 0) + (ca << 2) >> 2] | 0) | 0; do if (U | 0) { da = f[y >> 2] | 0; ja = 32 - da | 0; ka = 32 - U | 0; la = f[ba + (ca << 2) >> 2] << ka; if ((U | 0) > (ja | 0)) { ma = la >>> ka; ka = U - ja | 0; f[y >> 2] = ka; ja = f[h >> 2] | ma >>> ka; f[h >> 2] = ja; ka = f[j >> 2] | 0; if ((ka | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[ka >> 2] = ja; f[j >> 2] = ka + 4 } f[h >> 2] = ma << 32 - (f[y >> 2] | 0); break } ma = f[h >> 2] | la >>> da; f[h >> 2] = ma; la = da + U | 0; f[y >> 2] = la; if ((la | 0) != 32) break; la = f[j >> 2] | 0; if ((la | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[la >> 2] = ma; f[j >> 2] = la + 4 } f[h >> 2] = 0; f[y >> 2] = 0 } while (0); aa = aa + 1 | 0; U = f[g >> 2] | 0 } while (aa >>> 0 < U >>> 0); ia = U } ga = ga + 1 | 0; if (ga >>> 0 >= z >>> 0) { fa = 99; break a } else ha = ia } } $ = Z + 1 | 0; qg(R + ($ * 12 | 0) | 0, f[R + (Z * 12 | 0) >> 2] | 0, f[R + (Z * 12 | 0) + 4 >> 2] | 0); aa = (f[(f[k >> 2] | 0) + ($ * 12 | 0) >> 2] | 0) + (V << 2) | 0; ba = (f[aa >> 2] | 0) + (1 << T + -1) | 0; f[aa >> 2] = ba; aa = f[A >> 2] | 0; U = f[B >> 2] | 0; b: do if ((W | 0) == (S | 0)) na = S; else { ca = f[O >> 2] | 0; if (!aa) { if ((f[ca + (V << 2) >> 2] | 0) >>> 0 < ba >>> 0) { na = W; break } else { oa = W; pa = S } while (1) { la = oa; do { la = la + -1 | 0; if ((pa | 0) == (la | 0)) { na = pa; break b } ma = (f[P >> 2] | 0) + ((X(la, U) | 0) << 2) + (V << 2) | 0 } while ((f[ma >> 2] | 0) >>> 0 >= ba >>> 0); pa = pa + 1 | 0; if ((pa | 0) == (la | 0)) { na = la; break b } else oa = la } } else { qa = W; ra = S } while (1) { ma = ra; while (1) { sa = ca + ((X(ma, aa) | 0) << 2) | 0; if ((f[sa + (V << 2) >> 2] | 0) >>> 0 >= ba >>> 0) { ta = qa; break } da = ma + 1 | 0; if ((da | 0) == (qa | 0)) { na = qa; break b } else ma = da } while (1) { ta = ta + -1 | 0; if ((ma | 0) == (ta | 0)) { na = ma; break b } ua = (f[P >> 2] | 0) + ((X(ta, U) | 0) << 2) | 0; if ((f[ua + (V << 2) >> 2] | 0) >>> 0 < ba >>> 0) { va = 0; break } } do { la = sa + (va << 2) | 0; da = ua + (va << 2) | 0; ka = f[la >> 2] | 0; f[la >> 2] = f[da >> 2]; f[da >> 2] = ka; va = va + 1 | 0 } while ((va | 0) != (aa | 0)); ra = ma + 1 | 0; if ((ra | 0) == (ta | 0)) { na = ta; break } else qa = ta } } while (0); ba = (_(z | 0) | 0) ^ 31; U = na - S | 0; ca = W - na | 0; ka = U >>> 0 < ca >>> 0; if ((U | 0) != (ca | 0)) { da = f[H >> 2] | 0; if (ka) f[I >> 2] = f[I >> 2] | 1 << 31 - da; la = da + 1 | 0; f[H >> 2] = la; if ((la | 0) == 32) { la = f[J >> 2] | 0; if ((la | 0) == (f[K >> 2] | 0)) Ci(L, I); else { f[la >> 2] = f[I >> 2]; f[J >> 2] = la + 4 } f[H >> 2] = 0; f[I >> 2] = 0 } } la = z >>> 1; do if (ka) { da = f[C >> 2] | 0; ja = 32 - da | 0; wa = 32 - ba | 0; xa = la - U << wa; if ((ba | 0) > (ja | 0)) { ya = xa >>> wa; wa = ba - ja | 0; f[C >> 2] = wa; ja = f[D >> 2] | ya >>> wa; f[D >> 2] = ja; wa = f[E >> 2] | 0; if ((wa | 0) == (f[F >> 2] | 0)) Ci(G, D); else { f[wa >> 2] = ja; f[E >> 2] = wa + 4 } f[D >> 2] = ya << 32 - (f[C >> 2] | 0); break } ya = f[D >> 2] | xa >>> da; f[D >> 2] = ya; xa = da + ba | 0; f[C >> 2] = xa; if ((xa | 0) == 32) { xa = f[E >> 2] | 0; if ((xa | 0) == (f[F >> 2] | 0)) Ci(G, D); else { f[xa >> 2] = ya; f[E >> 2] = xa + 4 } f[D >> 2] = 0; f[C >> 2] = 0 } } else { xa = f[C >> 2] | 0; ya = 32 - xa | 0; da = 32 - ba | 0; wa = la - ca << da; if ((ba | 0) > (ya | 0)) { ja = wa >>> da; da = ba - ya | 0; f[C >> 2] = da; ya = f[D >> 2] | ja >>> da; f[D >> 2] = ya; da = f[E >> 2] | 0; if ((da | 0) == (f[F >> 2] | 0)) Ci(G, D); else { f[da >> 2] = ya; f[E >> 2] = da + 4 } f[D >> 2] = ja << 32 - (f[C >> 2] | 0); break } ja = f[D >> 2] | wa >>> xa; f[D >> 2] = ja; wa = xa + ba | 0; f[C >> 2] = wa; if ((wa | 0) == 32) { wa = f[E >> 2] | 0; if ((wa | 0) == (f[F >> 2] | 0)) Ci(G, D); else { f[wa >> 2] = ja; f[E >> 2] = wa + 4 } f[D >> 2] = 0; f[C >> 2] = 0 } } while (0); ba = f[s >> 2] | 0; la = f[ba + (Z * 12 | 0) >> 2] | 0; ka = la + (V << 2) | 0; f[ka >> 2] = (f[ka >> 2] | 0) + 1; qg(ba + ($ * 12 | 0) | 0, la, f[ba + (Z * 12 | 0) + 4 >> 2] | 0); if ((na | 0) != (S | 0)) { ba = f[o >> 2] | 0; la = f[t >> 2] | 0; ka = ba - la >> 2; wa = f[v >> 2] | 0; ja = f[l >> 2] | 0; if ((((ka | 0) == 0 ? 0 : (ka * 113 | 0) + -1 | 0) | 0) == (ja + wa | 0)) { Jc(e); za = f[v >> 2] | 0; Aa = f[l >> 2] | 0; Ba = f[o >> 2] | 0; Ca = f[t >> 2] | 0 } else { za = wa; Aa = ja; Ba = ba; Ca = la } la = Aa + za | 0; if ((Ba | 0) == (Ca | 0)) Da = 0; else Da = (f[Ca + (((la >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((la >>> 0) % 113 | 0) * 36 | 0) | 0; f[Da >> 2] = S; la = Da + 4 | 0; f[la >> 2] = r; f[la + 4 >> 2] = x; f[Da + 12 >> 2] = na; f[Da + 16 >> 2] = i; f[Da + 20 >> 2] = aa; f[Da + 24 >> 2] = V; f[Da + 28 >> 2] = U; f[Da + 32 >> 2] = Z; f[l >> 2] = (f[l >> 2] | 0) + 1 } if ((W | 0) != (na | 0)) { la = f[o >> 2] | 0; ba = f[t >> 2] | 0; ja = la - ba >> 2; wa = f[v >> 2] | 0; ka = f[l >> 2] | 0; if ((((ja | 0) == 0 ? 0 : (ja * 113 | 0) + -1 | 0) | 0) == (ka + wa | 0)) { Jc(e); Ea = f[v >> 2] | 0; Fa = f[l >> 2] | 0; Ga = f[o >> 2] | 0; Ha = f[t >> 2] | 0 } else { Ea = wa; Fa = ka; Ga = la; Ha = ba } ba = Fa + Ea | 0; if ((Ga | 0) == (Ha | 0)) Ia = 0; else Ia = (f[Ha + (((ba >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((ba >>> 0) % 113 | 0) * 36 | 0) | 0; f[Ia >> 2] = na; f[Ia + 4 >> 2] = i; f[Ia + 8 >> 2] = aa; f[Ia + 12 >> 2] = W; ba = Ia + 16 | 0; f[ba >> 2] = p; f[ba + 4 >> 2] = q; f[Ia + 24 >> 2] = V; f[Ia + 28 >> 2] = ca; f[Ia + 32 >> 2] = $; ba = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = ba; Ja = ba } else fa = 99 } else fa = 99; while (0); if ((fa | 0) == 99) { fa = 0; Ja = f[l >> 2] | 0 } if (!Ja) break; else Q = Ja } } Ja = f[t >> 2] | 0; Q = f[v >> 2] | 0; Ia = Ja + (((Q >>> 0) / 113 | 0) << 2) | 0; q = f[o >> 2] | 0; p = q; i = Ja; if ((q | 0) == (Ja | 0)) { Ka = 0; La = 0 } else { na = (f[Ia >> 2] | 0) + (((Q >>> 0) % 113 | 0) * 36 | 0) | 0; Ka = na; La = na } na = Ia; Ia = La; c: while (1) { La = Ia; do { Q = La; if ((Ka | 0) == (Q | 0)) break c; La = Q + 36 | 0 } while ((La - (f[na >> 2] | 0) | 0) != 4068); La = na + 4 | 0; na = La; Ia = f[La >> 2] | 0 } f[l >> 2] = 0; l = p - i >> 2; if (l >>> 0 > 2) { i = Ja; do { br(f[i >> 2] | 0); i = (f[t >> 2] | 0) + 4 | 0; f[t >> 2] = i; Ma = f[o >> 2] | 0; Na = Ma - i >> 2 } while (Na >>> 0 > 2); Oa = Na; Pa = i; Qa = Ma } else { Oa = l; Pa = Ja; Qa = q } switch (Oa | 0) { case 1: { Ra = 56; fa = 113; break } case 2: { Ra = 113; fa = 113; break } default: { } }if ((fa | 0) == 113) f[v >> 2] = Ra; if ((Pa | 0) != (Qa | 0)) { Ra = Pa; do { br(f[Ra >> 2] | 0); Ra = Ra + 4 | 0 } while ((Ra | 0) != (Qa | 0)); Qa = f[t >> 2] | 0; t = f[o >> 2] | 0; if ((t | 0) != (Qa | 0)) f[o >> 2] = t + (~((t + -4 - Qa | 0) >>> 2) << 2) } Qa = f[e >> 2] | 0; if (!Qa) { u = d; return } br(Qa); u = d; return } function ib(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0; d = u; u = u + 80 | 0; e = d + 56 | 0; g = d + 52 | 0; h = d + 48 | 0; i = d + 68 | 0; j = d; k = d + 44 | 0; l = d + 40 | 0; m = d + 36 | 0; n = d + 32 | 0; o = d + 28 | 0; p = d + 24 | 0; q = d + 20 | 0; r = d + 16 | 0; s = d + 12 | 0; if (!(b[c + 288 >> 0] | 0)) { Ne(e, f[c + 8 >> 2] | 0); t = c + 12 | 0; v = f[e >> 2] | 0; f[e >> 2] = 0; w = f[t >> 2] | 0; f[t >> 2] = v; if (w) { ui(w); br(w); w = f[e >> 2] | 0; f[e >> 2] = 0; if (w | 0) { ui(w); br(w) } } else f[e >> 2] = 0 } else { Mg(e, f[c + 8 >> 2] | 0); w = c + 12 | 0; v = f[e >> 2] | 0; f[e >> 2] = 0; t = f[w >> 2] | 0; f[w >> 2] = v; if (t) { ui(t); br(t); t = f[e >> 2] | 0; f[e >> 2] = 0; if (t | 0) { ui(t); br(t) } } else f[e >> 2] = 0 } t = c + 12 | 0; v = f[t >> 2] | 0; if (v | 0 ? (((f[v + 4 >> 2] | 0) - (f[v >> 2] | 0) >> 2 >>> 0) / 3 | 0 | 0) != (f[v + 40 >> 2] | 0) : 0) { w = c + 200 | 0; f[c + 264 >> 2] = c; x = c + 4 | 0; Nh(((f[v + 28 >> 2] | 0) - (f[v + 24 >> 2] | 0) >> 2) - (f[v + 44 >> 2] | 0) | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; v = f[t >> 2] | 0; Nh((((f[v + 4 >> 2] | 0) - (f[v >> 2] | 0) >> 2 >>> 0) / 3 | 0) - (f[v + 40 >> 2] | 0) | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; v = c + 28 | 0; y = c + 8 | 0; z = f[y >> 2] | 0; A = ((f[z + 100 >> 2] | 0) - (f[z + 96 >> 2] | 0) | 0) / 12 | 0; b[e >> 0] = 0; Xg(v, A, e); A = f[t >> 2] | 0; z = (f[A + 28 >> 2] | 0) - (f[A + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(c + 52 | 0, z, e); z = c + 40 | 0; A = f[z >> 2] | 0; B = c + 44 | 0; C = f[B >> 2] | 0; if ((C | 0) != (A | 0)) f[B >> 2] = C + (~((C + -4 - A | 0) >>> 2) << 2); A = f[t >> 2] | 0; C = (f[A + 4 >> 2] | 0) - (f[A >> 2] | 0) >> 2; $j(z, C - ((C >>> 0) % 3 | 0) | 0); C = c + 84 | 0; z = f[t >> 2] | 0; A = (f[z + 28 >> 2] | 0) - (f[z + 24 >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(C, A, e); A = c + 96 | 0; z = f[A >> 2] | 0; B = c + 100 | 0; D = f[B >> 2] | 0; if ((D | 0) != (z | 0)) f[B >> 2] = D + (~((D + -4 - z | 0) >>> 2) << 2); f[c + 164 >> 2] = -1; z = c + 168 | 0; f[z >> 2] = 0; D = f[c + 108 >> 2] | 0; E = c + 112 | 0; F = f[E >> 2] | 0; if ((F | 0) != (D | 0)) f[E >> 2] = F + (~(((F + -12 - D | 0) >>> 0) / 12 | 0) * 12 | 0); D = c + 132 | 0; if (f[D >> 2] | 0) { F = c + 128 | 0; E = f[F >> 2] | 0; if (E | 0) { G = E; do { E = G; G = f[G >> 2] | 0; br(E) } while ((G | 0) != 0) } f[F >> 2] = 0; F = f[c + 124 >> 2] | 0; if (F | 0) { G = c + 120 | 0; E = 0; do { f[(f[G >> 2] | 0) + (E << 2) >> 2] = 0; E = E + 1 | 0 } while ((E | 0) != (F | 0)) } f[D >> 2] = 0 } f[c + 144 >> 2] = 0; D = f[t >> 2] | 0; F = (f[D + 28 >> 2] | 0) - (f[D + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(c + 152 | 0, F, e); F = c + 72 | 0; D = f[F >> 2] | 0; E = c + 76 | 0; G = f[E >> 2] | 0; if ((G | 0) != (D | 0)) f[E >> 2] = G + (~((G + -4 - D | 0) >>> 2) << 2); D = f[t >> 2] | 0; $j(F, ((f[D + 4 >> 2] | 0) - (f[D >> 2] | 0) >> 2 >>> 0) / 3 | 0); f[c + 64 >> 2] = 0; if (!(oe(c) | 0)) { D = dn(32) | 0; f[e >> 2] = D; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; H = D; I = 13227; J = H + 29 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[D + 29 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } if (!(ch(c) | 0)) { D = dn(48) | 0; f[e >> 2] = D; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 36; H = D; I = 13257; J = H + 36 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[D + 36 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } D = c + 172 | 0; G = c + 176 | 0; K = (((f[G >> 2] | 0) - (f[D >> 2] | 0) | 0) / 136 | 0) & 255; b[i >> 0] = K; L = f[(f[x >> 2] | 0) + 44 >> 2] | 0; M = L + 16 | 0; N = f[M + 4 >> 2] | 0; if ((N | 0) > 0 | (N | 0) == 0 & (f[M >> 2] | 0) >>> 0 > 0) O = K; else { f[g >> 2] = f[L + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(L, e, i, i + 1 | 0) | 0; O = b[i >> 0] | 0 } i = c + 284 | 0; f[i >> 2] = O & 255; O = f[t >> 2] | 0; L = (f[O + 4 >> 2] | 0) - (f[O >> 2] | 0) | 0; O = L >> 2; Ti(w); f[j >> 2] = 0; K = j + 4 | 0; f[K >> 2] = 0; f[j + 8 >> 2] = 0; a: do if ((L | 0) > 0) { M = c + 104 | 0; N = j + 8 | 0; P = 0; b: while (1) { Q = (P >>> 0) / 3 | 0; R = Q >>> 5; S = 1 << (Q & 31); if ((f[(f[v >> 2] | 0) + (R << 2) >> 2] & S | 0) == 0 ? (T = f[t >> 2] | 0, f[k >> 2] = Q, f[e >> 2] = f[k >> 2], !(Rj(T, e) | 0)) : 0) { f[g >> 2] = 0; f[l >> 2] = Q; f[e >> 2] = f[l >> 2]; Q = gg(c, e, g) | 0; Vi(w, Q); T = f[g >> 2] | 0; U = (T | 0) == -1; do if (Q) { do if (U) { V = -1; W = -1; X = -1 } else { Y = f[f[t >> 2] >> 2] | 0; Z = f[Y + (T << 2) >> 2] | 0; _ = T + 1 | 0; $ = ((_ >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : _; if (($ | 0) == -1) aa = -1; else aa = f[Y + ($ << 2) >> 2] | 0; $ = (((T >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + T | 0; if (($ | 0) == -1) { V = -1; W = aa; X = Z; break } V = f[Y + ($ << 2) >> 2] | 0; W = aa; X = Z } while (0); Z = f[C >> 2] | 0; $ = Z + (X >>> 5 << 2) | 0; f[$ >> 2] = f[$ >> 2] | 1 << (X & 31); $ = Z + (W >>> 5 << 2) | 0; f[$ >> 2] = f[$ >> 2] | 1 << (W & 31); $ = Z + (V >>> 5 << 2) | 0; f[$ >> 2] = f[$ >> 2] | 1 << (V & 31); f[e >> 2] = 1; $ = f[B >> 2] | 0; if ($ >>> 0 < (f[M >> 2] | 0) >>> 0) { f[$ >> 2] = 1; f[B >> 2] = $ + 4 } else Ci(A, e); $ = (f[v >> 2] | 0) + (R << 2) | 0; f[$ >> 2] = f[$ >> 2] | S; $ = T + 1 | 0; if (U) ba = -1; else ba = (($ >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : $; f[e >> 2] = ba; Z = f[K >> 2] | 0; if (Z >>> 0 < (f[N >> 2] | 0) >>> 0) { f[Z >> 2] = ba; f[K >> 2] = Z + 4 } else Ci(j, e); if (U) break; Z = (($ >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : $; if ((Z | 0) == -1) break; $ = f[(f[(f[t >> 2] | 0) + 12 >> 2] | 0) + (Z << 2) >> 2] | 0; Z = ($ | 0) == -1; Y = Z ? -1 : ($ >>> 0) / 3 | 0; if (Z) break; if (f[(f[v >> 2] | 0) + (Y >>> 5 << 2) >> 2] & 1 << (Y & 31) | 0) break; f[m >> 2] = $; f[e >> 2] = f[m >> 2]; if (!(hc(c, e) | 0)) { ca = 65; break b } } else { $ = T + 1 | 0; if (U) da = -1; else da = (($ >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : $; f[n >> 2] = da; f[e >> 2] = f[n >> 2]; Ce(c, e, 1) | 0; f[o >> 2] = f[g >> 2]; f[e >> 2] = f[o >> 2]; if (!(hc(c, e) | 0)) { ca = 71; break b } } while (0) } P = P + 1 | 0; if ((P | 0) >= (O | 0)) { ca = 77; break a } } if ((ca | 0) == 65) { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; P = dn(48) | 0; f[e >> 2] = P; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 32; H = P; I = 13294; J = H + 32 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[P + 32 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0) } else if ((ca | 0) == 71) { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; N = dn(48) | 0; f[e >> 2] = N; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 32; H = N; I = 13294; J = H + 32 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[N + 32 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0) } } else ca = 77; while (0); do if ((ca | 0) == 77) { O = f[F >> 2] | 0; o = f[E >> 2] | 0; n = o; if ((O | 0) != (o | 0) ? (da = o + -4 | 0, O >>> 0 < da >>> 0) : 0) { o = O; O = da; do { da = f[o >> 2] | 0; f[o >> 2] = f[O >> 2]; f[O >> 2] = da; o = o + 4 | 0; O = O + -4 | 0 } while (o >>> 0 < O >>> 0) } f[p >> 2] = n; f[q >> 2] = f[j >> 2]; f[r >> 2] = f[K >> 2]; f[h >> 2] = f[p >> 2]; f[g >> 2] = f[q >> 2]; f[e >> 2] = f[r >> 2]; Md(F, h, g, e) | 0; if ((f[G >> 2] | 0) != (f[D >> 2] | 0) ? (O = f[y >> 2] | 0, o = ((f[O + 100 >> 2] | 0) - (f[O + 96 >> 2] | 0) | 0) / 12 | 0, b[e >> 0] = 0, Xg(v, o, e), o = f[F >> 2] | 0, O = f[E >> 2] | 0, (o | 0) != (O | 0)) : 0) { N = o; do { f[s >> 2] = f[N >> 2]; f[e >> 2] = f[s >> 2]; ue(c, e) | 0; N = N + 4 | 0 } while ((N | 0) != (O | 0)) } _g(w); O = c + 232 | 0; fd(w, O); N = c + 280 | 0; n = f[N >> 2] | 0; if ((n | 0 ? (f[i >> 2] | 0) > 0 : 0) ? (fd(n, O), (f[i >> 2] | 0) > 1) : 0) { n = 1; do { fd((f[N >> 2] | 0) + (n << 5) | 0, O); n = n + 1 | 0 } while ((n | 0) < (f[i >> 2] | 0)) } Nh((f[c + 272 >> 2] | 0) - (f[c + 268 >> 2] | 0) >> 2, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; Nh(f[z >> 2] | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; if (Jg(c) | 0) { n = f[(f[x >> 2] | 0) + 44 >> 2] | 0; N = f[O >> 2] | 0; o = n + 16 | 0; da = f[o + 4 >> 2] | 0; if (!((da | 0) > 0 | (da | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { o = (f[c + 236 >> 2] | 0) - N | 0; f[g >> 2] = f[n + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(n, e, N, N + o | 0) | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; break } else { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; o = dn(32) | 0; f[e >> 2] = o; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 28; H = o; I = 13327; J = H + 28 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[o + 28 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); break } } while (0); g = f[j >> 2] | 0; if (g | 0) { j = f[K >> 2] | 0; if ((j | 0) != (g | 0)) f[K >> 2] = j + (~((j + -4 - g | 0) >>> 2) << 2); br(g) } u = d; return } g = dn(32) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; H = g; I = 13197; J = H + 29 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[g + 29 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } function jb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0; d = u; u = u + 48 | 0; e = d + 36 | 0; g = d + 24 | 0; h = d; i = a + 8 | 0; j = f[i >> 2] | 0; f[e >> 2] = 0; k = e + 4 | 0; f[k >> 2] = 0; f[e + 8 >> 2] = 0; do if (j) if (j >>> 0 > 1073741823) mq(e); else { l = j << 2; m = dn(l) | 0; f[e >> 2] = m; n = m + (j << 2) | 0; f[e + 8 >> 2] = n; hj(m | 0, 0, l | 0) | 0; f[k >> 2] = n; o = n; p = m; break } else { o = 0; p = 0 } while (0); m = a + 1164 | 0; n = f[m >> 2] | 0; l = f[n >> 2] | 0; q = n + 4 | 0; if (!l) { r = n + 8 | 0; s = p; t = o; v = j } else { j = f[q >> 2] | 0; if ((j | 0) != (l | 0)) f[q >> 2] = j + (~((j + -4 - l | 0) >>> 2) << 2); br(l); l = n + 8 | 0; f[l >> 2] = 0; f[q >> 2] = 0; f[n >> 2] = 0; r = l; s = f[e >> 2] | 0; t = f[k >> 2] | 0; v = f[i >> 2] | 0 } f[n >> 2] = s; f[q >> 2] = t; f[r >> 2] = f[e + 8 >> 2]; f[e >> 2] = 0; r = e + 4 | 0; f[r >> 2] = 0; f[e + 8 >> 2] = 0; do if (v) if (v >>> 0 > 1073741823) mq(e); else { t = v << 2; q = dn(t) | 0; f[e >> 2] = q; s = q + (v << 2) | 0; f[e + 8 >> 2] = s; hj(q | 0, 0, t | 0) | 0; f[r >> 2] = s; w = s; x = q; break } else { w = 0; x = 0 } while (0); v = a + 1176 | 0; q = f[v >> 2] | 0; s = f[q >> 2] | 0; t = q + 4 | 0; if (!s) { y = q + 8 | 0; z = x; A = w } else { w = f[t >> 2] | 0; if ((w | 0) != (s | 0)) f[t >> 2] = w + (~((w + -4 - s | 0) >>> 2) << 2); br(s); s = q + 8 | 0; f[s >> 2] = 0; f[t >> 2] = 0; f[q >> 2] = 0; y = s; z = f[e >> 2] | 0; A = f[r >> 2] | 0 } f[q >> 2] = z; f[t >> 2] = A; f[y >> 2] = f[e + 8 >> 2]; y = f[b >> 2] | 0; A = b + 4 | 0; t = f[A >> 2] | 0; z = f[A + 4 >> 2] | 0; A = f[c >> 2] | 0; q = c + 4 | 0; r = f[q >> 2] | 0; s = f[q + 4 >> 2] | 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; f[h + 12 >> 2] = 0; f[h + 16 >> 2] = 0; f[h + 20 >> 2] = 0; q = h + 8 | 0; w = h + 4 | 0; x = h + 16 | 0; n = h + 20 | 0; k = t; Jc(h); l = f[w >> 2] | 0; j = (f[n >> 2] | 0) + (f[x >> 2] | 0) | 0; if ((f[q >> 2] | 0) == (l | 0)) B = 0; else B = (f[l + (((j >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((j >>> 0) % 113 | 0) * 36 | 0) | 0; f[B >> 2] = y; j = B + 4 | 0; f[j >> 2] = t; f[j + 4 >> 2] = z; f[B + 12 >> 2] = A; j = B + 16 | 0; f[j >> 2] = r; f[j + 4 >> 2] = s; f[B + 24 >> 2] = 0; f[B + 28 >> 2] = A - y; f[B + 32 >> 2] = 0; B = (f[n >> 2] | 0) + 1 | 0; f[n >> 2] = B; if (B | 0) { y = a + 1152 | 0; A = a + 1084 | 0; j = a + 1080 | 0; l = a + 1072 | 0; o = a + 1076 | 0; p = a + 1068 | 0; C = b + 8 | 0; D = c + 8 | 0; E = a + 1124 | 0; F = a + 1120 | 0; G = a + 1112 | 0; H = a + 1116 | 0; I = a + 1108 | 0; J = k + 4 | 0; K = k + 24 | 0; L = k + 24 | 0; M = r + 24 | 0; N = B; while (1) { B = f[x >> 2] | 0; O = N + -1 | 0; P = O + B | 0; Q = f[w >> 2] | 0; R = f[Q + (((P >>> 0) / 113 | 0) << 2) >> 2] | 0; S = (P >>> 0) % 113 | 0; P = f[R + (S * 36 | 0) >> 2] | 0; T = f[R + (S * 36 | 0) + 12 >> 2] | 0; U = f[R + (S * 36 | 0) + 24 >> 2] | 0; V = f[R + (S * 36 | 0) + 32 >> 2] | 0; f[n >> 2] = O; O = f[q >> 2] | 0; S = O - Q >> 2; if ((1 - N - B + ((S | 0) == 0 ? 0 : (S * 113 | 0) + -1 | 0) | 0) >>> 0 > 225) { br(f[O + -4 >> 2] | 0); f[q >> 2] = (f[q >> 2] | 0) + -4 } f[b >> 2] = P; f[c >> 2] = T; O = f[m >> 2] | 0; S = O + (V * 12 | 0) | 0; B = (f[v >> 2] | 0) + (V * 12 | 0) | 0; f[g >> 2] = f[b >> 2]; f[g + 4 >> 2] = f[b + 4 >> 2]; f[g + 8 >> 2] = f[b + 8 >> 2]; f[e >> 2] = f[c >> 2]; f[e + 4 >> 2] = f[c + 4 >> 2]; f[e + 8 >> 2] = f[c + 8 >> 2]; Q = Gd(a, g, e, S, B, U) | 0; U = T - P | 0; R = (f[a >> 2] | 0) - (f[(f[B >> 2] | 0) + (Q << 2) >> 2] | 0) | 0; a: do if (R) { if (U >>> 0 < 3) { W = f[y >> 2] | 0; f[W >> 2] = Q; Y = f[i >> 2] | 0; if (Y >>> 0 > 1) { Z = 1; $ = Y; aa = Q; while (1) { aa = (aa | 0) == ($ + -1 | 0) ? 0 : aa + 1 | 0; f[W + (Z << 2) >> 2] = aa; Z = Z + 1 | 0; ba = f[i >> 2] | 0; if (Z >>> 0 >= ba >>> 0) { ca = ba; break } else $ = ba } } else ca = Y; if (!U) { da = 87; break } else { ea = 0; fa = ca } while (1) { $ = (f[K >> 2] | 0) + ((X(f[J >> 2] | 0, P + ea | 0) | 0) << 2) | 0; if (!fa) ga = 0; else { Z = 0; do { aa = f[(f[y >> 2] | 0) + (Z << 2) >> 2] | 0; W = (f[a >> 2] | 0) - (f[(f[B >> 2] | 0) + (aa << 2) >> 2] | 0) | 0; do if (W | 0) { ba = f[A >> 2] | 0; ha = 32 - ba | 0; ia = 32 - W | 0; ja = f[$ + (aa << 2) >> 2] << ia; if ((W | 0) > (ha | 0)) { ka = ja >>> ia; ia = W - ha | 0; f[A >> 2] = ia; ha = f[j >> 2] | ka >>> ia; f[j >> 2] = ha; ia = f[l >> 2] | 0; if ((ia | 0) == (f[o >> 2] | 0)) Ci(p, j); else { f[ia >> 2] = ha; f[l >> 2] = ia + 4 } f[j >> 2] = ka << 32 - (f[A >> 2] | 0); break } ka = f[j >> 2] | ja >>> ba; f[j >> 2] = ka; ja = ba + W | 0; f[A >> 2] = ja; if ((ja | 0) != 32) break; ja = f[l >> 2] | 0; if ((ja | 0) == (f[o >> 2] | 0)) Ci(p, j); else { f[ja >> 2] = ka; f[l >> 2] = ja + 4 } f[j >> 2] = 0; f[A >> 2] = 0 } while (0); Z = Z + 1 | 0; W = f[i >> 2] | 0 } while (Z >>> 0 < W >>> 0); ga = W } ea = ea + 1 | 0; if (ea >>> 0 >= U >>> 0) { da = 87; break a } else fa = ga } } Y = V + 1 | 0; Z = f[m >> 2] | 0; $ = Z + (Y * 12 | 0) | 0; if (($ | 0) == (S | 0)) la = Z; else { qg($, f[S >> 2] | 0, f[O + (V * 12 | 0) + 4 >> 2] | 0); la = f[m >> 2] | 0 } $ = (f[la + (Y * 12 | 0) >> 2] | 0) + (Q << 2) | 0; Z = (f[$ >> 2] | 0) + (1 << R + -1) | 0; f[$ >> 2] = Z; $ = f[C >> 2] | 0; W = f[D >> 2] | 0; b: do if ((T | 0) == (P | 0)) ma = P; else { aa = f[L >> 2] | 0; if (!$) { if ((f[aa + (Q << 2) >> 2] | 0) >>> 0 < Z >>> 0) { ma = T; break } else { na = T; oa = P } while (1) { ja = na; do { ja = ja + -1 | 0; if ((oa | 0) == (ja | 0)) { ma = oa; break b } ka = (f[M >> 2] | 0) + ((X(ja, W) | 0) << 2) + (Q << 2) | 0 } while ((f[ka >> 2] | 0) >>> 0 >= Z >>> 0); oa = oa + 1 | 0; if ((oa | 0) == (ja | 0)) { ma = ja; break b } else na = ja } } else { pa = T; qa = P } while (1) { ka = qa; while (1) { ra = aa + ((X(ka, $) | 0) << 2) | 0; if ((f[ra + (Q << 2) >> 2] | 0) >>> 0 >= Z >>> 0) { sa = pa; break } ba = ka + 1 | 0; if ((ba | 0) == (pa | 0)) { ma = pa; break b } else ka = ba } while (1) { sa = sa + -1 | 0; if ((ka | 0) == (sa | 0)) { ma = ka; break b } ta = (f[M >> 2] | 0) + ((X(sa, W) | 0) << 2) | 0; if ((f[ta + (Q << 2) >> 2] | 0) >>> 0 < Z >>> 0) { ua = 0; break } } do { ja = ra + (ua << 2) | 0; ba = ta + (ua << 2) | 0; ia = f[ja >> 2] | 0; f[ja >> 2] = f[ba >> 2]; f[ba >> 2] = ia; ua = ua + 1 | 0 } while ((ua | 0) != ($ | 0)); qa = ka + 1 | 0; if ((qa | 0) == (sa | 0)) { ma = sa; break } else pa = sa } } while (0); Z = (_(U | 0) | 0) ^ 31; W = ma - P | 0; aa = T - ma | 0; ia = W >>> 0 < aa >>> 0; if ((W | 0) != (aa | 0)) { ba = f[E >> 2] | 0; if (ia) f[F >> 2] = f[F >> 2] | 1 << 31 - ba; ja = ba + 1 | 0; f[E >> 2] = ja; if ((ja | 0) == 32) { ja = f[G >> 2] | 0; if ((ja | 0) == (f[H >> 2] | 0)) Ci(I, F); else { f[ja >> 2] = f[F >> 2]; f[G >> 2] = ja + 4 } f[E >> 2] = 0; f[F >> 2] = 0 } } ja = U >>> 1; if (ia) { ia = ja - W | 0; if (Z | 0) { ba = 0; ha = 1 << Z + -1; while (1) { Vi(a + 12 + (ba << 5) | 0, (ha & ia | 0) != 0); ba = ba + 1 | 0; if ((ba | 0) == (Z | 0)) break; else ha = ha >>> 1 } } } else { ha = ja - aa | 0; if (Z | 0) { ba = 0; ia = 1 << Z + -1; while (1) { Vi(a + 12 + (ba << 5) | 0, (ia & ha | 0) != 0); ba = ba + 1 | 0; if ((ba | 0) == (Z | 0)) break; else ia = ia >>> 1 } } } ia = f[v >> 2] | 0; Z = f[ia + (V * 12 | 0) >> 2] | 0; ba = Z + (Q << 2) | 0; f[ba >> 2] = (f[ba >> 2] | 0) + 1; qg(ia + (Y * 12 | 0) | 0, Z, f[ia + (V * 12 | 0) + 4 >> 2] | 0); if ((ma | 0) != (P | 0)) { ia = f[q >> 2] | 0; Z = f[w >> 2] | 0; ba = ia - Z >> 2; ha = f[x >> 2] | 0; ja = f[n >> 2] | 0; if ((((ba | 0) == 0 ? 0 : (ba * 113 | 0) + -1 | 0) | 0) == (ja + ha | 0)) { Jc(h); va = f[x >> 2] | 0; wa = f[n >> 2] | 0; xa = f[q >> 2] | 0; ya = f[w >> 2] | 0 } else { va = ha; wa = ja; xa = ia; ya = Z } Z = wa + va | 0; if ((xa | 0) == (ya | 0)) za = 0; else za = (f[ya + (((Z >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((Z >>> 0) % 113 | 0) * 36 | 0) | 0; f[za >> 2] = P; Z = za + 4 | 0; f[Z >> 2] = t; f[Z + 4 >> 2] = z; f[za + 12 >> 2] = ma; f[za + 16 >> 2] = k; f[za + 20 >> 2] = $; f[za + 24 >> 2] = Q; f[za + 28 >> 2] = W; f[za + 32 >> 2] = V; f[n >> 2] = (f[n >> 2] | 0) + 1 } if ((T | 0) != (ma | 0)) { Z = f[q >> 2] | 0; ia = f[w >> 2] | 0; ja = Z - ia >> 2; ha = f[x >> 2] | 0; ba = f[n >> 2] | 0; if ((((ja | 0) == 0 ? 0 : (ja * 113 | 0) + -1 | 0) | 0) == (ba + ha | 0)) { Jc(h); Aa = f[x >> 2] | 0; Ba = f[n >> 2] | 0; Ca = f[q >> 2] | 0; Da = f[w >> 2] | 0 } else { Aa = ha; Ba = ba; Ca = Z; Da = ia } ia = Ba + Aa | 0; if ((Ca | 0) == (Da | 0)) Ea = 0; else Ea = (f[Da + (((ia >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((ia >>> 0) % 113 | 0) * 36 | 0) | 0; f[Ea >> 2] = ma; f[Ea + 4 >> 2] = k; f[Ea + 8 >> 2] = $; f[Ea + 12 >> 2] = T; ia = Ea + 16 | 0; f[ia >> 2] = r; f[ia + 4 >> 2] = s; f[Ea + 24 >> 2] = Q; f[Ea + 28 >> 2] = aa; f[Ea + 32 >> 2] = Y; ia = (f[n >> 2] | 0) + 1 | 0; f[n >> 2] = ia; Fa = ia } else da = 87 } else da = 87; while (0); if ((da | 0) == 87) { da = 0; Fa = f[n >> 2] | 0 } if (!Fa) break; else N = Fa } } Fa = f[w >> 2] | 0; N = f[x >> 2] | 0; Ea = Fa + (((N >>> 0) / 113 | 0) << 2) | 0; s = f[q >> 2] | 0; r = s; k = Fa; if ((s | 0) == (Fa | 0)) { Ga = 0; Ha = 0 } else { ma = (f[Ea >> 2] | 0) + (((N >>> 0) % 113 | 0) * 36 | 0) | 0; Ga = ma; Ha = ma } ma = Ea; Ea = Ha; c: while (1) { Ha = Ea; do { N = Ha; if ((Ga | 0) == (N | 0)) break c; Ha = N + 36 | 0 } while ((Ha - (f[ma >> 2] | 0) | 0) != 4068); Ha = ma + 4 | 0; ma = Ha; Ea = f[Ha >> 2] | 0 } f[n >> 2] = 0; n = r - k >> 2; if (n >>> 0 > 2) { k = Fa; do { br(f[k >> 2] | 0); k = (f[w >> 2] | 0) + 4 | 0; f[w >> 2] = k; Ia = f[q >> 2] | 0; Ja = Ia - k >> 2 } while (Ja >>> 0 > 2); Ka = Ja; La = k; Ma = Ia } else { Ka = n; La = Fa; Ma = s } switch (Ka | 0) { case 1: { Na = 56; da = 101; break } case 2: { Na = 113; da = 101; break } default: { } }if ((da | 0) == 101) f[x >> 2] = Na; if ((La | 0) != (Ma | 0)) { Na = La; do { br(f[Na >> 2] | 0); Na = Na + 4 | 0 } while ((Na | 0) != (Ma | 0)); Ma = f[w >> 2] | 0; w = f[q >> 2] | 0; if ((w | 0) != (Ma | 0)) f[q >> 2] = w + (~((w + -4 - Ma | 0) >>> 2) << 2) } Ma = f[h >> 2] | 0; if (!Ma) { u = d; return } br(Ma); u = d; return } function kb(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0; d = u; u = u + 1424 | 0; e = d + 1408 | 0; g = d + 1396 | 0; h = d + 1420 | 0; i = d + 1200 | 0; j = d + 12 | 0; k = d; l = d + 1384 | 0; m = d + 1372 | 0; n = d + 1360 | 0; o = d + 1348 | 0; p = d + 1336 | 0; q = d + 1324 | 0; r = d + 1312 | 0; s = d + 1300 | 0; t = d + 1288 | 0; v = d + 1276 | 0; w = d + 1264 | 0; x = d + 1252 | 0; y = d + 1240 | 0; z = d + 1228 | 0; A = a + 28 | 0; B = 10 - (Yh(f[(f[A >> 2] | 0) + 48 >> 2] | 0) | 0) | 0; C = (B | 0) < 6 ? B : 6; b[h >> 0] = C; if ((C & 255 | 0) == 6 ? (f[a + 72 >> 2] | 0) > 15 : 0) b[h >> 0] = 5; C = c + 16 | 0; B = f[C + 4 >> 2] | 0; if (!((B | 0) > 0 | (B | 0) == 0 & (f[C >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0 } C = f[A >> 2] | 0; B = f[(f[C + 4 >> 2] | 0) + 80 >> 2] | 0; D = a + 72 | 0; E = f[D >> 2] | 0; f[i >> 2] = B; F = i + 4 | 0; f[F >> 2] = E; f[i + 8 >> 2] = E << 2; G = i + 12 | 0; H = X(E, B) | 0; f[G >> 2] = 0; J = i + 16 | 0; f[J >> 2] = 0; f[i + 20 >> 2] = 0; do if (H) if (H >>> 0 > 1073741823) mq(G); else { K = H << 2; L = dn(K) | 0; f[G >> 2] = L; M = L + (H << 2) | 0; f[i + 20 >> 2] = M; hj(L | 0, 0, K | 0) | 0; f[J >> 2] = M; N = L; break } else N = 0; while (0); H = i + 24 | 0; f[H >> 2] = N; G = a + 4 | 0; L = a + 8 | 0; M = f[G >> 2] | 0; a: do if ((f[L >> 2] | 0) != (M | 0)) { K = j + 4 | 0; O = j + 8 | 0; P = j + 8 | 0; Q = (B | 0) == 0; R = j + 4 | 0; S = j + 8 | 0; T = k + 4 | 0; U = k + 8 | 0; V = k + 8 | 0; W = a + 48 | 0; Y = j + 8 | 0; Z = a + 60 | 0; $ = 0; aa = 0; ba = 0; ca = 0; da = M; ea = C; b: while (1) { fa = f[(f[(f[ea + 4 >> 2] | 0) + 8 >> 2] | 0) + (f[da + (ca << 2) >> 2] << 2) >> 2] | 0; switch (f[fa + 28 >> 2] | 0) { case 1: case 3: case 5: case 2: case 4: case 6: { ga = fa; ha = aa; break } case 9: { ga = f[(f[Z >> 2] | 0) + (aa << 2) >> 2] | 0; ha = aa + 1 | 0; break } default: { ia = 0; break a } }if (!ga) { ia = 0; break a } c: do switch (f[ga + 28 >> 2] | 0) { case 6: { if (Q) { ja = ba; ka = ga + 24 | 0; break c } fa = ga + 84 | 0; la = ga + 68 | 0; ma = ga + 48 | 0; na = ga + 40 | 0; oa = ga + 24 | 0; pa = 0; do { if (!(b[fa >> 0] | 0)) qa = f[(f[la >> 2] | 0) + (pa << 2) >> 2] | 0; else qa = pa; ra = ma; sa = f[ra >> 2] | 0; ta = f[ra + 4 >> 2] | 0; ra = na; ua = on(f[ra >> 2] | 0, f[ra + 4 >> 2] | 0, qa | 0, 0) | 0; ra = Tn(ua | 0, I | 0, sa | 0, ta | 0) | 0; Rg((f[H >> 2] | 0) + ((X(f[F >> 2] | 0, pa) | 0) << 2) + ($ << 2) | 0, (f[f[ga >> 2] >> 2] | 0) + ra | 0, b[oa >> 0] << 2 | 0) | 0; pa = pa + 1 | 0 } while ((pa | 0) != (B | 0)); ja = ba; ka = oa; break } case 1: case 3: case 5: { oa = ga + 24 | 0; pa = b[oa >> 0] | 0; na = pa << 24 >> 24; f[j >> 2] = 0; f[R >> 2] = 0; f[S >> 2] = 0; if (!(pa << 24 >> 24)) va = 0; else { if (pa << 24 >> 24 < 0) { wa = 24; break b } pa = na << 2; ma = dn(pa) | 0; f[j >> 2] = ma; la = ma + (na << 2) | 0; f[Y >> 2] = la; hj(ma | 0, 0, pa | 0) | 0; f[R >> 2] = la; va = b[oa >> 0] | 0 } la = va << 24 >> 24; f[k >> 2] = 0; f[T >> 2] = 0; f[U >> 2] = 0; if (!(va << 24 >> 24)) { xa = 0; ya = 0 } else { if (va << 24 >> 24 < 0) { wa = 30; break b } pa = la << 2; ma = dn(pa) | 0; f[k >> 2] = ma; na = ma + (la << 2) | 0; f[V >> 2] = na; hj(ma | 0, 0, pa | 0) | 0; f[T >> 2] = na; xa = ma; ya = ma } if (Q) { za = ya; Aa = xa } else { ma = ga + 84 | 0; na = ga + 68 | 0; pa = 0; do { if (!(b[ma >> 0] | 0)) Ba = f[(f[na >> 2] | 0) + (pa << 2) >> 2] | 0; else Ba = pa; la = f[j >> 2] | 0; f[g >> 2] = Ba; fa = b[oa >> 0] | 0; f[e >> 2] = f[g >> 2]; Pb(ga, e, fa, la) | 0; la = b[oa >> 0] | 0; fa = la << 24 >> 24; if (la << 24 >> 24 > 0) { la = f[j >> 2] | 0; ra = f[W >> 2] | 0; ta = f[k >> 2] | 0; sa = 0; do { f[ta + (sa << 2) >> 2] = (f[la + (sa << 2) >> 2] | 0) - (f[ra + (sa + ba << 2) >> 2] | 0); sa = sa + 1 | 0 } while ((sa | 0) < (fa | 0)); Ca = ta } else Ca = f[k >> 2] | 0; Rg((f[H >> 2] | 0) + ((X(f[F >> 2] | 0, pa) | 0) << 2) + ($ << 2) | 0, Ca | 0, fa << 2 | 0) | 0; pa = pa + 1 | 0 } while (pa >>> 0 < B >>> 0); pa = f[k >> 2] | 0; za = pa; Aa = pa } pa = ba + (b[oa >> 0] | 0) | 0; if (za | 0) { na = f[T >> 2] | 0; if ((na | 0) != (za | 0)) f[T >> 2] = na + (~((na + -4 - za | 0) >>> 2) << 2); br(Aa) } na = f[j >> 2] | 0; if (na | 0) { ma = f[R >> 2] | 0; if ((ma | 0) != (na | 0)) f[R >> 2] = ma + (~((ma + -4 - na | 0) >>> 2) << 2); br(na) } ja = pa; ka = oa; break } default: { pa = ga + 24 | 0; na = b[pa >> 0] | 0; ma = na << 24 >> 24; f[j >> 2] = 0; f[K >> 2] = 0; f[O >> 2] = 0; if (!(na << 24 >> 24)) { Da = 0; Ea = 0 } else { if (na << 24 >> 24 < 0) { wa = 53; break b } na = ma << 2; ta = dn(na) | 0; f[j >> 2] = ta; sa = ta + (ma << 2) | 0; f[P >> 2] = sa; hj(ta | 0, 0, na | 0) | 0; f[K >> 2] = sa; Da = ta; Ea = ta } if (Q) { Fa = Ea; Ga = Da } else { ta = ga + 84 | 0; sa = ga + 68 | 0; na = 0; do { if (!(b[ta >> 0] | 0)) Ha = f[(f[sa >> 2] | 0) + (na << 2) >> 2] | 0; else Ha = na; ma = f[j >> 2] | 0; f[g >> 2] = Ha; ra = b[pa >> 0] | 0; f[e >> 2] = f[g >> 2]; Ob(ga, e, ra, ma) | 0; Rg((f[H >> 2] | 0) + ((X(f[F >> 2] | 0, na) | 0) << 2) + ($ << 2) | 0, f[j >> 2] | 0, b[pa >> 0] << 2 | 0) | 0; na = na + 1 | 0 } while (na >>> 0 < B >>> 0); na = f[j >> 2] | 0; Fa = na; Ga = na } if (Fa | 0) { na = f[K >> 2] | 0; if ((na | 0) != (Fa | 0)) f[K >> 2] = na + (~((na + -4 - Fa | 0) >>> 2) << 2); br(Ga) } ja = ba; ka = pa } } while (0); na = ca + 1 | 0; sa = f[G >> 2] | 0; if (na >>> 0 >= (f[L >> 2] | 0) - sa >> 2 >>> 0) { wa = 66; break } $ = $ + (b[ka >> 0] | 0) | 0; aa = ha; ba = ja; ca = na; da = sa; ea = f[A >> 2] | 0 } if ((wa | 0) == 24) mq(j); else if ((wa | 0) == 30) mq(k); else if ((wa | 0) == 53) mq(j); else if ((wa | 0) == 66) { Ia = f[D >> 2] | 0; Ja = f[H >> 2] | 0; wa = 67; break } } else { Ia = E; Ja = N; wa = 67 } while (0); d: do if ((wa | 0) == 67) { N = X(Ia, B) | 0; if ((N | 0) > 0) { E = 0; H = 0; while (1) { D = f[Ja + (E << 2) >> 2] | 0; if (!D) Ka = H; else { A = (_(D | 0) | 0) ^ 31; Ka = (A | 0) < (H | 0) ? H : A + 1 | 0 } E = E + 1 | 0; if ((E | 0) >= (N | 0)) { La = Ka; break } else H = Ka } } else La = 0; switch (b[h >> 0] | 0) { case 6: { Ge(j, Ia); f[l >> 2] = 0; f[l + 4 >> 2] = i; H = f[F >> 2] | 0; f[l + 8 >> 2] = H; f[m >> 2] = f[i >> 2]; f[m + 4 >> 2] = i; f[m + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[l >> 2]; f[g + 4 >> 2] = f[l + 4 >> 2]; f[g + 8 >> 2] = f[l + 8 >> 2]; f[e >> 2] = f[m >> 2]; f[e + 4 >> 2] = f[m + 4 >> 2]; f[e + 8 >> 2] = f[m + 8 >> 2]; H = ff(j, g, e, k, c) | 0; Ee(j); if (!H) { ia = 0; break d } break } case 5: { Ge(j, Ia); f[n >> 2] = 0; f[n + 4 >> 2] = i; H = f[F >> 2] | 0; f[n + 8 >> 2] = H; f[o >> 2] = f[i >> 2]; f[o + 4 >> 2] = i; f[o + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[n >> 2]; f[g + 4 >> 2] = f[n + 4 >> 2]; f[g + 8 >> 2] = f[n + 8 >> 2]; f[e >> 2] = f[o >> 2]; f[e + 4 >> 2] = f[o + 4 >> 2]; f[e + 8 >> 2] = f[o + 8 >> 2]; H = gf(j, g, e, k, c) | 0; Ee(j); if (!H) { ia = 0; break d } break } case 4: { Ge(j, Ia); f[p >> 2] = 0; f[p + 4 >> 2] = i; H = f[F >> 2] | 0; f[p + 8 >> 2] = H; f[q >> 2] = f[i >> 2]; f[q + 4 >> 2] = i; f[q + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[p >> 2]; f[g + 4 >> 2] = f[p + 4 >> 2]; f[g + 8 >> 2] = f[p + 8 >> 2]; f[e >> 2] = f[q >> 2]; f[e + 4 >> 2] = f[q + 4 >> 2]; f[e + 8 >> 2] = f[q + 8 >> 2]; H = gf(j, g, e, k, c) | 0; Ee(j); if (!H) { ia = 0; break d } break } case 3: { Oe(j, Ia); f[r >> 2] = 0; f[r + 4 >> 2] = i; H = f[F >> 2] | 0; f[r + 8 >> 2] = H; f[s >> 2] = f[i >> 2]; f[s + 4 >> 2] = i; f[s + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[r >> 2]; f[g + 4 >> 2] = f[r + 4 >> 2]; f[g + 8 >> 2] = f[r + 8 >> 2]; f[e >> 2] = f[s >> 2]; f[e + 4 >> 2] = f[s + 4 >> 2]; f[e + 8 >> 2] = f[s + 8 >> 2]; H = mf(j, g, e, k, c) | 0; Ue(j); if (!H) { ia = 0; break d } break } case 2: { Oe(j, Ia); f[t >> 2] = 0; f[t + 4 >> 2] = i; H = f[F >> 2] | 0; f[t + 8 >> 2] = H; f[v >> 2] = f[i >> 2]; f[v + 4 >> 2] = i; f[v + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[t >> 2]; f[g + 4 >> 2] = f[t + 4 >> 2]; f[g + 8 >> 2] = f[t + 8 >> 2]; f[e >> 2] = f[v >> 2]; f[e + 4 >> 2] = f[v + 4 >> 2]; f[e + 8 >> 2] = f[v + 8 >> 2]; H = mf(j, g, e, k, c) | 0; Ue(j); if (!H) { ia = 0; break d } break } case 1: { Pe(j, Ia); f[w >> 2] = 0; f[w + 4 >> 2] = i; H = f[F >> 2] | 0; f[w + 8 >> 2] = H; f[x >> 2] = f[i >> 2]; f[x + 4 >> 2] = i; f[x + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[w >> 2]; f[g + 4 >> 2] = f[w + 4 >> 2]; f[g + 8 >> 2] = f[w + 8 >> 2]; f[e >> 2] = f[x >> 2]; f[e + 4 >> 2] = f[x + 4 >> 2]; f[e + 8 >> 2] = f[x + 8 >> 2]; H = lf(j, g, e, k, c) | 0; Te(j); if (!H) { ia = 0; break d } break } case 0: { Pe(j, Ia); f[y >> 2] = 0; f[y + 4 >> 2] = i; H = f[F >> 2] | 0; f[y + 8 >> 2] = H; f[z >> 2] = f[i >> 2]; f[z + 4 >> 2] = i; f[z + 8 >> 2] = H; f[k >> 2] = La; f[g >> 2] = f[y >> 2]; f[g + 4 >> 2] = f[y + 4 >> 2]; f[g + 8 >> 2] = f[y + 8 >> 2]; f[e >> 2] = f[z >> 2]; f[e + 4 >> 2] = f[z + 4 >> 2]; f[e + 8 >> 2] = f[z + 8 >> 2]; H = lf(j, g, e, k, c) | 0; Te(j); if (!H) { ia = 0; break d } break } default: { ia = 0; break d } }ia = 1 } while (0); j = f[i + 12 >> 2] | 0; if (!j) { u = d; return ia | 0 } i = f[J >> 2] | 0; if ((i | 0) != (j | 0)) f[J >> 2] = i + (~((i + -4 - j | 0) >>> 2) << 2); br(j); u = d; return ia | 0 } function lb(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0; d = u; u = u + 80 | 0; e = d + 56 | 0; g = d + 52 | 0; h = d + 48 | 0; i = d + 68 | 0; j = d; k = d + 44 | 0; l = d + 40 | 0; m = d + 36 | 0; n = d + 32 | 0; o = d + 28 | 0; p = d + 24 | 0; q = d + 20 | 0; r = d + 16 | 0; s = d + 12 | 0; if (!(b[c + 352 >> 0] | 0)) { Ne(e, f[c + 8 >> 2] | 0); t = c + 12 | 0; v = f[e >> 2] | 0; f[e >> 2] = 0; w = f[t >> 2] | 0; f[t >> 2] = v; if (w) { ui(w); br(w); w = f[e >> 2] | 0; f[e >> 2] = 0; if (w | 0) { ui(w); br(w) } } else f[e >> 2] = 0 } else { Mg(e, f[c + 8 >> 2] | 0); w = c + 12 | 0; v = f[e >> 2] | 0; f[e >> 2] = 0; t = f[w >> 2] | 0; f[w >> 2] = v; if (t) { ui(t); br(t); t = f[e >> 2] | 0; f[e >> 2] = 0; if (t | 0) { ui(t); br(t) } } else f[e >> 2] = 0 } t = c + 12 | 0; v = f[t >> 2] | 0; if (v | 0 ? (((f[v + 4 >> 2] | 0) - (f[v >> 2] | 0) >> 2 >>> 0) / 3 | 0 | 0) != (f[v + 40 >> 2] | 0) : 0) { v = c + 200 | 0; Td(v, c) | 0; w = f[t >> 2] | 0; x = c + 4 | 0; Nh(((f[w + 28 >> 2] | 0) - (f[w + 24 >> 2] | 0) >> 2) - (f[w + 44 >> 2] | 0) | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; w = f[t >> 2] | 0; Nh((((f[w + 4 >> 2] | 0) - (f[w >> 2] | 0) >> 2 >>> 0) / 3 | 0) - (f[w + 40 >> 2] | 0) | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; w = c + 28 | 0; y = c + 8 | 0; z = f[y >> 2] | 0; A = ((f[z + 100 >> 2] | 0) - (f[z + 96 >> 2] | 0) | 0) / 12 | 0; b[e >> 0] = 0; Xg(w, A, e); A = f[t >> 2] | 0; z = (f[A + 28 >> 2] | 0) - (f[A + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(c + 52 | 0, z, e); z = c + 40 | 0; A = f[z >> 2] | 0; B = c + 44 | 0; C = f[B >> 2] | 0; if ((C | 0) != (A | 0)) f[B >> 2] = C + (~((C + -4 - A | 0) >>> 2) << 2); A = f[t >> 2] | 0; C = (f[A + 4 >> 2] | 0) - (f[A >> 2] | 0) >> 2; $j(z, C - ((C >>> 0) % 3 | 0) | 0); C = c + 84 | 0; z = f[t >> 2] | 0; A = (f[z + 28 >> 2] | 0) - (f[z + 24 >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(C, A, e); A = c + 96 | 0; z = f[A >> 2] | 0; B = c + 100 | 0; D = f[B >> 2] | 0; if ((D | 0) != (z | 0)) f[B >> 2] = D + (~((D + -4 - z | 0) >>> 2) << 2); f[c + 164 >> 2] = -1; z = c + 168 | 0; f[z >> 2] = 0; D = f[c + 108 >> 2] | 0; E = c + 112 | 0; F = f[E >> 2] | 0; if ((F | 0) != (D | 0)) f[E >> 2] = F + (~(((F + -12 - D | 0) >>> 0) / 12 | 0) * 12 | 0); D = c + 132 | 0; if (f[D >> 2] | 0) { F = c + 128 | 0; E = f[F >> 2] | 0; if (E | 0) { G = E; do { E = G; G = f[G >> 2] | 0; br(E) } while ((G | 0) != 0) } f[F >> 2] = 0; F = f[c + 124 >> 2] | 0; if (F | 0) { G = c + 120 | 0; E = 0; do { f[(f[G >> 2] | 0) + (E << 2) >> 2] = 0; E = E + 1 | 0 } while ((E | 0) != (F | 0)) } f[D >> 2] = 0 } f[c + 144 >> 2] = 0; D = f[t >> 2] | 0; F = (f[D + 28 >> 2] | 0) - (f[D + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(c + 152 | 0, F, e); F = c + 72 | 0; D = f[F >> 2] | 0; E = c + 76 | 0; G = f[E >> 2] | 0; if ((G | 0) != (D | 0)) f[E >> 2] = G + (~((G + -4 - D | 0) >>> 2) << 2); D = f[t >> 2] | 0; $j(F, ((f[D + 4 >> 2] | 0) - (f[D >> 2] | 0) >> 2 >>> 0) / 3 | 0); f[c + 64 >> 2] = 0; if (!(oe(c) | 0)) { D = dn(32) | 0; f[e >> 2] = D; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; H = D; I = 13227; J = H + 29 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[D + 29 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } if (!(bh(c) | 0)) { D = dn(48) | 0; f[e >> 2] = D; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 36; H = D; I = 13257; J = H + 36 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[D + 36 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } D = c + 172 | 0; G = c + 176 | 0; K = (((f[G >> 2] | 0) - (f[D >> 2] | 0) | 0) / 136 | 0) & 255; b[i >> 0] = K; L = f[(f[x >> 2] | 0) + 44 >> 2] | 0; M = L + 16 | 0; N = f[M + 4 >> 2] | 0; if ((N | 0) > 0 | (N | 0) == 0 & (f[M >> 2] | 0) >>> 0 > 0) O = K; else { f[g >> 2] = f[L + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(L, e, i, i + 1 | 0) | 0; O = b[i >> 0] | 0 } f[c + 284 >> 2] = O & 255; O = f[t >> 2] | 0; i = (f[O + 4 >> 2] | 0) - (f[O >> 2] | 0) | 0; O = i >> 2; Ti(v); f[j >> 2] = 0; L = j + 4 | 0; f[L >> 2] = 0; f[j + 8 >> 2] = 0; a: do if ((i | 0) > 0) { K = c + 104 | 0; M = j + 8 | 0; N = 0; b: while (1) { P = (N >>> 0) / 3 | 0; Q = P >>> 5; R = 1 << (P & 31); if ((f[(f[w >> 2] | 0) + (Q << 2) >> 2] & R | 0) == 0 ? (S = f[t >> 2] | 0, f[k >> 2] = P, f[e >> 2] = f[k >> 2], !(Rj(S, e) | 0)) : 0) { f[g >> 2] = 0; f[l >> 2] = P; f[e >> 2] = f[l >> 2]; P = gg(c, e, g) | 0; Vi(v, P); S = f[g >> 2] | 0; T = (S | 0) == -1; do if (P) { do if (T) { U = -1; V = -1; W = -1 } else { X = f[f[t >> 2] >> 2] | 0; Y = f[X + (S << 2) >> 2] | 0; Z = S + 1 | 0; _ = ((Z >>> 0) % 3 | 0 | 0) == 0 ? S + -2 | 0 : Z; if ((_ | 0) == -1) $ = -1; else $ = f[X + (_ << 2) >> 2] | 0; _ = (((S >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + S | 0; if ((_ | 0) == -1) { U = -1; V = $; W = Y; break } U = f[X + (_ << 2) >> 2] | 0; V = $; W = Y } while (0); Y = f[C >> 2] | 0; _ = Y + (W >>> 5 << 2) | 0; f[_ >> 2] = f[_ >> 2] | 1 << (W & 31); _ = Y + (V >>> 5 << 2) | 0; f[_ >> 2] = f[_ >> 2] | 1 << (V & 31); _ = Y + (U >>> 5 << 2) | 0; f[_ >> 2] = f[_ >> 2] | 1 << (U & 31); f[e >> 2] = 1; _ = f[B >> 2] | 0; if (_ >>> 0 < (f[K >> 2] | 0) >>> 0) { f[_ >> 2] = 1; f[B >> 2] = _ + 4 } else Ci(A, e); _ = (f[w >> 2] | 0) + (Q << 2) | 0; f[_ >> 2] = f[_ >> 2] | R; _ = S + 1 | 0; if (T) aa = -1; else aa = ((_ >>> 0) % 3 | 0 | 0) == 0 ? S + -2 | 0 : _; f[e >> 2] = aa; Y = f[L >> 2] | 0; if (Y >>> 0 < (f[M >> 2] | 0) >>> 0) { f[Y >> 2] = aa; f[L >> 2] = Y + 4 } else Ci(j, e); if (T) break; Y = ((_ >>> 0) % 3 | 0 | 0) == 0 ? S + -2 | 0 : _; if ((Y | 0) == -1) break; _ = f[(f[(f[t >> 2] | 0) + 12 >> 2] | 0) + (Y << 2) >> 2] | 0; Y = (_ | 0) == -1; X = Y ? -1 : (_ >>> 0) / 3 | 0; if (Y) break; if (f[(f[w >> 2] | 0) + (X >>> 5 << 2) >> 2] & 1 << (X & 31) | 0) break; f[m >> 2] = _; f[e >> 2] = f[m >> 2]; if (!(Zb(c, e) | 0)) { ba = 65; break b } } else { _ = S + 1 | 0; if (T) ca = -1; else ca = ((_ >>> 0) % 3 | 0 | 0) == 0 ? S + -2 | 0 : _; f[n >> 2] = ca; f[e >> 2] = f[n >> 2]; Ce(c, e, 1) | 0; f[o >> 2] = f[g >> 2]; f[e >> 2] = f[o >> 2]; if (!(Zb(c, e) | 0)) { ba = 71; break b } } while (0) } N = N + 1 | 0; if ((N | 0) >= (O | 0)) { ba = 77; break a } } if ((ba | 0) == 65) { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; N = dn(48) | 0; f[e >> 2] = N; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 32; H = N; I = 13294; J = H + 32 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[N + 32 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0) } else if ((ba | 0) == 71) { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; M = dn(48) | 0; f[e >> 2] = M; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 32; H = M; I = 13294; J = H + 32 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[M + 32 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0) } } else ba = 77; while (0); do if ((ba | 0) == 77) { O = f[F >> 2] | 0; o = f[E >> 2] | 0; n = o; if ((O | 0) != (o | 0) ? (ca = o + -4 | 0, O >>> 0 < ca >>> 0) : 0) { o = O; O = ca; do { ca = f[o >> 2] | 0; f[o >> 2] = f[O >> 2]; f[O >> 2] = ca; o = o + 4 | 0; O = O + -4 | 0 } while (o >>> 0 < O >>> 0) } f[p >> 2] = n; f[q >> 2] = f[j >> 2]; f[r >> 2] = f[L >> 2]; f[h >> 2] = f[p >> 2]; f[g >> 2] = f[q >> 2]; f[e >> 2] = f[r >> 2]; Md(F, h, g, e) | 0; if ((f[G >> 2] | 0) != (f[D >> 2] | 0) ? (O = f[y >> 2] | 0, o = ((f[O + 100 >> 2] | 0) - (f[O + 96 >> 2] | 0) | 0) / 12 | 0, b[e >> 0] = 0, Xg(w, o, e), o = f[F >> 2] | 0, O = f[E >> 2] | 0, (o | 0) != (O | 0)) : 0) { M = o; do { f[s >> 2] = f[M >> 2]; f[e >> 2] = f[s >> 2]; ue(c, e) | 0; M = M + 4 | 0 } while ((M | 0) != (O | 0)) } $h(v); Nh(f[c + 324 >> 2] | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; Nh(f[z >> 2] | 0, f[(f[x >> 2] | 0) + 44 >> 2] | 0) | 0; if (Jg(c) | 0) { O = f[(f[x >> 2] | 0) + 44 >> 2] | 0; M = f[c + 232 >> 2] | 0; n = O + 16 | 0; o = f[n + 4 >> 2] | 0; if (!((o | 0) > 0 | (o | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) { n = (f[c + 236 >> 2] | 0) - M | 0; f[g >> 2] = f[O + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(O, e, M, M + n | 0) | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; break } else { f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; n = dn(32) | 0; f[e >> 2] = n; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 28; H = n; I = 13327; J = H + 28 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[n + 28 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); break } } while (0); g = f[j >> 2] | 0; if (g | 0) { j = f[L >> 2] | 0; if ((j | 0) != (g | 0)) f[L >> 2] = j + (~((j + -4 - g | 0) >>> 2) << 2); br(g) } u = d; return } g = dn(32) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483616; f[e + 4 >> 2] = 29; H = g; I = 13197; J = H + 29 | 0; do { b[H >> 0] = b[I >> 0] | 0; H = H + 1 | 0; I = I + 1 | 0 } while ((H | 0) < (J | 0)); b[g + 29 >> 0] = 0; f[a >> 2] = -1; dj(a + 4 | 0, e); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); u = d; return } function mb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0; d = u; u = u + 32 | 0; e = d; g = a + 8 | 0; h = f[g >> 2] | 0; f[e >> 2] = 0; i = e + 4 | 0; f[i >> 2] = 0; f[e + 8 >> 2] = 0; do if (h) if (h >>> 0 > 1073741823) mq(e); else { j = h << 2; k = dn(j) | 0; f[e >> 2] = k; l = k + (h << 2) | 0; f[e + 8 >> 2] = l; hj(k | 0, 0, j | 0) | 0; f[i >> 2] = l; m = l; n = k; break } else { m = 0; n = 0 } while (0); k = a + 1164 | 0; l = f[k >> 2] | 0; j = f[l >> 2] | 0; o = l + 4 | 0; if (!j) { p = l + 8 | 0; q = n; r = m; s = h } else { h = f[o >> 2] | 0; if ((h | 0) != (j | 0)) f[o >> 2] = h + (~((h + -4 - j | 0) >>> 2) << 2); br(j); j = l + 8 | 0; f[j >> 2] = 0; f[o >> 2] = 0; f[l >> 2] = 0; p = j; q = f[e >> 2] | 0; r = f[i >> 2] | 0; s = f[g >> 2] | 0 } f[l >> 2] = q; f[o >> 2] = r; f[p >> 2] = f[e + 8 >> 2]; f[e >> 2] = 0; p = e + 4 | 0; f[p >> 2] = 0; f[e + 8 >> 2] = 0; do if (s) if (s >>> 0 > 1073741823) mq(e); else { r = s << 2; o = dn(r) | 0; f[e >> 2] = o; q = o + (s << 2) | 0; f[e + 8 >> 2] = q; hj(o | 0, 0, r | 0) | 0; f[p >> 2] = q; t = q; v = o; break } else { t = 0; v = 0 } while (0); s = a + 1176 | 0; o = f[s >> 2] | 0; q = f[o >> 2] | 0; r = o + 4 | 0; if (!q) { w = o + 8 | 0; x = v; y = t } else { t = f[r >> 2] | 0; if ((t | 0) != (q | 0)) f[r >> 2] = t + (~((t + -4 - q | 0) >>> 2) << 2); br(q); q = o + 8 | 0; f[q >> 2] = 0; f[r >> 2] = 0; f[o >> 2] = 0; w = q; x = f[e >> 2] | 0; y = f[p >> 2] | 0 } f[o >> 2] = x; f[r >> 2] = y; f[w >> 2] = f[e + 8 >> 2]; w = f[b >> 2] | 0; y = b + 4 | 0; r = f[y >> 2] | 0; x = f[y + 4 >> 2] | 0; y = f[c >> 2] | 0; o = c + 4 | 0; p = f[o >> 2] | 0; q = f[o + 4 >> 2] | 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; f[e + 12 >> 2] = 0; f[e + 16 >> 2] = 0; f[e + 20 >> 2] = 0; o = e + 8 | 0; t = e + 4 | 0; v = e + 16 | 0; l = e + 20 | 0; i = r; Jc(e); j = f[t >> 2] | 0; h = (f[l >> 2] | 0) + (f[v >> 2] | 0) | 0; if ((f[o >> 2] | 0) == (j | 0)) z = 0; else z = (f[j + (((h >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((h >>> 0) % 113 | 0) * 36 | 0) | 0; f[z >> 2] = w; h = z + 4 | 0; f[h >> 2] = r; f[h + 4 >> 2] = x; f[z + 12 >> 2] = y; h = z + 16 | 0; f[h >> 2] = p; f[h + 4 >> 2] = q; f[z + 24 >> 2] = 0; f[z + 28 >> 2] = y - w; f[z + 32 >> 2] = 0; z = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = z; if (z | 0) { w = a + 1152 | 0; y = a + 1084 | 0; h = a + 1080 | 0; j = a + 1072 | 0; m = a + 1076 | 0; n = a + 1068 | 0; A = b + 8 | 0; B = c + 8 | 0; C = a + 1124 | 0; D = a + 1120 | 0; E = a + 1112 | 0; F = a + 1116 | 0; G = a + 1108 | 0; H = i + 4 | 0; I = i + 24 | 0; J = i + 24 | 0; K = p + 24 | 0; L = z; while (1) { z = f[v >> 2] | 0; M = L + -1 | 0; N = M + z | 0; O = f[t >> 2] | 0; P = f[O + (((N >>> 0) / 113 | 0) << 2) >> 2] | 0; Q = (N >>> 0) % 113 | 0; N = f[P + (Q * 36 | 0) >> 2] | 0; R = f[P + (Q * 36 | 0) + 12 >> 2] | 0; S = f[P + (Q * 36 | 0) + 24 >> 2] | 0; T = f[P + (Q * 36 | 0) + 32 >> 2] | 0; f[l >> 2] = M; M = f[o >> 2] | 0; Q = M - O >> 2; if ((1 - L - z + ((Q | 0) == 0 ? 0 : (Q * 113 | 0) + -1 | 0) | 0) >>> 0 > 225) { br(f[M + -4 >> 2] | 0); f[o >> 2] = (f[o >> 2] | 0) + -4 } f[b >> 2] = N; f[c >> 2] = R; M = f[k >> 2] | 0; Q = ((f[g >> 2] | 0) + -1 | 0) == (S | 0) ? 0 : S + 1 | 0; S = (f[s >> 2] | 0) + (T * 12 | 0) | 0; z = R - N | 0; O = (f[a >> 2] | 0) - (f[(f[S >> 2] | 0) + (Q << 2) >> 2] | 0) | 0; a: do if (O) { if (z >>> 0 < 3) { P = f[w >> 2] | 0; f[P >> 2] = Q; U = f[g >> 2] | 0; if (U >>> 0 > 1) { V = 1; W = U; Y = Q; while (1) { Y = (Y | 0) == (W + -1 | 0) ? 0 : Y + 1 | 0; f[P + (V << 2) >> 2] = Y; V = V + 1 | 0; Z = f[g >> 2] | 0; if (V >>> 0 >= Z >>> 0) { $ = Z; break } else W = Z } } else $ = U; if (!z) { aa = 85; break } else { ba = 0; ca = $ } while (1) { W = (f[I >> 2] | 0) + ((X(f[H >> 2] | 0, N + ba | 0) | 0) << 2) | 0; if (!ca) da = 0; else { V = 0; do { Y = f[(f[w >> 2] | 0) + (V << 2) >> 2] | 0; P = (f[a >> 2] | 0) - (f[(f[S >> 2] | 0) + (Y << 2) >> 2] | 0) | 0; do if (P | 0) { Z = f[y >> 2] | 0; ea = 32 - Z | 0; fa = 32 - P | 0; ga = f[W + (Y << 2) >> 2] << fa; if ((P | 0) > (ea | 0)) { ha = ga >>> fa; fa = P - ea | 0; f[y >> 2] = fa; ea = f[h >> 2] | ha >>> fa; f[h >> 2] = ea; fa = f[j >> 2] | 0; if ((fa | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[fa >> 2] = ea; f[j >> 2] = fa + 4 } f[h >> 2] = ha << 32 - (f[y >> 2] | 0); break } ha = f[h >> 2] | ga >>> Z; f[h >> 2] = ha; ga = Z + P | 0; f[y >> 2] = ga; if ((ga | 0) != 32) break; ga = f[j >> 2] | 0; if ((ga | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[ga >> 2] = ha; f[j >> 2] = ga + 4 } f[h >> 2] = 0; f[y >> 2] = 0 } while (0); V = V + 1 | 0; P = f[g >> 2] | 0 } while (V >>> 0 < P >>> 0); da = P } ba = ba + 1 | 0; if (ba >>> 0 >= z >>> 0) { aa = 85; break a } else ca = da } } U = T + 1 | 0; qg(M + (U * 12 | 0) | 0, f[M + (T * 12 | 0) >> 2] | 0, f[M + (T * 12 | 0) + 4 >> 2] | 0); V = (f[(f[k >> 2] | 0) + (U * 12 | 0) >> 2] | 0) + (Q << 2) | 0; W = (f[V >> 2] | 0) + (1 << O + -1) | 0; f[V >> 2] = W; V = f[A >> 2] | 0; P = f[B >> 2] | 0; b: do if ((R | 0) == (N | 0)) ia = N; else { Y = f[J >> 2] | 0; if (!V) { if ((f[Y + (Q << 2) >> 2] | 0) >>> 0 < W >>> 0) { ia = R; break } else { ja = R; ka = N } while (1) { ga = ja; do { ga = ga + -1 | 0; if ((ka | 0) == (ga | 0)) { ia = ka; break b } ha = (f[K >> 2] | 0) + ((X(ga, P) | 0) << 2) + (Q << 2) | 0 } while ((f[ha >> 2] | 0) >>> 0 >= W >>> 0); ka = ka + 1 | 0; if ((ka | 0) == (ga | 0)) { ia = ga; break b } else ja = ga } } else { la = R; ma = N } while (1) { ha = ma; while (1) { na = Y + ((X(ha, V) | 0) << 2) | 0; if ((f[na + (Q << 2) >> 2] | 0) >>> 0 >= W >>> 0) { oa = la; break } Z = ha + 1 | 0; if ((Z | 0) == (la | 0)) { ia = la; break b } else ha = Z } while (1) { oa = oa + -1 | 0; if ((ha | 0) == (oa | 0)) { ia = ha; break b } pa = (f[K >> 2] | 0) + ((X(oa, P) | 0) << 2) | 0; if ((f[pa + (Q << 2) >> 2] | 0) >>> 0 < W >>> 0) { qa = 0; break } } do { ga = na + (qa << 2) | 0; Z = pa + (qa << 2) | 0; fa = f[ga >> 2] | 0; f[ga >> 2] = f[Z >> 2]; f[Z >> 2] = fa; qa = qa + 1 | 0 } while ((qa | 0) != (V | 0)); ma = ha + 1 | 0; if ((ma | 0) == (oa | 0)) { ia = oa; break } else la = oa } } while (0); W = (_(z | 0) | 0) ^ 31; P = ia - N | 0; Y = R - ia | 0; fa = P >>> 0 < Y >>> 0; if ((P | 0) != (Y | 0)) { Z = f[C >> 2] | 0; if (fa) f[D >> 2] = f[D >> 2] | 1 << 31 - Z; ga = Z + 1 | 0; f[C >> 2] = ga; if ((ga | 0) == 32) { ga = f[E >> 2] | 0; if ((ga | 0) == (f[F >> 2] | 0)) Ci(G, D); else { f[ga >> 2] = f[D >> 2]; f[E >> 2] = ga + 4 } f[C >> 2] = 0; f[D >> 2] = 0 } } ga = z >>> 1; if (fa) { fa = ga - P | 0; if (W | 0) { Z = 0; ea = 1 << W + -1; while (1) { Vi(a + 12 + (Z << 5) | 0, (ea & fa | 0) != 0); Z = Z + 1 | 0; if ((Z | 0) == (W | 0)) break; else ea = ea >>> 1 } } } else { ea = ga - Y | 0; if (W | 0) { Z = 0; fa = 1 << W + -1; while (1) { Vi(a + 12 + (Z << 5) | 0, (fa & ea | 0) != 0); Z = Z + 1 | 0; if ((Z | 0) == (W | 0)) break; else fa = fa >>> 1 } } } fa = f[s >> 2] | 0; W = f[fa + (T * 12 | 0) >> 2] | 0; Z = W + (Q << 2) | 0; f[Z >> 2] = (f[Z >> 2] | 0) + 1; qg(fa + (U * 12 | 0) | 0, W, f[fa + (T * 12 | 0) + 4 >> 2] | 0); if ((ia | 0) != (N | 0)) { fa = f[o >> 2] | 0; W = f[t >> 2] | 0; Z = fa - W >> 2; ea = f[v >> 2] | 0; ga = f[l >> 2] | 0; if ((((Z | 0) == 0 ? 0 : (Z * 113 | 0) + -1 | 0) | 0) == (ga + ea | 0)) { Jc(e); ra = f[v >> 2] | 0; sa = f[l >> 2] | 0; ta = f[o >> 2] | 0; ua = f[t >> 2] | 0 } else { ra = ea; sa = ga; ta = fa; ua = W } W = sa + ra | 0; if ((ta | 0) == (ua | 0)) va = 0; else va = (f[ua + (((W >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((W >>> 0) % 113 | 0) * 36 | 0) | 0; f[va >> 2] = N; W = va + 4 | 0; f[W >> 2] = r; f[W + 4 >> 2] = x; f[va + 12 >> 2] = ia; f[va + 16 >> 2] = i; f[va + 20 >> 2] = V; f[va + 24 >> 2] = Q; f[va + 28 >> 2] = P; f[va + 32 >> 2] = T; f[l >> 2] = (f[l >> 2] | 0) + 1 } if ((R | 0) != (ia | 0)) { W = f[o >> 2] | 0; fa = f[t >> 2] | 0; ga = W - fa >> 2; ea = f[v >> 2] | 0; Z = f[l >> 2] | 0; if ((((ga | 0) == 0 ? 0 : (ga * 113 | 0) + -1 | 0) | 0) == (Z + ea | 0)) { Jc(e); wa = f[v >> 2] | 0; xa = f[l >> 2] | 0; ya = f[o >> 2] | 0; za = f[t >> 2] | 0 } else { wa = ea; xa = Z; ya = W; za = fa } fa = xa + wa | 0; if ((ya | 0) == (za | 0)) Aa = 0; else Aa = (f[za + (((fa >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((fa >>> 0) % 113 | 0) * 36 | 0) | 0; f[Aa >> 2] = ia; f[Aa + 4 >> 2] = i; f[Aa + 8 >> 2] = V; f[Aa + 12 >> 2] = R; fa = Aa + 16 | 0; f[fa >> 2] = p; f[fa + 4 >> 2] = q; f[Aa + 24 >> 2] = Q; f[Aa + 28 >> 2] = Y; f[Aa + 32 >> 2] = U; fa = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = fa; Ba = fa } else aa = 85 } else aa = 85; while (0); if ((aa | 0) == 85) { aa = 0; Ba = f[l >> 2] | 0 } if (!Ba) break; else L = Ba } } Ba = f[t >> 2] | 0; L = f[v >> 2] | 0; Aa = Ba + (((L >>> 0) / 113 | 0) << 2) | 0; q = f[o >> 2] | 0; p = q; i = Ba; if ((q | 0) == (Ba | 0)) { Ca = 0; Da = 0 } else { ia = (f[Aa >> 2] | 0) + (((L >>> 0) % 113 | 0) * 36 | 0) | 0; Ca = ia; Da = ia } ia = Aa; Aa = Da; c: while (1) { Da = Aa; do { L = Da; if ((Ca | 0) == (L | 0)) break c; Da = L + 36 | 0 } while ((Da - (f[ia >> 2] | 0) | 0) != 4068); Da = ia + 4 | 0; ia = Da; Aa = f[Da >> 2] | 0 } f[l >> 2] = 0; l = p - i >> 2; if (l >>> 0 > 2) { i = Ba; do { br(f[i >> 2] | 0); i = (f[t >> 2] | 0) + 4 | 0; f[t >> 2] = i; Ea = f[o >> 2] | 0; Fa = Ea - i >> 2 } while (Fa >>> 0 > 2); Ga = Fa; Ha = i; Ia = Ea } else { Ga = l; Ha = Ba; Ia = q } switch (Ga | 0) { case 1: { Ja = 56; aa = 99; break } case 2: { Ja = 113; aa = 99; break } default: { } }if ((aa | 0) == 99) f[v >> 2] = Ja; if ((Ha | 0) != (Ia | 0)) { Ja = Ha; do { br(f[Ja >> 2] | 0); Ja = Ja + 4 | 0 } while ((Ja | 0) != (Ia | 0)); Ia = f[t >> 2] | 0; t = f[o >> 2] | 0; if ((t | 0) != (Ia | 0)) f[o >> 2] = t + (~((t + -4 - Ia | 0) >>> 2) << 2) } Ia = f[e >> 2] | 0; if (!Ia) { u = d; return } br(Ia); u = d; return } function nb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0; d = u; u = u + 32 | 0; e = d; g = a + 8 | 0; h = f[g >> 2] | 0; f[e >> 2] = 0; i = e + 4 | 0; f[i >> 2] = 0; f[e + 8 >> 2] = 0; do if (h) if (h >>> 0 > 1073741823) mq(e); else { j = h << 2; k = dn(j) | 0; f[e >> 2] = k; l = k + (h << 2) | 0; f[e + 8 >> 2] = l; hj(k | 0, 0, j | 0) | 0; f[i >> 2] = l; m = l; n = k; break } else { m = 0; n = 0 } while (0); k = a + 140 | 0; l = f[k >> 2] | 0; j = f[l >> 2] | 0; o = l + 4 | 0; if (!j) { p = l + 8 | 0; q = n; r = m; s = h } else { h = f[o >> 2] | 0; if ((h | 0) != (j | 0)) f[o >> 2] = h + (~((h + -4 - j | 0) >>> 2) << 2); br(j); j = l + 8 | 0; f[j >> 2] = 0; f[o >> 2] = 0; f[l >> 2] = 0; p = j; q = f[e >> 2] | 0; r = f[i >> 2] | 0; s = f[g >> 2] | 0 } f[l >> 2] = q; f[o >> 2] = r; f[p >> 2] = f[e + 8 >> 2]; f[e >> 2] = 0; p = e + 4 | 0; f[p >> 2] = 0; f[e + 8 >> 2] = 0; do if (s) if (s >>> 0 > 1073741823) mq(e); else { r = s << 2; o = dn(r) | 0; f[e >> 2] = o; q = o + (s << 2) | 0; f[e + 8 >> 2] = q; hj(o | 0, 0, r | 0) | 0; f[p >> 2] = q; t = q; v = o; break } else { t = 0; v = 0 } while (0); s = a + 152 | 0; o = f[s >> 2] | 0; q = f[o >> 2] | 0; r = o + 4 | 0; if (!q) { w = o + 8 | 0; x = v; y = t } else { t = f[r >> 2] | 0; if ((t | 0) != (q | 0)) f[r >> 2] = t + (~((t + -4 - q | 0) >>> 2) << 2); br(q); q = o + 8 | 0; f[q >> 2] = 0; f[r >> 2] = 0; f[o >> 2] = 0; w = q; x = f[e >> 2] | 0; y = f[p >> 2] | 0 } f[o >> 2] = x; f[r >> 2] = y; f[w >> 2] = f[e + 8 >> 2]; w = f[b >> 2] | 0; y = b + 4 | 0; r = f[y >> 2] | 0; x = f[y + 4 >> 2] | 0; y = f[c >> 2] | 0; o = c + 4 | 0; p = f[o >> 2] | 0; q = f[o + 4 >> 2] | 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; f[e + 12 >> 2] = 0; f[e + 16 >> 2] = 0; f[e + 20 >> 2] = 0; o = e + 8 | 0; t = e + 4 | 0; v = e + 16 | 0; l = e + 20 | 0; i = r; Jc(e); j = f[t >> 2] | 0; h = (f[l >> 2] | 0) + (f[v >> 2] | 0) | 0; if ((f[o >> 2] | 0) == (j | 0)) z = 0; else z = (f[j + (((h >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((h >>> 0) % 113 | 0) * 36 | 0) | 0; f[z >> 2] = w; h = z + 4 | 0; f[h >> 2] = r; f[h + 4 >> 2] = x; f[z + 12 >> 2] = y; h = z + 16 | 0; f[h >> 2] = p; f[h + 4 >> 2] = q; f[z + 24 >> 2] = 0; f[z + 28 >> 2] = y - w; f[z + 32 >> 2] = 0; z = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = z; if (z | 0) { w = a + 128 | 0; y = a + 60 | 0; h = a + 56 | 0; j = a + 48 | 0; m = a + 52 | 0; n = a + 44 | 0; A = b + 8 | 0; B = c + 8 | 0; C = a + 12 | 0; D = a + 100 | 0; E = a + 96 | 0; F = a + 88 | 0; G = a + 92 | 0; H = a + 84 | 0; I = i + 4 | 0; J = i + 24 | 0; K = i + 24 | 0; L = p + 24 | 0; M = z; while (1) { z = f[v >> 2] | 0; N = M + -1 | 0; O = N + z | 0; P = f[t >> 2] | 0; Q = f[P + (((O >>> 0) / 113 | 0) << 2) >> 2] | 0; R = (O >>> 0) % 113 | 0; O = f[Q + (R * 36 | 0) >> 2] | 0; S = f[Q + (R * 36 | 0) + 12 >> 2] | 0; T = f[Q + (R * 36 | 0) + 24 >> 2] | 0; U = f[Q + (R * 36 | 0) + 32 >> 2] | 0; f[l >> 2] = N; N = f[o >> 2] | 0; R = N - P >> 2; if ((1 - M - z + ((R | 0) == 0 ? 0 : (R * 113 | 0) + -1 | 0) | 0) >>> 0 > 225) { br(f[N + -4 >> 2] | 0); f[o >> 2] = (f[o >> 2] | 0) + -4 } f[b >> 2] = O; f[c >> 2] = S; N = f[k >> 2] | 0; R = ((f[g >> 2] | 0) + -1 | 0) == (T | 0) ? 0 : T + 1 | 0; T = (f[s >> 2] | 0) + (U * 12 | 0) | 0; z = S - O | 0; P = (f[a >> 2] | 0) - (f[(f[T >> 2] | 0) + (R << 2) >> 2] | 0) | 0; a: do if (P) { if (z >>> 0 < 3) { Q = f[w >> 2] | 0; f[Q >> 2] = R; V = f[g >> 2] | 0; if (V >>> 0 > 1) { W = 1; Y = V; Z = R; while (1) { Z = (Z | 0) == (Y + -1 | 0) ? 0 : Z + 1 | 0; f[Q + (W << 2) >> 2] = Z; W = W + 1 | 0; $ = f[g >> 2] | 0; if (W >>> 0 >= $ >>> 0) { aa = $; break } else Y = $ } } else aa = V; if (!z) { ba = 81; break } else { ca = 0; da = aa } while (1) { Y = (f[J >> 2] | 0) + ((X(f[I >> 2] | 0, O + ca | 0) | 0) << 2) | 0; if (!da) ea = 0; else { W = 0; do { Z = f[(f[w >> 2] | 0) + (W << 2) >> 2] | 0; Q = (f[a >> 2] | 0) - (f[(f[T >> 2] | 0) + (Z << 2) >> 2] | 0) | 0; do if (Q | 0) { $ = f[y >> 2] | 0; fa = 32 - $ | 0; ga = 32 - Q | 0; ha = f[Y + (Z << 2) >> 2] << ga; if ((Q | 0) > (fa | 0)) { ia = ha >>> ga; ga = Q - fa | 0; f[y >> 2] = ga; fa = f[h >> 2] | ia >>> ga; f[h >> 2] = fa; ga = f[j >> 2] | 0; if ((ga | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[ga >> 2] = fa; f[j >> 2] = ga + 4 } f[h >> 2] = ia << 32 - (f[y >> 2] | 0); break } ia = f[h >> 2] | ha >>> $; f[h >> 2] = ia; ha = $ + Q | 0; f[y >> 2] = ha; if ((ha | 0) != 32) break; ha = f[j >> 2] | 0; if ((ha | 0) == (f[m >> 2] | 0)) Ci(n, h); else { f[ha >> 2] = ia; f[j >> 2] = ha + 4 } f[h >> 2] = 0; f[y >> 2] = 0 } while (0); W = W + 1 | 0; Q = f[g >> 2] | 0 } while (W >>> 0 < Q >>> 0); ea = Q } ca = ca + 1 | 0; if (ca >>> 0 >= z >>> 0) { ba = 81; break a } else da = ea } } V = U + 1 | 0; qg(N + (V * 12 | 0) | 0, f[N + (U * 12 | 0) >> 2] | 0, f[N + (U * 12 | 0) + 4 >> 2] | 0); W = (f[(f[k >> 2] | 0) + (V * 12 | 0) >> 2] | 0) + (R << 2) | 0; Y = (f[W >> 2] | 0) + (1 << P + -1) | 0; f[W >> 2] = Y; W = f[A >> 2] | 0; Q = f[B >> 2] | 0; b: do if ((S | 0) == (O | 0)) ja = O; else { Z = f[K >> 2] | 0; if (!W) { if ((f[Z + (R << 2) >> 2] | 0) >>> 0 < Y >>> 0) { ja = S; break } else { ka = S; la = O } while (1) { ha = ka; do { ha = ha + -1 | 0; if ((la | 0) == (ha | 0)) { ja = la; break b } ia = (f[L >> 2] | 0) + ((X(ha, Q) | 0) << 2) + (R << 2) | 0 } while ((f[ia >> 2] | 0) >>> 0 >= Y >>> 0); la = la + 1 | 0; if ((la | 0) == (ha | 0)) { ja = ha; break b } else ka = ha } } else { ma = S; na = O } while (1) { ia = na; while (1) { oa = Z + ((X(ia, W) | 0) << 2) | 0; if ((f[oa + (R << 2) >> 2] | 0) >>> 0 >= Y >>> 0) { pa = ma; break } $ = ia + 1 | 0; if (($ | 0) == (ma | 0)) { ja = ma; break b } else ia = $ } while (1) { pa = pa + -1 | 0; if ((ia | 0) == (pa | 0)) { ja = ia; break b } qa = (f[L >> 2] | 0) + ((X(pa, Q) | 0) << 2) | 0; if ((f[qa + (R << 2) >> 2] | 0) >>> 0 < Y >>> 0) { ra = 0; break } } do { ha = oa + (ra << 2) | 0; $ = qa + (ra << 2) | 0; ga = f[ha >> 2] | 0; f[ha >> 2] = f[$ >> 2]; f[$ >> 2] = ga; ra = ra + 1 | 0 } while ((ra | 0) != (W | 0)); na = ia + 1 | 0; if ((na | 0) == (pa | 0)) { ja = pa; break } else ma = pa } } while (0); Y = (_(z | 0) | 0) ^ 31; Q = ja - O | 0; Z = S - ja | 0; ga = Q >>> 0 < Z >>> 0; if ((Q | 0) != (Z | 0)) { $ = f[D >> 2] | 0; if (ga) f[E >> 2] = f[E >> 2] | 1 << 31 - $; ha = $ + 1 | 0; f[D >> 2] = ha; if ((ha | 0) == 32) { ha = f[F >> 2] | 0; if ((ha | 0) == (f[G >> 2] | 0)) Ci(H, E); else { f[ha >> 2] = f[E >> 2]; f[F >> 2] = ha + 4 } f[D >> 2] = 0; f[E >> 2] = 0 } } ha = z >>> 1; if (ga) bg(C, Y, ha - Q | 0); else bg(C, Y, ha - Z | 0); ha = f[s >> 2] | 0; Y = f[ha + (U * 12 | 0) >> 2] | 0; ga = Y + (R << 2) | 0; f[ga >> 2] = (f[ga >> 2] | 0) + 1; qg(ha + (V * 12 | 0) | 0, Y, f[ha + (U * 12 | 0) + 4 >> 2] | 0); if ((ja | 0) != (O | 0)) { ha = f[o >> 2] | 0; Y = f[t >> 2] | 0; ga = ha - Y >> 2; $ = f[v >> 2] | 0; fa = f[l >> 2] | 0; if ((((ga | 0) == 0 ? 0 : (ga * 113 | 0) + -1 | 0) | 0) == (fa + $ | 0)) { Jc(e); sa = f[v >> 2] | 0; ta = f[l >> 2] | 0; ua = f[o >> 2] | 0; va = f[t >> 2] | 0 } else { sa = $; ta = fa; ua = ha; va = Y } Y = ta + sa | 0; if ((ua | 0) == (va | 0)) wa = 0; else wa = (f[va + (((Y >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((Y >>> 0) % 113 | 0) * 36 | 0) | 0; f[wa >> 2] = O; Y = wa + 4 | 0; f[Y >> 2] = r; f[Y + 4 >> 2] = x; f[wa + 12 >> 2] = ja; f[wa + 16 >> 2] = i; f[wa + 20 >> 2] = W; f[wa + 24 >> 2] = R; f[wa + 28 >> 2] = Q; f[wa + 32 >> 2] = U; f[l >> 2] = (f[l >> 2] | 0) + 1 } if ((S | 0) != (ja | 0)) { Q = f[o >> 2] | 0; Y = f[t >> 2] | 0; ha = Q - Y >> 2; fa = f[v >> 2] | 0; $ = f[l >> 2] | 0; if ((((ha | 0) == 0 ? 0 : (ha * 113 | 0) + -1 | 0) | 0) == ($ + fa | 0)) { Jc(e); xa = f[v >> 2] | 0; ya = f[l >> 2] | 0; za = f[o >> 2] | 0; Aa = f[t >> 2] | 0 } else { xa = fa; ya = $; za = Q; Aa = Y } Y = ya + xa | 0; if ((za | 0) == (Aa | 0)) Ba = 0; else Ba = (f[Aa + (((Y >>> 0) / 113 | 0) << 2) >> 2] | 0) + (((Y >>> 0) % 113 | 0) * 36 | 0) | 0; f[Ba >> 2] = ja; f[Ba + 4 >> 2] = i; f[Ba + 8 >> 2] = W; f[Ba + 12 >> 2] = S; Y = Ba + 16 | 0; f[Y >> 2] = p; f[Y + 4 >> 2] = q; f[Ba + 24 >> 2] = R; f[Ba + 28 >> 2] = Z; f[Ba + 32 >> 2] = V; Z = (f[l >> 2] | 0) + 1 | 0; f[l >> 2] = Z; Ca = Z } else ba = 81 } else ba = 81; while (0); if ((ba | 0) == 81) { ba = 0; Ca = f[l >> 2] | 0 } if (!Ca) break; else M = Ca } } Ca = f[t >> 2] | 0; M = f[v >> 2] | 0; Ba = Ca + (((M >>> 0) / 113 | 0) << 2) | 0; q = f[o >> 2] | 0; p = q; i = Ca; if ((q | 0) == (Ca | 0)) { Da = 0; Ea = 0 } else { ja = (f[Ba >> 2] | 0) + (((M >>> 0) % 113 | 0) * 36 | 0) | 0; Da = ja; Ea = ja } ja = Ba; Ba = Ea; c: while (1) { Ea = Ba; do { M = Ea; if ((Da | 0) == (M | 0)) break c; Ea = M + 36 | 0 } while ((Ea - (f[ja >> 2] | 0) | 0) != 4068); Ea = ja + 4 | 0; ja = Ea; Ba = f[Ea >> 2] | 0 } f[l >> 2] = 0; l = p - i >> 2; if (l >>> 0 > 2) { i = Ca; do { br(f[i >> 2] | 0); i = (f[t >> 2] | 0) + 4 | 0; f[t >> 2] = i; Fa = f[o >> 2] | 0; Ga = Fa - i >> 2 } while (Ga >>> 0 > 2); Ha = Ga; Ia = i; Ja = Fa } else { Ha = l; Ia = Ca; Ja = q } switch (Ha | 0) { case 1: { Ka = 56; ba = 95; break } case 2: { Ka = 113; ba = 95; break } default: { } }if ((ba | 0) == 95) f[v >> 2] = Ka; if ((Ia | 0) != (Ja | 0)) { Ka = Ia; do { br(f[Ka >> 2] | 0); Ka = Ka + 4 | 0 } while ((Ka | 0) != (Ja | 0)); Ja = f[t >> 2] | 0; t = f[o >> 2] | 0; if ((t | 0) != (Ja | 0)) f[o >> 2] = t + (~((t + -4 - Ja | 0) >>> 2) << 2) } Ja = f[e >> 2] | 0; if (!Ja) { u = d; return } br(Ja); u = d; return } function ob(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0.0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0, Ja = 0, Ka = 0, La = 0, Ma = 0, Na = 0, Oa = 0, Pa = 0, Qa = 0, Ra = 0, Sa = 0, Ta = 0, Ua = 0, Va = 0, Wa = 0, Xa = 0, Ya = 0, Za = 0, _a = 0, $a = 0, ab = 0, bb = 0.0, cb = 0, db = 0, eb = 0, fb = 0, gb = 0, hb = 0, ib = 0, jb = 0.0, kb = 0.0, lb = 0.0, mb = 0.0, nb = 0.0, ob = 0.0, pb = 0.0, qb = 0.0, rb = 0.0, sb = 0.0, tb = 0; i = u; u = u + 512 | 0; j = i; k = d + c | 0; l = 0 - k | 0; m = a + 4 | 0; n = a + 100 | 0; o = b; b = 0; a: while (1) { switch (o | 0) { case 46: { p = 6; break a; break } case 48: break; default: { q = 0; r = o; s = b; t = 0; v = 0; break a } }w = f[m >> 2] | 0; if (w >>> 0 < (f[n >> 2] | 0) >>> 0) { f[m >> 2] = w + 1; o = h[w >> 0] | 0; b = 1; continue } else { o = Di(a) | 0; b = 1; continue } } if ((p | 0) == 6) { o = f[m >> 2] | 0; if (o >>> 0 < (f[n >> 2] | 0) >>> 0) { f[m >> 2] = o + 1; x = h[o >> 0] | 0 } else x = Di(a) | 0; if ((x | 0) == 48) { o = 0; w = 0; while (1) { y = Tn(o | 0, w | 0, -1, -1) | 0; z = I; A = f[m >> 2] | 0; if (A >>> 0 < (f[n >> 2] | 0) >>> 0) { f[m >> 2] = A + 1; B = h[A >> 0] | 0 } else B = Di(a) | 0; if ((B | 0) == 48) { o = y; w = z } else { q = 1; r = B; s = 1; t = y; v = z; break } } } else { q = 1; r = x; s = b; t = 0; v = 0 } } f[j >> 2] = 0; b = r + -48 | 0; x = (r | 0) == 46; b: do if (x | b >>> 0 < 10) { B = j + 496 | 0; w = 0; o = 0; z = 0; y = q; A = s; C = r; D = x; E = b; F = t; G = v; H = 0; J = 0; c: while (1) { do if (D) if (!y) { L = w; M = o; N = 1; O = z; P = A; Q = H; R = J; S = H; T = J } else break c; else { U = Tn(H | 0, J | 0, 1, 0) | 0; V = I; W = (C | 0) != 48; if ((o | 0) >= 125) { if (!W) { L = w; M = o; N = y; O = z; P = A; Q = F; R = G; S = U; T = V; break } f[B >> 2] = f[B >> 2] | 1; L = w; M = o; N = y; O = z; P = A; Q = F; R = G; S = U; T = V; break } Y = j + (o << 2) | 0; if (!w) Z = E; else Z = C + -48 + ((f[Y >> 2] | 0) * 10 | 0) | 0; f[Y >> 2] = Z; Y = w + 1 | 0; _ = (Y | 0) == 9; L = _ ? 0 : Y; M = o + (_ & 1) | 0; N = y; O = W ? U : z; P = 1; Q = F; R = G; S = U; T = V } while (0); V = f[m >> 2] | 0; if (V >>> 0 < (f[n >> 2] | 0) >>> 0) { f[m >> 2] = V + 1; $ = h[V >> 0] | 0 } else $ = Di(a) | 0; E = $ + -48 | 0; D = ($ | 0) == 46; if (!(D | E >>> 0 < 10)) { aa = L; ba = M; ca = O; da = N; ea = $; fa = P; ga = S; ha = Q; ia = T; ja = R; p = 29; break b } else { w = L; o = M; z = O; y = N; A = P; C = $; F = Q; G = R; H = S; J = T } } ka = w; la = o; ma = z; na = H; oa = J; pa = F; qa = G; ra = (A | 0) != 0; p = 37 } else { aa = 0; ba = 0; ca = 0; da = q; ea = r; fa = s; ga = 0; ha = t; ia = 0; ja = v; p = 29 } while (0); do if ((p | 0) == 29) { v = (da | 0) == 0; t = v ? ga : ha; s = v ? ia : ja; v = (fa | 0) != 0; if (!(v & (ea | 32 | 0) == 101)) if ((ea | 0) > -1) { ka = aa; la = ba; ma = ca; na = ga; oa = ia; pa = t; qa = s; ra = v; p = 37; break } else { sa = aa; ta = ba; ua = ca; va = ga; wa = ia; xa = v; ya = t; za = s; p = 39; break } v = De(a, g) | 0; r = I; if ((v | 0) == 0 & (r | 0) == -2147483648) { if (!g) { Rm(a, 0); Aa = 0.0; break } if (!(f[n >> 2] | 0)) { Ba = 0; Ca = 0 } else { f[m >> 2] = (f[m >> 2] | 0) + -1; Ba = 0; Ca = 0 } } else { Ba = v; Ca = r } r = Tn(Ba | 0, Ca | 0, t | 0, s | 0) | 0; Da = aa; Ea = ba; Fa = ca; Ga = r; Ha = ga; Ia = I; Ja = ia; p = 41 } while (0); if ((p | 0) == 37) if (f[n >> 2] | 0) { f[m >> 2] = (f[m >> 2] | 0) + -1; if (ra) { Da = ka; Ea = la; Fa = ma; Ga = pa; Ha = na; Ia = qa; Ja = oa; p = 41 } else p = 40 } else { sa = ka; ta = la; ua = ma; va = na; wa = oa; xa = ra; ya = pa; za = qa; p = 39 } if ((p | 0) == 39) if (xa) { Da = sa; Ea = ta; Fa = ua; Ga = ya; Ha = va; Ia = za; Ja = wa; p = 41 } else p = 40; do if ((p | 0) == 40) { wa = ir() | 0; f[wa >> 2] = 22; Rm(a, 0); Aa = 0.0 } else if ((p | 0) == 41) { wa = f[j >> 2] | 0; if (!wa) { Aa = +(e | 0) * 0.0; break } if (((Ja | 0) < 0 | (Ja | 0) == 0 & Ha >>> 0 < 10) & ((Ga | 0) == (Ha | 0) & (Ia | 0) == (Ja | 0)) ? (c | 0) > 30 | (wa >>> c | 0) == 0 : 0) { Aa = +(e | 0) * +(wa >>> 0); break } wa = (d | 0) / -2 | 0; za = ((wa | 0) < 0) << 31 >> 31; if ((Ia | 0) > (za | 0) | (Ia | 0) == (za | 0) & Ga >>> 0 > wa >>> 0) { wa = ir() | 0; f[wa >> 2] = 34; Aa = +(e | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284; break } wa = d + -106 | 0; za = ((wa | 0) < 0) << 31 >> 31; if ((Ia | 0) < (za | 0) | (Ia | 0) == (za | 0) & Ga >>> 0 < wa >>> 0) { wa = ir() | 0; f[wa >> 2] = 34; Aa = +(e | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308; break } if (!Da) Ka = Ea; else { if ((Da | 0) < 9) { wa = j + (Ea << 2) | 0; za = Da; va = f[wa >> 2] | 0; while (1) { va = va * 10 | 0; if ((za | 0) >= 8) break; else za = za + 1 | 0 } f[wa >> 2] = va } Ka = Ea + 1 | 0 } if ((Fa | 0) < 9 ? (Fa | 0) <= (Ga | 0) & (Ga | 0) < 18 : 0) { if ((Ga | 0) == 9) { Aa = +(e | 0) * +((f[j >> 2] | 0) >>> 0); break } if ((Ga | 0) < 9) { Aa = +(e | 0) * +((f[j >> 2] | 0) >>> 0) / +(f[6408 + (8 - Ga << 2) >> 2] | 0); break } za = c + 27 + (X(Ga, -3) | 0) | 0; A = f[j >> 2] | 0; if ((za | 0) > 30 | (A >>> za | 0) == 0) { Aa = +(e | 0) * +(A >>> 0) * +(f[6408 + (Ga + -10 << 2) >> 2] | 0); break } } A = (Ga | 0) % 9 | 0; if (!A) { La = 0; Ma = Ka; Na = 0; Oa = Ga } else { za = (Ga | 0) > -1 ? A : A + 9 | 0; A = f[6408 + (8 - za << 2) >> 2] | 0; if (Ka) { G = 1e9 / (A | 0) | 0; F = 0; J = 0; H = Ga; z = 0; do { o = j + (z << 2) | 0; w = f[o >> 2] | 0; ya = ((w >>> 0) / (A >>> 0) | 0) + F | 0; f[o >> 2] = ya; F = X(G, (w >>> 0) % (A >>> 0) | 0) | 0; w = (z | 0) == (J | 0) & (ya | 0) == 0; H = w ? H + -9 | 0 : H; J = w ? J + 1 & 127 : J; z = z + 1 | 0 } while ((z | 0) != (Ka | 0)); if (!F) { Pa = J; Qa = Ka; Ra = H } else { f[j + (Ka << 2) >> 2] = F; Pa = J; Qa = Ka + 1 | 0; Ra = H } } else { Pa = 0; Qa = 0; Ra = Ga } La = 0; Ma = Qa; Na = Pa; Oa = 9 - za + Ra | 0 } d: while (1) { z = (Oa | 0) < 18; A = (Oa | 0) == 18; G = j + (Na << 2) | 0; va = La; wa = Ma; while (1) { if (!z) { if (!A) { Sa = va; Ta = Na; Ua = Oa; Va = wa; break d } if ((f[G >> 2] | 0) >>> 0 >= 9007199) { Sa = va; Ta = Na; Ua = 18; Va = wa; break d } } w = 0; Wa = wa; ya = wa + 127 | 0; while (1) { o = ya & 127; ua = j + (o << 2) | 0; ta = Rn(f[ua >> 2] | 0, 0, 29) | 0; sa = Tn(ta | 0, I | 0, w | 0, 0) | 0; ta = I; if (ta >>> 0 > 0 | (ta | 0) == 0 & sa >>> 0 > 1e9) { xa = up(sa | 0, ta | 0, 1e9, 0) | 0; qa = an(sa | 0, ta | 0, 1e9, 0) | 0; Xa = xa; Ya = qa } else { Xa = 0; Ya = sa } f[ua >> 2] = Ya; ua = (o | 0) == (Na | 0); Wa = (Ya | 0) == 0 & (((o | 0) != (Wa + 127 & 127 | 0) | ua) ^ 1) ? o : Wa; if (ua) break; else { w = Xa; ya = o + -1 | 0 } } va = va + -29 | 0; if (Xa | 0) break; else wa = Wa } wa = Na + 127 & 127; G = Wa + 127 & 127; A = j + ((Wa + 126 & 127) << 2) | 0; if ((wa | 0) == (Wa | 0)) { f[A >> 2] = f[A >> 2] | f[j + (G << 2) >> 2]; Za = G } else Za = Wa; f[j + (wa << 2) >> 2] = Xa; La = va; Ma = Za; Na = wa; Oa = Oa + 9 | 0 } e: while (1) { za = Va + 1 & 127; H = j + ((Va + 127 & 127) << 2) | 0; J = Sa; F = Ta; wa = Ua; while (1) { G = (wa | 0) == 18; A = (wa | 0) > 27 ? 9 : 1; _a = J; $a = F; while (1) { z = 0; while (1) { ya = z + $a & 127; if ((ya | 0) == (Va | 0)) { ab = 2; p = 88; break } w = f[j + (ya << 2) >> 2] | 0; ya = f[6440 + (z << 2) >> 2] | 0; if (w >>> 0 < ya >>> 0) { ab = 2; p = 88; break } if (w >>> 0 > ya >>> 0) break; ya = z + 1 | 0; if ((z | 0) < 1) z = ya; else { ab = ya; p = 88; break } } if ((p | 0) == 88 ? (p = 0, G & (ab | 0) == 2) : 0) { bb = 0.0; cb = 0; db = Va; break e } eb = A + _a | 0; if (($a | 0) == (Va | 0)) { _a = eb; $a = Va } else break } G = (1 << A) + -1 | 0; z = 1e9 >>> A; fb = 0; gb = $a; hb = wa; ya = $a; do { w = j + (ya << 2) | 0; o = f[w >> 2] | 0; ua = (o >>> A) + fb | 0; f[w >> 2] = ua; fb = X(o & G, z) | 0; o = (ya | 0) == (gb | 0) & (ua | 0) == 0; hb = o ? hb + -9 | 0 : hb; gb = o ? gb + 1 & 127 : gb; ya = ya + 1 & 127 } while ((ya | 0) != (Va | 0)); if (!fb) { J = eb; F = gb; wa = hb; continue } if ((za | 0) != (gb | 0)) break; f[H >> 2] = f[H >> 2] | 1; J = eb; F = gb; wa = hb } f[j + (Va << 2) >> 2] = fb; Sa = eb; Ta = gb; Ua = hb; Va = za } while (1) { wa = cb + $a & 127; F = db + 1 & 127; if ((wa | 0) == (db | 0)) { f[j + (F + -1 << 2) >> 2] = 0; ib = F } else ib = db; bb = bb * 1.0e9 + +((f[j + (wa << 2) >> 2] | 0) >>> 0); cb = cb + 1 | 0; if ((cb | 0) == 2) break; else db = ib } jb = +(e | 0); kb = bb * jb; wa = _a + 53 | 0; F = wa - d | 0; J = (F | 0) < (c | 0); H = J ? ((F | 0) > 0 ? F : 0) : c; if ((H | 0) < 53) { lb = +Gq(+Wj(1.0, 105 - H | 0), kb); mb = +Sq(kb, +Wj(1.0, 53 - H | 0)); nb = lb; ob = mb; pb = lb + (kb - mb) } else { nb = 0.0; ob = 0.0; pb = kb } va = $a + 2 & 127; if ((va | 0) != (ib | 0)) { ya = f[j + (va << 2) >> 2] | 0; do if (ya >>> 0 >= 5e8) { if ((ya | 0) != 5e8) { qb = jb * .75 + ob; break } if (($a + 3 & 127 | 0) == (ib | 0)) { qb = jb * .5 + ob; break } else { qb = jb * .75 + ob; break } } else { if ((ya | 0) == 0 ? ($a + 3 & 127 | 0) == (ib | 0) : 0) { qb = ob; break } qb = jb * .25 + ob } while (0); if ((53 - H | 0) > 1 ? !(+Sq(qb, 1.0) != 0.0) : 0) rb = qb + 1.0; else rb = qb } else rb = ob; jb = pb + rb - nb; do if ((wa & 2147483647 | 0) > (-2 - k | 0)) { ya = !(+K(+jb) >= 9007199254740992.0); va = _a + ((ya ^ 1) & 1) | 0; kb = ya ? jb : jb * .5; if ((va + 50 | 0) <= (l | 0) ? !(rb != 0.0 & (J & ((H | 0) != (F | 0) | ya))) : 0) { sb = kb; tb = va; break } ya = ir() | 0; f[ya >> 2] = 34; sb = kb; tb = va } else { sb = jb; tb = _a } while (0); Aa = +Hq(sb, tb) } while (0); u = i; return +Aa } function pb(a, c, d, e, g, i) { a = a | 0; c = +c; d = d | 0; e = e | 0; g = g | 0; i = i | 0; var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0.0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0.0, C = 0, D = 0.0, E = 0, F = 0, G = 0, H = 0.0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0.0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0.0, ga = 0.0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0; j = u; u = u + 560 | 0; k = j + 8 | 0; l = j; m = j + 524 | 0; n = m; o = j + 512 | 0; f[l >> 2] = 0; p = o + 12 | 0; xo(c) | 0; if ((I | 0) < 0) { q = -c; r = 1; s = 15511 } else { q = c; r = (g & 2049 | 0) != 0 & 1; s = (g & 2048 | 0) == 0 ? ((g & 1 | 0) == 0 ? 15512 : 15517) : 15514 } xo(q) | 0; do if (0 == 0 & (I & 2146435072 | 0) == 2146435072) { t = (i & 32 | 0) != 0; v = r + 3 | 0; Hk(a, 32, d, v, g & -65537); ep(a, s, r); ep(a, q != q | 0.0 != 0.0 ? (t ? 17461 : 15538) : t ? 15530 : 15534, 3); Hk(a, 32, d, v, g ^ 8192); w = v } else { c = +Iq(q, l) * 2.0; v = c != 0.0; if (v) f[l >> 2] = (f[l >> 2] | 0) + -1; t = i | 32; if ((t | 0) == 97) { x = i & 32; y = (x | 0) == 0 ? s : s + 9 | 0; z = r | 2; A = 12 - e | 0; do if (!(e >>> 0 > 11 | (A | 0) == 0)) { B = 8.0; C = A; do { C = C + -1 | 0; B = B * 16.0 } while ((C | 0) != 0); if ((b[y >> 0] | 0) == 45) { D = -(B + (-c - B)); break } else { D = c + B - B; break } } else D = c; while (0); A = f[l >> 2] | 0; C = (A | 0) < 0 ? 0 - A | 0 : A; E = Jj(C, ((C | 0) < 0) << 31 >> 31, p) | 0; if ((E | 0) == (p | 0)) { C = o + 11 | 0; b[C >> 0] = 48; F = C } else F = E; b[F + -1 >> 0] = (A >> 31 & 2) + 43; A = F + -2 | 0; b[A >> 0] = i + 15; E = (e | 0) < 1; C = (g & 8 | 0) == 0; G = m; H = D; while (1) { J = ~~H; K = G + 1 | 0; b[G >> 0] = x | h[15542 + J >> 0]; H = (H - +(J | 0)) * 16.0; if ((K - n | 0) == 1 ? !(C & (E & H == 0.0)) : 0) { b[K >> 0] = 46; L = G + 2 | 0 } else L = K; if (!(H != 0.0)) break; else G = L } G = L; if ((e | 0) != 0 ? (-2 - n + G | 0) < (e | 0) : 0) { M = G - n | 0; N = e + 2 | 0 } else { E = G - n | 0; M = E; N = E } E = p - A | 0; G = E + z + N | 0; Hk(a, 32, d, G, g); ep(a, y, z); Hk(a, 48, d, G, g ^ 65536); ep(a, m, M); Hk(a, 48, N - M | 0, 0, 0); ep(a, A, E); Hk(a, 32, d, G, g ^ 8192); w = G; break } G = (e | 0) < 0 ? 6 : e; if (v) { E = (f[l >> 2] | 0) + -28 | 0; f[l >> 2] = E; O = c * 268435456.0; P = E } else { O = c; P = f[l >> 2] | 0 } E = (P | 0) < 0 ? k : k + 288 | 0; C = E; H = O; do { x = ~~H >>> 0; f[C >> 2] = x; C = C + 4 | 0; H = (H - +(x >>> 0)) * 1.0e9 } while (H != 0.0); if ((P | 0) > 0) { v = E; A = C; z = P; while (1) { y = (z | 0) < 29 ? z : 29; x = A + -4 | 0; if (x >>> 0 >= v >>> 0) { K = x; x = 0; do { J = Rn(f[K >> 2] | 0, 0, y | 0) | 0; Q = Tn(J | 0, I | 0, x | 0, 0) | 0; J = I; R = an(Q | 0, J | 0, 1e9, 0) | 0; f[K >> 2] = R; x = up(Q | 0, J | 0, 1e9, 0) | 0; K = K + -4 | 0 } while (K >>> 0 >= v >>> 0); if (x) { K = v + -4 | 0; f[K >> 2] = x; S = K } else S = v } else S = v; K = A; while (1) { if (K >>> 0 <= S >>> 0) break; J = K + -4 | 0; if (!(f[J >> 2] | 0)) K = J; else break } x = (f[l >> 2] | 0) - y | 0; f[l >> 2] = x; if ((x | 0) > 0) { v = S; A = K; z = x } else { T = S; U = K; V = x; break } } } else { T = E; U = C; V = P } if ((V | 0) < 0) { z = ((G + 25 | 0) / 9 | 0) + 1 | 0; A = (t | 0) == 102; v = T; x = U; J = V; while (1) { Q = 0 - J | 0; R = (Q | 0) < 9 ? Q : 9; if (v >>> 0 < x >>> 0) { Q = (1 << R) + -1 | 0; W = 1e9 >>> R; Y = 0; Z = v; do { _ = f[Z >> 2] | 0; f[Z >> 2] = (_ >>> R) + Y; Y = X(_ & Q, W) | 0; Z = Z + 4 | 0 } while (Z >>> 0 < x >>> 0); Z = (f[v >> 2] | 0) == 0 ? v + 4 | 0 : v; if (!Y) { $ = Z; aa = x } else { f[x >> 2] = Y; $ = Z; aa = x + 4 | 0 } } else { $ = (f[v >> 2] | 0) == 0 ? v + 4 | 0 : v; aa = x } Z = A ? E : $; W = (aa - Z >> 2 | 0) > (z | 0) ? Z + (z << 2) | 0 : aa; J = (f[l >> 2] | 0) + R | 0; f[l >> 2] = J; if ((J | 0) >= 0) { ba = $; ca = W; break } else { v = $; x = W } } } else { ba = T; ca = U } x = E; if (ba >>> 0 < ca >>> 0) { v = (x - ba >> 2) * 9 | 0; J = f[ba >> 2] | 0; if (J >>> 0 < 10) da = v; else { z = v; v = 10; while (1) { v = v * 10 | 0; A = z + 1 | 0; if (J >>> 0 < v >>> 0) { da = A; break } else z = A } } } else da = 0; z = (t | 0) == 103; v = (G | 0) != 0; J = G - ((t | 0) != 102 ? da : 0) + ((v & z) << 31 >> 31) | 0; if ((J | 0) < (((ca - x >> 2) * 9 | 0) + -9 | 0)) { A = J + 9216 | 0; J = E + 4 + (((A | 0) / 9 | 0) + -1024 << 2) | 0; C = (A | 0) % 9 | 0; if ((C | 0) < 8) { A = C; C = 10; while (1) { W = C * 10 | 0; if ((A | 0) < 7) { A = A + 1 | 0; C = W } else { ea = W; break } } } else ea = 10; C = f[J >> 2] | 0; A = (C >>> 0) % (ea >>> 0) | 0; t = (J + 4 | 0) == (ca | 0); if (!(t & (A | 0) == 0)) { B = (((C >>> 0) / (ea >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0; W = (ea | 0) / 2 | 0; H = A >>> 0 < W >>> 0 ? .5 : t & (A | 0) == (W | 0) ? 1.0 : 1.5; if (!r) { fa = H; ga = B } else { W = (b[s >> 0] | 0) == 45; fa = W ? -H : H; ga = W ? -B : B } W = C - A | 0; f[J >> 2] = W; if (ga + fa != ga) { A = W + ea | 0; f[J >> 2] = A; if (A >>> 0 > 999999999) { A = ba; W = J; while (1) { C = W + -4 | 0; f[W >> 2] = 0; if (C >>> 0 < A >>> 0) { t = A + -4 | 0; f[t >> 2] = 0; ha = t } else ha = A; t = (f[C >> 2] | 0) + 1 | 0; f[C >> 2] = t; if (t >>> 0 > 999999999) { A = ha; W = C } else { ia = ha; ja = C; break } } } else { ia = ba; ja = J } W = (x - ia >> 2) * 9 | 0; A = f[ia >> 2] | 0; if (A >>> 0 < 10) { ka = ja; la = W; ma = ia } else { C = W; W = 10; while (1) { W = W * 10 | 0; t = C + 1 | 0; if (A >>> 0 < W >>> 0) { ka = ja; la = t; ma = ia; break } else C = t } } } else { ka = J; la = da; ma = ba } } else { ka = J; la = da; ma = ba } C = ka + 4 | 0; na = la; oa = ca >>> 0 > C >>> 0 ? C : ca; pa = ma } else { na = da; oa = ca; pa = ba } C = oa; while (1) { if (C >>> 0 <= pa >>> 0) { qa = 0; break } W = C + -4 | 0; if (!(f[W >> 2] | 0)) C = W; else { qa = 1; break } } J = 0 - na | 0; do if (z) { W = G + ((v ^ 1) & 1) | 0; if ((W | 0) > (na | 0) & (na | 0) > -5) { ra = i + -1 | 0; sa = W + -1 - na | 0 } else { ra = i + -2 | 0; sa = W + -1 | 0 } W = g & 8; if (!W) { if (qa ? (A = f[C + -4 >> 2] | 0, (A | 0) != 0) : 0) if (!((A >>> 0) % 10 | 0)) { t = 0; Z = 10; while (1) { Z = Z * 10 | 0; Q = t + 1 | 0; if ((A >>> 0) % (Z >>> 0) | 0 | 0) { ta = Q; break } else t = Q } } else ta = 0; else ta = 9; t = ((C - x >> 2) * 9 | 0) + -9 | 0; if ((ra | 32 | 0) == 102) { Z = t - ta | 0; A = (Z | 0) > 0 ? Z : 0; ua = ra; va = (sa | 0) < (A | 0) ? sa : A; wa = 0; break } else { A = t + na - ta | 0; t = (A | 0) > 0 ? A : 0; ua = ra; va = (sa | 0) < (t | 0) ? sa : t; wa = 0; break } } else { ua = ra; va = sa; wa = W } } else { ua = i; va = G; wa = g & 8 } while (0); G = va | wa; x = (G | 0) != 0 & 1; v = (ua | 32 | 0) == 102; if (v) { xa = 0; ya = (na | 0) > 0 ? na : 0 } else { z = (na | 0) < 0 ? J : na; t = Jj(z, ((z | 0) < 0) << 31 >> 31, p) | 0; z = p; if ((z - t | 0) < 2) { A = t; while (1) { Z = A + -1 | 0; b[Z >> 0] = 48; if ((z - Z | 0) < 2) A = Z; else { za = Z; break } } } else za = t; b[za + -1 >> 0] = (na >> 31 & 2) + 43; A = za + -2 | 0; b[A >> 0] = ua; xa = A; ya = z - A | 0 } A = r + 1 + va + x + ya | 0; Hk(a, 32, d, A, g); ep(a, s, r); Hk(a, 48, d, A, g ^ 65536); if (v) { J = pa >>> 0 > E >>> 0 ? E : pa; Z = m + 9 | 0; R = Z; Y = m + 8 | 0; Q = J; do { K = Jj(f[Q >> 2] | 0, 0, Z) | 0; if ((Q | 0) == (J | 0)) if ((K | 0) == (Z | 0)) { b[Y >> 0] = 48; Aa = Y } else Aa = K; else if (K >>> 0 > m >>> 0) { hj(m | 0, 48, K - n | 0) | 0; y = K; while (1) { _ = y + -1 | 0; if (_ >>> 0 > m >>> 0) y = _; else { Aa = _; break } } } else Aa = K; ep(a, Aa, R - Aa | 0); Q = Q + 4 | 0 } while (Q >>> 0 <= E >>> 0); if (G | 0) ep(a, 15558, 1); if (Q >>> 0 < C >>> 0 & (va | 0) > 0) { E = va; R = Q; while (1) { Y = Jj(f[R >> 2] | 0, 0, Z) | 0; if (Y >>> 0 > m >>> 0) { hj(m | 0, 48, Y - n | 0) | 0; J = Y; while (1) { v = J + -1 | 0; if (v >>> 0 > m >>> 0) J = v; else { Ba = v; break } } } else Ba = Y; ep(a, Ba, (E | 0) < 9 ? E : 9); R = R + 4 | 0; J = E + -9 | 0; if (!(R >>> 0 < C >>> 0 & (E | 0) > 9)) { Ca = J; break } else E = J } } else Ca = va; Hk(a, 48, Ca + 9 | 0, 9, 0) } else { E = qa ? C : pa + 4 | 0; if ((va | 0) > -1) { R = m + 9 | 0; Z = (wa | 0) == 0; Q = R; G = 0 - n | 0; J = m + 8 | 0; K = va; v = pa; while (1) { x = Jj(f[v >> 2] | 0, 0, R) | 0; if ((x | 0) == (R | 0)) { b[J >> 0] = 48; Da = J } else Da = x; do if ((v | 0) == (pa | 0)) { x = Da + 1 | 0; ep(a, Da, 1); if (Z & (K | 0) < 1) { Ea = x; break } ep(a, 15558, 1); Ea = x } else { if (Da >>> 0 <= m >>> 0) { Ea = Da; break } hj(m | 0, 48, Da + G | 0) | 0; x = Da; while (1) { z = x + -1 | 0; if (z >>> 0 > m >>> 0) x = z; else { Ea = z; break } } } while (0); Y = Q - Ea | 0; ep(a, Ea, (K | 0) > (Y | 0) ? Y : K); x = K - Y | 0; v = v + 4 | 0; if (!(v >>> 0 < E >>> 0 & (x | 0) > -1)) { Fa = x; break } else K = x } } else Fa = va; Hk(a, 48, Fa + 18 | 0, 18, 0); ep(a, xa, p - xa | 0) } Hk(a, 32, d, A, g ^ 8192); w = A } while (0); u = j; return ((w | 0) < (d | 0) ? d : w) | 0 } function qb(a, c, e, g, h) { a = a | 0; c = c | 0; e = e | 0; g = g | 0; h = h | 0; var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0, Aa = 0, Ba = 0, Ca = 0, Da = 0, Ea = 0, Fa = 0, Ga = 0, Ha = 0, Ia = 0; i = u; u = u + 64 | 0; j = i + 16 | 0; k = i; l = i + 24 | 0; m = i + 8 | 0; n = i + 20 | 0; f[j >> 2] = c; c = (a | 0) != 0; o = l + 40 | 0; q = o; r = l + 39 | 0; l = m + 4 | 0; s = 0; t = 0; v = 0; a: while (1) { do if ((t | 0) > -1) if ((s | 0) > (2147483647 - t | 0)) { w = ir() | 0; f[w >> 2] = 75; x = -1; break } else { x = s + t | 0; break } else x = t; while (0); w = f[j >> 2] | 0; y = b[w >> 0] | 0; if (!(y << 24 >> 24)) { z = 88; break } else { A = y; B = w } b: while (1) { switch (A << 24 >> 24) { case 37: { C = B; D = B; z = 9; break b; break } case 0: { E = B; break b; break } default: { } }y = B + 1 | 0; f[j >> 2] = y; A = b[y >> 0] | 0; B = y } c: do if ((z | 0) == 9) while (1) { z = 0; if ((b[D + 1 >> 0] | 0) != 37) { E = C; break c } y = C + 1 | 0; D = D + 2 | 0; f[j >> 2] = D; if ((b[D >> 0] | 0) != 37) { E = y; break } else { C = y; z = 9 } } while (0); y = E - w | 0; if (c) ep(a, w, y); if (y | 0) { s = y; t = x; continue } y = (Pq(b[(f[j >> 2] | 0) + 1 >> 0] | 0) | 0) == 0; F = f[j >> 2] | 0; if (!y ? (b[F + 2 >> 0] | 0) == 36 : 0) { G = (b[F + 1 >> 0] | 0) + -48 | 0; H = 1; J = 3 } else { G = -1; H = v; J = 1 } y = F + J | 0; f[j >> 2] = y; F = b[y >> 0] | 0; K = (F << 24 >> 24) + -32 | 0; if (K >>> 0 > 31 | (1 << K & 75913 | 0) == 0) { L = 0; M = F; N = y } else { K = 0; O = F; F = y; while (1) { y = 1 << (O << 24 >> 24) + -32 | K; P = F + 1 | 0; f[j >> 2] = P; Q = b[P >> 0] | 0; R = (Q << 24 >> 24) + -32 | 0; if (R >>> 0 > 31 | (1 << R & 75913 | 0) == 0) { L = y; M = Q; N = P; break } else { K = y; O = Q; F = P } } } if (M << 24 >> 24 == 42) { if ((Pq(b[N + 1 >> 0] | 0) | 0) != 0 ? (F = f[j >> 2] | 0, (b[F + 2 >> 0] | 0) == 36) : 0) { O = F + 1 | 0; f[h + ((b[O >> 0] | 0) + -48 << 2) >> 2] = 10; S = f[g + ((b[O >> 0] | 0) + -48 << 3) >> 2] | 0; T = 1; U = F + 3 | 0 } else { if (H | 0) { V = -1; break } if (c) { F = (f[e >> 2] | 0) + (4 - 1) & ~(4 - 1); O = f[F >> 2] | 0; f[e >> 2] = F + 4; W = O } else W = 0; S = W; T = 0; U = (f[j >> 2] | 0) + 1 | 0 } f[j >> 2] = U; O = (S | 0) < 0; X = O ? 0 - S | 0 : S; Y = O ? L | 8192 : L; Z = T; _ = U } else { O = Cl(j) | 0; if ((O | 0) < 0) { V = -1; break } X = O; Y = L; Z = H; _ = f[j >> 2] | 0 } do if ((b[_ >> 0] | 0) == 46) { if ((b[_ + 1 >> 0] | 0) != 42) { f[j >> 2] = _ + 1; O = Cl(j) | 0; $ = O; aa = f[j >> 2] | 0; break } if (Pq(b[_ + 2 >> 0] | 0) | 0 ? (O = f[j >> 2] | 0, (b[O + 3 >> 0] | 0) == 36) : 0) { F = O + 2 | 0; f[h + ((b[F >> 0] | 0) + -48 << 2) >> 2] = 10; K = f[g + ((b[F >> 0] | 0) + -48 << 3) >> 2] | 0; F = O + 4 | 0; f[j >> 2] = F; $ = K; aa = F; break } if (Z | 0) { V = -1; break a } if (c) { F = (f[e >> 2] | 0) + (4 - 1) & ~(4 - 1); K = f[F >> 2] | 0; f[e >> 2] = F + 4; ba = K } else ba = 0; K = (f[j >> 2] | 0) + 2 | 0; f[j >> 2] = K; $ = ba; aa = K } else { $ = -1; aa = _ } while (0); K = 0; F = aa; while (1) { if (((b[F >> 0] | 0) + -65 | 0) >>> 0 > 57) { V = -1; break a } O = F; F = F + 1 | 0; f[j >> 2] = F; ca = b[(b[O >> 0] | 0) + -65 + (15030 + (K * 58 | 0)) >> 0] | 0; da = ca & 255; if ((da + -1 | 0) >>> 0 >= 8) break; else K = da } if (!(ca << 24 >> 24)) { V = -1; break } O = (G | 0) > -1; do if (ca << 24 >> 24 == 19) if (O) { V = -1; break a } else z = 50; else { if (O) { f[h + (G << 2) >> 2] = da; P = g + (G << 3) | 0; Q = f[P + 4 >> 2] | 0; y = k; f[y >> 2] = f[P >> 2]; f[y + 4 >> 2] = Q; z = 50; break } if (!c) { V = 0; break a } Ie(k, da, e); ea = f[j >> 2] | 0 } while (0); if ((z | 0) == 50) { z = 0; if (c) ea = F; else { s = 0; t = x; v = Z; continue } } O = b[ea + -1 >> 0] | 0; Q = (K | 0) != 0 & (O & 15 | 0) == 3 ? O & -33 : O; O = Y & -65537; y = (Y & 8192 | 0) == 0 ? Y : O; d: do switch (Q | 0) { case 110: { switch ((K & 255) << 24 >> 24) { case 0: { f[f[k >> 2] >> 2] = x; s = 0; t = x; v = Z; continue a; break } case 1: { f[f[k >> 2] >> 2] = x; s = 0; t = x; v = Z; continue a; break } case 2: { P = f[k >> 2] | 0; f[P >> 2] = x; f[P + 4 >> 2] = ((x | 0) < 0) << 31 >> 31; s = 0; t = x; v = Z; continue a; break } case 3: { d[f[k >> 2] >> 1] = x; s = 0; t = x; v = Z; continue a; break } case 4: { b[f[k >> 2] >> 0] = x; s = 0; t = x; v = Z; continue a; break } case 6: { f[f[k >> 2] >> 2] = x; s = 0; t = x; v = Z; continue a; break } case 7: { P = f[k >> 2] | 0; f[P >> 2] = x; f[P + 4 >> 2] = ((x | 0) < 0) << 31 >> 31; s = 0; t = x; v = Z; continue a; break } default: { s = 0; t = x; v = Z; continue a } }break } case 112: { fa = 120; ga = $ >>> 0 > 8 ? $ : 8; ha = y | 8; z = 62; break } case 88: case 120: { fa = Q; ga = $; ha = y; z = 62; break } case 111: { P = k; R = f[P >> 2] | 0; ia = f[P + 4 >> 2] | 0; P = Gl(R, ia, o) | 0; ja = q - P | 0; ka = P; la = 0; ma = 15494; na = (y & 8 | 0) == 0 | ($ | 0) > (ja | 0) ? $ : ja + 1 | 0; oa = y; pa = R; qa = ia; z = 68; break } case 105: case 100: { ia = k; R = f[ia >> 2] | 0; ja = f[ia + 4 >> 2] | 0; if ((ja | 0) < 0) { ia = Vn(0, 0, R | 0, ja | 0) | 0; P = I; ra = k; f[ra >> 2] = ia; f[ra + 4 >> 2] = P; sa = 1; ta = 15494; ua = ia; va = P; z = 67; break d } else { sa = (y & 2049 | 0) != 0 & 1; ta = (y & 2048 | 0) == 0 ? ((y & 1 | 0) == 0 ? 15494 : 15496) : 15495; ua = R; va = ja; z = 67; break d } break } case 117: { ja = k; sa = 0; ta = 15494; ua = f[ja >> 2] | 0; va = f[ja + 4 >> 2] | 0; z = 67; break } case 99: { b[r >> 0] = f[k >> 2]; wa = r; xa = 0; ya = 15494; za = o; Aa = 1; Ba = O; break } case 109: { ja = ir() | 0; Ca = kp(f[ja >> 2] | 0) | 0; z = 72; break } case 115: { ja = f[k >> 2] | 0; Ca = ja | 0 ? ja : 15504; z = 72; break } case 67: { f[m >> 2] = f[k >> 2]; f[l >> 2] = 0; f[k >> 2] = m; Da = -1; Ea = m; z = 76; break } case 83: { ja = f[k >> 2] | 0; if (!$) { Hk(a, 32, X, 0, y); Fa = 0; z = 85 } else { Da = $; Ea = ja; z = 76 } break } case 65: case 71: case 70: case 69: case 97: case 103: case 102: case 101: { s = pb(a, +p[k >> 3], X, $, y, Q) | 0; t = x; v = Z; continue a; break } default: { wa = w; xa = 0; ya = 15494; za = o; Aa = $; Ba = y } } while (0); e: do if ((z | 0) == 62) { z = 0; w = k; Q = f[w >> 2] | 0; K = f[w + 4 >> 2] | 0; w = ol(Q, K, o, fa & 32) | 0; F = (ha & 8 | 0) == 0 | (Q | 0) == 0 & (K | 0) == 0; ka = w; la = F ? 0 : 2; ma = F ? 15494 : 15494 + (fa >> 4) | 0; na = ga; oa = ha; pa = Q; qa = K; z = 68 } else if ((z | 0) == 67) { z = 0; ka = Jj(ua, va, o) | 0; la = sa; ma = ta; na = $; oa = y; pa = ua; qa = va; z = 68 } else if ((z | 0) == 72) { z = 0; K = cg(Ca, 0, $) | 0; Q = (K | 0) == 0; wa = Ca; xa = 0; ya = 15494; za = Q ? Ca + $ | 0 : K; Aa = Q ? $ : K - Ca | 0; Ba = O } else if ((z | 0) == 76) { z = 0; K = Ea; Q = 0; F = 0; while (1) { w = f[K >> 2] | 0; if (!w) { Ga = Q; Ha = F; break } ja = Yo(n, w) | 0; if ((ja | 0) < 0 | ja >>> 0 > (Da - Q | 0) >>> 0) { Ga = Q; Ha = ja; break } w = ja + Q | 0; if (Da >>> 0 > w >>> 0) { K = K + 4 | 0; Q = w; F = ja } else { Ga = w; Ha = ja; break } } if ((Ha | 0) < 0) { V = -1; break a } Hk(a, 32, X, Ga, y); if (!Ga) { Fa = 0; z = 85 } else { F = Ea; Q = 0; while (1) { K = f[F >> 2] | 0; if (!K) { Fa = Ga; z = 85; break e } ja = Yo(n, K) | 0; Q = ja + Q | 0; if ((Q | 0) > (Ga | 0)) { Fa = Ga; z = 85; break e } ep(a, n, ja); if (Q >>> 0 >= Ga >>> 0) { Fa = Ga; z = 85; break } else F = F + 4 | 0 } } } while (0); if ((z | 0) == 68) { z = 0; O = (pa | 0) != 0 | (qa | 0) != 0; F = (na | 0) != 0 | O; Q = q - ka + ((O ^ 1) & 1) | 0; wa = F ? ka : o; xa = la; ya = ma; za = o; Aa = F ? ((na | 0) > (Q | 0) ? na : Q) : na; Ba = (na | 0) > -1 ? oa & -65537 : oa } else if ((z | 0) == 85) { z = 0; Hk(a, 32, X, Fa, y ^ 8192); s = (X | 0) > (Fa | 0) ? X : Fa; t = x; v = Z; continue } Q = za - wa | 0; F = (Aa | 0) < (Q | 0) ? Q : Aa; O = F + xa | 0; ja = (X | 0) < (O | 0) ? O : X; Hk(a, 32, ja, O, Ba); ep(a, ya, xa); Hk(a, 48, ja, O, Ba ^ 65536); Hk(a, 48, F, Q, 0); ep(a, wa, Q); Hk(a, 32, ja, O, Ba ^ 8192); s = ja; t = x; v = Z } f: do if ((z | 0) == 88) if (!a) if (v) { Z = 1; while (1) { t = f[h + (Z << 2) >> 2] | 0; if (!t) { Ia = Z; break } Ie(g + (Z << 3) | 0, t, e); t = Z + 1 | 0; if ((Z | 0) < 9) Z = t; else { Ia = t; break } } if ((Ia | 0) < 10) { Z = Ia; while (1) { if (f[h + (Z << 2) >> 2] | 0) { V = -1; break f } if ((Z | 0) < 9) Z = Z + 1 | 0; else { V = 1; break } } } else V = 1 } else V = 0; else V = x; while (0); u = i; return V | 0 } function rb(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = Oa, ma = Oa, na = Oa, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0; c = u; u = u + 64 | 0; d = c + 28 | 0; e = c + 16 | 0; g = c + 4 | 0; h = c; i = a; j = a + 80 | 0; k = f[j >> 2] | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = i; l = d + 20 | 0; n[l >> 2] = $(1.0); f[d + 24 >> 2] = i; qh(d, k); k = f[j >> 2] | 0; f[e >> 2] = 0; i = e + 4 | 0; f[i >> 2] = 0; f[e + 8 >> 2] = 0; m = (k | 0) == 0; do if (!m) if (k >>> 0 > 1073741823) mq(e); else { o = k << 2; p = dn(o) | 0; f[e >> 2] = p; q = p + (k << 2) | 0; f[e + 8 >> 2] = q; hj(p | 0, 0, o | 0) | 0; f[i >> 2] = q; break } while (0); f[g >> 2] = 0; k = g + 4 | 0; f[k >> 2] = 0; f[g + 8 >> 2] = 0; f[h >> 2] = 0; if (!m) { m = d + 16 | 0; q = d + 4 | 0; o = d + 12 | 0; p = d + 8 | 0; r = g + 8 | 0; s = d + 24 | 0; t = 0; v = 0; while (1) { w = f[m >> 2] | 0; x = f[w + 8 >> 2] | 0; y = (f[w + 12 >> 2] | 0) - x | 0; w = (y | 0) > 0; z = x; if (w) { x = y >>> 2; A = 0; B = 0; while (1) { C = f[z + (A << 2) >> 2] | 0; if (!(b[C + 84 >> 0] | 0)) D = f[(f[C + 68 >> 2] | 0) + (v << 2) >> 2] | 0; else D = v; C = D + 239 ^ B; A = A + 1 | 0; if ((A | 0) >= (x | 0)) { E = C; break } else B = C } } else E = 0; B = f[q >> 2] | 0; x = (B | 0) == 0; a: do if (!x) { A = B + -1 | 0; C = (A & B | 0) == 0; if (!C) if (E >>> 0 < B >>> 0) F = E; else F = (E >>> 0) % (B >>> 0) | 0; else F = A & E; G = f[(f[d >> 2] | 0) + (F << 2) >> 2] | 0; if ((G | 0) != 0 ? (H = f[G >> 2] | 0, (H | 0) != 0) : 0) { G = f[s >> 2] | 0; I = G + 8 | 0; J = G + 12 | 0; b: do if (C) { G = H; while (1) { K = f[G + 4 >> 2] | 0; L = (K | 0) == (E | 0); if (!(L | (K & A | 0) == (F | 0))) { M = 44; break a } c: do if (L) { K = f[G + 8 >> 2] | 0; N = f[I >> 2] | 0; O = (f[J >> 2] | 0) - N | 0; P = N; if ((O | 0) <= 0) { Q = G; break b } N = O >>> 2; O = 0; while (1) { R = f[P + (O << 2) >> 2] | 0; if (!(b[R + 84 >> 0] | 0)) { S = f[R + 68 >> 2] | 0; T = f[S + (v << 2) >> 2] | 0; U = f[S + (K << 2) >> 2] | 0 } else { T = v; U = K } O = O + 1 | 0; if ((U | 0) != (T | 0)) break c; if ((O | 0) >= (N | 0)) { V = G; M = 42; break b } } } while (0); G = f[G >> 2] | 0; if (!G) { M = 44; break a } } } else { G = H; while (1) { L = f[G + 4 >> 2] | 0; d: do if ((L | 0) != (E | 0)) { if (L >>> 0 < B >>> 0) X = L; else X = (L >>> 0) % (B >>> 0) | 0; if ((X | 0) != (F | 0)) { M = 44; break a } } else { N = f[G + 8 >> 2] | 0; O = f[I >> 2] | 0; K = (f[J >> 2] | 0) - O | 0; P = O; if ((K | 0) <= 0) { Q = G; break b } O = K >>> 2; K = 0; while (1) { S = f[P + (K << 2) >> 2] | 0; if (!(b[S + 84 >> 0] | 0)) { R = f[S + 68 >> 2] | 0; Y = f[R + (v << 2) >> 2] | 0; Z = f[R + (N << 2) >> 2] | 0 } else { Y = v; Z = N } K = K + 1 | 0; if ((Z | 0) != (Y | 0)) break d; if ((K | 0) >= (O | 0)) { V = G; M = 42; break b } } } while (0); G = f[G >> 2] | 0; if (!G) { M = 44; break a } } } while (0); if ((M | 0) == 42) { M = 0; if (!V) { M = 44; break } else Q = V } f[(f[e >> 2] | 0) + (v << 2) >> 2] = f[Q + 12 >> 2]; _ = t } else M = 44 } else M = 44; while (0); do if ((M | 0) == 44) { M = 0; if (w) { J = y >>> 2; I = 0; H = 0; while (1) { A = f[z + (I << 2) >> 2] | 0; if (!(b[A + 84 >> 0] | 0)) aa = f[(f[A + 68 >> 2] | 0) + (v << 2) >> 2] | 0; else aa = v; A = aa + 239 ^ H; I = I + 1 | 0; if ((I | 0) >= (J | 0)) { ba = A; break } else H = A } } else ba = 0; e: do if (!x) { H = B + -1 | 0; J = (H & B | 0) == 0; if (!J) if (ba >>> 0 < B >>> 0) ca = ba; else ca = (ba >>> 0) % (B >>> 0) | 0; else ca = H & ba; I = f[(f[d >> 2] | 0) + (ca << 2) >> 2] | 0; if ((I | 0) != 0 ? (A = f[I >> 2] | 0, (A | 0) != 0) : 0) { I = f[s >> 2] | 0; C = I + 8 | 0; G = I + 12 | 0; if (J) { J = A; while (1) { I = f[J + 4 >> 2] | 0; if (!((I | 0) == (ba | 0) | (I & H | 0) == (ca | 0))) { da = ca; M = 76; break e } I = f[J + 8 >> 2] | 0; L = f[C >> 2] | 0; O = (f[G >> 2] | 0) - L | 0; K = L; if ((O | 0) <= 0) { ea = v; break e } L = O >>> 2; O = 0; while (1) { N = f[K + (O << 2) >> 2] | 0; if (!(b[N + 84 >> 0] | 0)) { P = f[N + 68 >> 2] | 0; fa = f[P + (v << 2) >> 2] | 0; ga = f[P + (I << 2) >> 2] | 0 } else { fa = v; ga = I } O = O + 1 | 0; if ((ga | 0) != (fa | 0)) break; if ((O | 0) >= (L | 0)) { ea = v; break e } } J = f[J >> 2] | 0; if (!J) { da = ca; M = 76; break e } } } else ha = A; while (1) { J = f[ha + 4 >> 2] | 0; if ((J | 0) != (ba | 0)) { if (J >>> 0 < B >>> 0) ia = J; else ia = (J >>> 0) % (B >>> 0) | 0; if ((ia | 0) != (ca | 0)) { da = ca; M = 76; break e } } J = f[ha + 8 >> 2] | 0; H = f[C >> 2] | 0; L = (f[G >> 2] | 0) - H | 0; O = H; if ((L | 0) <= 0) { ea = v; break e } H = L >>> 2; L = 0; while (1) { I = f[O + (L << 2) >> 2] | 0; if (!(b[I + 84 >> 0] | 0)) { K = f[I + 68 >> 2] | 0; ja = f[K + (v << 2) >> 2] | 0; ka = f[K + (J << 2) >> 2] | 0 } else { ja = v; ka = J } L = L + 1 | 0; if ((ka | 0) != (ja | 0)) break; if ((L | 0) >= (H | 0)) { ea = v; break e } } ha = f[ha >> 2] | 0; if (!ha) { da = ca; M = 76; break } } } else { da = ca; M = 76 } } else { da = 0; M = 76 } while (0); if ((M | 0) == 76) { M = 0; G = dn(16) | 0; f[G + 8 >> 2] = v; f[G + 12 >> 2] = t; f[G + 4 >> 2] = ba; f[G >> 2] = 0; la = $(((f[o >> 2] | 0) + 1 | 0) >>> 0); ma = $(B >>> 0); na = $(n[l >> 2]); do if (x | $(na * ma) < la) { C = B << 1 | (B >>> 0 < 3 | (B + -1 & B | 0) != 0) & 1; A = ~~$(W($(la / na))) >>> 0; qh(d, C >>> 0 < A >>> 0 ? A : C); C = f[q >> 2] | 0; A = C + -1 | 0; if (!(A & C)) { oa = C; pa = A & ba; break } if (ba >>> 0 < C >>> 0) { oa = C; pa = ba } else { oa = C; pa = (ba >>> 0) % (C >>> 0) | 0 } } else { oa = B; pa = da } while (0); C = (f[d >> 2] | 0) + (pa << 2) | 0; A = f[C >> 2] | 0; if (!A) { f[G >> 2] = f[p >> 2]; f[p >> 2] = G; f[C >> 2] = p; C = f[G >> 2] | 0; if (C | 0) { H = f[C + 4 >> 2] | 0; C = oa + -1 | 0; if (C & oa) if (H >>> 0 < oa >>> 0) qa = H; else qa = (H >>> 0) % (oa >>> 0) | 0; else qa = H & C; ra = (f[d >> 2] | 0) + (qa << 2) | 0; M = 89 } } else { f[G >> 2] = f[A >> 2]; ra = A; M = 89 } if ((M | 0) == 89) { M = 0; f[ra >> 2] = G } f[o >> 2] = (f[o >> 2] | 0) + 1; ea = f[h >> 2] | 0 } A = t + 1 | 0; f[(f[e >> 2] | 0) + (ea << 2) >> 2] = t; C = f[k >> 2] | 0; if ((C | 0) == (f[r >> 2] | 0)) { Ci(g, h); _ = A; break } else { f[C >> 2] = f[h >> 2]; f[k >> 2] = C + 4; _ = A; break } } while (0); v = (f[h >> 2] | 0) + 1 | 0; f[h >> 2] = v; sa = f[j >> 2] | 0; if (v >>> 0 >= sa >>> 0) break; else t = _ } if ((_ | 0) != (sa | 0)) { Xa[f[(f[a >> 2] | 0) + 24 >> 2] & 15](a, e, g); f[j >> 2] = _ } } _ = f[g >> 2] | 0; if (_ | 0) { g = f[k >> 2] | 0; if ((g | 0) != (_ | 0)) f[k >> 2] = g + (~((g + -4 - _ | 0) >>> 2) << 2); br(_) } _ = f[e >> 2] | 0; if (_ | 0) { e = f[i >> 2] | 0; if ((e | 0) != (_ | 0)) f[i >> 2] = e + (~((e + -4 - _ | 0) >>> 2) << 2); br(_) } _ = f[d + 8 >> 2] | 0; if (_ | 0) { e = _; do { _ = e; e = f[e >> 2] | 0; br(_) } while ((e | 0) != 0) } e = f[d >> 2] | 0; f[d >> 2] = 0; if (!e) { u = c; return } br(e); u = c; return } function sb(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0; g = u; u = u + 80 | 0; h = g + 76 | 0; i = g + 72 | 0; j = g + 48 | 0; k = g + 24 | 0; l = g; m = a + 32 | 0; n = f[c >> 2] | 0; c = n + 1 | 0; if ((n | 0) != -1) { o = ((c >>> 0) % 3 | 0 | 0) == 0 ? n + -2 | 0 : c; c = (((n >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + n | 0; if ((o | 0) == -1) p = -1; else p = f[(f[f[m >> 2] >> 2] | 0) + (o << 2) >> 2] | 0; if ((c | 0) == -1) { q = p; r = -1 } else { q = p; r = f[(f[f[m >> 2] >> 2] | 0) + (c << 2) >> 2] | 0 } } else { q = -1; r = -1 } c = f[a + 36 >> 2] | 0; m = f[c >> 2] | 0; p = (f[c + 4 >> 2] | 0) - m >> 2; if (p >>> 0 <= q >>> 0) mq(c); o = m; m = f[o + (q << 2) >> 2] | 0; if (p >>> 0 <= r >>> 0) mq(c); c = f[o + (r << 2) >> 2] | 0; r = (m | 0) < (e | 0); do if (r & (c | 0) < (e | 0)) { o = m << 1; p = f[d + (o << 2) >> 2] | 0; q = ((p | 0) < 0) << 31 >> 31; n = f[d + ((o | 1) << 2) >> 2] | 0; o = ((n | 0) < 0) << 31 >> 31; s = c << 1; t = f[d + (s << 2) >> 2] | 0; v = f[d + ((s | 1) << 2) >> 2] | 0; if (!((t | 0) != (p | 0) | (v | 0) != (n | 0))) { f[a + 8 >> 2] = p; f[a + 12 >> 2] = n; u = g; return 1 } s = a + 4 | 0; w = f[(f[s >> 2] | 0) + (e << 2) >> 2] | 0; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; f[j + 12 >> 2] = 0; f[j + 16 >> 2] = 0; f[j + 20 >> 2] = 0; x = f[a >> 2] | 0; if (!(b[x + 84 >> 0] | 0)) y = f[(f[x + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else y = w; f[i >> 2] = y; w = b[x + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(x, h, w, j) | 0; w = f[(f[s >> 2] | 0) + (m << 2) >> 2] | 0; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; x = f[a >> 2] | 0; if (!(b[x + 84 >> 0] | 0)) z = f[(f[x + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else z = w; f[i >> 2] = z; w = b[x + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(x, h, w, k) | 0; w = f[(f[s >> 2] | 0) + (c << 2) >> 2] | 0; f[l >> 2] = 0; f[l + 4 >> 2] = 0; f[l + 8 >> 2] = 0; f[l + 12 >> 2] = 0; f[l + 16 >> 2] = 0; f[l + 20 >> 2] = 0; s = f[a >> 2] | 0; if (!(b[s + 84 >> 0] | 0)) A = f[(f[s + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else A = w; f[i >> 2] = A; w = b[s + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(s, h, w, l) | 0; w = l; s = k; x = f[s >> 2] | 0; B = f[s + 4 >> 2] | 0; s = Vn(f[w >> 2] | 0, f[w + 4 >> 2] | 0, x | 0, B | 0) | 0; w = I; C = l + 8 | 0; D = k + 8 | 0; E = f[D >> 2] | 0; F = f[D + 4 >> 2] | 0; D = Vn(f[C >> 2] | 0, f[C + 4 >> 2] | 0, E | 0, F | 0) | 0; C = I; G = l + 16 | 0; H = k + 16 | 0; J = f[H >> 2] | 0; K = f[H + 4 >> 2] | 0; H = Vn(f[G >> 2] | 0, f[G + 4 >> 2] | 0, J | 0, K | 0) | 0; G = I; L = on(s | 0, w | 0, s | 0, w | 0) | 0; M = I; N = on(D | 0, C | 0, D | 0, C | 0) | 0; O = Tn(N | 0, I | 0, L | 0, M | 0) | 0; M = I; L = on(H | 0, G | 0, H | 0, G | 0) | 0; N = Tn(O | 0, M | 0, L | 0, I | 0) | 0; L = I; if ((N | 0) == 0 & (L | 0) == 0) break; M = j; O = Vn(f[M >> 2] | 0, f[M + 4 >> 2] | 0, x | 0, B | 0) | 0; B = I; x = j + 8 | 0; M = Vn(f[x >> 2] | 0, f[x + 4 >> 2] | 0, E | 0, F | 0) | 0; F = I; E = j + 16 | 0; x = Vn(f[E >> 2] | 0, f[E + 4 >> 2] | 0, J | 0, K | 0) | 0; K = I; J = on(O | 0, B | 0, s | 0, w | 0) | 0; E = I; P = on(M | 0, F | 0, D | 0, C | 0) | 0; Q = Tn(P | 0, I | 0, J | 0, E | 0) | 0; E = I; J = on(x | 0, K | 0, H | 0, G | 0) | 0; P = Tn(Q | 0, E | 0, J | 0, I | 0) | 0; J = I; E = Vn(t | 0, ((t | 0) < 0) << 31 >> 31 | 0, p | 0, q | 0) | 0; t = I; Q = Vn(v | 0, ((v | 0) < 0) << 31 >> 31 | 0, n | 0, o | 0) | 0; v = I; R = on(N | 0, L | 0, p | 0, q | 0) | 0; q = I; p = on(N | 0, L | 0, n | 0, o | 0) | 0; o = I; n = on(P | 0, J | 0, E | 0, t | 0) | 0; S = I; T = on(P | 0, J | 0, Q | 0, v | 0) | 0; U = I; V = Tn(n | 0, S | 0, R | 0, q | 0) | 0; q = I; R = Tn(T | 0, U | 0, p | 0, o | 0) | 0; o = I; p = on(P | 0, J | 0, s | 0, w | 0) | 0; w = I; s = on(P | 0, J | 0, D | 0, C | 0) | 0; C = I; D = on(P | 0, J | 0, H | 0, G | 0) | 0; G = I; H = zk(p | 0, w | 0, N | 0, L | 0) | 0; w = I; p = zk(s | 0, C | 0, N | 0, L | 0) | 0; C = I; s = zk(D | 0, G | 0, N | 0, L | 0) | 0; G = I; D = Vn(O | 0, B | 0, H | 0, w | 0) | 0; w = I; H = Vn(M | 0, F | 0, p | 0, C | 0) | 0; C = I; p = Vn(x | 0, K | 0, s | 0, G | 0) | 0; G = I; s = on(D | 0, w | 0, D | 0, w | 0) | 0; w = I; D = on(H | 0, C | 0, H | 0, C | 0) | 0; C = Tn(D | 0, I | 0, s | 0, w | 0) | 0; w = I; s = on(p | 0, G | 0, p | 0, G | 0) | 0; G = Tn(C | 0, w | 0, s | 0, I | 0) | 0; s = I; w = Vn(0, 0, E | 0, t | 0) | 0; t = I; E = on(G | 0, s | 0, N | 0, L | 0) | 0; s = I; switch (E | 0) { case 0: { if (!s) { W = 0; X = 0 } else { Y = 1; Z = 0; _ = E; $ = s; aa = 23 } break } case 1: { if (!s) { ba = 1; ca = 0; aa = 24 } else { Y = 1; Z = 0; _ = E; $ = s; aa = 23 } break } default: { Y = 1; Z = 0; _ = E; $ = s; aa = 23 } }if ((aa | 0) == 23) while (1) { aa = 0; G = Rn(Y | 0, Z | 0, 1) | 0; C = I; p = _; _ = Wn(_ | 0, $ | 0, 2) | 0; if (!($ >>> 0 > 0 | ($ | 0) == 0 & p >>> 0 > 7)) { ba = G; ca = C; aa = 24; break } else { Y = G; Z = C; $ = I; aa = 23 } } if ((aa | 0) == 24) while (1) { aa = 0; C = up(E | 0, s | 0, ba | 0, ca | 0) | 0; G = Tn(C | 0, I | 0, ba | 0, ca | 0) | 0; C = Wn(G | 0, I | 0, 1) | 0; G = I; p = on(C | 0, G | 0, C | 0, G | 0) | 0; D = I; if (D >>> 0 > s >>> 0 | (D | 0) == (s | 0) & p >>> 0 > E >>> 0) { ba = C; ca = G; aa = 24 } else { W = C; X = G; break } } E = on(W | 0, X | 0, Q | 0, v | 0) | 0; s = I; G = on(W | 0, X | 0, w | 0, t | 0) | 0; C = I; p = Tn(E | 0, s | 0, V | 0, q | 0) | 0; D = I; H = Tn(G | 0, C | 0, R | 0, o | 0) | 0; K = I; x = zk(p | 0, D | 0, N | 0, L | 0) | 0; D = I; p = zk(H | 0, K | 0, N | 0, L | 0) | 0; K = I; H = Vn(V | 0, q | 0, E | 0, s | 0) | 0; s = I; E = Vn(R | 0, o | 0, G | 0, C | 0) | 0; C = I; G = zk(H | 0, s | 0, N | 0, L | 0) | 0; s = I; H = zk(E | 0, C | 0, N | 0, L | 0) | 0; C = I; E = e << 1; F = f[d + (E << 2) >> 2] | 0; M = ((F | 0) < 0) << 31 >> 31; B = f[d + ((E | 1) << 2) >> 2] | 0; E = ((B | 0) < 0) << 31 >> 31; O = Vn(F | 0, M | 0, x | 0, D | 0) | 0; J = I; P = Vn(B | 0, E | 0, p | 0, K | 0) | 0; U = I; T = on(O | 0, J | 0, O | 0, J | 0) | 0; J = I; O = on(P | 0, U | 0, P | 0, U | 0) | 0; U = Tn(O | 0, I | 0, T | 0, J | 0) | 0; J = I; T = Vn(F | 0, M | 0, G | 0, s | 0) | 0; M = I; F = Vn(B | 0, E | 0, H | 0, C | 0) | 0; E = I; B = on(T | 0, M | 0, T | 0, M | 0) | 0; M = I; T = on(F | 0, E | 0, F | 0, E | 0) | 0; E = Tn(T | 0, I | 0, B | 0, M | 0) | 0; M = I; B = a + 16 | 0; T = a + 20 | 0; F = f[T >> 2] | 0; O = f[a + 24 >> 2] | 0; P = (F | 0) == (O << 5 | 0); if (J >>> 0 < M >>> 0 | (J | 0) == (M | 0) & U >>> 0 < E >>> 0) { do if (P) if ((F + 1 | 0) < 0) mq(B); else { E = O << 6; U = F + 32 & -32; hi(B, F >>> 0 < 1073741823 ? (E >>> 0 < U >>> 0 ? U : E) : 2147483647); da = f[T >> 2] | 0; break } else da = F; while (0); f[T >> 2] = da + 1; L = (f[B >> 2] | 0) + (da >>> 5 << 2) | 0; f[L >> 2] = f[L >> 2] | 1 << (da & 31); ea = x; fa = p; ga = K; ha = D } else { do if (P) if ((F + 1 | 0) < 0) mq(B); else { L = O << 6; N = F + 32 & -32; hi(B, F >>> 0 < 1073741823 ? (L >>> 0 < N >>> 0 ? N : L) : 2147483647); ia = f[T >> 2] | 0; break } else ia = F; while (0); f[T >> 2] = ia + 1; F = (f[B >> 2] | 0) + (ia >>> 5 << 2) | 0; f[F >> 2] = f[F >> 2] & ~(1 << (ia & 31)); ea = G; fa = H; ga = C; ha = s } f[a + 8 >> 2] = ea; f[a + 12 >> 2] = fa; u = g; return 1 } while (0); do if (r) ja = m << 1; else { if ((e | 0) > 0) { ja = (e << 1) + -2 | 0; break } fa = a + 8 | 0; f[fa >> 2] = 0; f[fa + 4 >> 2] = 0; u = g; return 1 } while (0); f[a + 8 >> 2] = f[d + (ja << 2) >> 2]; f[a + 12 >> 2] = f[d + (ja + 1 << 2) >> 2]; u = g; return 1 } function tb(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0; g = u; u = u + 80 | 0; h = g + 76 | 0; i = g + 72 | 0; j = g + 48 | 0; k = g + 24 | 0; l = g; m = a + 32 | 0; n = f[c >> 2] | 0; c = n + 1 | 0; do if ((n | 0) != -1) { o = ((c >>> 0) % 3 | 0 | 0) == 0 ? n + -2 | 0 : c; if (!((n >>> 0) % 3 | 0)) { p = n + 2 | 0; q = o; break } else { p = n + -1 | 0; q = o; break } } else { p = -1; q = -1 } while (0); n = f[(f[m >> 2] | 0) + 28 >> 2] | 0; m = f[n + (q << 2) >> 2] | 0; q = f[n + (p << 2) >> 2] | 0; p = f[a + 36 >> 2] | 0; n = f[p >> 2] | 0; c = (f[p + 4 >> 2] | 0) - n >> 2; if (c >>> 0 <= m >>> 0) mq(p); o = n; n = f[o + (m << 2) >> 2] | 0; if (c >>> 0 <= q >>> 0) mq(p); p = f[o + (q << 2) >> 2] | 0; q = (n | 0) < (e | 0); do if (q & (p | 0) < (e | 0)) { o = n << 1; c = f[d + (o << 2) >> 2] | 0; m = ((c | 0) < 0) << 31 >> 31; r = f[d + ((o | 1) << 2) >> 2] | 0; o = ((r | 0) < 0) << 31 >> 31; s = p << 1; t = f[d + (s << 2) >> 2] | 0; v = f[d + ((s | 1) << 2) >> 2] | 0; if (!((t | 0) != (c | 0) | (v | 0) != (r | 0))) { f[a + 8 >> 2] = c; f[a + 12 >> 2] = r; u = g; return 1 } s = a + 4 | 0; w = f[(f[s >> 2] | 0) + (e << 2) >> 2] | 0; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; f[j + 12 >> 2] = 0; f[j + 16 >> 2] = 0; f[j + 20 >> 2] = 0; x = f[a >> 2] | 0; if (!(b[x + 84 >> 0] | 0)) y = f[(f[x + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else y = w; f[i >> 2] = y; w = b[x + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(x, h, w, j) | 0; w = f[(f[s >> 2] | 0) + (n << 2) >> 2] | 0; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; x = f[a >> 2] | 0; if (!(b[x + 84 >> 0] | 0)) z = f[(f[x + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else z = w; f[i >> 2] = z; w = b[x + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(x, h, w, k) | 0; w = f[(f[s >> 2] | 0) + (p << 2) >> 2] | 0; f[l >> 2] = 0; f[l + 4 >> 2] = 0; f[l + 8 >> 2] = 0; f[l + 12 >> 2] = 0; f[l + 16 >> 2] = 0; f[l + 20 >> 2] = 0; s = f[a >> 2] | 0; if (!(b[s + 84 >> 0] | 0)) A = f[(f[s + 68 >> 2] | 0) + (w << 2) >> 2] | 0; else A = w; f[i >> 2] = A; w = b[s + 24 >> 0] | 0; f[h >> 2] = f[i >> 2]; ub(s, h, w, l) | 0; w = l; s = k; x = f[s >> 2] | 0; B = f[s + 4 >> 2] | 0; s = Vn(f[w >> 2] | 0, f[w + 4 >> 2] | 0, x | 0, B | 0) | 0; w = I; C = l + 8 | 0; D = k + 8 | 0; E = f[D >> 2] | 0; F = f[D + 4 >> 2] | 0; D = Vn(f[C >> 2] | 0, f[C + 4 >> 2] | 0, E | 0, F | 0) | 0; C = I; G = l + 16 | 0; H = k + 16 | 0; J = f[H >> 2] | 0; K = f[H + 4 >> 2] | 0; H = Vn(f[G >> 2] | 0, f[G + 4 >> 2] | 0, J | 0, K | 0) | 0; G = I; L = on(s | 0, w | 0, s | 0, w | 0) | 0; M = I; N = on(D | 0, C | 0, D | 0, C | 0) | 0; O = Tn(N | 0, I | 0, L | 0, M | 0) | 0; M = I; L = on(H | 0, G | 0, H | 0, G | 0) | 0; N = Tn(O | 0, M | 0, L | 0, I | 0) | 0; L = I; if ((N | 0) == 0 & (L | 0) == 0) break; M = j; O = Vn(f[M >> 2] | 0, f[M + 4 >> 2] | 0, x | 0, B | 0) | 0; B = I; x = j + 8 | 0; M = Vn(f[x >> 2] | 0, f[x + 4 >> 2] | 0, E | 0, F | 0) | 0; F = I; E = j + 16 | 0; x = Vn(f[E >> 2] | 0, f[E + 4 >> 2] | 0, J | 0, K | 0) | 0; K = I; J = on(O | 0, B | 0, s | 0, w | 0) | 0; E = I; P = on(M | 0, F | 0, D | 0, C | 0) | 0; Q = Tn(P | 0, I | 0, J | 0, E | 0) | 0; E = I; J = on(x | 0, K | 0, H | 0, G | 0) | 0; P = Tn(Q | 0, E | 0, J | 0, I | 0) | 0; J = I; E = Vn(t | 0, ((t | 0) < 0) << 31 >> 31 | 0, c | 0, m | 0) | 0; t = I; Q = Vn(v | 0, ((v | 0) < 0) << 31 >> 31 | 0, r | 0, o | 0) | 0; v = I; R = on(N | 0, L | 0, c | 0, m | 0) | 0; m = I; c = on(N | 0, L | 0, r | 0, o | 0) | 0; o = I; r = on(P | 0, J | 0, E | 0, t | 0) | 0; S = I; T = on(P | 0, J | 0, Q | 0, v | 0) | 0; U = I; V = Tn(r | 0, S | 0, R | 0, m | 0) | 0; m = I; R = Tn(T | 0, U | 0, c | 0, o | 0) | 0; o = I; c = on(P | 0, J | 0, s | 0, w | 0) | 0; w = I; s = on(P | 0, J | 0, D | 0, C | 0) | 0; C = I; D = on(P | 0, J | 0, H | 0, G | 0) | 0; G = I; H = zk(c | 0, w | 0, N | 0, L | 0) | 0; w = I; c = zk(s | 0, C | 0, N | 0, L | 0) | 0; C = I; s = zk(D | 0, G | 0, N | 0, L | 0) | 0; G = I; D = Vn(O | 0, B | 0, H | 0, w | 0) | 0; w = I; H = Vn(M | 0, F | 0, c | 0, C | 0) | 0; C = I; c = Vn(x | 0, K | 0, s | 0, G | 0) | 0; G = I; s = on(D | 0, w | 0, D | 0, w | 0) | 0; w = I; D = on(H | 0, C | 0, H | 0, C | 0) | 0; C = Tn(D | 0, I | 0, s | 0, w | 0) | 0; w = I; s = on(c | 0, G | 0, c | 0, G | 0) | 0; G = Tn(C | 0, w | 0, s | 0, I | 0) | 0; s = I; w = Vn(0, 0, E | 0, t | 0) | 0; t = I; E = on(G | 0, s | 0, N | 0, L | 0) | 0; s = I; switch (E | 0) { case 0: { if (!s) { W = 0; X = 0 } else { Y = 1; Z = 0; _ = E; $ = s; aa = 22 } break } case 1: { if (!s) { ba = 1; ca = 0; aa = 23 } else { Y = 1; Z = 0; _ = E; $ = s; aa = 22 } break } default: { Y = 1; Z = 0; _ = E; $ = s; aa = 22 } }if ((aa | 0) == 22) while (1) { aa = 0; G = Rn(Y | 0, Z | 0, 1) | 0; C = I; c = _; _ = Wn(_ | 0, $ | 0, 2) | 0; if (!($ >>> 0 > 0 | ($ | 0) == 0 & c >>> 0 > 7)) { ba = G; ca = C; aa = 23; break } else { Y = G; Z = C; $ = I; aa = 22 } } if ((aa | 0) == 23) while (1) { aa = 0; C = up(E | 0, s | 0, ba | 0, ca | 0) | 0; G = Tn(C | 0, I | 0, ba | 0, ca | 0) | 0; C = Wn(G | 0, I | 0, 1) | 0; G = I; c = on(C | 0, G | 0, C | 0, G | 0) | 0; D = I; if (D >>> 0 > s >>> 0 | (D | 0) == (s | 0) & c >>> 0 > E >>> 0) { ba = C; ca = G; aa = 23 } else { W = C; X = G; break } } E = on(W | 0, X | 0, Q | 0, v | 0) | 0; s = I; G = on(W | 0, X | 0, w | 0, t | 0) | 0; C = I; c = Tn(E | 0, s | 0, V | 0, m | 0) | 0; D = I; H = Tn(G | 0, C | 0, R | 0, o | 0) | 0; K = I; x = zk(c | 0, D | 0, N | 0, L | 0) | 0; D = I; c = zk(H | 0, K | 0, N | 0, L | 0) | 0; K = I; H = Vn(V | 0, m | 0, E | 0, s | 0) | 0; s = I; E = Vn(R | 0, o | 0, G | 0, C | 0) | 0; C = I; G = zk(H | 0, s | 0, N | 0, L | 0) | 0; s = I; H = zk(E | 0, C | 0, N | 0, L | 0) | 0; C = I; E = e << 1; F = f[d + (E << 2) >> 2] | 0; M = ((F | 0) < 0) << 31 >> 31; B = f[d + ((E | 1) << 2) >> 2] | 0; E = ((B | 0) < 0) << 31 >> 31; O = Vn(F | 0, M | 0, x | 0, D | 0) | 0; J = I; P = Vn(B | 0, E | 0, c | 0, K | 0) | 0; U = I; T = on(O | 0, J | 0, O | 0, J | 0) | 0; J = I; O = on(P | 0, U | 0, P | 0, U | 0) | 0; U = Tn(O | 0, I | 0, T | 0, J | 0) | 0; J = I; T = Vn(F | 0, M | 0, G | 0, s | 0) | 0; M = I; F = Vn(B | 0, E | 0, H | 0, C | 0) | 0; E = I; B = on(T | 0, M | 0, T | 0, M | 0) | 0; M = I; T = on(F | 0, E | 0, F | 0, E | 0) | 0; E = Tn(T | 0, I | 0, B | 0, M | 0) | 0; M = I; B = a + 16 | 0; T = a + 20 | 0; F = f[T >> 2] | 0; O = f[a + 24 >> 2] | 0; P = (F | 0) == (O << 5 | 0); if (J >>> 0 < M >>> 0 | (J | 0) == (M | 0) & U >>> 0 < E >>> 0) { do if (P) if ((F + 1 | 0) < 0) mq(B); else { E = O << 6; U = F + 32 & -32; hi(B, F >>> 0 < 1073741823 ? (E >>> 0 < U >>> 0 ? U : E) : 2147483647); da = f[T >> 2] | 0; break } else da = F; while (0); f[T >> 2] = da + 1; L = (f[B >> 2] | 0) + (da >>> 5 << 2) | 0; f[L >> 2] = f[L >> 2] | 1 << (da & 31); ea = x; fa = c; ga = K; ha = D } else { do if (P) if ((F + 1 | 0) < 0) mq(B); else { L = O << 6; N = F + 32 & -32; hi(B, F >>> 0 < 1073741823 ? (L >>> 0 < N >>> 0 ? N : L) : 2147483647); ia = f[T >> 2] | 0; break } else ia = F; while (0); f[T >> 2] = ia + 1; F = (f[B >> 2] | 0) + (ia >>> 5 << 2) | 0; f[F >> 2] = f[F >> 2] & ~(1 << (ia & 31)); ea = G; fa = H; ga = C; ha = s } f[a + 8 >> 2] = ea; f[a + 12 >> 2] = fa; u = g; return 1 } while (0); do if (q) ja = n << 1; else { if ((e | 0) > 0) { ja = (e << 1) + -2 | 0; break } fa = a + 8 | 0; f[fa >> 2] = 0; f[fa + 4 >> 2] = 0; u = g; return 1 } while (0); f[a + 8 >> 2] = f[d + (ja << 2) >> 2]; f[a + 12 >> 2] = f[d + (ja + 1 << 2) >> 2]; u = g; return 1 } function ub(a, c, e, g) { a = a | 0; c = c | 0; e = e | 0; g = g | 0; var i = 0, k = 0, l = 0, m = 0, o = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = Oa, D = 0, E = 0.0, F = 0, G = 0; if (!g) { i = 0; return i | 0 } do switch (f[a + 28 >> 2] | 0) { case 1: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; q = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; r = Tn(q | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = m + r | 0; r = 0; while (1) { m = b[o >> 0] | 0; q = g + (r << 3) | 0; f[q >> 2] = m; f[q + 4 >> 2] = ((m | 0) < 0) << 31 >> 31; r = r + 1 | 0; m = b[k >> 0] | 0; if ((r | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { s = m; break } else o = o + 1 | 0 } } else s = l; o = s << 24 >> 24; if (s << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 3) | 0, 0, (e << 24 >> 24) - o << 3 | 0) | 0; i = 1; return i | 0 } case 2: { o = a + 24 | 0; r = b[o >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; q = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(q | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { k = g + (t << 3) | 0; f[k >> 2] = h[m >> 0]; f[k + 4 >> 2] = 0; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { u = k; break } else m = m + 1 | 0 } } else u = r; m = u << 24 >> 24; if (u << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 3) | 0, 0, (e << 24 >> 24) - m << 3 | 0) | 0; i = 1; return i | 0 } case 3: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; q = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + q | 0; q = 0; while (1) { o = d[l >> 1] | 0; k = g + (q << 3) | 0; f[k >> 2] = o; f[k + 4 >> 2] = ((o | 0) < 0) << 31 >> 31; q = q + 1 | 0; o = b[m >> 0] | 0; if ((q | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { v = o; break } else l = l + 2 | 0 } } else v = t; l = v << 24 >> 24; if (v << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 3) | 0, 0, (e << 24 >> 24) - l << 3 | 0) | 0; i = 1; return i | 0 } case 4: { l = a + 24 | 0; q = b[l >> 0] | 0; if ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; r = a + 40 | 0; o = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; r = a + 48 | 0; k = Tn(o | 0, I | 0, f[r >> 2] | 0, f[r + 4 >> 2] | 0) | 0; r = m + k | 0; k = 0; while (1) { m = g + (k << 3) | 0; f[m >> 2] = j[r >> 1]; f[m + 4 >> 2] = 0; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { w = m; break } else r = r + 2 | 0 } } else w = q; r = w << 24 >> 24; if (w << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (r << 3) | 0, 0, (e << 24 >> 24) - r << 3 | 0) | 0; i = 1; return i | 0 } case 5: { r = a + 24 | 0; k = b[r >> 0] | 0; if ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 > 0) { l = f[f[a >> 2] >> 2] | 0; t = a + 40 | 0; m = on(f[t >> 2] | 0, f[t + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; t = a + 48 | 0; o = Tn(m | 0, I | 0, f[t >> 2] | 0, f[t + 4 >> 2] | 0) | 0; t = l + o | 0; o = 0; while (1) { l = f[t >> 2] | 0; m = g + (o << 3) | 0; f[m >> 2] = l; f[m + 4 >> 2] = ((l | 0) < 0) << 31 >> 31; o = o + 1 | 0; l = b[r >> 0] | 0; if ((o | 0) >= ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 | 0)) { x = l; break } else t = t + 4 | 0 } } else x = k; t = x << 24 >> 24; if (x << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (t << 3) | 0, 0, (e << 24 >> 24) - t << 3 | 0) | 0; i = 1; return i | 0 } case 6: { t = a + 24 | 0; o = b[t >> 0] | 0; if ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 > 0) { r = f[f[a >> 2] >> 2] | 0; q = a + 40 | 0; l = on(f[q >> 2] | 0, f[q + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; q = a + 48 | 0; m = Tn(l | 0, I | 0, f[q >> 2] | 0, f[q + 4 >> 2] | 0) | 0; q = r + m | 0; m = 0; while (1) { r = g + (m << 3) | 0; f[r >> 2] = f[q >> 2]; f[r + 4 >> 2] = 0; m = m + 1 | 0; r = b[t >> 0] | 0; if ((m | 0) >= ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 | 0)) { y = r; break } else q = q + 4 | 0 } } else y = o; q = y << 24 >> 24; if (y << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (q << 3) | 0, 0, (e << 24 >> 24) - q << 3 | 0) | 0; i = 1; return i | 0 } case 7: { q = a + 24 | 0; m = b[q >> 0] | 0; if ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 > 0) { t = f[f[a >> 2] >> 2] | 0; k = a + 40 | 0; r = on(f[k >> 2] | 0, f[k + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; k = a + 48 | 0; l = Tn(r | 0, I | 0, f[k >> 2] | 0, f[k + 4 >> 2] | 0) | 0; k = t + l | 0; l = 0; while (1) { t = k; r = f[t + 4 >> 2] | 0; z = g + (l << 3) | 0; f[z >> 2] = f[t >> 2]; f[z + 4 >> 2] = r; l = l + 1 | 0; r = b[q >> 0] | 0; if ((l | 0) >= ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 | 0)) { A = r; break } else k = k + 8 | 0 } } else A = m; k = A << 24 >> 24; if (A << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (k << 3) | 0, 0, (e << 24 >> 24) - k << 3 | 0) | 0; i = 1; return i | 0 } case 8: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { q = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; r = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; z = Tn(r | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = q + z | 0; z = 0; while (1) { q = o; r = f[q + 4 >> 2] | 0; t = g + (z << 3) | 0; f[t >> 2] = f[q >> 2]; f[t + 4 >> 2] = r; z = z + 1 | 0; r = b[k >> 0] | 0; if ((z | 0) >= ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 | 0)) { B = r; break } else o = o + 8 | 0 } } else B = l; o = B << 24 >> 24; if (B << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 3) | 0, 0, (e << 24 >> 24) - o << 3 | 0) | 0; i = 1; return i | 0 } case 9: { o = a + 24 | 0; z = b[o >> 0] | 0; if ((z << 24 >> 24 > e << 24 >> 24 ? e : z) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; r = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(r | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { C = $(n[m >> 2]); k = +K(+C) >= 1.0 ? (+C > 0.0 ? ~~+Y(+J(+C / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((+C - +(~~+C >>> 0)) / 4294967296.0) >>> 0) : 0; r = g + (t << 3) | 0; f[r >> 2] = ~~+C >>> 0; f[r + 4 >> 2] = k; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { D = k; break } else m = m + 4 | 0 } } else D = z; m = D << 24 >> 24; if (D << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 3) | 0, 0, (e << 24 >> 24) - m << 3 | 0) | 0; i = 1; return i | 0 } case 10: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; r = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + r | 0; r = 0; while (1) { E = +p[l >> 3]; o = +K(E) >= 1.0 ? (E > 0.0 ? ~~+Y(+J(E / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((E - +(~~E >>> 0)) / 4294967296.0) >>> 0) : 0; k = g + (r << 3) | 0; f[k >> 2] = ~~E >>> 0; f[k + 4 >> 2] = o; r = r + 1 | 0; o = b[m >> 0] | 0; if ((r | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { F = o; break } else l = l + 8 | 0 } } else F = t; l = F << 24 >> 24; if (F << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 3) | 0, 0, (e << 24 >> 24) - l << 3 | 0) | 0; i = 1; return i | 0 } case 11: { l = a + 24 | 0; r = b[l >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; z = a + 40 | 0; o = on(f[z >> 2] | 0, f[z + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; z = a + 48 | 0; k = Tn(o | 0, I | 0, f[z >> 2] | 0, f[z + 4 >> 2] | 0) | 0; z = m + k | 0; k = 0; while (1) { m = g + (k << 3) | 0; f[m >> 2] = h[z >> 0]; f[m + 4 >> 2] = 0; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { G = m; break } else z = z + 1 | 0 } } else G = r; z = G << 24 >> 24; if (G << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (z << 3) | 0, 0, (e << 24 >> 24) - z << 3 | 0) | 0; i = 1; return i | 0 } default: { i = 0; return i | 0 } } while (0); return 0 } function vb(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c; if ((f[a + 92 >> 2] | 0) == (f[a + 88 >> 2] | 0)) { u = c; return 1 } g = a + 52 | 0; h = f[g >> 2] | 0; if ((h | 0) == (f[a + 56 >> 2] | 0)) { Ci(a + 48 | 0, b); i = b } else { f[h >> 2] = f[b >> 2]; f[g >> 2] = h + 4; i = b } b = a + 84 | 0; f[b >> 2] = 0; h = a + 4 | 0; g = f[h >> 2] | 0; j = f[i >> 2] | 0; k = j + 1 | 0; if ((j | 0) != -1) { l = ((k >>> 0) % 3 | 0 | 0) == 0 ? j + -2 | 0 : k; if ((l | 0) == -1) m = -1; else m = f[(f[g >> 2] | 0) + (l << 2) >> 2] | 0; l = (((j >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + j | 0; if ((l | 0) == -1) { n = m; o = -1 } else { n = m; o = f[(f[g >> 2] | 0) + (l << 2) >> 2] | 0 } } else { n = -1; o = -1 } l = a + 36 | 0; g = f[l >> 2] | 0; m = g + (n >>> 5 << 2) | 0; j = 1 << (n & 31); k = f[m >> 2] | 0; if (!(k & j)) { f[m >> 2] = k | j; j = f[i >> 2] | 0; k = j + 1 | 0; if ((j | 0) == -1) p = -1; else p = ((k >>> 0) % 3 | 0 | 0) == 0 ? j + -2 | 0 : k; f[e >> 2] = p; k = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((p >>> 0) / 3 | 0) * 12 | 0) + (((p >>> 0) % 3 | 0) << 2) >> 2] | 0; p = f[a + 20 >> 2] | 0; f[d >> 2] = k; j = f[p + 4 >> 2] | 0; p = j + 4 | 0; m = f[p >> 2] | 0; if ((m | 0) == (f[j + 8 >> 2] | 0)) Ci(j, d); else { f[m >> 2] = k; f[p >> 2] = m + 4 } m = a + 12 | 0; p = f[m >> 2] | 0; k = p + 4 | 0; j = f[k >> 2] | 0; if ((j | 0) == (f[p + 8 >> 2] | 0)) { Ci(p, e); q = f[m >> 2] | 0 } else { f[j >> 2] = f[e >> 2]; f[k >> 2] = j + 4; q = p } p = q + 24 | 0; f[(f[q + 12 >> 2] | 0) + (n << 2) >> 2] = f[p >> 2]; f[p >> 2] = (f[p >> 2] | 0) + 1; r = f[l >> 2] | 0 } else r = g; g = r + (o >>> 5 << 2) | 0; r = 1 << (o & 31); p = f[g >> 2] | 0; if (!(p & r)) { f[g >> 2] = p | r; r = f[i >> 2] | 0; do if ((r | 0) != -1) if (!((r >>> 0) % 3 | 0)) { s = r + 2 | 0; break } else { s = r + -1 | 0; break } else s = -1; while (0); f[e >> 2] = s; r = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((s >>> 0) / 3 | 0) * 12 | 0) + (((s >>> 0) % 3 | 0) << 2) >> 2] | 0; s = f[a + 20 >> 2] | 0; f[d >> 2] = r; p = f[s + 4 >> 2] | 0; s = p + 4 | 0; g = f[s >> 2] | 0; if ((g | 0) == (f[p + 8 >> 2] | 0)) Ci(p, d); else { f[g >> 2] = r; f[s >> 2] = g + 4 } g = a + 12 | 0; s = f[g >> 2] | 0; r = s + 4 | 0; p = f[r >> 2] | 0; if ((p | 0) == (f[s + 8 >> 2] | 0)) { Ci(s, e); t = f[g >> 2] | 0 } else { f[p >> 2] = f[e >> 2]; f[r >> 2] = p + 4; t = s } s = t + 24 | 0; f[(f[t + 12 >> 2] | 0) + (o << 2) >> 2] = f[s >> 2]; f[s >> 2] = (f[s >> 2] | 0) + 1 } s = f[i >> 2] | 0; if ((s | 0) == -1) v = -1; else v = f[(f[f[h >> 2] >> 2] | 0) + (s << 2) >> 2] | 0; s = (f[l >> 2] | 0) + (v >>> 5 << 2) | 0; o = 1 << (v & 31); t = f[s >> 2] | 0; if (!(o & t)) { f[s >> 2] = t | o; o = f[i >> 2] | 0; f[e >> 2] = o; t = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((o >>> 0) / 3 | 0) * 12 | 0) + (((o >>> 0) % 3 | 0) << 2) >> 2] | 0; o = f[a + 20 >> 2] | 0; f[d >> 2] = t; s = f[o + 4 >> 2] | 0; o = s + 4 | 0; p = f[o >> 2] | 0; if ((p | 0) == (f[s + 8 >> 2] | 0)) Ci(s, d); else { f[p >> 2] = t; f[o >> 2] = p + 4 } p = a + 12 | 0; o = f[p >> 2] | 0; t = o + 4 | 0; s = f[t >> 2] | 0; if ((s | 0) == (f[o + 8 >> 2] | 0)) { Ci(o, e); w = f[p >> 2] | 0 } else { f[s >> 2] = f[e >> 2]; f[t >> 2] = s + 4; w = o } o = w + 24 | 0; f[(f[w + 12 >> 2] | 0) + (v << 2) >> 2] = f[o >> 2]; f[o >> 2] = (f[o >> 2] | 0) + 1 } o = f[b >> 2] | 0; a: do if ((o | 0) < 3) { v = a + 24 | 0; w = a + 16 | 0; s = a + 20 | 0; t = a + 12 | 0; p = a + 88 | 0; r = o; while (1) { g = r; while (1) { x = a + 48 + (g * 12 | 0) + 4 | 0; y = f[x >> 2] | 0; if ((f[a + 48 + (g * 12 | 0) >> 2] | 0) != (y | 0)) break; if ((g | 0) < 2) g = g + 1 | 0; else break a } n = y + -4 | 0; q = f[n >> 2] | 0; f[x >> 2] = n; f[b >> 2] = g; f[i >> 2] = q; if ((q | 0) == -1) break; n = (q >>> 0) / 3 | 0; j = f[v >> 2] | 0; do if (!(f[j + (n >>> 5 << 2) >> 2] & 1 << (n & 31))) { k = q; m = j; b: while (1) { z = (k >>> 0) / 3 | 0; A = m + (z >>> 5 << 2) | 0; f[A >> 2] = 1 << (z & 31) | f[A >> 2]; A = f[i >> 2] | 0; if ((A | 0) == -1) B = -1; else B = f[(f[f[h >> 2] >> 2] | 0) + (A << 2) >> 2] | 0; z = (f[l >> 2] | 0) + (B >>> 5 << 2) | 0; C = 1 << (B & 31); D = f[z >> 2] | 0; if (!(C & D)) { f[z >> 2] = D | C; C = f[i >> 2] | 0; f[e >> 2] = C; D = f[(f[(f[w >> 2] | 0) + 96 >> 2] | 0) + (((C >>> 0) / 3 | 0) * 12 | 0) + (((C >>> 0) % 3 | 0) << 2) >> 2] | 0; C = f[s >> 2] | 0; f[d >> 2] = D; z = f[C + 4 >> 2] | 0; C = z + 4 | 0; E = f[C >> 2] | 0; if ((E | 0) == (f[z + 8 >> 2] | 0)) Ci(z, d); else { f[E >> 2] = D; f[C >> 2] = E + 4 } E = f[t >> 2] | 0; C = E + 4 | 0; D = f[C >> 2] | 0; if ((D | 0) == (f[E + 8 >> 2] | 0)) { Ci(E, e); F = f[t >> 2] | 0 } else { f[D >> 2] = f[e >> 2]; f[C >> 2] = D + 4; F = E } E = F + 24 | 0; f[(f[F + 12 >> 2] | 0) + (B << 2) >> 2] = f[E >> 2]; f[E >> 2] = (f[E >> 2] | 0) + 1; G = f[i >> 2] | 0 } else G = A; A = f[h >> 2] | 0; if ((G | 0) == -1) { H = 93; break } E = G + 1 | 0; D = ((E >>> 0) % 3 | 0 | 0) == 0 ? G + -2 | 0 : E; if ((D | 0) == -1) I = -1; else I = f[(f[A + 12 >> 2] | 0) + (D << 2) >> 2] | 0; D = (((G >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + G | 0; if ((D | 0) == -1) J = -1; else J = f[(f[A + 12 >> 2] | 0) + (D << 2) >> 2] | 0; D = (I | 0) == -1; E = D ? -1 : (I >>> 0) / 3 | 0; C = (J | 0) == -1; z = C ? -1 : (J >>> 0) / 3 | 0; if (D) K = 1; else K = (f[(f[v >> 2] | 0) + (E >>> 5 << 2) >> 2] & 1 << (E & 31) | 0) != 0; do if (C) if (K) { H = 93; break b } else H = 82; else { if (f[(f[v >> 2] | 0) + (z >>> 5 << 2) >> 2] & 1 << (z & 31) | 0) if (K) { H = 93; break b } else { H = 82; break } E = f[(f[A >> 2] | 0) + (J << 2) >> 2] | 0; if (!(1 << (E & 31) & f[(f[l >> 2] | 0) + (E >>> 5 << 2) >> 2])) { L = (f[p >> 2] | 0) + (E << 2) | 0; E = f[L >> 2] | 0; f[L >> 2] = E + 1; M = (E | 0) > 0 ? 1 : 2 } else M = 0; if (K ? (M | 0) <= (f[b >> 2] | 0) : 0) { N = J; break } f[d >> 2] = J; E = a + 48 + (M * 12 | 0) + 4 | 0; L = f[E >> 2] | 0; if ((L | 0) == (f[a + 48 + (M * 12 | 0) + 8 >> 2] | 0)) Ci(a + 48 + (M * 12 | 0) | 0, d); else { f[L >> 2] = J; f[E >> 2] = L + 4 } if ((f[b >> 2] | 0) > (M | 0)) f[b >> 2] = M; if (K) { H = 93; break b } else H = 82 } while (0); if ((H | 0) == 82) { H = 0; if (D) O = -1; else O = f[(f[f[h >> 2] >> 2] | 0) + (I << 2) >> 2] | 0; if (!(1 << (O & 31) & f[(f[l >> 2] | 0) + (O >>> 5 << 2) >> 2])) { A = (f[p >> 2] | 0) + (O << 2) | 0; z = f[A >> 2] | 0; f[A >> 2] = z + 1; P = (z | 0) > 0 ? 1 : 2 } else P = 0; if ((P | 0) > (f[b >> 2] | 0)) break; else N = I } f[i >> 2] = N; k = N; m = f[v >> 2] | 0 } if ((H | 0) == 93) { H = 0; Q = f[b >> 2] | 0; break } f[d >> 2] = I; m = a + 48 + (P * 12 | 0) + 4 | 0; k = f[m >> 2] | 0; if ((k | 0) == (f[a + 48 + (P * 12 | 0) + 8 >> 2] | 0)) Ci(a + 48 + (P * 12 | 0) | 0, d); else { f[k >> 2] = I; f[m >> 2] = k + 4 } k = f[b >> 2] | 0; if ((k | 0) > (P | 0)) { f[b >> 2] = P; R = P } else R = k; Q = R } else Q = g; while (0); if ((Q | 0) < 3) r = Q; else break a } u = c; return 1 } while (0); f[i >> 2] = -1; u = c; return 1 } function wb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } wb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; wb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function xb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } xb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; xb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function yb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } yb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; yb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function zb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } zb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; zb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Ab(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Ab(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Ab(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } }
    function Bb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Bb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Bb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Cb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Cb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Cb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Db(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Db(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Db(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Eb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Eb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Eb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Fb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Fb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Fb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Gb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Gb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Gb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Hb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Hb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Hb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Ib(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Ib(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Ib(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Jb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Jb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Jb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Kb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Kb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Kb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Lb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Lb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Lb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Mb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Mb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Mb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Nb(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0; d = a; a = b; a: while (1) { b = a; e = a + -4 | 0; g = d; while (1) { h = g; b: while (1) { i = h; j = b - i | 0; k = j >> 2; switch (k | 0) { case 2: { l = 5; break a; break } case 3: { l = 11; break a; break } case 4: { l = 12; break a; break } case 5: { l = 13; break a; break } case 1: case 0: { l = 84; break a; break } default: { } }if ((j | 0) < 124) { l = 15; break a } m = h + (((k | 0) / 2 | 0) << 2) | 0; if ((j | 0) > 3996) { j = (k | 0) / 4 | 0; n = Tf(h, h + (j << 2) | 0, m, m + (j << 2) | 0, e, c) | 0 } else n = Cg(h, m, e, c) | 0; o = f[h >> 2] | 0; j = f[m >> 2] | 0; p = f[c >> 2] | 0; k = f[p >> 2] | 0; q = (f[p + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= o >>> 0) { l = 20; break a } r = k; if (q >>> 0 <= j >>> 0) { l = 22; break a } k = f[r + (o << 3) >> 2] | 0; s = f[r + (j << 3) >> 2] | 0; if (k >>> 0 < s >>> 0) { t = e; u = n; break } else v = e; while (1) { v = v + -4 | 0; if ((h | 0) == (v | 0)) break; w = f[v >> 2] | 0; if (q >>> 0 <= w >>> 0) { l = 51; break a } if ((f[r + (w << 3) >> 2] | 0) >>> 0 < s >>> 0) { l = 53; break b } } s = h + 4 | 0; j = f[e >> 2] | 0; if (q >>> 0 <= j >>> 0) { l = 26; break a } if (k >>> 0 < (f[r + (j << 3) >> 2] | 0) >>> 0) x = s; else { if ((s | 0) == (e | 0)) { l = 84; break a } else y = s; while (1) { z = f[y >> 2] | 0; if (q >>> 0 <= z >>> 0) { l = 32; break a } if (k >>> 0 < (f[r + (z << 3) >> 2] | 0) >>> 0) break; s = y + 4 | 0; if ((s | 0) == (e | 0)) { l = 84; break a } else y = s } f[y >> 2] = j; f[e >> 2] = z; x = y + 4 | 0 } if ((x | 0) == (e | 0)) { l = 84; break a } r = f[h >> 2] | 0; A = f[c >> 2] | 0; k = f[A >> 2] | 0; q = (f[A + 4 >> 2] | 0) - k >> 3; if (q >>> 0 <= r >>> 0) { l = 38; break a } s = k; k = e; B = x; C = r; while (1) { r = s + (C << 3) | 0; D = q >>> 0 > C >>> 0; E = B; while (1) { F = f[E >> 2] | 0; if (q >>> 0 <= F >>> 0) { l = 40; break a } G = f[r >> 2] | 0; if (G >>> 0 < (f[s + (F << 3) >> 2] | 0) >>> 0) break; if (D) E = E + 4 | 0; else { l = 38; break a } } if (q >>> 0 > C >>> 0) H = k; else { l = 46; break a } do { H = H + -4 | 0; I = f[H >> 2] | 0; if (q >>> 0 <= I >>> 0) { l = 47; break a } } while (G >>> 0 < (f[s + (I << 3) >> 2] | 0) >>> 0); if (E >>> 0 >= H >>> 0) { h = E; continue b } D = f[E >> 2] | 0; f[E >> 2] = I; f[H >> 2] = D; C = f[h >> 2] | 0; if (q >>> 0 <= C >>> 0) { l = 38; break a } else { k = H; B = E + 4 | 0 } } } if ((l | 0) == 53) { l = 0; f[h >> 2] = w; f[v >> 2] = o; t = v; u = n + 1 | 0 } B = h + 4 | 0; c: do if (B >>> 0 < t >>> 0) { k = f[B >> 2] | 0; C = f[c >> 2] | 0; q = f[C >> 2] | 0; s = (f[C + 4 >> 2] | 0) - q >> 3; if (s >>> 0 > k >>> 0) { J = t; K = B; L = u; M = m; N = s; O = q; P = C; Q = k } else { R = C; l = 57; break a } while (1) { C = f[c >> 2] | 0; k = C + 4 | 0; q = f[M >> 2] | 0; s = K; j = O; D = N; S = P; r = Q; while (1) { F = j; if (D >>> 0 <= q >>> 0) { l = 59; break a } if ((f[F + (r << 3) >> 2] | 0) >>> 0 >= (f[F + (q << 3) >> 2] | 0) >>> 0) break; F = s + 4 | 0; T = f[F >> 2] | 0; j = f[C >> 2] | 0; D = (f[k >> 2] | 0) - j >> 3; if (D >>> 0 <= T >>> 0) { R = C; l = 57; break a } else { s = F; S = C; r = T } } C = f[M >> 2] | 0; O = f[S >> 2] | 0; N = (f[S + 4 >> 2] | 0) - O >> 3; D = O; j = D + (C << 3) | 0; if (N >>> 0 > C >>> 0) U = J; else { l = 65; break a } do { U = U + -4 | 0; V = f[U >> 2] | 0; if (N >>> 0 <= V >>> 0) { l = 66; break a } } while ((f[D + (V << 3) >> 2] | 0) >>> 0 >= (f[j >> 2] | 0) >>> 0); if (s >>> 0 > U >>> 0) { W = M; X = L; Y = s; break c } f[s >> 2] = V; f[U >> 2] = r; K = s + 4 | 0; Q = f[K >> 2] | 0; if (N >>> 0 <= Q >>> 0) { R = S; l = 57; break a } else { J = U; L = L + 1 | 0; M = (M | 0) == (s | 0) ? U : M; P = S } } } else { W = m; X = u; Y = B } while (0); if ((Y | 0) != (W | 0)) { B = f[W >> 2] | 0; j = f[Y >> 2] | 0; Z = f[c >> 2] | 0; D = f[Z >> 2] | 0; C = (f[Z + 4 >> 2] | 0) - D >> 3; if (C >>> 0 <= B >>> 0) { l = 72; break a } k = D; if (C >>> 0 <= j >>> 0) { l = 74; break a } if ((f[k + (B << 3) >> 2] | 0) >>> 0 < (f[k + (j << 3) >> 2] | 0) >>> 0) { f[Y >> 2] = B; f[W >> 2] = j; _ = X + 1 | 0 } else _ = X } else _ = X; if (!_) { $ = Qd(h, Y, c) | 0; j = Y + 4 | 0; if (Qd(j, a, c) | 0) { l = 83; break } if ($) { g = j; continue } } j = Y; if ((j - i | 0) >= (b - j | 0)) { l = 82; break } Nb(h, Y, c); g = Y + 4 | 0 } if ((l | 0) == 82) { l = 0; Nb(Y + 4 | 0, a, c); d = h; a = Y; continue } else if ((l | 0) == 83) { l = 0; if ($) { l = 84; break } else { d = h; a = Y; continue } } } switch (l | 0) { case 5: { l = f[e >> 2] | 0; Y = f[h >> 2] | 0; d = f[c >> 2] | 0; $ = f[d >> 2] | 0; i = (f[d + 4 >> 2] | 0) - $ >> 3; if (i >>> 0 <= l >>> 0) mq(d); _ = $; if (i >>> 0 <= Y >>> 0) mq(d); if ((f[_ + (l << 3) >> 2] | 0) >>> 0 >= (f[_ + (Y << 3) >> 2] | 0) >>> 0) return; f[h >> 2] = l; f[e >> 2] = Y; return } case 11: { Cg(h, h + 4 | 0, e, c) | 0; return } case 12: { Qg(h, h + 4 | 0, h + 8 | 0, e, c) | 0; return } case 13: { Tf(h, h + 4 | 0, h + 8 | 0, h + 12 | 0, e, c) | 0; return } case 15: { Pg(h, a, c); return } case 20: { mq(p); break } case 22: { mq(p); break } case 26: { mq(p); break } case 32: { mq(p); break } case 38: { mq(A); break } case 40: { mq(A); break } case 46: { mq(A); break } case 47: { mq(A); break } case 51: { mq(p); break } case 57: { mq(R); break } case 59: { mq(S); break } case 65: { if (N >>> 0 > (f[J + -4 >> 2] | 0) >>> 0) mq(S); else mq(S); break } case 66: { mq(S); break } case 72: { mq(Z); break } case 74: { mq(Z); break } case 84: return } } function Ob(a, c, e, g) { a = a | 0; c = c | 0; e = e | 0; g = g | 0; var i = 0, k = 0, l = 0, m = 0, o = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; if (!g) { i = 0; return i | 0 } do switch (f[a + 28 >> 2] | 0) { case 1: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; q = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; r = Tn(q | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = m + r | 0; r = 0; while (1) { f[g + (r << 2) >> 2] = b[o >> 0]; r = r + 1 | 0; m = b[k >> 0] | 0; if ((r | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { s = m; break } else o = o + 1 | 0 } } else s = l; o = s << 24 >> 24; if (s << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 2) | 0, 0, (e << 24 >> 24) - o << 2 | 0) | 0; i = 1; return i | 0 } case 2: { o = a + 24 | 0; r = b[o >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; q = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(q | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { f[g + (t << 2) >> 2] = h[m >> 0]; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { u = k; break } else m = m + 1 | 0 } } else u = r; m = u << 24 >> 24; if (u << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 2) | 0, 0, (e << 24 >> 24) - m << 2 | 0) | 0; i = 1; return i | 0 } case 3: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; q = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + q | 0; q = 0; while (1) { f[g + (q << 2) >> 2] = d[l >> 1]; q = q + 1 | 0; o = b[m >> 0] | 0; if ((q | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { v = o; break } else l = l + 2 | 0 } } else v = t; l = v << 24 >> 24; if (v << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 2) | 0, 0, (e << 24 >> 24) - l << 2 | 0) | 0; i = 1; return i | 0 } case 4: { l = a + 24 | 0; q = b[l >> 0] | 0; if ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; r = a + 40 | 0; o = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; r = a + 48 | 0; k = Tn(o | 0, I | 0, f[r >> 2] | 0, f[r + 4 >> 2] | 0) | 0; r = m + k | 0; k = 0; while (1) { f[g + (k << 2) >> 2] = j[r >> 1]; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { w = m; break } else r = r + 2 | 0 } } else w = q; r = w << 24 >> 24; if (w << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (r << 2) | 0, 0, (e << 24 >> 24) - r << 2 | 0) | 0; i = 1; return i | 0 } case 5: { r = a + 24 | 0; k = b[r >> 0] | 0; if ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 > 0) { l = f[f[a >> 2] >> 2] | 0; t = a + 40 | 0; m = on(f[t >> 2] | 0, f[t + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; t = a + 48 | 0; o = Tn(m | 0, I | 0, f[t >> 2] | 0, f[t + 4 >> 2] | 0) | 0; t = l + o | 0; o = 0; while (1) { f[g + (o << 2) >> 2] = f[t >> 2]; o = o + 1 | 0; l = b[r >> 0] | 0; if ((o | 0) >= ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 | 0)) { x = l; break } else t = t + 4 | 0 } } else x = k; t = x << 24 >> 24; if (x << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (t << 2) | 0, 0, (e << 24 >> 24) - t << 2 | 0) | 0; i = 1; return i | 0 } case 6: { t = a + 24 | 0; o = b[t >> 0] | 0; if ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 > 0) { r = f[f[a >> 2] >> 2] | 0; q = a + 40 | 0; l = on(f[q >> 2] | 0, f[q + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; q = a + 48 | 0; m = Tn(l | 0, I | 0, f[q >> 2] | 0, f[q + 4 >> 2] | 0) | 0; q = r + m | 0; m = 0; while (1) { f[g + (m << 2) >> 2] = f[q >> 2]; m = m + 1 | 0; r = b[t >> 0] | 0; if ((m | 0) >= ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 | 0)) { y = r; break } else q = q + 4 | 0 } } else y = o; q = y << 24 >> 24; if (y << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (q << 2) | 0, 0, (e << 24 >> 24) - q << 2 | 0) | 0; i = 1; return i | 0 } case 7: { q = a + 24 | 0; m = b[q >> 0] | 0; if ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 > 0) { t = f[f[a >> 2] >> 2] | 0; k = a + 40 | 0; r = on(f[k >> 2] | 0, f[k + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; k = a + 48 | 0; l = Tn(r | 0, I | 0, f[k >> 2] | 0, f[k + 4 >> 2] | 0) | 0; k = t + l | 0; l = 0; while (1) { f[g + (l << 2) >> 2] = f[k >> 2]; l = l + 1 | 0; t = b[q >> 0] | 0; if ((l | 0) >= ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 | 0)) { z = t; break } else k = k + 8 | 0 } } else z = m; k = z << 24 >> 24; if (z << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (k << 2) | 0, 0, (e << 24 >> 24) - k << 2 | 0) | 0; i = 1; return i | 0 } case 8: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { q = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; t = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; r = Tn(t | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = q + r | 0; r = 0; while (1) { f[g + (r << 2) >> 2] = f[o >> 2]; r = r + 1 | 0; q = b[k >> 0] | 0; if ((r | 0) >= ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 | 0)) { A = q; break } else o = o + 8 | 0 } } else A = l; o = A << 24 >> 24; if (A << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 2) | 0, 0, (e << 24 >> 24) - o << 2 | 0) | 0; i = 1; return i | 0 } case 9: { o = a + 24 | 0; r = b[o >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; q = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(q | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { k = ~~$(n[m >> 2]) >>> 0; f[g + (t << 2) >> 2] = k; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { B = k; break } else m = m + 4 | 0 } } else B = r; m = B << 24 >> 24; if (B << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 2) | 0, 0, (e << 24 >> 24) - m << 2 | 0) | 0; i = 1; return i | 0 } case 10: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; q = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + q | 0; q = 0; while (1) { f[g + (q << 2) >> 2] = ~~+p[l >> 3] >>> 0; q = q + 1 | 0; o = b[m >> 0] | 0; if ((q | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { C = o; break } else l = l + 8 | 0 } } else C = t; l = C << 24 >> 24; if (C << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 2) | 0, 0, (e << 24 >> 24) - l << 2 | 0) | 0; i = 1; return i | 0 } case 11: { l = a + 24 | 0; q = b[l >> 0] | 0; if ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; r = a + 40 | 0; o = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; r = a + 48 | 0; k = Tn(o | 0, I | 0, f[r >> 2] | 0, f[r + 4 >> 2] | 0) | 0; r = m + k | 0; k = 0; while (1) { f[g + (k << 2) >> 2] = h[r >> 0]; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { D = m; break } else r = r + 1 | 0 } } else D = q; r = D << 24 >> 24; if (D << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (r << 2) | 0, 0, (e << 24 >> 24) - r << 2 | 0) | 0; i = 1; return i | 0 } default: { i = 0; return i | 0 } } while (0); return 0 } function Pb(a, c, e, g) { a = a | 0; c = c | 0; e = e | 0; g = g | 0; var i = 0, k = 0, l = 0, m = 0, o = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0; if (!g) { i = 0; return i | 0 } do switch (f[a + 28 >> 2] | 0) { case 1: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; q = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; r = Tn(q | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = m + r | 0; r = 0; while (1) { f[g + (r << 2) >> 2] = b[o >> 0]; r = r + 1 | 0; m = b[k >> 0] | 0; if ((r | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { s = m; break } else o = o + 1 | 0 } } else s = l; o = s << 24 >> 24; if (s << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 2) | 0, 0, (e << 24 >> 24) - o << 2 | 0) | 0; i = 1; return i | 0 } case 2: { o = a + 24 | 0; r = b[o >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; q = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(q | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { f[g + (t << 2) >> 2] = h[m >> 0]; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { u = k; break } else m = m + 1 | 0 } } else u = r; m = u << 24 >> 24; if (u << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 2) | 0, 0, (e << 24 >> 24) - m << 2 | 0) | 0; i = 1; return i | 0 } case 3: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; q = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + q | 0; q = 0; while (1) { f[g + (q << 2) >> 2] = d[l >> 1]; q = q + 1 | 0; o = b[m >> 0] | 0; if ((q | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { v = o; break } else l = l + 2 | 0 } } else v = t; l = v << 24 >> 24; if (v << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 2) | 0, 0, (e << 24 >> 24) - l << 2 | 0) | 0; i = 1; return i | 0 } case 4: { l = a + 24 | 0; q = b[l >> 0] | 0; if ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; r = a + 40 | 0; o = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; r = a + 48 | 0; k = Tn(o | 0, I | 0, f[r >> 2] | 0, f[r + 4 >> 2] | 0) | 0; r = m + k | 0; k = 0; while (1) { f[g + (k << 2) >> 2] = j[r >> 1]; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { w = m; break } else r = r + 2 | 0 } } else w = q; r = w << 24 >> 24; if (w << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (r << 2) | 0, 0, (e << 24 >> 24) - r << 2 | 0) | 0; i = 1; return i | 0 } case 5: { r = a + 24 | 0; k = b[r >> 0] | 0; if ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 > 0) { l = f[f[a >> 2] >> 2] | 0; t = a + 40 | 0; m = on(f[t >> 2] | 0, f[t + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; t = a + 48 | 0; o = Tn(m | 0, I | 0, f[t >> 2] | 0, f[t + 4 >> 2] | 0) | 0; t = l + o | 0; o = 0; while (1) { f[g + (o << 2) >> 2] = f[t >> 2]; o = o + 1 | 0; l = b[r >> 0] | 0; if ((o | 0) >= ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 | 0)) { x = l; break } else t = t + 4 | 0 } } else x = k; t = x << 24 >> 24; if (x << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (t << 2) | 0, 0, (e << 24 >> 24) - t << 2 | 0) | 0; i = 1; return i | 0 } case 6: { t = a + 24 | 0; o = b[t >> 0] | 0; if ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 > 0) { r = f[f[a >> 2] >> 2] | 0; q = a + 40 | 0; l = on(f[q >> 2] | 0, f[q + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; q = a + 48 | 0; m = Tn(l | 0, I | 0, f[q >> 2] | 0, f[q + 4 >> 2] | 0) | 0; q = r + m | 0; m = 0; while (1) { f[g + (m << 2) >> 2] = f[q >> 2]; m = m + 1 | 0; r = b[t >> 0] | 0; if ((m | 0) >= ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 | 0)) { y = r; break } else q = q + 4 | 0 } } else y = o; q = y << 24 >> 24; if (y << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (q << 2) | 0, 0, (e << 24 >> 24) - q << 2 | 0) | 0; i = 1; return i | 0 } case 7: { q = a + 24 | 0; m = b[q >> 0] | 0; if ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 > 0) { t = f[f[a >> 2] >> 2] | 0; k = a + 40 | 0; r = on(f[k >> 2] | 0, f[k + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; k = a + 48 | 0; l = Tn(r | 0, I | 0, f[k >> 2] | 0, f[k + 4 >> 2] | 0) | 0; k = t + l | 0; l = 0; while (1) { f[g + (l << 2) >> 2] = f[k >> 2]; l = l + 1 | 0; t = b[q >> 0] | 0; if ((l | 0) >= ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 | 0)) { z = t; break } else k = k + 8 | 0 } } else z = m; k = z << 24 >> 24; if (z << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (k << 2) | 0, 0, (e << 24 >> 24) - k << 2 | 0) | 0; i = 1; return i | 0 } case 8: { k = a + 24 | 0; l = b[k >> 0] | 0; if ((l << 24 >> 24 > e << 24 >> 24 ? e : l) << 24 >> 24 > 0) { q = f[f[a >> 2] >> 2] | 0; o = a + 40 | 0; t = on(f[o >> 2] | 0, f[o + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; o = a + 48 | 0; r = Tn(t | 0, I | 0, f[o >> 2] | 0, f[o + 4 >> 2] | 0) | 0; o = q + r | 0; r = 0; while (1) { f[g + (r << 2) >> 2] = f[o >> 2]; r = r + 1 | 0; q = b[k >> 0] | 0; if ((r | 0) >= ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 | 0)) { A = q; break } else o = o + 8 | 0 } } else A = l; o = A << 24 >> 24; if (A << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (o << 2) | 0, 0, (e << 24 >> 24) - o << 2 | 0) | 0; i = 1; return i | 0 } case 9: { o = a + 24 | 0; r = b[o >> 0] | 0; if ((r << 24 >> 24 > e << 24 >> 24 ? e : r) << 24 >> 24 > 0) { k = f[f[a >> 2] >> 2] | 0; m = a + 40 | 0; q = on(f[m >> 2] | 0, f[m + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; m = a + 48 | 0; t = Tn(q | 0, I | 0, f[m >> 2] | 0, f[m + 4 >> 2] | 0) | 0; m = k + t | 0; t = 0; while (1) { k = ~~$(n[m >> 2]); f[g + (t << 2) >> 2] = k; t = t + 1 | 0; k = b[o >> 0] | 0; if ((t | 0) >= ((k << 24 >> 24 > e << 24 >> 24 ? e : k) << 24 >> 24 | 0)) { B = k; break } else m = m + 4 | 0 } } else B = r; m = B << 24 >> 24; if (B << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (m << 2) | 0, 0, (e << 24 >> 24) - m << 2 | 0) | 0; i = 1; return i | 0 } case 10: { m = a + 24 | 0; t = b[m >> 0] | 0; if ((t << 24 >> 24 > e << 24 >> 24 ? e : t) << 24 >> 24 > 0) { o = f[f[a >> 2] >> 2] | 0; l = a + 40 | 0; k = on(f[l >> 2] | 0, f[l + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; l = a + 48 | 0; q = Tn(k | 0, I | 0, f[l >> 2] | 0, f[l + 4 >> 2] | 0) | 0; l = o + q | 0; q = 0; while (1) { f[g + (q << 2) >> 2] = ~~+p[l >> 3]; q = q + 1 | 0; o = b[m >> 0] | 0; if ((q | 0) >= ((o << 24 >> 24 > e << 24 >> 24 ? e : o) << 24 >> 24 | 0)) { C = o; break } else l = l + 8 | 0 } } else C = t; l = C << 24 >> 24; if (C << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (l << 2) | 0, 0, (e << 24 >> 24) - l << 2 | 0) | 0; i = 1; return i | 0 } case 11: { l = a + 24 | 0; q = b[l >> 0] | 0; if ((q << 24 >> 24 > e << 24 >> 24 ? e : q) << 24 >> 24 > 0) { m = f[f[a >> 2] >> 2] | 0; r = a + 40 | 0; o = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, f[c >> 2] | 0, 0) | 0; r = a + 48 | 0; k = Tn(o | 0, I | 0, f[r >> 2] | 0, f[r + 4 >> 2] | 0) | 0; r = m + k | 0; k = 0; while (1) { f[g + (k << 2) >> 2] = h[r >> 0]; k = k + 1 | 0; m = b[l >> 0] | 0; if ((k | 0) >= ((m << 24 >> 24 > e << 24 >> 24 ? e : m) << 24 >> 24 | 0)) { D = m; break } else r = r + 1 | 0 } } else D = q; r = D << 24 >> 24; if (D << 24 >> 24 >= e << 24 >> 24) { i = 1; return i | 0 } hj(g + (r << 2) | 0, 0, (e << 24 >> 24) - r << 2 | 0) | 0; i = 1; return i | 0 } default: { i = 0; return i | 0 } } while (0); return 0 } function Qb(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = Oa, J = 0, K = 0, L = 0, M = 0, N = Oa; e = u; u = u + 48 | 0; g = e + 36 | 0; h = e + 24 | 0; i = e + 12 | 0; j = e; if (!(ih(a, c, d) | 0)) { k = 0; u = e; return k | 0 } l = f[(f[(f[c + 4 >> 2] | 0) + 8 >> 2] | 0) + (d << 2) >> 2] | 0; if ((f[l + 28 >> 2] | 0) != 9) { k = 0; u = e; return k | 0 } m = c + 48 | 0; c = f[m >> 2] | 0; o = dn(32) | 0; f[g >> 2] = o; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 17; p = o; q = 12932; r = p + 17 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[o + 17 >> 0] = 0; o = c + 16 | 0; s = f[o >> 2] | 0; if (s) { t = o; v = s; a: while (1) { s = v; while (1) { if ((f[s + 16 >> 2] | 0) >= (d | 0)) break; w = f[s + 4 >> 2] | 0; if (!w) { x = t; break a } else s = w } v = f[s >> 2] | 0; if (!v) { x = s; break } else t = s } if (((x | 0) != (o | 0) ? (f[x + 16 >> 2] | 0) <= (d | 0) : 0) ? (o = x + 20 | 0, (sh(o, g) | 0) != 0) : 0) y = yk(o, g, -1) | 0; else z = 12 } else z = 12; if ((z | 0) == 12) y = yk(c, g, -1) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); if ((y | 0) < 1) { k = 0; u = e; return k | 0 } c = f[m >> 2] | 0; o = dn(32) | 0; f[g >> 2] = o; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 19; p = o; q = 13005; r = p + 19 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[o + 19 >> 0] = 0; o = c + 16 | 0; x = f[o >> 2] | 0; if (x) { t = o; v = x; b: while (1) { x = v; while (1) { if ((f[x + 16 >> 2] | 0) >= (d | 0)) break; w = f[x + 4 >> 2] | 0; if (!w) { A = t; break b } else x = w } v = f[x >> 2] | 0; if (!v) { A = x; break } else t = x } if ((A | 0) != (o | 0) ? (f[A + 16 >> 2] | 0) <= (d | 0) : 0) B = A + 20 | 0; else z = 24 } else z = 24; if ((z | 0) == 24) B = c; if (!(sh(B, g) | 0)) C = 0; else { B = f[m >> 2] | 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; c = dn(32) | 0; f[h >> 2] = c; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 18; p = c; q = 13025; r = p + 18 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[c + 18 >> 0] = 0; c = B + 16 | 0; A = f[c >> 2] | 0; if (A) { o = c; t = A; c: while (1) { A = t; while (1) { if ((f[A + 16 >> 2] | 0) >= (d | 0)) break; v = f[A + 4 >> 2] | 0; if (!v) { D = o; break c } else A = v } t = f[A >> 2] | 0; if (!t) { D = A; break } else o = A } if ((D | 0) != (c | 0) ? (f[D + 16 >> 2] | 0) <= (d | 0) : 0) E = D + 20 | 0; else z = 34 } else z = 34; if ((z | 0) == 34) E = B; B = (sh(E, h) | 0) != 0; if ((b[h + 11 >> 0] | 0) < 0) br(f[h >> 2] | 0); C = B } if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); if (!C) { Kd(a + 40 | 0, l, y) | 0; k = 1; u = e; return k | 0 } C = l + 24 | 0; l = b[C >> 0] | 0; B = l << 24 >> 24; f[i >> 2] = 0; E = i + 4 | 0; f[E >> 2] = 0; f[i + 8 >> 2] = 0; do if (l << 24 >> 24) if (l << 24 >> 24 < 0) mq(i); else { D = B << 2; c = dn(D) | 0; f[i >> 2] = c; o = c + (B << 2) | 0; f[i + 8 >> 2] = o; hj(c | 0, 0, D | 0) | 0; f[E >> 2] = o; F = c; break } else F = 0; while (0); B = f[m >> 2] | 0; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; l = dn(32) | 0; f[j >> 2] = l; f[j + 8 >> 2] = -2147483616; f[j + 4 >> 2] = 19; p = l; q = 13005; r = p + 19 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[l + 19 >> 0] = 0; l = b[C >> 0] | 0; c = l << 24 >> 24; o = B + 16 | 0; D = f[o >> 2] | 0; if (D) { t = o; x = D; d: while (1) { D = x; while (1) { if ((f[D + 16 >> 2] | 0) >= (d | 0)) break; v = f[D + 4 >> 2] | 0; if (!v) { G = t; break d } else D = v } x = f[D >> 2] | 0; if (!x) { G = D; break } else t = D } if (((G | 0) != (o | 0) ? (f[G + 16 >> 2] | 0) <= (d | 0) : 0) ? (o = G + 20 | 0, (sh(o, j) | 0) != 0) : 0) { t = zg(o, j) | 0; if ((t | 0) != (G + 24 | 0)) { dj(g, t + 28 | 0); t = g + 11 | 0; G = b[t >> 0] | 0; o = G << 24 >> 24 < 0; if (!((o ? f[g + 4 >> 2] | 0 : G & 255) | 0)) H = G; else { if (l << 24 >> 24 > 0) { x = o ? f[g >> 2] | 0 : g; o = 0; do { I = $(pq(x, h)); A = x; x = f[h >> 2] | 0; if ((A | 0) == (x | 0)) break; n[F + (o << 2) >> 2] = I; o = o + 1 | 0 } while ((o | 0) < (c | 0)); J = b[t >> 0] | 0 } else J = G; H = J } if (H << 24 >> 24 < 0) br(f[g >> 2] | 0) } } else z = 64 } else z = 64; if ((z | 0) == 64 ? (H = zg(B, j) | 0, (H | 0) != (B + 4 | 0)) : 0) { dj(g, H + 28 | 0); H = g + 11 | 0; B = b[H >> 0] | 0; J = B << 24 >> 24 < 0; if (!((J ? f[g + 4 >> 2] | 0 : B & 255) | 0)) K = B; else { if (l << 24 >> 24 > 0) { l = J ? f[g >> 2] | 0 : g; J = 0; do { I = $(pq(l, h)); G = l; l = f[h >> 2] | 0; if ((G | 0) == (l | 0)) break; n[F + (J << 2) >> 2] = I; J = J + 1 | 0 } while ((J | 0) < (c | 0)); L = b[H >> 0] | 0 } else L = B; K = L } if (K << 24 >> 24 < 0) br(f[g >> 2] | 0) } if ((b[j + 11 >> 0] | 0) < 0) br(f[j >> 2] | 0); j = f[m >> 2] | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; m = dn(32) | 0; f[g >> 2] = m; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 18; p = m; q = 13025; r = p + 18 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[m + 18 >> 0] = 0; m = j + 16 | 0; q = f[m >> 2] | 0; if (q) { p = m; r = q; e: while (1) { q = r; while (1) { if ((f[q + 16 >> 2] | 0) >= (d | 0)) break; K = f[q + 4 >> 2] | 0; if (!K) { M = p; break e } else q = K } r = f[q >> 2] | 0; if (!r) { M = q; break } else p = q } if (((M | 0) != (m | 0) ? (f[M + 16 >> 2] | 0) <= (d | 0) : 0) ? (d = M + 20 | 0, (sh(d, g) | 0) != 0) : 0) N = $(kk(d, g, $(1.0))); else z = 86 } else z = 86; if ((z | 0) == 86) N = $(kk(j, g, $(1.0))); if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); wl(a + 40 | 0, y, f[i >> 2] | 0, b[C >> 0] | 0, N); C = f[i >> 2] | 0; if (C | 0) { i = f[E >> 2] | 0; if ((i | 0) != (C | 0)) f[E >> 2] = i + (~((i + -4 - C | 0) >>> 2) << 2); br(C) } k = 1; u = e; return k | 0 } function Rb(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0; e = u; u = u + 64 | 0; d = e + 48 | 0; h = e + 36 | 0; i = e + 24 | 0; j = e + 16 | 0; k = e + 8 | 0; l = e; m = e + 32 | 0; n = a + 60 | 0; f[a + 68 >> 2] = g; g = a + 108 | 0; lk(g); o = a + 56 | 0; p = f[o >> 2] | 0; q = (f[p + 4 >> 2] | 0) - (f[p >> 2] | 0) | 0; r = q >> 2; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; s = i; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = j; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = k; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = l; f[s >> 2] = 0; f[s + 4 >> 2] = 0; if ((q | 0) <= 0) { u = e; return 1 } q = h + 4 | 0; s = h + 8 | 0; t = a + 104 | 0; v = i + 4 | 0; w = a + 100 | 0; x = j + 4 | 0; y = a + 8 | 0; z = a + 16 | 0; A = a + 32 | 0; B = a + 12 | 0; C = a + 28 | 0; D = a + 20 | 0; E = a + 24 | 0; F = a + 96 | 0; a = k + 4 | 0; G = l + 4 | 0; H = f[p >> 2] | 0; if ((f[p + 4 >> 2] | 0) == (H | 0)) { J = p; mq(J) } else { K = 0; L = H } while (1) { f[m >> 2] = f[L + (K << 2) >> 2]; f[d >> 2] = f[m >> 2]; fc(n, d, h); H = f[h >> 2] | 0; p = (H | 0) > -1 ? H : 0 - H | 0; M = f[q >> 2] | 0; N = (M | 0) > -1 ? M : 0 - M | 0; O = Tn(N | 0, ((N | 0) < 0) << 31 >> 31 | 0, p | 0, ((p | 0) < 0) << 31 >> 31 | 0) | 0; p = f[s >> 2] | 0; N = (p | 0) > -1; P = N ? p : 0 - p | 0; p = Tn(O | 0, I | 0, P | 0, ((P | 0) < 0) << 31 >> 31 | 0) | 0; P = I; if ((p | 0) == 0 & (P | 0) == 0) { O = f[t >> 2] | 0; Q = O; R = h; S = M; T = O } else { O = f[t >> 2] | 0; U = ((O | 0) < 0) << 31 >> 31; V = on(O | 0, U | 0, H | 0, ((H | 0) < 0) << 31 >> 31 | 0) | 0; H = zk(V | 0, I | 0, p | 0, P | 0) | 0; f[h >> 2] = H; V = on(O | 0, U | 0, M | 0, ((M | 0) < 0) << 31 >> 31 | 0) | 0; M = zk(V | 0, I | 0, p | 0, P | 0) | 0; f[q >> 2] = M; P = O - ((H | 0) > -1 ? H : 0 - H | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; Q = N ? P : 0 - P | 0; R = s; S = M; T = O } f[R >> 2] = Q; O = f[h >> 2] | 0; do if ((O | 0) <= -1) { if ((S | 0) < 0) { M = f[s >> 2] | 0; W = (M | 0) > -1 ? M : 0 - M | 0; X = M } else { M = f[s >> 2] | 0; W = (f[w >> 2] | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; X = M } if ((X | 0) < 0) { Y = (S | 0) > -1 ? S : 0 - S | 0; Z = W; _ = X; break } else { Y = (f[w >> 2] | 0) - ((S | 0) > -1 ? S : 0 - S | 0) | 0; Z = W; _ = X; break } } else { M = f[s >> 2] | 0; Y = M + T | 0; Z = T + S | 0; _ = M } while (0); M = (Z | 0) == 0; P = (Y | 0) == 0; N = f[w >> 2] | 0; do if (Y | Z) { H = (N | 0) == (Y | 0); if (!(M & H)) { p = (N | 0) == (Z | 0); if (!(P & p)) { if (M & (T | 0) < (Y | 0)) { $ = 0; aa = (T << 1) - Y | 0; break } if (p & (T | 0) > (Y | 0)) { $ = Z; aa = (T << 1) - Y | 0; break } if (H & (T | 0) > (Z | 0)) { $ = (T << 1) - Z | 0; aa = Y; break } if (P) { $ = (T | 0) < (Z | 0) ? (T << 1) - Z | 0 : Z; aa = 0 } else { $ = Z; aa = Y } } else { $ = Z; aa = Z } } else { $ = Y; aa = Y } } else { $ = N; aa = N } while (0); f[i >> 2] = $; f[v >> 2] = aa; P = 0 - S | 0; M = 0 - _ | 0; f[h >> 2] = 0 - O; f[q >> 2] = P; f[s >> 2] = M; if ((O | 0) < 1) { ba = T - _ | 0; ca = T - S | 0 } else { H = (_ | 0) < 1 ? M : _; M = (S | 0) < 1 ? P : S; ba = (_ | 0) > 0 ? M : N - M | 0; ca = (S | 0) > 0 ? H : N - H | 0 } H = (ca | 0) == 0; M = (ba | 0) == 0; do if (((ba | ca | 0) != 0 ? (P = (N | 0) == (ba | 0), !(H & P)) : 0) ? (p = (N | 0) == (ca | 0), !(M & p)) : 0) { if (H & (T | 0) < (ba | 0)) { da = 0; ea = (T << 1) - ba | 0; break } if (p & (T | 0) > (ba | 0)) { da = N; ea = (T << 1) - ba | 0; break } if (P & (T | 0) > (ca | 0)) { da = (T << 1) - ca | 0; ea = N; break } if (M) { da = (T | 0) < (ca | 0) ? (T << 1) - ca | 0 : ca; ea = 0 } else { da = ca; ea = ba } } else { da = N; ea = N } while (0); f[j >> 2] = da; f[x >> 2] = ea; N = K << 1; M = b + (N << 2) | 0; H = f[y >> 2] | 0; if ((H | 0) > 0) { O = 0; P = i; p = H; while (1) { if ((p | 0) > 0) { H = 0; do { V = f[P + (H << 2) >> 2] | 0; U = f[z >> 2] | 0; if ((V | 0) > (U | 0)) { fa = f[A >> 2] | 0; f[fa + (H << 2) >> 2] = U; ga = fa } else { fa = f[B >> 2] | 0; U = f[A >> 2] | 0; f[U + (H << 2) >> 2] = (V | 0) < (fa | 0) ? fa : V; ga = U } H = H + 1 | 0; U = f[y >> 2] | 0 } while ((H | 0) < (U | 0)); ha = ga; ia = U } else { ha = f[A >> 2] | 0; ia = p } H = (f[M + (O << 2) >> 2] | 0) - (f[ha + (O << 2) >> 2] | 0) | 0; U = k + (O << 2) | 0; f[U >> 2] = H; ja = f[C >> 2] | 0; if ((H | 0) >= (ja | 0)) { if ((H | 0) > (f[E >> 2] | 0)) { ka = H - (f[D >> 2] | 0) | 0; la = 52 } } else { ka = (f[D >> 2] | 0) + H | 0; la = 52 } if ((la | 0) == 52) { la = 0; f[U >> 2] = ka } O = O + 1 | 0; if ((O | 0) >= (ia | 0)) break; else { P = ha; p = ia } } if ((ia | 0) > 0) { p = 0; P = j; O = ia; U = ja; while (1) { if ((O | 0) > 0) { H = 0; do { V = f[P + (H << 2) >> 2] | 0; fa = f[z >> 2] | 0; if ((V | 0) > (fa | 0)) f[ha + (H << 2) >> 2] = fa; else { fa = f[B >> 2] | 0; f[ha + (H << 2) >> 2] = (V | 0) < (fa | 0) ? fa : V } H = H + 1 | 0; ma = f[y >> 2] | 0 } while ((H | 0) < (ma | 0)); na = f[C >> 2] | 0; oa = ma } else { na = U; oa = O } H = (f[M + (p << 2) >> 2] | 0) - (f[ha + (p << 2) >> 2] | 0) | 0; V = l + (p << 2) | 0; f[V >> 2] = H; if ((H | 0) >= (na | 0)) { if ((H | 0) > (f[E >> 2] | 0)) { pa = H - (f[D >> 2] | 0) | 0; la = 65 } } else { pa = (f[D >> 2] | 0) + H | 0; la = 65 } if ((la | 0) == 65) { la = 0; f[V >> 2] = pa } p = p + 1 | 0; if ((p | 0) >= (oa | 0)) break; else { P = ha; O = oa; U = na } } } } U = f[k >> 2] | 0; O = f[t >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) qa = (f[F >> 2] | 0) + U | 0; else qa = U; else qa = U - (f[F >> 2] | 0) | 0; f[k >> 2] = qa; U = f[a >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) ra = (f[F >> 2] | 0) + U | 0; else ra = U; else ra = U - (f[F >> 2] | 0) | 0; f[a >> 2] = ra; U = f[l >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) sa = (f[F >> 2] | 0) + U | 0; else sa = U; else sa = U - (f[F >> 2] | 0) | 0; f[l >> 2] = sa; U = f[G >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) ta = (f[F >> 2] | 0) + U | 0; else ta = U; else ta = U - (f[F >> 2] | 0) | 0; f[G >> 2] = ta; if ((((ra | 0) > -1 ? ra : 0 - ra | 0) + ((qa | 0) > -1 ? qa : 0 - qa | 0) | 0) < (((sa | 0) > -1 ? sa : 0 - sa | 0) + ((ta | 0) > -1 ? ta : 0 - ta | 0) | 0)) { Vi(g, 0); ua = k } else { Vi(g, 1); ua = l } U = f[ua >> 2] | 0; if ((U | 0) < 0) va = (f[F >> 2] | 0) + U | 0; else va = U; U = c + (N << 2) | 0; f[U >> 2] = va; O = f[ua + 4 >> 2] | 0; if ((O | 0) < 0) wa = (f[F >> 2] | 0) + O | 0; else wa = O; f[U + 4 >> 2] = wa; K = K + 1 | 0; if ((K | 0) >= (r | 0)) { la = 3; break } U = f[o >> 2] | 0; L = f[U >> 2] | 0; if ((f[U + 4 >> 2] | 0) - L >> 2 >>> 0 <= K >>> 0) { J = U; la = 4; break } } if ((la | 0) == 3) { u = e; return 1 } else if ((la | 0) == 4) mq(J); return 0 } function Sb(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0; e = u; u = u + 64 | 0; d = e + 48 | 0; h = e + 36 | 0; i = e + 24 | 0; j = e + 16 | 0; k = e + 8 | 0; l = e; m = e + 32 | 0; n = a + 60 | 0; f[a + 68 >> 2] = g; g = a + 108 | 0; lk(g); o = a + 56 | 0; p = f[o >> 2] | 0; q = (f[p + 4 >> 2] | 0) - (f[p >> 2] | 0) | 0; r = q >> 2; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; s = i; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = j; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = k; f[s >> 2] = 0; f[s + 4 >> 2] = 0; s = l; f[s >> 2] = 0; f[s + 4 >> 2] = 0; if ((q | 0) <= 0) { u = e; return 1 } q = h + 4 | 0; s = h + 8 | 0; t = a + 104 | 0; v = i + 4 | 0; w = a + 100 | 0; x = j + 4 | 0; y = a + 8 | 0; z = a + 16 | 0; A = a + 32 | 0; B = a + 12 | 0; C = a + 28 | 0; D = a + 20 | 0; E = a + 24 | 0; F = a + 96 | 0; a = k + 4 | 0; G = l + 4 | 0; H = f[p >> 2] | 0; if ((f[p + 4 >> 2] | 0) == (H | 0)) { J = p; mq(J) } else { K = 0; L = H } while (1) { f[m >> 2] = f[L + (K << 2) >> 2]; f[d >> 2] = f[m >> 2]; $b(n, d, h); H = f[h >> 2] | 0; p = (H | 0) > -1 ? H : 0 - H | 0; M = f[q >> 2] | 0; N = (M | 0) > -1 ? M : 0 - M | 0; O = Tn(N | 0, ((N | 0) < 0) << 31 >> 31 | 0, p | 0, ((p | 0) < 0) << 31 >> 31 | 0) | 0; p = f[s >> 2] | 0; N = (p | 0) > -1; P = N ? p : 0 - p | 0; p = Tn(O | 0, I | 0, P | 0, ((P | 0) < 0) << 31 >> 31 | 0) | 0; P = I; if ((p | 0) == 0 & (P | 0) == 0) { O = f[t >> 2] | 0; Q = O; R = h; S = M; T = O } else { O = f[t >> 2] | 0; U = ((O | 0) < 0) << 31 >> 31; V = on(O | 0, U | 0, H | 0, ((H | 0) < 0) << 31 >> 31 | 0) | 0; H = zk(V | 0, I | 0, p | 0, P | 0) | 0; f[h >> 2] = H; V = on(O | 0, U | 0, M | 0, ((M | 0) < 0) << 31 >> 31 | 0) | 0; M = zk(V | 0, I | 0, p | 0, P | 0) | 0; f[q >> 2] = M; P = O - ((H | 0) > -1 ? H : 0 - H | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; Q = N ? P : 0 - P | 0; R = s; S = M; T = O } f[R >> 2] = Q; O = f[h >> 2] | 0; do if ((O | 0) <= -1) { if ((S | 0) < 0) { M = f[s >> 2] | 0; W = (M | 0) > -1 ? M : 0 - M | 0; X = M } else { M = f[s >> 2] | 0; W = (f[w >> 2] | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; X = M } if ((X | 0) < 0) { Y = (S | 0) > -1 ? S : 0 - S | 0; Z = W; _ = X; break } else { Y = (f[w >> 2] | 0) - ((S | 0) > -1 ? S : 0 - S | 0) | 0; Z = W; _ = X; break } } else { M = f[s >> 2] | 0; Y = M + T | 0; Z = T + S | 0; _ = M } while (0); M = (Z | 0) == 0; P = (Y | 0) == 0; N = f[w >> 2] | 0; do if (Y | Z) { H = (N | 0) == (Y | 0); if (!(M & H)) { p = (N | 0) == (Z | 0); if (!(P & p)) { if (M & (T | 0) < (Y | 0)) { $ = 0; aa = (T << 1) - Y | 0; break } if (p & (T | 0) > (Y | 0)) { $ = Z; aa = (T << 1) - Y | 0; break } if (H & (T | 0) > (Z | 0)) { $ = (T << 1) - Z | 0; aa = Y; break } if (P) { $ = (T | 0) < (Z | 0) ? (T << 1) - Z | 0 : Z; aa = 0 } else { $ = Z; aa = Y } } else { $ = Z; aa = Z } } else { $ = Y; aa = Y } } else { $ = N; aa = N } while (0); f[i >> 2] = $; f[v >> 2] = aa; P = 0 - S | 0; M = 0 - _ | 0; f[h >> 2] = 0 - O; f[q >> 2] = P; f[s >> 2] = M; if ((O | 0) < 1) { ba = T - _ | 0; ca = T - S | 0 } else { H = (_ | 0) < 1 ? M : _; M = (S | 0) < 1 ? P : S; ba = (_ | 0) > 0 ? M : N - M | 0; ca = (S | 0) > 0 ? H : N - H | 0 } H = (ca | 0) == 0; M = (ba | 0) == 0; do if (((ba | ca | 0) != 0 ? (P = (N | 0) == (ba | 0), !(H & P)) : 0) ? (p = (N | 0) == (ca | 0), !(M & p)) : 0) { if (H & (T | 0) < (ba | 0)) { da = 0; ea = (T << 1) - ba | 0; break } if (p & (T | 0) > (ba | 0)) { da = N; ea = (T << 1) - ba | 0; break } if (P & (T | 0) > (ca | 0)) { da = (T << 1) - ca | 0; ea = N; break } if (M) { da = (T | 0) < (ca | 0) ? (T << 1) - ca | 0 : ca; ea = 0 } else { da = ca; ea = ba } } else { da = N; ea = N } while (0); f[j >> 2] = da; f[x >> 2] = ea; N = K << 1; M = b + (N << 2) | 0; H = f[y >> 2] | 0; if ((H | 0) > 0) { O = 0; P = i; p = H; while (1) { if ((p | 0) > 0) { H = 0; do { V = f[P + (H << 2) >> 2] | 0; U = f[z >> 2] | 0; if ((V | 0) > (U | 0)) { fa = f[A >> 2] | 0; f[fa + (H << 2) >> 2] = U; ga = fa } else { fa = f[B >> 2] | 0; U = f[A >> 2] | 0; f[U + (H << 2) >> 2] = (V | 0) < (fa | 0) ? fa : V; ga = U } H = H + 1 | 0; U = f[y >> 2] | 0 } while ((H | 0) < (U | 0)); ha = ga; ia = U } else { ha = f[A >> 2] | 0; ia = p } H = (f[M + (O << 2) >> 2] | 0) - (f[ha + (O << 2) >> 2] | 0) | 0; U = k + (O << 2) | 0; f[U >> 2] = H; ja = f[C >> 2] | 0; if ((H | 0) >= (ja | 0)) { if ((H | 0) > (f[E >> 2] | 0)) { ka = H - (f[D >> 2] | 0) | 0; la = 52 } } else { ka = (f[D >> 2] | 0) + H | 0; la = 52 } if ((la | 0) == 52) { la = 0; f[U >> 2] = ka } O = O + 1 | 0; if ((O | 0) >= (ia | 0)) break; else { P = ha; p = ia } } if ((ia | 0) > 0) { p = 0; P = j; O = ia; U = ja; while (1) { if ((O | 0) > 0) { H = 0; do { V = f[P + (H << 2) >> 2] | 0; fa = f[z >> 2] | 0; if ((V | 0) > (fa | 0)) f[ha + (H << 2) >> 2] = fa; else { fa = f[B >> 2] | 0; f[ha + (H << 2) >> 2] = (V | 0) < (fa | 0) ? fa : V } H = H + 1 | 0; ma = f[y >> 2] | 0 } while ((H | 0) < (ma | 0)); na = f[C >> 2] | 0; oa = ma } else { na = U; oa = O } H = (f[M + (p << 2) >> 2] | 0) - (f[ha + (p << 2) >> 2] | 0) | 0; V = l + (p << 2) | 0; f[V >> 2] = H; if ((H | 0) >= (na | 0)) { if ((H | 0) > (f[E >> 2] | 0)) { pa = H - (f[D >> 2] | 0) | 0; la = 65 } } else { pa = (f[D >> 2] | 0) + H | 0; la = 65 } if ((la | 0) == 65) { la = 0; f[V >> 2] = pa } p = p + 1 | 0; if ((p | 0) >= (oa | 0)) break; else { P = ha; O = oa; U = na } } } } U = f[k >> 2] | 0; O = f[t >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) qa = (f[F >> 2] | 0) + U | 0; else qa = U; else qa = U - (f[F >> 2] | 0) | 0; f[k >> 2] = qa; U = f[a >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) ra = (f[F >> 2] | 0) + U | 0; else ra = U; else ra = U - (f[F >> 2] | 0) | 0; f[a >> 2] = ra; U = f[l >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) sa = (f[F >> 2] | 0) + U | 0; else sa = U; else sa = U - (f[F >> 2] | 0) | 0; f[l >> 2] = sa; U = f[G >> 2] | 0; if ((O | 0) >= (U | 0)) if ((U | 0) < (0 - O | 0)) ta = (f[F >> 2] | 0) + U | 0; else ta = U; else ta = U - (f[F >> 2] | 0) | 0; f[G >> 2] = ta; if ((((ra | 0) > -1 ? ra : 0 - ra | 0) + ((qa | 0) > -1 ? qa : 0 - qa | 0) | 0) < (((sa | 0) > -1 ? sa : 0 - sa | 0) + ((ta | 0) > -1 ? ta : 0 - ta | 0) | 0)) { Vi(g, 0); ua = k } else { Vi(g, 1); ua = l } U = f[ua >> 2] | 0; if ((U | 0) < 0) va = (f[F >> 2] | 0) + U | 0; else va = U; U = c + (N << 2) | 0; f[U >> 2] = va; O = f[ua + 4 >> 2] | 0; if ((O | 0) < 0) wa = (f[F >> 2] | 0) + O | 0; else wa = O; f[U + 4 >> 2] = wa; K = K + 1 | 0; if ((K | 0) >= (r | 0)) { la = 3; break } U = f[o >> 2] | 0; L = f[U >> 2] | 0; if ((f[U + 4 >> 2] | 0) - L >> 2 >>> 0 <= K >>> 0) { J = U; la = 4; break } } if ((la | 0) == 3) { u = e; return 1 } else if ((la | 0) == 4) mq(J); return 0 } function Tb(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c; g = f[b >> 2] | 0; if ((g | 0) == -1) { h = 1; u = c; return h | 0 } i = (g >>> 0) / 3 | 0; j = a + 24 | 0; if (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) { h = 1; u = c; return h | 0 } i = a + 48 | 0; k = f[i >> 2] | 0; l = a + 52 | 0; m = f[l >> 2] | 0; if ((m | 0) == (k | 0)) n = k; else { o = m + (~((m + -4 - k | 0) >>> 2) << 2) | 0; f[l >> 2] = o; n = o } o = a + 56 | 0; if ((n | 0) == (f[o >> 2] | 0)) Ci(i, b); else { f[n >> 2] = g; f[l >> 2] = n + 4 } n = a + 4 | 0; g = f[n >> 2] | 0; k = f[b >> 2] | 0; m = k + 1 | 0; do if ((k | 0) != -1) { p = f[g + 28 >> 2] | 0; q = f[p + ((((m >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : m) << 2) >> 2] | 0; if (!((k >>> 0) % 3 | 0)) { r = q; s = k + 2 | 0; t = p; break } else { r = q; s = k + -1 | 0; t = p; break } } else { p = f[g + 28 >> 2] | 0; r = f[p + -4 >> 2] | 0; s = -1; t = p } while (0); g = f[t + (s << 2) >> 2] | 0; if ((r | 0) == -1 | (g | 0) == -1) { h = 0; u = c; return h | 0 } s = a + 36 | 0; t = f[s >> 2] | 0; k = t + (r >>> 5 << 2) | 0; m = 1 << (r & 31); p = f[k >> 2] | 0; if (!(p & m)) { f[k >> 2] = p | m; m = f[b >> 2] | 0; p = m + 1 | 0; if ((m | 0) == -1) v = -1; else v = ((p >>> 0) % 3 | 0 | 0) == 0 ? m + -2 | 0 : p; f[e >> 2] = v; p = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((v >>> 0) / 3 | 0) * 12 | 0) + (((v >>> 0) % 3 | 0) << 2) >> 2] | 0; v = f[a + 20 >> 2] | 0; f[d >> 2] = p; m = f[v + 4 >> 2] | 0; v = m + 4 | 0; k = f[v >> 2] | 0; if ((k | 0) == (f[m + 8 >> 2] | 0)) Ci(m, d); else { f[k >> 2] = p; f[v >> 2] = k + 4 } k = a + 12 | 0; v = f[k >> 2] | 0; p = v + 4 | 0; m = f[p >> 2] | 0; if ((m | 0) == (f[v + 8 >> 2] | 0)) { Ci(v, e); w = f[k >> 2] | 0 } else { f[m >> 2] = f[e >> 2]; f[p >> 2] = m + 4; w = v } v = w + 24 | 0; f[(f[w + 12 >> 2] | 0) + (r << 2) >> 2] = f[v >> 2]; f[v >> 2] = (f[v >> 2] | 0) + 1; x = f[s >> 2] | 0 } else x = t; t = x + (g >>> 5 << 2) | 0; x = 1 << (g & 31); v = f[t >> 2] | 0; if (!(v & x)) { f[t >> 2] = v | x; x = f[b >> 2] | 0; do if ((x | 0) != -1) if (!((x >>> 0) % 3 | 0)) { y = x + 2 | 0; break } else { y = x + -1 | 0; break } else y = -1; while (0); f[e >> 2] = y; x = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((y >>> 0) / 3 | 0) * 12 | 0) + (((y >>> 0) % 3 | 0) << 2) >> 2] | 0; y = f[a + 20 >> 2] | 0; f[d >> 2] = x; v = f[y + 4 >> 2] | 0; y = v + 4 | 0; t = f[y >> 2] | 0; if ((t | 0) == (f[v + 8 >> 2] | 0)) Ci(v, d); else { f[t >> 2] = x; f[y >> 2] = t + 4 } t = a + 12 | 0; y = f[t >> 2] | 0; x = y + 4 | 0; v = f[x >> 2] | 0; if ((v | 0) == (f[y + 8 >> 2] | 0)) { Ci(y, e); z = f[t >> 2] | 0 } else { f[v >> 2] = f[e >> 2]; f[x >> 2] = v + 4; z = y } y = z + 24 | 0; f[(f[z + 12 >> 2] | 0) + (g << 2) >> 2] = f[y >> 2]; f[y >> 2] = (f[y >> 2] | 0) + 1 } y = f[i >> 2] | 0; g = f[l >> 2] | 0; if ((y | 0) == (g | 0)) { h = 1; u = c; return h | 0 } z = a + 16 | 0; v = a + 20 | 0; x = a + 12 | 0; a = g; g = y; a: while (1) { y = f[a + -4 >> 2] | 0; f[b >> 2] = y; t = (y >>> 0) / 3 | 0; if ((y | 0) != -1 ? (y = (f[j >> 2] | 0) + (t >>> 5 << 2) | 0, r = 1 << (t & 31), t = f[y >> 2] | 0, (t & r | 0) == 0) : 0) { f[y >> 2] = t | r; r = f[n >> 2] | 0; t = f[b >> 2] | 0; y = f[(f[r + 28 >> 2] | 0) + (t << 2) >> 2] | 0; if ((y | 0) == -1) { h = 0; A = 79; break } else { B = y; C = r; D = t } b: while (1) { t = (f[s >> 2] | 0) + (B >>> 5 << 2) | 0; r = 1 << (B & 31); y = f[t >> 2] | 0; do if (!(y & r)) { w = f[(f[C + 40 >> 2] | 0) + (B << 2) >> 2] | 0; if ((w | 0) == -1) E = 1; else { m = f[(f[f[C + 64 >> 2] >> 2] | 0) + (w << 2) >> 2] | 0; E = (1 << (m & 31) & f[(f[C + 12 >> 2] | 0) + (m >>> 5 << 2) >> 2] | 0) != 0 } f[t >> 2] = y | r; m = f[b >> 2] | 0; f[e >> 2] = m; w = f[(f[(f[z >> 2] | 0) + 96 >> 2] | 0) + (((m >>> 0) / 3 | 0) * 12 | 0) + (((m >>> 0) % 3 | 0) << 2) >> 2] | 0; m = f[v >> 2] | 0; f[d >> 2] = w; p = f[m + 4 >> 2] | 0; m = p + 4 | 0; k = f[m >> 2] | 0; if ((k | 0) == (f[p + 8 >> 2] | 0)) Ci(p, d); else { f[k >> 2] = w; f[m >> 2] = k + 4 } k = f[x >> 2] | 0; m = k + 4 | 0; w = f[m >> 2] | 0; if ((w | 0) == (f[k + 8 >> 2] | 0)) { Ci(k, e); F = f[x >> 2] | 0 } else { f[w >> 2] = f[e >> 2]; f[m >> 2] = w + 4; F = k } k = F + 24 | 0; f[(f[F + 12 >> 2] | 0) + (B << 2) >> 2] = f[k >> 2]; f[k >> 2] = (f[k >> 2] | 0) + 1; k = f[n >> 2] | 0; w = f[b >> 2] | 0; if (E) { G = w; H = k; A = 59; break } m = w + 1 | 0; do if ((w | 0) == -1) I = -1; else { p = ((m >>> 0) % 3 | 0 | 0) == 0 ? w + -2 | 0 : m; if ((p | 0) == -1) { I = -1; break } if (f[(f[k >> 2] | 0) + (p >>> 5 << 2) >> 2] & 1 << (p & 31) | 0) { I = -1; break } I = f[(f[(f[k + 64 >> 2] | 0) + 12 >> 2] | 0) + (p << 2) >> 2] | 0 } while (0); f[b >> 2] = I; J = (I >>> 0) / 3 | 0; K = k } else { G = D; H = C; A = 59 } while (0); if ((A | 0) == 59) { A = 0; r = G + 1 | 0; if ((G | 0) == -1) { A = 60; break } y = ((r >>> 0) % 3 | 0 | 0) == 0 ? G + -2 | 0 : r; do if ((y | 0) == -1) L = -1; else { if (f[(f[H >> 2] | 0) + (y >>> 5 << 2) >> 2] & 1 << (y & 31) | 0) { L = -1; break } L = f[(f[(f[H + 64 >> 2] | 0) + 12 >> 2] | 0) + (y << 2) >> 2] | 0 } while (0); f[d >> 2] = L; y = (((G >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + G | 0; do if ((y | 0) == -1) M = -1; else { if (f[(f[H >> 2] | 0) + (y >>> 5 << 2) >> 2] & 1 << (y & 31) | 0) { M = -1; break } M = f[(f[(f[H + 64 >> 2] | 0) + 12 >> 2] | 0) + (y << 2) >> 2] | 0 } while (0); y = (L | 0) == -1; r = (L >>> 0) / 3 | 0; t = y ? -1 : r; m = (M | 0) == -1; w = (M >>> 0) / 3 | 0; p = m ? -1 : w; do if (!y) { q = f[j >> 2] | 0; if (f[q + (t >>> 5 << 2) >> 2] & 1 << (t & 31) | 0) { A = 69; break } if (m) { N = L; O = r; break } if (!(f[q + (p >>> 5 << 2) >> 2] & 1 << (p & 31))) { A = 74; break b } else { N = L; O = r } } else A = 69; while (0); if ((A | 0) == 69) { A = 0; if (m) { A = 71; break } if (!(f[(f[j >> 2] | 0) + (p >>> 5 << 2) >> 2] & 1 << (p & 31))) { N = M; O = w } else { A = 71; break } } f[b >> 2] = N; J = O; K = H } r = (f[j >> 2] | 0) + (J >>> 5 << 2) | 0; f[r >> 2] = f[r >> 2] | 1 << (J & 31); D = f[b >> 2] | 0; B = f[(f[K + 28 >> 2] | 0) + (D << 2) >> 2] | 0; if ((B | 0) == -1) { h = 0; A = 79; break a } else C = K } do if ((A | 0) == 60) { A = 0; f[d >> 2] = -1; A = 71 } else if ((A | 0) == 74) { A = 0; r = f[l >> 2] | 0; f[r + -4 >> 2] = M; if ((r | 0) == (f[o >> 2] | 0)) { Ci(i, d); P = f[l >> 2] | 0; break } else { f[r >> 2] = f[d >> 2]; t = r + 4 | 0; f[l >> 2] = t; P = t; break } } while (0); if ((A | 0) == 71) { A = 0; t = (f[l >> 2] | 0) + -4 | 0; f[l >> 2] = t; P = t } Q = f[i >> 2] | 0; R = P } else { t = a + -4 | 0; f[l >> 2] = t; Q = g; R = t } if ((Q | 0) == (R | 0)) { h = 1; A = 79; break } else { a = R; g = Q } } if ((A | 0) == 79) { u = c; return h | 0 } return 0 } function Ub(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = Oa, V = Oa, Y = Oa, Z = 0, _ = 0, aa = 0, ba = 0; d = u; u = u + 16 | 0; e = d; g = a + 16 | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; n[g >> 2] = $(1.0); i = a + 20 | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; f[i + 12 >> 2] = 0; n[a + 36 >> 2] = $(1.0); j = f[c + 8 >> 2] | 0; a: do if (j | 0) { k = a + 4 | 0; l = a + 12 | 0; m = a + 8 | 0; o = j; p = j; while (1) { q = o + 8 | 0; r = b[q + 11 >> 0] | 0; s = r << 24 >> 24 < 0; t = s ? f[q >> 2] | 0 : q; v = s ? f[o + 12 >> 2] | 0 : r & 255; if (v >>> 0 > 3) { r = t; s = v; w = v; while (1) { x = X(h[r >> 0] | h[r + 1 >> 0] << 8 | h[r + 2 >> 0] << 16 | h[r + 3 >> 0] << 24, 1540483477) | 0; s = (X(x >>> 24 ^ x, 1540483477) | 0) ^ (X(s, 1540483477) | 0); w = w + -4 | 0; if (w >>> 0 <= 3) break; else r = r + 4 | 0 } r = v + -4 | 0; w = r & -4; y = r - w | 0; z = t + (w + 4) | 0; A = s } else { y = v; z = t; A = v } switch (y | 0) { case 3: { B = h[z + 2 >> 0] << 16 ^ A; C = 8; break } case 2: { B = A; C = 8; break } case 1: { D = A; C = 9; break } default: E = A }if ((C | 0) == 8) { C = 0; D = h[z + 1 >> 0] << 8 ^ B; C = 9 } if ((C | 0) == 9) { C = 0; E = X(D ^ h[z >> 0], 1540483477) | 0 } w = X(E >>> 13 ^ E, 1540483477) | 0; r = w >>> 15 ^ w; w = f[k >> 2] | 0; x = (w | 0) == 0; b: do if (!x) { F = w + -1 | 0; G = (F & w | 0) == 0; if (!G) if (r >>> 0 < w >>> 0) H = r; else H = (r >>> 0) % (w >>> 0) | 0; else H = r & F; I = f[(f[a >> 2] | 0) + (H << 2) >> 2] | 0; if ((I | 0) != 0 ? (J = f[I >> 2] | 0, (J | 0) != 0) : 0) { I = (v | 0) == 0; if (G) { if (I) { G = J; while (1) { K = f[G + 4 >> 2] | 0; if (!((K | 0) == (r | 0) | (K & F | 0) == (H | 0))) { L = H; C = 50; break b } K = b[G + 8 + 11 >> 0] | 0; if (!((K << 24 >> 24 < 0 ? f[G + 12 >> 2] | 0 : K & 255) | 0)) break b; G = f[G >> 2] | 0; if (!G) { L = H; C = 50; break b } } } else M = J; while (1) { G = f[M + 4 >> 2] | 0; if (!((G | 0) == (r | 0) | (G & F | 0) == (H | 0))) { L = H; C = 50; break b } G = M + 8 | 0; K = b[G + 11 >> 0] | 0; N = K << 24 >> 24 < 0; O = K & 255; do if (((N ? f[M + 12 >> 2] | 0 : O) | 0) == (v | 0)) { K = f[G >> 2] | 0; if (N) if (!(Pk(K, t, v) | 0)) break b; else break; if ((b[t >> 0] | 0) == (K & 255) << 24 >> 24) { K = G; P = O; Q = t; do { P = P + -1 | 0; K = K + 1 | 0; if (!P) break b; Q = Q + 1 | 0 } while ((b[K >> 0] | 0) == (b[Q >> 0] | 0)) } } while (0); M = f[M >> 2] | 0; if (!M) { L = H; C = 50; break b } } } if (I) { F = J; while (1) { O = f[F + 4 >> 2] | 0; if ((O | 0) != (r | 0)) { if (O >>> 0 < w >>> 0) R = O; else R = (O >>> 0) % (w >>> 0) | 0; if ((R | 0) != (H | 0)) { L = H; C = 50; break b } } O = b[F + 8 + 11 >> 0] | 0; if (!((O << 24 >> 24 < 0 ? f[F + 12 >> 2] | 0 : O & 255) | 0)) break b; F = f[F >> 2] | 0; if (!F) { L = H; C = 50; break b } } } else S = J; while (1) { F = f[S + 4 >> 2] | 0; if ((F | 0) != (r | 0)) { if (F >>> 0 < w >>> 0) T = F; else T = (F >>> 0) % (w >>> 0) | 0; if ((T | 0) != (H | 0)) { L = H; C = 50; break b } } F = S + 8 | 0; I = b[F + 11 >> 0] | 0; O = I << 24 >> 24 < 0; G = I & 255; do if (((O ? f[S + 12 >> 2] | 0 : G) | 0) == (v | 0)) { I = f[F >> 2] | 0; if (O) if (!(Pk(I, t, v) | 0)) break b; else break; if ((b[t >> 0] | 0) == (I & 255) << 24 >> 24) { I = F; N = G; Q = t; do { N = N + -1 | 0; I = I + 1 | 0; if (!N) break b; Q = Q + 1 | 0 } while ((b[I >> 0] | 0) == (b[Q >> 0] | 0)) } } while (0); S = f[S >> 2] | 0; if (!S) { L = H; C = 50; break } } } else { L = H; C = 50 } } else { L = 0; C = 50 } while (0); if ((C | 0) == 50) { C = 0; pi(e, a, r, q); U = $(((f[l >> 2] | 0) + 1 | 0) >>> 0); V = $(w >>> 0); Y = $(n[g >> 2]); do if (x | $(Y * V) < U) { t = w << 1 | (w >>> 0 < 3 | (w + -1 & w | 0) != 0) & 1; v = ~~$(W($(U / Y))) >>> 0; Ph(a, t >>> 0 < v >>> 0 ? v : t); t = f[k >> 2] | 0; v = t + -1 | 0; if (!(v & t)) { Z = t; _ = v & r; break } if (r >>> 0 < t >>> 0) { Z = t; _ = r } else { Z = t; _ = (r >>> 0) % (t >>> 0) | 0 } } else { Z = w; _ = L } while (0); w = f[(f[a >> 2] | 0) + (_ << 2) >> 2] | 0; if (!w) { f[f[e >> 2] >> 2] = f[m >> 2]; f[m >> 2] = f[e >> 2]; f[(f[a >> 2] | 0) + (_ << 2) >> 2] = m; r = f[e >> 2] | 0; x = f[r >> 2] | 0; if (x | 0) { q = f[x + 4 >> 2] | 0; x = Z + -1 | 0; if (x & Z) if (q >>> 0 < Z >>> 0) aa = q; else aa = (q >>> 0) % (Z >>> 0) | 0; else aa = q & x; f[(f[a >> 2] | 0) + (aa << 2) >> 2] = r } } else { f[f[e >> 2] >> 2] = f[w >> 2]; f[w >> 2] = f[e >> 2] } f[l >> 2] = (f[l >> 2] | 0) + 1 } w = f[p >> 2] | 0; if (!w) break a; else { o = w; p = w } } } while (0); e = f[c + 28 >> 2] | 0; if (!e) { u = d; return } else ba = e; do { e = ba; c = dn(40) | 0; Ub(c, f[e + 20 >> 2] | 0); aa = xc(i, e + 8 | 0) | 0; e = f[aa >> 2] | 0; f[aa >> 2] = c; if (e | 0) { c = f[e + 28 >> 2] | 0; if (c | 0) { aa = c; do { c = aa; aa = f[aa >> 2] | 0; bi(c + 8 | 0); br(c) } while ((aa | 0) != 0) } aa = e + 20 | 0; c = f[aa >> 2] | 0; f[aa >> 2] = 0; if (c | 0) br(c); c = f[e + 8 >> 2] | 0; if (c | 0) { aa = c; do { c = aa; aa = f[aa >> 2] | 0; a = c + 8 | 0; Z = f[c + 20 >> 2] | 0; if (Z | 0) { _ = c + 24 | 0; if ((f[_ >> 2] | 0) != (Z | 0)) f[_ >> 2] = Z; br(Z) } if ((b[a + 11 >> 0] | 0) < 0) br(f[a >> 2] | 0); br(c) } while ((aa | 0) != 0) } aa = f[e >> 2] | 0; f[e >> 2] = 0; if (aa | 0) br(aa); br(e) } ba = f[ba >> 2] | 0 } while ((ba | 0) != 0); u = d; return } function Vb(a, c, e) { a = a | 0; c = c | 0; e = e | 0; var g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = Oa, fa = Oa, ga = Oa, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0; g = u; u = u + 48 | 0; i = g + 16 | 0; j = g + 12 | 0; k = g; l = i + 16 | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; f[i + 12 >> 2] = 0; n[l >> 2] = $(1.0); m = a + 80 | 0; o = f[m >> 2] | 0; f[k >> 2] = 0; p = k + 4 | 0; f[p >> 2] = 0; f[k + 8 >> 2] = 0; if (o) { if (o >>> 0 > 1073741823) mq(k); q = o << 2; r = dn(q) | 0; f[k >> 2] = r; s = r + (o << 2) | 0; f[k + 8 >> 2] = s; hj(r | 0, 0, q | 0) | 0; f[p >> 2] = s; s = c + 48 | 0; q = c + 40 | 0; o = i + 4 | 0; t = i + 12 | 0; v = i + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = f[e >> 2] | 0; e = r; z = 0; A = 0; B = r; C = r; D = 0; E = r; while (1) { r = s; F = f[r >> 2] | 0; G = f[r + 4 >> 2] | 0; r = q; H = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, y + z | 0, 0) | 0; r = Tn(H | 0, I | 0, F | 0, G | 0) | 0; G = (f[f[c >> 2] >> 2] | 0) + r | 0; r = h[G >> 0] | h[G + 1 >> 0] << 8 | h[G + 2 >> 0] << 16 | h[G + 3 >> 0] << 24; f[j >> 2] = r; G = r & 65535; F = r >>> 16; H = F & 65535; J = (r & 65535 ^ 318) + 239 ^ F; F = (D | 0) == 0; a: do if (!F) { K = D + -1 | 0; L = (K & D | 0) == 0; if (!L) if (J >>> 0 < D >>> 0) M = J; else M = (J >>> 0) % (D >>> 0) | 0; else M = J & K; N = f[(f[i >> 2] | 0) + (M << 2) >> 2] | 0; do if (N | 0 ? (O = f[N >> 2] | 0, O | 0) : 0) { b: do if (L) { P = O; while (1) { Q = f[P + 4 >> 2] | 0; R = (Q | 0) == (J | 0); if (!(R | (Q & K | 0) == (M | 0))) { S = 27; break b } if ((R ? (R = P + 8 | 0, (d[R >> 1] | 0) == G << 16 >> 16) : 0) ? (d[R + 2 >> 1] | 0) == H << 16 >> 16 : 0) { T = P; S = 26; break b } P = f[P >> 2] | 0; if (!P) { S = 27; break } } } else { P = O; while (1) { R = f[P + 4 >> 2] | 0; if ((R | 0) == (J | 0)) { Q = P + 8 | 0; if ((d[Q >> 1] | 0) == G << 16 >> 16 ? (d[Q + 2 >> 1] | 0) == H << 16 >> 16 : 0) { T = P; S = 26; break b } } else { if (R >>> 0 < D >>> 0) U = R; else U = (R >>> 0) % (D >>> 0) | 0; if ((U | 0) != (M | 0)) { S = 27; break b } } P = f[P >> 2] | 0; if (!P) { S = 27; break } } } while (0); if ((S | 0) == 26) { S = 0; f[E + (z << 2) >> 2] = f[T + 12 >> 2]; V = e; X = A; Y = C; Z = B; _ = E; break a } else if ((S | 0) == 27) { S = 0; if (F) { aa = 0; S = 46; break a } else break } } while (0); K = D + -1 | 0; L = (K & D | 0) == 0; if (!L) if (J >>> 0 < D >>> 0) ba = J; else ba = (J >>> 0) % (D >>> 0) | 0; else ba = K & J; N = f[(f[i >> 2] | 0) + (ba << 2) >> 2] | 0; if ((N | 0) != 0 ? (O = f[N >> 2] | 0, (O | 0) != 0) : 0) { if (L) { L = O; while (1) { N = f[L + 4 >> 2] | 0; if (!((N | 0) == (J | 0) | (N & K | 0) == (ba | 0))) { aa = ba; S = 46; break a } N = L + 8 | 0; if ((d[N >> 1] | 0) == G << 16 >> 16 ? (d[N + 2 >> 1] | 0) == H << 16 >> 16 : 0) { S = 61; break a } L = f[L >> 2] | 0; if (!L) { aa = ba; S = 46; break a } } } else ca = O; while (1) { L = f[ca + 4 >> 2] | 0; if ((L | 0) != (J | 0)) { if (L >>> 0 < D >>> 0) da = L; else da = (L >>> 0) % (D >>> 0) | 0; if ((da | 0) != (ba | 0)) { aa = ba; S = 46; break a } } L = ca + 8 | 0; if ((d[L >> 1] | 0) == G << 16 >> 16 ? (d[L + 2 >> 1] | 0) == H << 16 >> 16 : 0) { S = 61; break a } ca = f[ca >> 2] | 0; if (!ca) { aa = ba; S = 46; break } } } else { aa = ba; S = 46 } } else { aa = 0; S = 46 } while (0); if ((S | 0) == 46) { S = 0; H = dn(16) | 0; G = H + 8 | 0; d[G >> 1] = r; d[G + 2 >> 1] = r >>> 16; f[H + 12 >> 2] = A; f[H + 4 >> 2] = J; f[H >> 2] = 0; ea = $(((f[t >> 2] | 0) + 1 | 0) >>> 0); fa = $(D >>> 0); ga = $(n[l >> 2]); do if (F | $(ga * fa) < ea) { G = D << 1 | (D >>> 0 < 3 | (D + -1 & D | 0) != 0) & 1; O = ~~$(W($(ea / ga))) >>> 0; Eh(i, G >>> 0 < O >>> 0 ? O : G); G = f[o >> 2] | 0; O = G + -1 | 0; if (!(O & G)) { ha = G; ia = O & J; break } if (J >>> 0 < G >>> 0) { ha = G; ia = J } else { ha = G; ia = (J >>> 0) % (G >>> 0) | 0 } } else { ha = D; ia = aa } while (0); J = (f[i >> 2] | 0) + (ia << 2) | 0; F = f[J >> 2] | 0; if (!F) { f[H >> 2] = f[v >> 2]; f[v >> 2] = H; f[J >> 2] = v; J = f[H >> 2] | 0; if (J | 0) { r = f[J + 4 >> 2] | 0; J = ha + -1 | 0; if (J & ha) if (r >>> 0 < ha >>> 0) ja = r; else ja = (r >>> 0) % (ha >>> 0) | 0; else ja = r & J; ka = (f[i >> 2] | 0) + (ja << 2) | 0; S = 59 } } else { f[H >> 2] = f[F >> 2]; ka = F; S = 59 } if ((S | 0) == 59) { S = 0; f[ka >> 2] = H } f[t >> 2] = (f[t >> 2] | 0) + 1; S = 61 } if ((S | 0) == 61) { S = 0; F = w; J = f[F >> 2] | 0; r = on(J | 0, f[F + 4 >> 2] | 0, A | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + r | 0, j | 0, J | 0) | 0; J = f[k >> 2] | 0; f[J + (z << 2) >> 2] = A; V = J; X = A + 1 | 0; Y = J; Z = J; _ = J } J = z + 1 | 0; la = f[m >> 2] | 0; if (J >>> 0 >= la >>> 0) break; e = V; z = J; A = X; B = Z; C = Y; D = f[o >> 2] | 0; E = _ } if ((X | 0) == (la | 0)) ma = Z; else { Z = a + 84 | 0; if (!(b[Z >> 0] | 0)) { _ = f[a + 72 >> 2] | 0; E = f[a + 68 >> 2] | 0; o = E; if ((_ | 0) == (E | 0)) na = V; else { D = _ - E >> 2; E = 0; do { _ = o + (E << 2) | 0; f[_ >> 2] = f[Y + (f[_ >> 2] << 2) >> 2]; E = E + 1 | 0 } while (E >>> 0 < D >>> 0); na = V } } else { b[Z >> 0] = 0; Z = a + 68 | 0; V = a + 72 | 0; D = f[V >> 2] | 0; E = f[Z >> 2] | 0; Y = D - E >> 2; o = E; E = D; if (la >>> 0 <= Y >>> 0) if (la >>> 0 < Y >>> 0 ? (D = o + (la << 2) | 0, (D | 0) != (E | 0)) : 0) { f[V >> 2] = E + (~((E + -4 - D | 0) >>> 2) << 2); oa = la } else oa = la; else { kh(Z, la - Y | 0, 1204); oa = f[m >> 2] | 0 } Y = f[k >> 2] | 0; if (!oa) na = Y; else { k = f[a + 68 >> 2] | 0; a = 0; do { f[k + (a << 2) >> 2] = f[Y + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < oa >>> 0); na = Y } } f[m >> 2] = X; ma = na } if (!ma) pa = X; else { na = f[p >> 2] | 0; if ((na | 0) != (ma | 0)) f[p >> 2] = na + (~((na + -4 - ma | 0) >>> 2) << 2); br(ma); pa = X } } else pa = 0; X = f[i + 8 >> 2] | 0; if (X | 0) { ma = X; do { X = ma; ma = f[ma >> 2] | 0; br(X) } while ((ma | 0) != 0) } ma = f[i >> 2] | 0; f[i >> 2] = 0; if (!ma) { u = g; return pa | 0 } br(ma); u = g; return pa | 0 } function Wb(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c; g = f[b >> 2] | 0; if ((g | 0) == -1) { h = 1; u = c; return h | 0 } i = (g >>> 0) / 3 | 0; j = a + 24 | 0; if (f[(f[j >> 2] | 0) + (i >>> 5 << 2) >> 2] & 1 << (i & 31) | 0) { h = 1; u = c; return h | 0 } i = a + 48 | 0; k = f[i >> 2] | 0; l = a + 52 | 0; m = f[l >> 2] | 0; if ((m | 0) == (k | 0)) n = k; else { o = m + (~((m + -4 - k | 0) >>> 2) << 2) | 0; f[l >> 2] = o; n = o } o = a + 56 | 0; if ((n | 0) == (f[o >> 2] | 0)) Ci(i, b); else { f[n >> 2] = g; f[l >> 2] = n + 4 } n = a + 4 | 0; g = f[n >> 2] | 0; k = f[b >> 2] | 0; m = k + 1 | 0; if ((k | 0) == -1) { h = 0; u = c; return h | 0 } p = ((m >>> 0) % 3 | 0 | 0) == 0 ? k + -2 | 0 : m; if ((p | 0) == -1) q = -1; else q = f[(f[g >> 2] | 0) + (p << 2) >> 2] | 0; p = (((k >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + k | 0; if ((p | 0) == -1) { h = 0; u = c; return h | 0 } k = f[(f[g >> 2] | 0) + (p << 2) >> 2] | 0; if ((q | 0) == -1 | (k | 0) == -1) { h = 0; u = c; return h | 0 } p = a + 36 | 0; g = f[p >> 2] | 0; m = g + (q >>> 5 << 2) | 0; r = 1 << (q & 31); s = f[m >> 2] | 0; if (!(s & r)) { f[m >> 2] = s | r; r = f[b >> 2] | 0; s = r + 1 | 0; if ((r | 0) == -1) t = -1; else t = ((s >>> 0) % 3 | 0 | 0) == 0 ? r + -2 | 0 : s; f[e >> 2] = t; s = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((t >>> 0) / 3 | 0) * 12 | 0) + (((t >>> 0) % 3 | 0) << 2) >> 2] | 0; t = f[a + 20 >> 2] | 0; f[d >> 2] = s; r = f[t + 4 >> 2] | 0; t = r + 4 | 0; m = f[t >> 2] | 0; if ((m | 0) == (f[r + 8 >> 2] | 0)) Ci(r, d); else { f[m >> 2] = s; f[t >> 2] = m + 4 } m = a + 12 | 0; t = f[m >> 2] | 0; s = t + 4 | 0; r = f[s >> 2] | 0; if ((r | 0) == (f[t + 8 >> 2] | 0)) { Ci(t, e); v = f[m >> 2] | 0 } else { f[r >> 2] = f[e >> 2]; f[s >> 2] = r + 4; v = t } t = v + 24 | 0; f[(f[v + 12 >> 2] | 0) + (q << 2) >> 2] = f[t >> 2]; f[t >> 2] = (f[t >> 2] | 0) + 1; w = f[p >> 2] | 0 } else w = g; g = w + (k >>> 5 << 2) | 0; w = 1 << (k & 31); t = f[g >> 2] | 0; if (!(t & w)) { f[g >> 2] = t | w; w = f[b >> 2] | 0; do if ((w | 0) != -1) if (!((w >>> 0) % 3 | 0)) { x = w + 2 | 0; break } else { x = w + -1 | 0; break } else x = -1; while (0); f[e >> 2] = x; w = f[(f[(f[a + 16 >> 2] | 0) + 96 >> 2] | 0) + (((x >>> 0) / 3 | 0) * 12 | 0) + (((x >>> 0) % 3 | 0) << 2) >> 2] | 0; x = f[a + 20 >> 2] | 0; f[d >> 2] = w; t = f[x + 4 >> 2] | 0; x = t + 4 | 0; g = f[x >> 2] | 0; if ((g | 0) == (f[t + 8 >> 2] | 0)) Ci(t, d); else { f[g >> 2] = w; f[x >> 2] = g + 4 } g = a + 12 | 0; x = f[g >> 2] | 0; w = x + 4 | 0; t = f[w >> 2] | 0; if ((t | 0) == (f[x + 8 >> 2] | 0)) { Ci(x, e); y = f[g >> 2] | 0 } else { f[t >> 2] = f[e >> 2]; f[w >> 2] = t + 4; y = x } x = y + 24 | 0; f[(f[y + 12 >> 2] | 0) + (k << 2) >> 2] = f[x >> 2]; f[x >> 2] = (f[x >> 2] | 0) + 1 } x = f[i >> 2] | 0; k = f[l >> 2] | 0; if ((x | 0) == (k | 0)) { h = 1; u = c; return h | 0 } y = a + 16 | 0; t = a + 20 | 0; w = a + 12 | 0; a = k; k = x; a: while (1) { x = f[a + -4 >> 2] | 0; f[b >> 2] = x; g = (x >>> 0) / 3 | 0; if ((x | 0) != -1 ? (x = (f[j >> 2] | 0) + (g >>> 5 << 2) | 0, q = 1 << (g & 31), g = f[x >> 2] | 0, (g & q | 0) == 0) : 0) { f[x >> 2] = g | q; q = f[b >> 2] | 0; if ((q | 0) == -1) { h = 0; z = 80; break } g = f[n >> 2] | 0; x = q; b: while (1) { q = f[(f[g >> 2] | 0) + (x << 2) >> 2] | 0; if ((q | 0) == -1) { h = 0; z = 80; break a } v = (f[p >> 2] | 0) + (q >>> 5 << 2) | 0; r = 1 << (q & 31); s = f[v >> 2] | 0; do if (!(s & r)) { m = f[(f[g + 24 >> 2] | 0) + (q << 2) >> 2] | 0; A = m + 1 | 0; do if ((m | 0) == -1) B = 1; else { C = ((A >>> 0) % 3 | 0 | 0) == 0 ? m + -2 | 0 : A; if ((C | 0) == -1) { B = 1; break } D = f[(f[g + 12 >> 2] | 0) + (C << 2) >> 2] | 0; C = D + 1 | 0; if ((D | 0) == -1) { B = 1; break } B = ((((C >>> 0) % 3 | 0 | 0) == 0 ? D + -2 | 0 : C) | 0) == -1 } while (0); f[v >> 2] = s | r; A = f[b >> 2] | 0; f[e >> 2] = A; m = f[(f[(f[y >> 2] | 0) + 96 >> 2] | 0) + (((A >>> 0) / 3 | 0) * 12 | 0) + (((A >>> 0) % 3 | 0) << 2) >> 2] | 0; A = f[t >> 2] | 0; f[d >> 2] = m; C = f[A + 4 >> 2] | 0; A = C + 4 | 0; D = f[A >> 2] | 0; if ((D | 0) == (f[C + 8 >> 2] | 0)) Ci(C, d); else { f[D >> 2] = m; f[A >> 2] = D + 4 } D = f[w >> 2] | 0; A = D + 4 | 0; m = f[A >> 2] | 0; if ((m | 0) == (f[D + 8 >> 2] | 0)) { Ci(D, e); E = f[w >> 2] | 0 } else { f[m >> 2] = f[e >> 2]; f[A >> 2] = m + 4; E = D } D = E + 24 | 0; f[(f[E + 12 >> 2] | 0) + (q << 2) >> 2] = f[D >> 2]; f[D >> 2] = (f[D >> 2] | 0) + 1; D = f[n >> 2] | 0; m = f[b >> 2] | 0; if (B) if ((m | 0) == -1) { z = 63; break b } else { F = m; G = D; z = 64; break } do if ((m | 0) == -1) H = -1; else { A = m + 1 | 0; C = ((A >>> 0) % 3 | 0 | 0) == 0 ? m + -2 | 0 : A; if ((C | 0) == -1) { H = -1; break } H = f[(f[D + 12 >> 2] | 0) + (C << 2) >> 2] | 0 } while (0); f[b >> 2] = H; I = (H >>> 0) / 3 | 0; J = D } else { F = x; G = g; z = 64 } while (0); if ((z | 0) == 64) { z = 0; q = F + 1 | 0; r = ((q >>> 0) % 3 | 0 | 0) == 0 ? F + -2 | 0 : q; if ((r | 0) == -1) K = -1; else K = f[(f[G + 12 >> 2] | 0) + (r << 2) >> 2] | 0; f[d >> 2] = K; r = (((F >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + F | 0; if ((r | 0) == -1) L = -1; else L = f[(f[G + 12 >> 2] | 0) + (r << 2) >> 2] | 0; r = (K | 0) == -1; q = (K >>> 0) / 3 | 0; s = r ? -1 : q; v = (L | 0) == -1; m = (L >>> 0) / 3 | 0; C = v ? -1 : m; do if (!r) { A = f[j >> 2] | 0; if (f[A + (s >>> 5 << 2) >> 2] & 1 << (s & 31) | 0) { z = 70; break } if (v) { M = K; N = q; break } if (!(f[A + (C >>> 5 << 2) >> 2] & 1 << (C & 31))) { z = 75; break b } else { M = K; N = q } } else z = 70; while (0); if ((z | 0) == 70) { z = 0; if (v) { z = 72; break } if (!(f[(f[j >> 2] | 0) + (C >>> 5 << 2) >> 2] & 1 << (C & 31))) { M = L; N = m } else { z = 72; break } } f[b >> 2] = M; I = N; J = G } q = (f[j >> 2] | 0) + (I >>> 5 << 2) | 0; f[q >> 2] = f[q >> 2] | 1 << (I & 31); x = f[b >> 2] | 0; if ((x | 0) == -1) { h = 0; z = 80; break a } else g = J } do if ((z | 0) == 63) { z = 0; f[d >> 2] = -1; z = 72 } else if ((z | 0) == 75) { z = 0; g = f[l >> 2] | 0; f[g + -4 >> 2] = L; if ((g | 0) == (f[o >> 2] | 0)) { Ci(i, d); O = f[l >> 2] | 0; break } else { f[g >> 2] = f[d >> 2]; x = g + 4 | 0; f[l >> 2] = x; O = x; break } } while (0); if ((z | 0) == 72) { z = 0; x = (f[l >> 2] | 0) + -4 | 0; f[l >> 2] = x; O = x } P = f[i >> 2] | 0; Q = O } else { x = a + -4 | 0; f[l >> 2] = x; P = k; Q = x } if ((P | 0) == (Q | 0)) { h = 1; z = 80; break } else { a = Q; k = P } } if ((z | 0) == 80) { u = c; return h | 0 } return 0 } function Xb(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = Oa, da = Oa, ea = Oa, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0; e = u; u = u + 48 | 0; g = e + 20 | 0; i = e; j = e + 8 | 0; k = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[k >> 2] = $(1.0); l = a + 80 | 0; m = f[l >> 2] | 0; f[j >> 2] = 0; o = j + 4 | 0; f[o >> 2] = 0; f[j + 8 >> 2] = 0; if (m) { if (m >>> 0 > 1073741823) mq(j); p = m << 2; q = dn(p) | 0; f[j >> 2] = q; r = q + (m << 2) | 0; f[j + 8 >> 2] = r; hj(q | 0, 0, p | 0) | 0; f[o >> 2] = r; r = c + 48 | 0; p = c + 40 | 0; m = g + 4 | 0; s = g + 12 | 0; t = g + 8 | 0; v = a + 40 | 0; w = a + 64 | 0; x = f[d >> 2] | 0; d = q; y = 0; z = 0; A = q; B = q; C = q; q = 0; while (1) { D = r; E = f[D >> 2] | 0; F = f[D + 4 >> 2] | 0; D = p; G = on(f[D >> 2] | 0, f[D + 4 >> 2] | 0, x + y | 0, 0) | 0; D = Tn(G | 0, I | 0, E | 0, F | 0) | 0; F = (f[f[c >> 2] >> 2] | 0) + D | 0; D = F; E = h[D >> 0] | h[D + 1 >> 0] << 8 | h[D + 2 >> 0] << 16 | h[D + 3 >> 0] << 24; D = F + 4 | 0; F = h[D >> 0] | h[D + 1 >> 0] << 8 | h[D + 2 >> 0] << 16 | h[D + 3 >> 0] << 24; D = i; f[D >> 2] = E; f[D + 4 >> 2] = F; D = (E ^ 318) + 239 ^ F; G = (q | 0) == 0; a: do if (!G) { H = q + -1 | 0; J = (H & q | 0) == 0; if (!J) if (D >>> 0 < q >>> 0) K = D; else K = (D >>> 0) % (q >>> 0) | 0; else K = D & H; L = f[(f[g >> 2] | 0) + (K << 2) >> 2] | 0; do if (L | 0 ? (M = f[L >> 2] | 0, M | 0) : 0) { b: do if (J) { N = M; while (1) { O = f[N + 4 >> 2] | 0; P = (O | 0) == (D | 0); if (!(P | (O & H | 0) == (K | 0))) { Q = 27; break b } if ((P ? (f[N + 8 >> 2] | 0) == (E | 0) : 0) ? (f[N + 12 >> 2] | 0) == (F | 0) : 0) { R = N; Q = 26; break b } N = f[N >> 2] | 0; if (!N) { Q = 27; break } } } else { N = M; while (1) { P = f[N + 4 >> 2] | 0; if ((P | 0) == (D | 0)) { if ((f[N + 8 >> 2] | 0) == (E | 0) ? (f[N + 12 >> 2] | 0) == (F | 0) : 0) { R = N; Q = 26; break b } } else { if (P >>> 0 < q >>> 0) S = P; else S = (P >>> 0) % (q >>> 0) | 0; if ((S | 0) != (K | 0)) { Q = 27; break b } } N = f[N >> 2] | 0; if (!N) { Q = 27; break } } } while (0); if ((Q | 0) == 26) { Q = 0; f[A + (y << 2) >> 2] = f[R + 16 >> 2]; T = d; U = z; V = C; X = B; Y = A; break a } else if ((Q | 0) == 27) { Q = 0; if (G) { Z = 0; Q = 46; break a } else break } } while (0); H = q + -1 | 0; J = (H & q | 0) == 0; if (!J) if (D >>> 0 < q >>> 0) _ = D; else _ = (D >>> 0) % (q >>> 0) | 0; else _ = H & D; L = f[(f[g >> 2] | 0) + (_ << 2) >> 2] | 0; if ((L | 0) != 0 ? (M = f[L >> 2] | 0, (M | 0) != 0) : 0) { if (J) { J = M; while (1) { L = f[J + 4 >> 2] | 0; if (!((L | 0) == (D | 0) | (L & H | 0) == (_ | 0))) { Z = _; Q = 46; break a } if ((f[J + 8 >> 2] | 0) == (E | 0) ? (f[J + 12 >> 2] | 0) == (F | 0) : 0) { Q = 61; break a } J = f[J >> 2] | 0; if (!J) { Z = _; Q = 46; break a } } } else aa = M; while (1) { J = f[aa + 4 >> 2] | 0; if ((J | 0) != (D | 0)) { if (J >>> 0 < q >>> 0) ba = J; else ba = (J >>> 0) % (q >>> 0) | 0; if ((ba | 0) != (_ | 0)) { Z = _; Q = 46; break a } } if ((f[aa + 8 >> 2] | 0) == (E | 0) ? (f[aa + 12 >> 2] | 0) == (F | 0) : 0) { Q = 61; break a } aa = f[aa >> 2] | 0; if (!aa) { Z = _; Q = 46; break } } } else { Z = _; Q = 46 } } else { Z = 0; Q = 46 } while (0); if ((Q | 0) == 46) { Q = 0; M = dn(20) | 0; J = M + 8 | 0; f[J >> 2] = E; f[J + 4 >> 2] = F; f[M + 16 >> 2] = z; f[M + 4 >> 2] = D; f[M >> 2] = 0; ca = $(((f[s >> 2] | 0) + 1 | 0) >>> 0); da = $(q >>> 0); ea = $(n[k >> 2]); do if (G | $(ea * da) < ca) { J = q << 1 | (q >>> 0 < 3 | (q + -1 & q | 0) != 0) & 1; H = ~~$(W($(ca / ea))) >>> 0; Ih(g, J >>> 0 < H >>> 0 ? H : J); J = f[m >> 2] | 0; H = J + -1 | 0; if (!(H & J)) { fa = J; ga = H & D; break } if (D >>> 0 < J >>> 0) { fa = J; ga = D } else { fa = J; ga = (D >>> 0) % (J >>> 0) | 0 } } else { fa = q; ga = Z } while (0); D = (f[g >> 2] | 0) + (ga << 2) | 0; G = f[D >> 2] | 0; if (!G) { f[M >> 2] = f[t >> 2]; f[t >> 2] = M; f[D >> 2] = t; D = f[M >> 2] | 0; if (D | 0) { F = f[D + 4 >> 2] | 0; D = fa + -1 | 0; if (D & fa) if (F >>> 0 < fa >>> 0) ha = F; else ha = (F >>> 0) % (fa >>> 0) | 0; else ha = F & D; ia = (f[g >> 2] | 0) + (ha << 2) | 0; Q = 59 } } else { f[M >> 2] = f[G >> 2]; ia = G; Q = 59 } if ((Q | 0) == 59) { Q = 0; f[ia >> 2] = M } f[s >> 2] = (f[s >> 2] | 0) + 1; Q = 61 } if ((Q | 0) == 61) { Q = 0; G = v; D = f[G >> 2] | 0; F = on(D | 0, f[G + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[w >> 2] >> 2] | 0) + F | 0, i | 0, D | 0) | 0; D = f[j >> 2] | 0; f[D + (y << 2) >> 2] = z; T = D; U = z + 1 | 0; V = D; X = D; Y = D } D = y + 1 | 0; ja = f[l >> 2] | 0; if (D >>> 0 >= ja >>> 0) break; d = T; y = D; z = U; A = Y; B = X; C = V; q = f[m >> 2] | 0 } if ((U | 0) == (ja | 0)) ka = X; else { X = a + 84 | 0; if (!(b[X >> 0] | 0)) { m = f[a + 72 >> 2] | 0; q = f[a + 68 >> 2] | 0; C = q; if ((m | 0) == (q | 0)) la = T; else { B = m - q >> 2; q = 0; do { m = C + (q << 2) | 0; f[m >> 2] = f[V + (f[m >> 2] << 2) >> 2]; q = q + 1 | 0 } while (q >>> 0 < B >>> 0); la = T } } else { b[X >> 0] = 0; X = a + 68 | 0; T = a + 72 | 0; B = f[T >> 2] | 0; q = f[X >> 2] | 0; V = B - q >> 2; C = q; q = B; if (ja >>> 0 <= V >>> 0) if (ja >>> 0 < V >>> 0 ? (B = C + (ja << 2) | 0, (B | 0) != (q | 0)) : 0) { f[T >> 2] = q + (~((q + -4 - B | 0) >>> 2) << 2); ma = ja } else ma = ja; else { kh(X, ja - V | 0, 1204); ma = f[l >> 2] | 0 } V = f[j >> 2] | 0; if (!ma) la = V; else { j = f[a + 68 >> 2] | 0; a = 0; do { f[j + (a << 2) >> 2] = f[V + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ma >>> 0); la = V } } f[l >> 2] = U; ka = la } if (!ka) na = U; else { la = f[o >> 2] | 0; if ((la | 0) != (ka | 0)) f[o >> 2] = la + (~((la + -4 - ka | 0) >>> 2) << 2); br(ka); na = U } } else na = 0; U = f[g + 8 >> 2] | 0; if (U | 0) { ka = U; do { U = ka; ka = f[ka >> 2] | 0; br(U) } while ((ka | 0) != 0) } ka = f[g >> 2] | 0; f[g >> 2] = 0; if (!ka) { u = e; return na | 0 } br(ka); u = e; return na | 0 } function Yb(a, c, e) { a = a | 0; c = c | 0; e = e | 0; var g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = Oa, fa = Oa, ga = Oa, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0; g = u; u = u + 48 | 0; i = g + 12 | 0; j = g + 32 | 0; k = g; l = i + 16 | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; f[i + 12 >> 2] = 0; n[l >> 2] = $(1.0); m = a + 80 | 0; o = f[m >> 2] | 0; f[k >> 2] = 0; p = k + 4 | 0; f[p >> 2] = 0; f[k + 8 >> 2] = 0; if (o) { if (o >>> 0 > 1073741823) mq(k); q = o << 2; r = dn(q) | 0; f[k >> 2] = r; s = r + (o << 2) | 0; f[k + 8 >> 2] = s; hj(r | 0, 0, q | 0) | 0; f[p >> 2] = s; s = c + 48 | 0; q = c + 40 | 0; o = i + 4 | 0; t = i + 12 | 0; v = i + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = f[e >> 2] | 0; e = r; z = 0; A = 0; B = r; C = r; D = 0; E = r; while (1) { r = s; F = f[r >> 2] | 0; G = f[r + 4 >> 2] | 0; r = q; H = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, y + z | 0, 0) | 0; r = Tn(H | 0, I | 0, F | 0, G | 0) | 0; G = (f[f[c >> 2] >> 2] | 0) + r | 0; r = h[G >> 0] | h[G + 1 >> 0] << 8; d[j >> 1] = r; G = r & 255; F = (r & 65535) >>> 8; H = F & 255; J = ((r & 255 ^ 318) + 239 << 16 >> 16 ^ F) & 65535; F = (D | 0) == 0; a: do if (!F) { K = D + -1 | 0; L = (K & D | 0) == 0; if (!L) if (D >>> 0 > J >>> 0) M = J; else M = (J >>> 0) % (D >>> 0) | 0; else M = K & J; N = f[(f[i >> 2] | 0) + (M << 2) >> 2] | 0; do if (N | 0 ? (O = f[N >> 2] | 0, O | 0) : 0) { b: do if (L) { P = O; while (1) { Q = f[P + 4 >> 2] | 0; R = (Q | 0) == (J | 0); if (!(R | (Q & K | 0) == (M | 0))) { S = 27; break b } if ((R ? (R = P + 8 | 0, (b[R >> 0] | 0) == G << 24 >> 24) : 0) ? (b[R + 1 >> 0] | 0) == H << 24 >> 24 : 0) { T = P; S = 26; break b } P = f[P >> 2] | 0; if (!P) { S = 27; break } } } else { P = O; while (1) { R = f[P + 4 >> 2] | 0; if ((R | 0) == (J | 0)) { Q = P + 8 | 0; if ((b[Q >> 0] | 0) == G << 24 >> 24 ? (b[Q + 1 >> 0] | 0) == H << 24 >> 24 : 0) { T = P; S = 26; break b } } else { if (R >>> 0 < D >>> 0) U = R; else U = (R >>> 0) % (D >>> 0) | 0; if ((U | 0) != (M | 0)) { S = 27; break b } } P = f[P >> 2] | 0; if (!P) { S = 27; break } } } while (0); if ((S | 0) == 26) { S = 0; f[E + (z << 2) >> 2] = f[T + 12 >> 2]; V = e; X = A; Y = C; Z = B; _ = E; break a } else if ((S | 0) == 27) { S = 0; if (F) { aa = 0; S = 46; break a } else break } } while (0); K = D + -1 | 0; L = (K & D | 0) == 0; if (!L) if (D >>> 0 > J >>> 0) ba = J; else ba = (J >>> 0) % (D >>> 0) | 0; else ba = K & J; N = f[(f[i >> 2] | 0) + (ba << 2) >> 2] | 0; if ((N | 0) != 0 ? (O = f[N >> 2] | 0, (O | 0) != 0) : 0) { if (L) { L = O; while (1) { N = f[L + 4 >> 2] | 0; if (!((N | 0) == (J | 0) | (N & K | 0) == (ba | 0))) { aa = ba; S = 46; break a } N = L + 8 | 0; if ((b[N >> 0] | 0) == G << 24 >> 24 ? (b[N + 1 >> 0] | 0) == H << 24 >> 24 : 0) { S = 61; break a } L = f[L >> 2] | 0; if (!L) { aa = ba; S = 46; break a } } } else ca = O; while (1) { L = f[ca + 4 >> 2] | 0; if ((L | 0) != (J | 0)) { if (L >>> 0 < D >>> 0) da = L; else da = (L >>> 0) % (D >>> 0) | 0; if ((da | 0) != (ba | 0)) { aa = ba; S = 46; break a } } L = ca + 8 | 0; if ((b[L >> 0] | 0) == G << 24 >> 24 ? (b[L + 1 >> 0] | 0) == H << 24 >> 24 : 0) { S = 61; break a } ca = f[ca >> 2] | 0; if (!ca) { aa = ba; S = 46; break } } } else { aa = ba; S = 46 } } else { aa = 0; S = 46 } while (0); if ((S | 0) == 46) { S = 0; H = dn(16) | 0; G = H + 8 | 0; b[G >> 0] = r; b[G + 1 >> 0] = r >> 8; f[H + 12 >> 2] = A; f[H + 4 >> 2] = J; f[H >> 2] = 0; ea = $(((f[t >> 2] | 0) + 1 | 0) >>> 0); fa = $(D >>> 0); ga = $(n[l >> 2]); do if (F | $(ga * fa) < ea) { G = D << 1 | (D >>> 0 < 3 | (D + -1 & D | 0) != 0) & 1; O = ~~$(W($(ea / ga))) >>> 0; Lh(i, G >>> 0 < O >>> 0 ? O : G); G = f[o >> 2] | 0; O = G + -1 | 0; if (!(O & G)) { ha = G; ia = O & J; break } if (G >>> 0 > J >>> 0) { ha = G; ia = J } else { ha = G; ia = (J >>> 0) % (G >>> 0) | 0 } } else { ha = D; ia = aa } while (0); J = (f[i >> 2] | 0) + (ia << 2) | 0; F = f[J >> 2] | 0; if (!F) { f[H >> 2] = f[v >> 2]; f[v >> 2] = H; f[J >> 2] = v; J = f[H >> 2] | 0; if (J | 0) { r = f[J + 4 >> 2] | 0; J = ha + -1 | 0; if (J & ha) if (r >>> 0 < ha >>> 0) ja = r; else ja = (r >>> 0) % (ha >>> 0) | 0; else ja = r & J; ka = (f[i >> 2] | 0) + (ja << 2) | 0; S = 59 } } else { f[H >> 2] = f[F >> 2]; ka = F; S = 59 } if ((S | 0) == 59) { S = 0; f[ka >> 2] = H } f[t >> 2] = (f[t >> 2] | 0) + 1; S = 61 } if ((S | 0) == 61) { S = 0; F = w; J = f[F >> 2] | 0; r = on(J | 0, f[F + 4 >> 2] | 0, A | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + r | 0, j | 0, J | 0) | 0; J = f[k >> 2] | 0; f[J + (z << 2) >> 2] = A; V = J; X = A + 1 | 0; Y = J; Z = J; _ = J } J = z + 1 | 0; la = f[m >> 2] | 0; if (J >>> 0 >= la >>> 0) break; e = V; z = J; A = X; B = Z; C = Y; D = f[o >> 2] | 0; E = _ } if ((X | 0) == (la | 0)) ma = Z; else { Z = a + 84 | 0; if (!(b[Z >> 0] | 0)) { _ = f[a + 72 >> 2] | 0; E = f[a + 68 >> 2] | 0; o = E; if ((_ | 0) == (E | 0)) na = V; else { D = _ - E >> 2; E = 0; do { _ = o + (E << 2) | 0; f[_ >> 2] = f[Y + (f[_ >> 2] << 2) >> 2]; E = E + 1 | 0 } while (E >>> 0 < D >>> 0); na = V } } else { b[Z >> 0] = 0; Z = a + 68 | 0; V = a + 72 | 0; D = f[V >> 2] | 0; E = f[Z >> 2] | 0; Y = D - E >> 2; o = E; E = D; if (la >>> 0 <= Y >>> 0) if (la >>> 0 < Y >>> 0 ? (D = o + (la << 2) | 0, (D | 0) != (E | 0)) : 0) { f[V >> 2] = E + (~((E + -4 - D | 0) >>> 2) << 2); oa = la } else oa = la; else { kh(Z, la - Y | 0, 1204); oa = f[m >> 2] | 0 } Y = f[k >> 2] | 0; if (!oa) na = Y; else { k = f[a + 68 >> 2] | 0; a = 0; do { f[k + (a << 2) >> 2] = f[Y + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < oa >>> 0); na = Y } } f[m >> 2] = X; ma = na } if (!ma) pa = X; else { na = f[p >> 2] | 0; if ((na | 0) != (ma | 0)) f[p >> 2] = na + (~((na + -4 - ma | 0) >>> 2) << 2); br(ma); pa = X } } else pa = 0; X = f[i + 8 >> 2] | 0; if (X | 0) { ma = X; do { X = ma; ma = f[ma >> 2] | 0; br(X) } while ((ma | 0) != 0) } ma = f[i >> 2] | 0; f[i >> 2] = 0; if (!ma) { u = g; return pa | 0 } br(ma); u = g; return pa | 0 } function Zb(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c; g = c + 4 | 0; h = a + 16 | 0; i = f[h >> 2] | 0; j = a + 20 | 0; k = f[j >> 2] | 0; if ((k | 0) == (i | 0)) l = i; else { m = k + (~((k + -4 - i | 0) >>> 2) << 2) | 0; f[j >> 2] = m; l = m } m = a + 24 | 0; if ((l | 0) == (f[m >> 2] | 0)) { Ci(h, b); n = f[h >> 2] | 0; o = f[j >> 2] | 0 } else { f[l >> 2] = f[b >> 2]; k = l + 4 | 0; f[j >> 2] = k; n = i; o = k } k = f[a + 8 >> 2] | 0; i = (f[k + 100 >> 2] | 0) - (f[k + 96 >> 2] | 0) | 0; k = (i | 0) / 12 | 0; if ((n | 0) == (o | 0)) { u = c; return 1 } n = a + 28 | 0; l = (i | 0) > 0; i = a + 164 | 0; p = a + 12 | 0; q = a + 76 | 0; r = a + 80 | 0; s = a + 72 | 0; t = a + 200 | 0; v = a + 320 | 0; w = a + 152 | 0; x = a + 84 | 0; y = a + 324 | 0; z = a + 292 | 0; A = a + 304 | 0; B = a + 316 | 0; C = a + 328 | 0; D = a + 336 | 0; E = a + 332 | 0; F = a + 168 | 0; G = a + 140 | 0; H = a + 120 | 0; I = o; do { o = f[I + -4 >> 2] | 0; f[b >> 2] = o; a: do if ((o | 0) != -1 ? (J = (o >>> 0) / 3 | 0, K = f[n >> 2] | 0, (f[K + (J >>> 5 << 2) >> 2] & 1 << (J & 31) | 0) == 0) : 0) { if (l) { J = 0; L = K; b: while (1) { K = J + 1 | 0; f[i >> 2] = (f[i >> 2] | 0) + 1; M = f[b >> 2] | 0; N = (M | 0) == -1 ? -1 : (M >>> 0) / 3 | 0; M = L + (N >>> 5 << 2) | 0; f[M >> 2] = 1 << (N & 31) | f[M >> 2]; M = f[q >> 2] | 0; if ((M | 0) == (f[r >> 2] | 0)) Ci(s, b); else { f[M >> 2] = f[b >> 2]; f[q >> 2] = M + 4 } f[v >> 2] = f[b >> 2]; M = f[b >> 2] | 0; if ((M | 0) == -1) O = -1; else O = f[(f[f[p >> 2] >> 2] | 0) + (M << 2) >> 2] | 0; P = (f[(f[w >> 2] | 0) + (O << 2) >> 2] | 0) != -1; Q = (f[x >> 2] | 0) + (O >>> 5 << 2) | 0; R = 1 << (O & 31); S = f[Q >> 2] | 0; do if (!(S & R)) { f[Q >> 2] = S | R; if (P) { T = f[b >> 2] | 0; U = 38; break } f[y >> 2] = (f[y >> 2] | 0) + 1; V = f[v >> 2] | 0; W = V + 1 | 0; do if ((V | 0) != -1) { X = ((W >>> 0) % 3 | 0 | 0) == 0 ? V + -2 | 0 : W; if (!((V >>> 0) % 3 | 0)) { Y = V + 2 | 0; Z = X; break } else { Y = V + -1 | 0; Z = X; break } } else { Y = -1; Z = -1 } while (0); V = f[z >> 2] | 0; W = f[A >> 2] | 0; X = W + (f[V + (Z << 2) >> 2] << 2) | 0; _ = f[X >> 2] | 0; f[X >> 2] = _ + -1; X = W + (f[V + (Y << 2) >> 2] << 2) | 0; f[X >> 2] = (f[X >> 2] | 0) + -1; X = f[B >> 2] | 0; if ((X | 0) != -1) { V = f[C >> 2] | 0; if ((_ | 0) < (V | 0)) $ = V; else { W = f[E >> 2] | 0; $ = (_ | 0) > (W | 0) ? W : _ } _ = $ - V | 0; V = f[D >> 2] | 0; W = f[3384 + (X << 2) >> 2] | 0; f[d >> 2] = W; X = V + (_ * 12 | 0) + 4 | 0; aa = f[X >> 2] | 0; if (aa >>> 0 < (f[V + (_ * 12 | 0) + 8 >> 2] | 0) >>> 0) { f[aa >> 2] = W; f[X >> 2] = aa + 4 } else Ci(V + (_ * 12 | 0) | 0, d) } f[B >> 2] = 0; _ = f[b >> 2] | 0; V = _ + 1 | 0; if ((_ | 0) != -1 ? (aa = ((V >>> 0) % 3 | 0 | 0) == 0 ? _ + -2 | 0 : V, (aa | 0) != -1) : 0) ba = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (aa << 2) >> 2] | 0; else ba = -1; f[b >> 2] = ba } else { T = M; U = 38 } while (0); if ((U | 0) == 38) { U = 0; M = T + 1 | 0; if ((T | 0) == -1) { U = 43; break } R = ((M >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : M; if ((R | 0) == -1) ca = -1; else ca = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (R << 2) >> 2] | 0; f[e >> 2] = ca; R = (((T >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + T | 0; if ((R | 0) == -1) da = -1; else da = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (R << 2) >> 2] | 0; R = (ca | 0) == -1; S = R ? -1 : (ca >>> 0) / 3 | 0; ea = (da | 0) == -1; fa = ea ? -1 : (da >>> 0) / 3 | 0; Q = ((M >>> 0) % 3 | 0 | 0) == 0 ? T + -2 | 0 : M; if (((Q | 0) != -1 ? (M = f[(f[p >> 2] | 0) + 12 >> 2] | 0, aa = f[M + (Q << 2) >> 2] | 0, (aa | 0) != -1) : 0) ? (Q = (aa >>> 0) / 3 | 0, aa = f[n >> 2] | 0, (f[aa + (Q >>> 5 << 2) >> 2] & 1 << (Q & 31) | 0) == 0) : 0) { Q = (((T >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + T | 0; do if ((Q | 0) != -1) { V = f[M + (Q << 2) >> 2] | 0; if ((V | 0) == -1) break; _ = (V >>> 0) / 3 | 0; if (!(f[aa + (_ >>> 5 << 2) >> 2] & 1 << (_ & 31))) { U = 62; break b } } while (0); if (!ea) jf(a, f[i >> 2] | 0, N, 0, fa); hd(t, 3); ga = f[e >> 2] | 0 } else { if (!R) { jf(a, f[i >> 2] | 0, N, 1, S); aa = f[b >> 2] | 0; if ((aa | 0) == -1) { U = 52; break } else ha = aa } else ha = T; aa = (((ha >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + ha | 0; if ((aa | 0) == -1) { U = 52; break } Q = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (aa << 2) >> 2] | 0; if ((Q | 0) == -1) { U = 52; break } aa = (Q >>> 0) / 3 | 0; if (f[(f[n >> 2] | 0) + (aa >>> 5 << 2) >> 2] & 1 << (aa & 31) | 0) { U = 52; break } hd(t, 5); ga = da } f[b >> 2] = ga } if ((K | 0) >= (k | 0)) break a; J = K; L = f[n >> 2] | 0 } do if ((U | 0) == 43) { U = 0; f[e >> 2] = -1; U = 54 } else if ((U | 0) == 52) { U = 0; if (ea) U = 54; else { jf(a, f[i >> 2] | 0, N, 0, fa); U = 54 } } else if ((U | 0) == 62) { U = 0; hd(t, 1); f[F >> 2] = (f[F >> 2] | 0) + 1; if (P ? (L = f[(f[w >> 2] | 0) + (O << 2) >> 2] | 0, (1 << (L & 31) & f[(f[G >> 2] | 0) + (L >>> 5 << 2) >> 2] | 0) == 0) : 0) { f[g >> 2] = f[b >> 2]; f[d >> 2] = f[g >> 2]; Ce(a, d, 0) | 0 } L = f[i >> 2] | 0; f[d >> 2] = N; J = Sd(H, d) | 0; f[J >> 2] = L; L = f[j >> 2] | 0; f[L + -4 >> 2] = da; if ((L | 0) == (f[m >> 2] | 0)) { Ci(h, e); break } else { f[L >> 2] = f[e >> 2]; f[j >> 2] = L + 4; break } } while (0); if ((U | 0) == 54) { U = 0; hd(t, 7); f[j >> 2] = (f[j >> 2] | 0) + -4 } } } else U = 11; while (0); if ((U | 0) == 11) { U = 0; f[j >> 2] = I + -4 } I = f[j >> 2] | 0 } while ((f[h >> 2] | 0) != (I | 0)); u = c; return 1 } function _b(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = Oa, K = Oa, L = Oa, M = 0, N = 0, O = 0, P = 0; e = u; u = u + 64 | 0; g = e + 40 | 0; i = e + 16 | 0; j = e; k = xd(a, c) | 0; if (k | 0) { f[i >> 2] = k; f[g >> 2] = f[i >> 2]; Xe(a, g) | 0 } f[j >> 2] = 0; k = j + 4 | 0; f[k >> 2] = 0; f[j + 8 >> 2] = 0; ri(j, 8); l = d; d = l; m = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; d = l + 4 | 0; l = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; d = f[j >> 2] | 0; o = d; b[o >> 0] = m; b[o + 1 >> 0] = m >> 8; b[o + 2 >> 0] = m >> 16; b[o + 3 >> 0] = m >> 24; m = d + 4 | 0; b[m >> 0] = l; b[m + 1 >> 0] = l >> 8; b[m + 2 >> 0] = l >> 16; b[m + 3 >> 0] = l >> 24; dj(i, c); c = i + 12 | 0; f[c >> 2] = 0; l = i + 16 | 0; f[l >> 2] = 0; f[i + 20 >> 2] = 0; m = f[k >> 2] | 0; d = f[j >> 2] | 0; o = m - d | 0; if (!o) { p = d; q = m; r = 0 } else { ri(c, o); p = f[j >> 2] | 0; q = f[k >> 2] | 0; r = f[c >> 2] | 0 } Rg(r | 0, p | 0, q - p | 0) | 0; p = i + 11 | 0; q = b[p >> 0] | 0; r = q << 24 >> 24 < 0; c = r ? f[i >> 2] | 0 : i; o = r ? f[i + 4 >> 2] | 0 : q & 255; if (o >>> 0 > 3) { q = c; r = o; m = o; while (1) { d = X(h[q >> 0] | h[q + 1 >> 0] << 8 | h[q + 2 >> 0] << 16 | h[q + 3 >> 0] << 24, 1540483477) | 0; r = (X(d >>> 24 ^ d, 1540483477) | 0) ^ (X(r, 1540483477) | 0); m = m + -4 | 0; if (m >>> 0 <= 3) break; else q = q + 4 | 0 } q = o + -4 | 0; m = q & -4; s = q - m | 0; t = c + (m + 4) | 0; v = r } else { s = o; t = c; v = o } switch (s | 0) { case 3: { w = h[t + 2 >> 0] << 16 ^ v; x = 10; break } case 2: { w = v; x = 10; break } case 1: { y = v; x = 11; break } default: z = v }if ((x | 0) == 10) { y = h[t + 1 >> 0] << 8 ^ w; x = 11 } if ((x | 0) == 11) z = X(y ^ h[t >> 0], 1540483477) | 0; t = X(z >>> 13 ^ z, 1540483477) | 0; z = t >>> 15 ^ t; t = a + 4 | 0; y = f[t >> 2] | 0; w = (y | 0) == 0; a: do if (!w) { v = y + -1 | 0; s = (v & y | 0) == 0; if (!s) if (z >>> 0 < y >>> 0) A = z; else A = (z >>> 0) % (y >>> 0) | 0; else A = z & v; r = f[(f[a >> 2] | 0) + (A << 2) >> 2] | 0; if ((r | 0) != 0 ? (m = f[r >> 2] | 0, (m | 0) != 0) : 0) { r = (o | 0) == 0; if (s) { if (r) { s = m; while (1) { q = f[s + 4 >> 2] | 0; if (!((q | 0) == (z | 0) | (q & v | 0) == (A | 0))) { B = A; x = 52; break a } q = b[s + 8 + 11 >> 0] | 0; if (!((q << 24 >> 24 < 0 ? f[s + 12 >> 2] | 0 : q & 255) | 0)) break a; s = f[s >> 2] | 0; if (!s) { B = A; x = 52; break a } } } else C = m; while (1) { s = f[C + 4 >> 2] | 0; if (!((s | 0) == (z | 0) | (s & v | 0) == (A | 0))) { B = A; x = 52; break a } s = C + 8 | 0; q = b[s + 11 >> 0] | 0; d = q << 24 >> 24 < 0; D = q & 255; do if (((d ? f[C + 12 >> 2] | 0 : D) | 0) == (o | 0)) { q = f[s >> 2] | 0; if (d) if (!(Pk(q, c, o) | 0)) break a; else break; if ((b[c >> 0] | 0) == (q & 255) << 24 >> 24) { q = s; E = D; F = c; do { E = E + -1 | 0; q = q + 1 | 0; if (!E) break a; F = F + 1 | 0 } while ((b[q >> 0] | 0) == (b[F >> 0] | 0)) } } while (0); C = f[C >> 2] | 0; if (!C) { B = A; x = 52; break a } } } if (r) { v = m; while (1) { D = f[v + 4 >> 2] | 0; if ((D | 0) != (z | 0)) { if (D >>> 0 < y >>> 0) G = D; else G = (D >>> 0) % (y >>> 0) | 0; if ((G | 0) != (A | 0)) { B = A; x = 52; break a } } D = b[v + 8 + 11 >> 0] | 0; if (!((D << 24 >> 24 < 0 ? f[v + 12 >> 2] | 0 : D & 255) | 0)) break a; v = f[v >> 2] | 0; if (!v) { B = A; x = 52; break a } } } else H = m; while (1) { v = f[H + 4 >> 2] | 0; if ((v | 0) != (z | 0)) { if (v >>> 0 < y >>> 0) I = v; else I = (v >>> 0) % (y >>> 0) | 0; if ((I | 0) != (A | 0)) { B = A; x = 52; break a } } v = H + 8 | 0; r = b[v + 11 >> 0] | 0; D = r << 24 >> 24 < 0; s = r & 255; do if (((D ? f[H + 12 >> 2] | 0 : s) | 0) == (o | 0)) { r = f[v >> 2] | 0; if (D) if (!(Pk(r, c, o) | 0)) break a; else break; if ((b[c >> 0] | 0) == (r & 255) << 24 >> 24) { r = v; d = s; F = c; do { d = d + -1 | 0; r = r + 1 | 0; if (!d) break a; F = F + 1 | 0 } while ((b[r >> 0] | 0) == (b[F >> 0] | 0)) } } while (0); H = f[H >> 2] | 0; if (!H) { B = A; x = 52; break } } } else { B = A; x = 52 } } else { B = 0; x = 52 } while (0); if ((x | 0) == 52) { _h(g, a, z, i); x = a + 12 | 0; J = $(((f[x >> 2] | 0) + 1 | 0) >>> 0); K = $(y >>> 0); L = $(n[a + 16 >> 2]); do if (w | $(L * K) < J) { A = y << 1 | (y >>> 0 < 3 | (y + -1 & y | 0) != 0) & 1; H = ~~$(W($(J / L))) >>> 0; Ph(a, A >>> 0 < H >>> 0 ? H : A); A = f[t >> 2] | 0; H = A + -1 | 0; if (!(H & A)) { M = A; N = H & z; break } if (z >>> 0 < A >>> 0) { M = A; N = z } else { M = A; N = (z >>> 0) % (A >>> 0) | 0 } } else { M = y; N = B } while (0); B = f[(f[a >> 2] | 0) + (N << 2) >> 2] | 0; if (!B) { y = a + 8 | 0; f[f[g >> 2] >> 2] = f[y >> 2]; f[y >> 2] = f[g >> 2]; f[(f[a >> 2] | 0) + (N << 2) >> 2] = y; y = f[g >> 2] | 0; N = f[y >> 2] | 0; if (!N) O = g; else { z = f[N + 4 >> 2] | 0; N = M + -1 | 0; if (N & M) if (z >>> 0 < M >>> 0) P = z; else P = (z >>> 0) % (M >>> 0) | 0; else P = z & N; f[(f[a >> 2] | 0) + (P << 2) >> 2] = y; O = g } } else { f[f[g >> 2] >> 2] = f[B >> 2]; f[B >> 2] = f[g >> 2]; O = g } f[x >> 2] = (f[x >> 2] | 0) + 1; f[O >> 2] = 0 } O = f[i + 12 >> 2] | 0; if (O | 0) { if ((f[l >> 2] | 0) != (O | 0)) f[l >> 2] = O; br(O) } if ((b[p >> 0] | 0) < 0) br(f[i >> 2] | 0); i = f[j >> 2] | 0; if (!i) { u = e; return } if ((f[k >> 2] | 0) != (i | 0)) f[k >> 2] = i; br(i); u = e; return } function $b(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0, ua = 0, va = 0, wa = 0, xa = 0, ya = 0, za = 0; e = u; u = u + 96 | 0; g = e + 92 | 0; h = e + 88 | 0; i = e + 72 | 0; j = e + 48 | 0; k = e + 24 | 0; l = e; m = a + 16 | 0; n = f[m >> 2] | 0; o = f[c >> 2] | 0; f[i >> 2] = n; f[i + 4 >> 2] = o; c = i + 8 | 0; f[c >> 2] = o; b[i + 12 >> 0] = 1; p = (o | 0) == -1; if (p) q = -1; else q = f[(f[n >> 2] | 0) + (o << 2) >> 2] | 0; n = a + 20 | 0; r = f[n >> 2] | 0; s = f[r >> 2] | 0; if ((f[r + 4 >> 2] | 0) - s >> 2 >>> 0 <= q >>> 0) mq(r); r = a + 8 | 0; t = f[(f[r >> 2] | 0) + (f[s + (q << 2) >> 2] << 2) >> 2] | 0; q = a + 4 | 0; s = f[q >> 2] | 0; if (!(b[s + 84 >> 0] | 0)) v = f[(f[s + 68 >> 2] | 0) + (t << 2) >> 2] | 0; else v = t; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; f[j + 12 >> 2] = 0; f[j + 16 >> 2] = 0; f[j + 20 >> 2] = 0; f[h >> 2] = v; v = b[s + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(s, g, v, j) | 0; v = a + 28 | 0; a = (f[v >> 2] | 0) == 0; a: do if (!p) { s = k + 8 | 0; t = j + 8 | 0; w = k + 16 | 0; x = j + 16 | 0; y = l + 8 | 0; z = l + 16 | 0; A = o; B = o; C = 0; D = 0; E = 0; F = 0; G = 0; H = 0; J = a; K = o; while (1) { do if (J) { L = K + 1 | 0; if ((K | 0) == -1) { M = A; N = -1; O = -1; P = -1; break } Q = ((L >>> 0) % 3 | 0 | 0) == 0 ? K + -2 | 0 : L; if ((A | 0) != -1) if (!((A >>> 0) % 3 | 0)) { R = A; S = A + 2 | 0; T = Q; U = A; V = 19; break } else { R = A; S = A + -1 | 0; T = Q; U = A; V = 19; break } else { R = -1; S = -1; T = Q; U = -1; V = 19 } } else { Q = B + 1 | 0; L = ((Q >>> 0) % 3 | 0 | 0) == 0 ? B + -2 | 0 : Q; if (!((B >>> 0) % 3 | 0)) { R = A; S = B + 2 | 0; T = L; U = K; V = 19; break } else { R = A; S = B + -1 | 0; T = L; U = K; V = 19; break } } while (0); if ((V | 0) == 19) { V = 0; if ((T | 0) == -1) { M = R; N = -1; O = S; P = U } else { M = R; N = f[(f[f[m >> 2] >> 2] | 0) + (T << 2) >> 2] | 0; O = S; P = U } } W = f[n >> 2] | 0; L = f[W >> 2] | 0; if ((f[W + 4 >> 2] | 0) - L >> 2 >>> 0 <= N >>> 0) { V = 22; break } Q = f[(f[r >> 2] | 0) + (f[L + (N << 2) >> 2] << 2) >> 2] | 0; L = f[q >> 2] | 0; if (!(b[L + 84 >> 0] | 0)) X = f[(f[L + 68 >> 2] | 0) + (Q << 2) >> 2] | 0; else X = Q; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; f[h >> 2] = X; Q = b[L + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(L, g, Q, k) | 0; if ((O | 0) == -1) Y = -1; else Y = f[(f[f[m >> 2] >> 2] | 0) + (O << 2) >> 2] | 0; Z = f[n >> 2] | 0; Q = f[Z >> 2] | 0; if ((f[Z + 4 >> 2] | 0) - Q >> 2 >>> 0 <= Y >>> 0) { V = 28; break } L = f[(f[r >> 2] | 0) + (f[Q + (Y << 2) >> 2] << 2) >> 2] | 0; Q = f[q >> 2] | 0; if (!(b[Q + 84 >> 0] | 0)) _ = f[(f[Q + 68 >> 2] | 0) + (L << 2) >> 2] | 0; else _ = L; f[l >> 2] = 0; f[l + 4 >> 2] = 0; f[l + 8 >> 2] = 0; f[l + 12 >> 2] = 0; f[l + 16 >> 2] = 0; f[l + 20 >> 2] = 0; f[h >> 2] = _; L = b[Q + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(Q, g, L, l) | 0; L = k; Q = j; $ = f[Q >> 2] | 0; aa = f[Q + 4 >> 2] | 0; Q = Vn(f[L >> 2] | 0, f[L + 4 >> 2] | 0, $ | 0, aa | 0) | 0; L = I; ba = s; ca = t; da = f[ca >> 2] | 0; ea = f[ca + 4 >> 2] | 0; ca = Vn(f[ba >> 2] | 0, f[ba + 4 >> 2] | 0, da | 0, ea | 0) | 0; ba = I; fa = w; ga = x; ha = f[ga >> 2] | 0; ia = f[ga + 4 >> 2] | 0; ga = Vn(f[fa >> 2] | 0, f[fa + 4 >> 2] | 0, ha | 0, ia | 0) | 0; fa = I; ja = l; ka = Vn(f[ja >> 2] | 0, f[ja + 4 >> 2] | 0, $ | 0, aa | 0) | 0; aa = I; $ = y; ja = Vn(f[$ >> 2] | 0, f[$ + 4 >> 2] | 0, da | 0, ea | 0) | 0; ea = I; da = z; $ = Vn(f[da >> 2] | 0, f[da + 4 >> 2] | 0, ha | 0, ia | 0) | 0; ia = I; ha = on($ | 0, ia | 0, ca | 0, ba | 0) | 0; da = I; la = on(ja | 0, ea | 0, ga | 0, fa | 0) | 0; ma = I; na = on(ka | 0, aa | 0, ga | 0, fa | 0) | 0; fa = I; ga = on($ | 0, ia | 0, Q | 0, L | 0) | 0; ia = I; $ = on(ja | 0, ea | 0, Q | 0, L | 0) | 0; L = I; Q = on(ka | 0, aa | 0, ca | 0, ba | 0) | 0; ba = I; ca = Vn(C | 0, D | 0, la | 0, ma | 0) | 0; ma = Tn(ca | 0, I | 0, ha | 0, da | 0) | 0; da = I; ha = Tn(na | 0, fa | 0, E | 0, F | 0) | 0; fa = Vn(ha | 0, I | 0, ga | 0, ia | 0) | 0; ia = I; ga = Vn(G | 0, H | 0, Q | 0, ba | 0) | 0; ba = Tn(ga | 0, I | 0, $ | 0, L | 0) | 0; L = I; ph(i); B = f[c >> 2] | 0; $ = (f[v >> 2] | 0) == 0; if ((B | 0) == -1) { oa = $; pa = da; qa = ma; ra = ia; sa = fa; ta = L; ua = ba; break a } else { A = M; C = ma; D = da; E = fa; F = ia; G = ba; H = L; J = $; K = P } } if ((V | 0) == 22) mq(W); else if ((V | 0) == 28) mq(Z) } else { oa = a; pa = 0; qa = 0; ra = 0; sa = 0; ta = 0; ua = 0 } while (0); a = (pa | 0) > -1 | (pa | 0) == -1 & qa >>> 0 > 4294967295; Z = Vn(0, 0, qa | 0, pa | 0) | 0; V = a ? pa : I; W = (ra | 0) > -1 | (ra | 0) == -1 & sa >>> 0 > 4294967295; P = Vn(0, 0, sa | 0, ra | 0) | 0; M = W ? ra : I; v = (ta | 0) > -1 | (ta | 0) == -1 & ua >>> 0 > 4294967295; c = Vn(0, 0, ua | 0, ta | 0) | 0; i = Tn((W ? sa : P) | 0, M | 0, (v ? ua : c) | 0, (v ? ta : I) | 0) | 0; v = Tn(i | 0, I | 0, (a ? qa : Z) | 0, V | 0) | 0; V = I; if (oa) { if ((v | 0) <= 536870912) { va = qa; wa = sa; xa = ua; f[d >> 2] = va; ya = d + 4 | 0; f[ya >> 2] = wa; za = d + 8 | 0; f[za >> 2] = xa; u = e; return } oa = Wn(v | 0, V | 0, 29) | 0; Z = oa & 7; oa = zk(qa | 0, pa | 0, Z | 0, 0) | 0; a = zk(sa | 0, ra | 0, Z | 0, 0) | 0; i = zk(ua | 0, ta | 0, Z | 0, 0) | 0; va = oa; wa = a; xa = i; f[d >> 2] = va; ya = d + 4 | 0; f[ya >> 2] = wa; za = d + 8 | 0; f[za >> 2] = xa; u = e; return } else { if (!((V | 0) > 0 | (V | 0) == 0 & v >>> 0 > 536870912)) { va = qa; wa = sa; xa = ua; f[d >> 2] = va; ya = d + 4 | 0; f[ya >> 2] = wa; za = d + 8 | 0; f[za >> 2] = xa; u = e; return } i = Wn(v | 0, V | 0, 29) | 0; V = I; v = zk(qa | 0, pa | 0, i | 0, V | 0) | 0; pa = zk(sa | 0, ra | 0, i | 0, V | 0) | 0; ra = zk(ua | 0, ta | 0, i | 0, V | 0) | 0; va = v; wa = pa; xa = ra; f[d >> 2] = va; ya = d + 4 | 0; f[ya >> 2] = wa; za = d + 8 | 0; f[za >> 2] = xa; u = e; return } } function ac(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = Oa, M = Oa, N = Oa, O = 0, P = 0, Q = 0, R = 0; e = u; u = u + 64 | 0; g = e + 40 | 0; i = e + 16 | 0; j = e; k = xd(a, c) | 0; if (k | 0) { f[i >> 2] = k; f[g >> 2] = f[i >> 2]; Xe(a, g) | 0 } f[j >> 2] = 0; k = j + 4 | 0; f[k >> 2] = 0; f[j + 8 >> 2] = 0; l = d + 11 | 0; m = b[l >> 0] | 0; o = d + 4 | 0; p = f[o >> 2] | 0; q = m << 24 >> 24 < 0 ? p : m & 255; if (!q) { r = m; s = p; t = 0 } else { ri(j, q); r = b[l >> 0] | 0; s = f[o >> 2] | 0; t = f[j >> 2] | 0 } o = r << 24 >> 24 < 0; Rg(t | 0, (o ? f[d >> 2] | 0 : d) | 0, (o ? s : r & 255) | 0) | 0; dj(i, c); c = i + 12 | 0; f[c >> 2] = 0; r = i + 16 | 0; f[r >> 2] = 0; f[i + 20 >> 2] = 0; s = f[k >> 2] | 0; o = f[j >> 2] | 0; d = s - o | 0; if (!d) { v = o; w = s; x = 0 } else { ri(c, d); v = f[j >> 2] | 0; w = f[k >> 2] | 0; x = f[c >> 2] | 0 } Rg(x | 0, v | 0, w - v | 0) | 0; v = i + 11 | 0; w = b[v >> 0] | 0; x = w << 24 >> 24 < 0; c = x ? f[i >> 2] | 0 : i; d = x ? f[i + 4 >> 2] | 0 : w & 255; if (d >>> 0 > 3) { w = c; x = d; s = d; while (1) { o = X(h[w >> 0] | h[w + 1 >> 0] << 8 | h[w + 2 >> 0] << 16 | h[w + 3 >> 0] << 24, 1540483477) | 0; x = (X(o >>> 24 ^ o, 1540483477) | 0) ^ (X(x, 1540483477) | 0); s = s + -4 | 0; if (s >>> 0 <= 3) break; else w = w + 4 | 0 } w = d + -4 | 0; s = w & -4; y = w - s | 0; z = c + (s + 4) | 0; A = x } else { y = d; z = c; A = d } switch (y | 0) { case 3: { B = h[z + 2 >> 0] << 16 ^ A; C = 12; break } case 2: { B = A; C = 12; break } case 1: { D = A; C = 13; break } default: E = A }if ((C | 0) == 12) { D = h[z + 1 >> 0] << 8 ^ B; C = 13 } if ((C | 0) == 13) E = X(D ^ h[z >> 0], 1540483477) | 0; z = X(E >>> 13 ^ E, 1540483477) | 0; E = z >>> 15 ^ z; z = a + 4 | 0; D = f[z >> 2] | 0; B = (D | 0) == 0; a: do if (!B) { A = D + -1 | 0; y = (A & D | 0) == 0; if (!y) if (E >>> 0 < D >>> 0) F = E; else F = (E >>> 0) % (D >>> 0) | 0; else F = E & A; x = f[(f[a >> 2] | 0) + (F << 2) >> 2] | 0; if ((x | 0) != 0 ? (s = f[x >> 2] | 0, (s | 0) != 0) : 0) { x = (d | 0) == 0; if (y) { if (x) { y = s; while (1) { w = f[y + 4 >> 2] | 0; if (!((w | 0) == (E | 0) | (w & A | 0) == (F | 0))) { G = F; C = 54; break a } w = b[y + 8 + 11 >> 0] | 0; if (!((w << 24 >> 24 < 0 ? f[y + 12 >> 2] | 0 : w & 255) | 0)) break a; y = f[y >> 2] | 0; if (!y) { G = F; C = 54; break a } } } else H = s; while (1) { y = f[H + 4 >> 2] | 0; if (!((y | 0) == (E | 0) | (y & A | 0) == (F | 0))) { G = F; C = 54; break a } y = H + 8 | 0; w = b[y + 11 >> 0] | 0; o = w << 24 >> 24 < 0; t = w & 255; do if (((o ? f[H + 12 >> 2] | 0 : t) | 0) == (d | 0)) { w = f[y >> 2] | 0; if (o) if (!(Pk(w, c, d) | 0)) break a; else break; if ((b[c >> 0] | 0) == (w & 255) << 24 >> 24) { w = y; l = t; q = c; do { l = l + -1 | 0; w = w + 1 | 0; if (!l) break a; q = q + 1 | 0 } while ((b[w >> 0] | 0) == (b[q >> 0] | 0)) } } while (0); H = f[H >> 2] | 0; if (!H) { G = F; C = 54; break a } } } if (x) { A = s; while (1) { t = f[A + 4 >> 2] | 0; if ((t | 0) != (E | 0)) { if (t >>> 0 < D >>> 0) I = t; else I = (t >>> 0) % (D >>> 0) | 0; if ((I | 0) != (F | 0)) { G = F; C = 54; break a } } t = b[A + 8 + 11 >> 0] | 0; if (!((t << 24 >> 24 < 0 ? f[A + 12 >> 2] | 0 : t & 255) | 0)) break a; A = f[A >> 2] | 0; if (!A) { G = F; C = 54; break a } } } else J = s; while (1) { A = f[J + 4 >> 2] | 0; if ((A | 0) != (E | 0)) { if (A >>> 0 < D >>> 0) K = A; else K = (A >>> 0) % (D >>> 0) | 0; if ((K | 0) != (F | 0)) { G = F; C = 54; break a } } A = J + 8 | 0; x = b[A + 11 >> 0] | 0; t = x << 24 >> 24 < 0; y = x & 255; do if (((t ? f[J + 12 >> 2] | 0 : y) | 0) == (d | 0)) { x = f[A >> 2] | 0; if (t) if (!(Pk(x, c, d) | 0)) break a; else break; if ((b[c >> 0] | 0) == (x & 255) << 24 >> 24) { x = A; o = y; q = c; do { o = o + -1 | 0; x = x + 1 | 0; if (!o) break a; q = q + 1 | 0 } while ((b[x >> 0] | 0) == (b[q >> 0] | 0)) } } while (0); J = f[J >> 2] | 0; if (!J) { G = F; C = 54; break } } } else { G = F; C = 54 } } else { G = 0; C = 54 } while (0); if ((C | 0) == 54) { _h(g, a, E, i); C = a + 12 | 0; L = $(((f[C >> 2] | 0) + 1 | 0) >>> 0); M = $(D >>> 0); N = $(n[a + 16 >> 2]); do if (B | $(N * M) < L) { F = D << 1 | (D >>> 0 < 3 | (D + -1 & D | 0) != 0) & 1; J = ~~$(W($(L / N))) >>> 0; Ph(a, F >>> 0 < J >>> 0 ? J : F); F = f[z >> 2] | 0; J = F + -1 | 0; if (!(J & F)) { O = F; P = J & E; break } if (E >>> 0 < F >>> 0) { O = F; P = E } else { O = F; P = (E >>> 0) % (F >>> 0) | 0 } } else { O = D; P = G } while (0); G = f[(f[a >> 2] | 0) + (P << 2) >> 2] | 0; if (!G) { D = a + 8 | 0; f[f[g >> 2] >> 2] = f[D >> 2]; f[D >> 2] = f[g >> 2]; f[(f[a >> 2] | 0) + (P << 2) >> 2] = D; D = f[g >> 2] | 0; P = f[D >> 2] | 0; if (!P) Q = g; else { E = f[P + 4 >> 2] | 0; P = O + -1 | 0; if (P & O) if (E >>> 0 < O >>> 0) R = E; else R = (E >>> 0) % (O >>> 0) | 0; else R = E & P; f[(f[a >> 2] | 0) + (R << 2) >> 2] = D; Q = g } } else { f[f[g >> 2] >> 2] = f[G >> 2]; f[G >> 2] = f[g >> 2]; Q = g } f[C >> 2] = (f[C >> 2] | 0) + 1; f[Q >> 2] = 0 } Q = f[i + 12 >> 2] | 0; if (Q | 0) { if ((f[r >> 2] | 0) != (Q | 0)) f[r >> 2] = Q; br(Q) } if ((b[v >> 0] | 0) < 0) br(f[i >> 2] | 0); i = f[j >> 2] | 0; if (!i) { u = e; return } if ((f[k >> 2] | 0) != (i | 0)) f[k >> 2] = i; br(i); u = e; return } function bc(a, c, e) { a = a | 0; c = c | 0; e = e | 0; var g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = Oa, fa = Oa, ga = Oa, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0; g = u; u = u + 48 | 0; i = g + 12 | 0; j = g + 32 | 0; k = g; l = i + 16 | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; f[i + 12 >> 2] = 0; n[l >> 2] = $(1.0); m = a + 80 | 0; o = f[m >> 2] | 0; f[k >> 2] = 0; p = k + 4 | 0; f[p >> 2] = 0; f[k + 8 >> 2] = 0; if (o) { if (o >>> 0 > 1073741823) mq(k); q = o << 2; r = dn(q) | 0; f[k >> 2] = r; s = r + (o << 2) | 0; f[k + 8 >> 2] = s; hj(r | 0, 0, q | 0) | 0; f[p >> 2] = s; s = c + 48 | 0; q = c + 40 | 0; o = i + 4 | 0; t = i + 12 | 0; v = i + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = f[e >> 2] | 0; e = 0; z = r; A = 0; B = 0; C = r; D = r; E = r; while (1) { r = s; F = f[r >> 2] | 0; G = f[r + 4 >> 2] | 0; r = q; H = on(f[r >> 2] | 0, f[r + 4 >> 2] | 0, y + A | 0, 0) | 0; r = Tn(H | 0, I | 0, F | 0, G | 0) | 0; G = (f[f[c >> 2] >> 2] | 0) + r | 0; r = h[G >> 0] | h[G + 1 >> 0] << 8; d[j >> 1] = r; G = (r ^ 318) & 65535; a: do if (e) { F = e + -1 | 0; H = (F & e | 0) == 0; if (!H) if (e >>> 0 > G >>> 0) J = G; else J = (G >>> 0) % (e >>> 0) | 0; else J = F & G; K = f[i >> 2] | 0; L = f[K + (J << 2) >> 2] | 0; b: do if (L | 0 ? (M = f[L >> 2] | 0, M | 0) : 0) { c: do if (H) { N = M; while (1) { O = f[N + 4 >> 2] | 0; P = (O | 0) == (G | 0); if (!(P | (O & F | 0) == (J | 0))) break b; if (P ? (d[N + 8 >> 1] | 0) == r << 16 >> 16 : 0) { Q = N; break c } N = f[N >> 2] | 0; if (!N) break b } } else { N = M; while (1) { P = f[N + 4 >> 2] | 0; if ((P | 0) == (G | 0)) { if ((d[N + 8 >> 1] | 0) == r << 16 >> 16) { Q = N; break c } } else { if (P >>> 0 < e >>> 0) R = P; else R = (P >>> 0) % (e >>> 0) | 0; if ((R | 0) != (J | 0)) break b } N = f[N >> 2] | 0; if (!N) break b } } while (0); f[E + (A << 2) >> 2] = f[Q + 12 >> 2]; S = z; T = B; U = D; V = C; X = E; break a } while (0); if (!H) if (e >>> 0 > G >>> 0) Y = G; else Y = (G >>> 0) % (e >>> 0) | 0; else Y = F & G; L = f[K + (Y << 2) >> 2] | 0; if (!L) { Z = Y; _ = e; aa = 0; ba = 40 } else { if (H) { M = L; while (1) { M = f[M >> 2] | 0; if (!M) { Z = Y; _ = e; aa = 0; ba = 40; break a } N = f[M + 4 >> 2] | 0; if (!((N | 0) == (G | 0) | (N & F | 0) == (Y | 0))) { Z = Y; _ = e; aa = 0; ba = 40; break a } if ((d[M + 8 >> 1] | 0) == r << 16 >> 16) { ba = 55; break a } } } else ca = L; while (1) { ca = f[ca >> 2] | 0; if (!ca) { Z = Y; _ = e; aa = 0; ba = 40; break a } M = f[ca + 4 >> 2] | 0; if ((M | 0) != (G | 0)) { if (M >>> 0 < e >>> 0) da = M; else da = (M >>> 0) % (e >>> 0) | 0; if ((da | 0) != (Y | 0)) { Z = Y; _ = e; aa = 0; ba = 40; break a } } if ((d[ca + 8 >> 1] | 0) == r << 16 >> 16) { ba = 55; break } } } } else { Z = 0; _ = 0; aa = 1; ba = 40 } while (0); if ((ba | 0) == 40) { ba = 0; L = dn(16) | 0; d[L + 8 >> 1] = r; f[L + 12 >> 2] = B; f[L + 4 >> 2] = G; f[L >> 2] = 0; ea = $(((f[t >> 2] | 0) + 1 | 0) >>> 0); fa = $(_ >>> 0); ga = $(n[l >> 2]); do if (aa | $(ga * fa) < ea) { M = _ << 1 | (_ >>> 0 < 3 | (_ + -1 & _ | 0) != 0) & 1; F = ~~$(W($(ea / ga))) >>> 0; Fh(i, M >>> 0 < F >>> 0 ? F : M); M = f[o >> 2] | 0; F = M + -1 | 0; if (!(F & M)) { ha = M; ia = F & G; break } if (M >>> 0 > G >>> 0) { ha = M; ia = G } else { ha = M; ia = (G >>> 0) % (M >>> 0) | 0 } } else { ha = _; ia = Z } while (0); G = (f[i >> 2] | 0) + (ia << 2) | 0; r = f[G >> 2] | 0; if (!r) { f[L >> 2] = f[v >> 2]; f[v >> 2] = L; f[G >> 2] = v; G = f[L >> 2] | 0; if (G | 0) { M = f[G + 4 >> 2] | 0; G = ha + -1 | 0; if (G & ha) if (M >>> 0 < ha >>> 0) ja = M; else ja = (M >>> 0) % (ha >>> 0) | 0; else ja = M & G; ka = (f[i >> 2] | 0) + (ja << 2) | 0; ba = 53 } } else { f[L >> 2] = f[r >> 2]; ka = r; ba = 53 } if ((ba | 0) == 53) { ba = 0; f[ka >> 2] = L } f[t >> 2] = (f[t >> 2] | 0) + 1; ba = 55 } if ((ba | 0) == 55) { ba = 0; r = w; G = f[r >> 2] | 0; M = on(G | 0, f[r + 4 >> 2] | 0, B | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + M | 0, j | 0, G | 0) | 0; G = f[k >> 2] | 0; f[G + (A << 2) >> 2] = B; S = G; T = B + 1 | 0; U = G; V = G; X = G } G = A + 1 | 0; la = f[m >> 2] | 0; if (G >>> 0 >= la >>> 0) break; e = f[o >> 2] | 0; z = S; A = G; B = T; C = V; D = U; E = X } if ((T | 0) == (la | 0)) ma = V; else { V = a + 84 | 0; if (!(b[V >> 0] | 0)) { X = f[a + 72 >> 2] | 0; E = f[a + 68 >> 2] | 0; D = E; if ((X | 0) == (E | 0)) na = S; else { C = X - E >> 2; E = 0; do { X = D + (E << 2) | 0; f[X >> 2] = f[U + (f[X >> 2] << 2) >> 2]; E = E + 1 | 0 } while (E >>> 0 < C >>> 0); na = S } } else { b[V >> 0] = 0; V = a + 68 | 0; S = a + 72 | 0; C = f[S >> 2] | 0; E = f[V >> 2] | 0; U = C - E >> 2; D = E; E = C; if (la >>> 0 <= U >>> 0) if (la >>> 0 < U >>> 0 ? (C = D + (la << 2) | 0, (C | 0) != (E | 0)) : 0) { f[S >> 2] = E + (~((E + -4 - C | 0) >>> 2) << 2); oa = la } else oa = la; else { kh(V, la - U | 0, 1204); oa = f[m >> 2] | 0 } U = f[k >> 2] | 0; if (!oa) na = U; else { k = f[a + 68 >> 2] | 0; a = 0; do { f[k + (a << 2) >> 2] = f[U + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < oa >>> 0); na = U } } f[m >> 2] = T; ma = na } if (!ma) pa = T; else { na = f[p >> 2] | 0; if ((na | 0) != (ma | 0)) f[p >> 2] = na + (~((na + -4 - ma | 0) >>> 2) << 2); br(ma); pa = T } } else pa = 0; T = f[i + 8 >> 2] | 0; if (T | 0) { ma = T; do { T = ma; ma = f[ma >> 2] | 0; br(T) } while ((ma | 0) != 0) } ma = f[i >> 2] | 0; f[i >> 2] = 0; if (!ma) { u = g; return pa | 0 } br(ma); u = g; return pa | 0 } function cc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = Oa, K = Oa, L = Oa, M = 0, N = 0, O = 0, P = 0; e = u; u = u + 64 | 0; g = e + 40 | 0; i = e + 16 | 0; j = e; k = xd(a, c) | 0; if (k | 0) { f[i >> 2] = k; f[g >> 2] = f[i >> 2]; Xe(a, g) | 0 } f[j >> 2] = 0; k = j + 4 | 0; f[k >> 2] = 0; f[j + 8 >> 2] = 0; ri(j, 4); l = f[j >> 2] | 0; m = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; b[l >> 0] = m; b[l + 1 >> 0] = m >> 8; b[l + 2 >> 0] = m >> 16; b[l + 3 >> 0] = m >> 24; dj(i, c); c = i + 12 | 0; f[c >> 2] = 0; m = i + 16 | 0; f[m >> 2] = 0; f[i + 20 >> 2] = 0; l = f[k >> 2] | 0; d = f[j >> 2] | 0; o = l - d | 0; if (!o) { p = d; q = l; r = 0 } else { ri(c, o); p = f[j >> 2] | 0; q = f[k >> 2] | 0; r = f[c >> 2] | 0 } Rg(r | 0, p | 0, q - p | 0) | 0; p = i + 11 | 0; q = b[p >> 0] | 0; r = q << 24 >> 24 < 0; c = r ? f[i >> 2] | 0 : i; o = r ? f[i + 4 >> 2] | 0 : q & 255; if (o >>> 0 > 3) { q = c; r = o; l = o; while (1) { d = X(h[q >> 0] | h[q + 1 >> 0] << 8 | h[q + 2 >> 0] << 16 | h[q + 3 >> 0] << 24, 1540483477) | 0; r = (X(d >>> 24 ^ d, 1540483477) | 0) ^ (X(r, 1540483477) | 0); l = l + -4 | 0; if (l >>> 0 <= 3) break; else q = q + 4 | 0 } q = o + -4 | 0; l = q & -4; s = q - l | 0; t = c + (l + 4) | 0; v = r } else { s = o; t = c; v = o } switch (s | 0) { case 3: { w = h[t + 2 >> 0] << 16 ^ v; x = 10; break } case 2: { w = v; x = 10; break } case 1: { y = v; x = 11; break } default: z = v }if ((x | 0) == 10) { y = h[t + 1 >> 0] << 8 ^ w; x = 11 } if ((x | 0) == 11) z = X(y ^ h[t >> 0], 1540483477) | 0; t = X(z >>> 13 ^ z, 1540483477) | 0; z = t >>> 15 ^ t; t = a + 4 | 0; y = f[t >> 2] | 0; w = (y | 0) == 0; a: do if (!w) { v = y + -1 | 0; s = (v & y | 0) == 0; if (!s) if (z >>> 0 < y >>> 0) A = z; else A = (z >>> 0) % (y >>> 0) | 0; else A = z & v; r = f[(f[a >> 2] | 0) + (A << 2) >> 2] | 0; if ((r | 0) != 0 ? (l = f[r >> 2] | 0, (l | 0) != 0) : 0) { r = (o | 0) == 0; if (s) { if (r) { s = l; while (1) { q = f[s + 4 >> 2] | 0; if (!((q | 0) == (z | 0) | (q & v | 0) == (A | 0))) { B = A; x = 52; break a } q = b[s + 8 + 11 >> 0] | 0; if (!((q << 24 >> 24 < 0 ? f[s + 12 >> 2] | 0 : q & 255) | 0)) break a; s = f[s >> 2] | 0; if (!s) { B = A; x = 52; break a } } } else C = l; while (1) { s = f[C + 4 >> 2] | 0; if (!((s | 0) == (z | 0) | (s & v | 0) == (A | 0))) { B = A; x = 52; break a } s = C + 8 | 0; q = b[s + 11 >> 0] | 0; d = q << 24 >> 24 < 0; D = q & 255; do if (((d ? f[C + 12 >> 2] | 0 : D) | 0) == (o | 0)) { q = f[s >> 2] | 0; if (d) if (!(Pk(q, c, o) | 0)) break a; else break; if ((b[c >> 0] | 0) == (q & 255) << 24 >> 24) { q = s; E = D; F = c; do { E = E + -1 | 0; q = q + 1 | 0; if (!E) break a; F = F + 1 | 0 } while ((b[q >> 0] | 0) == (b[F >> 0] | 0)) } } while (0); C = f[C >> 2] | 0; if (!C) { B = A; x = 52; break a } } } if (r) { v = l; while (1) { D = f[v + 4 >> 2] | 0; if ((D | 0) != (z | 0)) { if (D >>> 0 < y >>> 0) G = D; else G = (D >>> 0) % (y >>> 0) | 0; if ((G | 0) != (A | 0)) { B = A; x = 52; break a } } D = b[v + 8 + 11 >> 0] | 0; if (!((D << 24 >> 24 < 0 ? f[v + 12 >> 2] | 0 : D & 255) | 0)) break a; v = f[v >> 2] | 0; if (!v) { B = A; x = 52; break a } } } else H = l; while (1) { v = f[H + 4 >> 2] | 0; if ((v | 0) != (z | 0)) { if (v >>> 0 < y >>> 0) I = v; else I = (v >>> 0) % (y >>> 0) | 0; if ((I | 0) != (A | 0)) { B = A; x = 52; break a } } v = H + 8 | 0; r = b[v + 11 >> 0] | 0; D = r << 24 >> 24 < 0; s = r & 255; do if (((D ? f[H + 12 >> 2] | 0 : s) | 0) == (o | 0)) { r = f[v >> 2] | 0; if (D) if (!(Pk(r, c, o) | 0)) break a; else break; if ((b[c >> 0] | 0) == (r & 255) << 24 >> 24) { r = v; d = s; F = c; do { d = d + -1 | 0; r = r + 1 | 0; if (!d) break a; F = F + 1 | 0 } while ((b[r >> 0] | 0) == (b[F >> 0] | 0)) } } while (0); H = f[H >> 2] | 0; if (!H) { B = A; x = 52; break } } } else { B = A; x = 52 } } else { B = 0; x = 52 } while (0); if ((x | 0) == 52) { _h(g, a, z, i); x = a + 12 | 0; J = $(((f[x >> 2] | 0) + 1 | 0) >>> 0); K = $(y >>> 0); L = $(n[a + 16 >> 2]); do if (w | $(L * K) < J) { A = y << 1 | (y >>> 0 < 3 | (y + -1 & y | 0) != 0) & 1; H = ~~$(W($(J / L))) >>> 0; Ph(a, A >>> 0 < H >>> 0 ? H : A); A = f[t >> 2] | 0; H = A + -1 | 0; if (!(H & A)) { M = A; N = H & z; break } if (z >>> 0 < A >>> 0) { M = A; N = z } else { M = A; N = (z >>> 0) % (A >>> 0) | 0 } } else { M = y; N = B } while (0); B = f[(f[a >> 2] | 0) + (N << 2) >> 2] | 0; if (!B) { y = a + 8 | 0; f[f[g >> 2] >> 2] = f[y >> 2]; f[y >> 2] = f[g >> 2]; f[(f[a >> 2] | 0) + (N << 2) >> 2] = y; y = f[g >> 2] | 0; N = f[y >> 2] | 0; if (!N) O = g; else { z = f[N + 4 >> 2] | 0; N = M + -1 | 0; if (N & M) if (z >>> 0 < M >>> 0) P = z; else P = (z >>> 0) % (M >>> 0) | 0; else P = z & N; f[(f[a >> 2] | 0) + (P << 2) >> 2] = y; O = g } } else { f[f[g >> 2] >> 2] = f[B >> 2]; f[B >> 2] = f[g >> 2]; O = g } f[x >> 2] = (f[x >> 2] | 0) + 1; f[O >> 2] = 0 } O = f[i + 12 >> 2] | 0; if (O | 0) { if ((f[m >> 2] | 0) != (O | 0)) f[m >> 2] = O; br(O) } if ((b[p >> 0] | 0) < 0) br(f[i >> 2] | 0); i = f[j >> 2] | 0; if (!i) { u = e; return } if ((f[k >> 2] | 0) != (i | 0)) f[k >> 2] = i; br(i); u = e; return } function dc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = Oa, da = Oa, ea = Oa, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0; e = u; u = u + 48 | 0; g = e + 12 | 0; h = e + 32 | 0; i = e; j = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[j >> 2] = $(1.0); k = a + 80 | 0; l = f[k >> 2] | 0; f[i >> 2] = 0; m = i + 4 | 0; f[m >> 2] = 0; f[i + 8 >> 2] = 0; if (l) { if (l >>> 0 > 1073741823) mq(i); o = l << 2; p = dn(o) | 0; f[i >> 2] = p; q = p + (l << 2) | 0; f[i + 8 >> 2] = q; hj(p | 0, 0, o | 0) | 0; f[m >> 2] = q; q = c + 48 | 0; o = c + 40 | 0; l = g + 4 | 0; r = g + 12 | 0; s = g + 8 | 0; t = a + 40 | 0; v = a + 64 | 0; w = f[d >> 2] | 0; d = 0; x = p; y = 0; z = 0; A = p; B = p; C = p; while (1) { p = q; D = f[p >> 2] | 0; E = f[p + 4 >> 2] | 0; p = o; F = on(f[p >> 2] | 0, f[p + 4 >> 2] | 0, w + y | 0, 0) | 0; p = Tn(F | 0, I | 0, D | 0, E | 0) | 0; E = b[(f[f[c >> 2] >> 2] | 0) + p >> 0] | 0; b[h >> 0] = E; p = E & 255 ^ 318; a: do if (d) { D = d + -1 | 0; F = (D & d | 0) == 0; if (!F) if (p >>> 0 < d >>> 0) G = p; else G = (p >>> 0) % (d >>> 0) | 0; else G = D & p; H = f[g >> 2] | 0; J = f[H + (G << 2) >> 2] | 0; b: do if (J | 0 ? (K = f[J >> 2] | 0, K | 0) : 0) { c: do if (F) { L = K; while (1) { M = f[L + 4 >> 2] | 0; N = (M | 0) == (p | 0); if (!(N | (M & D | 0) == (G | 0))) break b; if (N ? (b[L + 8 >> 0] | 0) == E << 24 >> 24 : 0) { O = L; break c } L = f[L >> 2] | 0; if (!L) break b } } else { L = K; while (1) { N = f[L + 4 >> 2] | 0; if ((N | 0) == (p | 0)) { if ((b[L + 8 >> 0] | 0) == E << 24 >> 24) { O = L; break c } } else { if (N >>> 0 < d >>> 0) P = N; else P = (N >>> 0) % (d >>> 0) | 0; if ((P | 0) != (G | 0)) break b } L = f[L >> 2] | 0; if (!L) break b } } while (0); f[C + (y << 2) >> 2] = f[O + 12 >> 2]; Q = x; R = z; S = B; T = A; U = C; break a } while (0); if (!F) if (p >>> 0 < d >>> 0) V = p; else V = (p >>> 0) % (d >>> 0) | 0; else V = D & p; J = f[H + (V << 2) >> 2] | 0; if (!J) { X = V; Y = d; Z = 0; _ = 40 } else { if (F) { K = J; while (1) { K = f[K >> 2] | 0; if (!K) { X = V; Y = d; Z = 0; _ = 40; break a } L = f[K + 4 >> 2] | 0; if (!((L | 0) == (p | 0) | (L & D | 0) == (V | 0))) { X = V; Y = d; Z = 0; _ = 40; break a } if ((b[K + 8 >> 0] | 0) == E << 24 >> 24) { _ = 55; break a } } } else aa = J; while (1) { aa = f[aa >> 2] | 0; if (!aa) { X = V; Y = d; Z = 0; _ = 40; break a } K = f[aa + 4 >> 2] | 0; if ((K | 0) != (p | 0)) { if (K >>> 0 < d >>> 0) ba = K; else ba = (K >>> 0) % (d >>> 0) | 0; if ((ba | 0) != (V | 0)) { X = V; Y = d; Z = 0; _ = 40; break a } } if ((b[aa + 8 >> 0] | 0) == E << 24 >> 24) { _ = 55; break } } } } else { X = 0; Y = 0; Z = 1; _ = 40 } while (0); if ((_ | 0) == 40) { _ = 0; J = dn(16) | 0; b[J + 8 >> 0] = E; f[J + 12 >> 2] = z; f[J + 4 >> 2] = p; f[J >> 2] = 0; ca = $(((f[r >> 2] | 0) + 1 | 0) >>> 0); da = $(Y >>> 0); ea = $(n[j >> 2]); do if (Z | $(ea * da) < ca) { K = Y << 1 | (Y >>> 0 < 3 | (Y + -1 & Y | 0) != 0) & 1; D = ~~$(W($(ca / ea))) >>> 0; Mh(g, K >>> 0 < D >>> 0 ? D : K); K = f[l >> 2] | 0; D = K + -1 | 0; if (!(D & K)) { fa = K; ga = D & p; break } if (p >>> 0 < K >>> 0) { fa = K; ga = p } else { fa = K; ga = (p >>> 0) % (K >>> 0) | 0 } } else { fa = Y; ga = X } while (0); p = (f[g >> 2] | 0) + (ga << 2) | 0; E = f[p >> 2] | 0; if (!E) { f[J >> 2] = f[s >> 2]; f[s >> 2] = J; f[p >> 2] = s; p = f[J >> 2] | 0; if (p | 0) { K = f[p + 4 >> 2] | 0; p = fa + -1 | 0; if (p & fa) if (K >>> 0 < fa >>> 0) ha = K; else ha = (K >>> 0) % (fa >>> 0) | 0; else ha = K & p; ia = (f[g >> 2] | 0) + (ha << 2) | 0; _ = 53 } } else { f[J >> 2] = f[E >> 2]; ia = E; _ = 53 } if ((_ | 0) == 53) { _ = 0; f[ia >> 2] = J } f[r >> 2] = (f[r >> 2] | 0) + 1; _ = 55 } if ((_ | 0) == 55) { _ = 0; E = t; p = f[E >> 2] | 0; K = on(p | 0, f[E + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[v >> 2] >> 2] | 0) + K | 0, h | 0, p | 0) | 0; p = f[i >> 2] | 0; f[p + (y << 2) >> 2] = z; Q = p; R = z + 1 | 0; S = p; T = p; U = p } p = y + 1 | 0; ja = f[k >> 2] | 0; if (p >>> 0 >= ja >>> 0) break; d = f[l >> 2] | 0; x = Q; y = p; z = R; A = T; B = S; C = U } if ((R | 0) == (ja | 0)) ka = T; else { T = a + 84 | 0; if (!(b[T >> 0] | 0)) { U = f[a + 72 >> 2] | 0; C = f[a + 68 >> 2] | 0; B = C; if ((U | 0) == (C | 0)) la = Q; else { A = U - C >> 2; C = 0; do { U = B + (C << 2) | 0; f[U >> 2] = f[S + (f[U >> 2] << 2) >> 2]; C = C + 1 | 0 } while (C >>> 0 < A >>> 0); la = Q } } else { b[T >> 0] = 0; T = a + 68 | 0; Q = a + 72 | 0; A = f[Q >> 2] | 0; C = f[T >> 2] | 0; S = A - C >> 2; B = C; C = A; if (ja >>> 0 <= S >>> 0) if (ja >>> 0 < S >>> 0 ? (A = B + (ja << 2) | 0, (A | 0) != (C | 0)) : 0) { f[Q >> 2] = C + (~((C + -4 - A | 0) >>> 2) << 2); ma = ja } else ma = ja; else { kh(T, ja - S | 0, 1204); ma = f[k >> 2] | 0 } S = f[i >> 2] | 0; if (!ma) la = S; else { i = f[a + 68 >> 2] | 0; a = 0; do { f[i + (a << 2) >> 2] = f[S + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ma >>> 0); la = S } } f[k >> 2] = R; ka = la } if (!ka) na = R; else { la = f[m >> 2] | 0; if ((la | 0) != (ka | 0)) f[m >> 2] = la + (~((la + -4 - ka | 0) >>> 2) << 2); br(ka); na = R } } else na = 0; R = f[g + 8 >> 2] | 0; if (R | 0) { ka = R; do { R = ka; ka = f[ka >> 2] | 0; br(R) } while ((ka | 0) != 0) } ka = f[g >> 2] | 0; f[g >> 2] = 0; if (!ka) { u = e; return na | 0 } br(ka); u = e; return na | 0 } function ec(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = Oa, ea = Oa, fa = Oa, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0; e = u; u = u + 48 | 0; g = e + 16 | 0; i = e + 12 | 0; j = e; k = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[k >> 2] = $(1.0); l = a + 80 | 0; m = f[l >> 2] | 0; f[j >> 2] = 0; o = j + 4 | 0; f[o >> 2] = 0; f[j + 8 >> 2] = 0; if (m) { if (m >>> 0 > 1073741823) mq(j); p = m << 2; q = dn(p) | 0; f[j >> 2] = q; r = q + (m << 2) | 0; f[j + 8 >> 2] = r; hj(q | 0, 0, p | 0) | 0; f[o >> 2] = r; r = c + 48 | 0; p = c + 40 | 0; m = g + 4 | 0; s = g + 12 | 0; t = g + 8 | 0; v = a + 40 | 0; w = a + 64 | 0; x = f[d >> 2] | 0; d = 0; y = q; z = 0; A = 0; B = q; C = q; D = q; while (1) { q = r; E = f[q >> 2] | 0; F = f[q + 4 >> 2] | 0; q = p; G = on(f[q >> 2] | 0, f[q + 4 >> 2] | 0, x + z | 0, 0) | 0; q = Tn(G | 0, I | 0, E | 0, F | 0) | 0; F = (f[f[c >> 2] >> 2] | 0) + q | 0; q = h[F >> 0] | h[F + 1 >> 0] << 8 | h[F + 2 >> 0] << 16 | h[F + 3 >> 0] << 24; f[i >> 2] = q; F = q ^ 318; a: do if (d) { E = d + -1 | 0; G = (E & d | 0) == 0; if (!G) if (F >>> 0 < d >>> 0) H = F; else H = (F >>> 0) % (d >>> 0) | 0; else H = E & F; J = f[g >> 2] | 0; K = f[J + (H << 2) >> 2] | 0; b: do if (K | 0 ? (L = f[K >> 2] | 0, L | 0) : 0) { c: do if (G) { M = L; while (1) { N = f[M + 4 >> 2] | 0; O = (N | 0) == (F | 0); if (!(O | (N & E | 0) == (H | 0))) break b; if (O ? (f[M + 8 >> 2] | 0) == (q | 0) : 0) { P = M; break c } M = f[M >> 2] | 0; if (!M) break b } } else { M = L; while (1) { O = f[M + 4 >> 2] | 0; if ((O | 0) == (F | 0)) { if ((f[M + 8 >> 2] | 0) == (q | 0)) { P = M; break c } } else { if (O >>> 0 < d >>> 0) Q = O; else Q = (O >>> 0) % (d >>> 0) | 0; if ((Q | 0) != (H | 0)) break b } M = f[M >> 2] | 0; if (!M) break b } } while (0); f[D + (z << 2) >> 2] = f[P + 12 >> 2]; R = y; S = A; T = C; U = B; V = D; break a } while (0); if (!G) if (F >>> 0 < d >>> 0) X = F; else X = (F >>> 0) % (d >>> 0) | 0; else X = E & F; K = f[J + (X << 2) >> 2] | 0; if (!K) { Y = X; Z = d; _ = 0; aa = 40 } else { if (G) { L = K; while (1) { L = f[L >> 2] | 0; if (!L) { Y = X; Z = d; _ = 0; aa = 40; break a } M = f[L + 4 >> 2] | 0; if (!((M | 0) == (F | 0) | (M & E | 0) == (X | 0))) { Y = X; Z = d; _ = 0; aa = 40; break a } if ((f[L + 8 >> 2] | 0) == (q | 0)) { aa = 55; break a } } } else ba = K; while (1) { ba = f[ba >> 2] | 0; if (!ba) { Y = X; Z = d; _ = 0; aa = 40; break a } L = f[ba + 4 >> 2] | 0; if ((L | 0) != (F | 0)) { if (L >>> 0 < d >>> 0) ca = L; else ca = (L >>> 0) % (d >>> 0) | 0; if ((ca | 0) != (X | 0)) { Y = X; Z = d; _ = 0; aa = 40; break a } } if ((f[ba + 8 >> 2] | 0) == (q | 0)) { aa = 55; break } } } } else { Y = 0; Z = 0; _ = 1; aa = 40 } while (0); if ((aa | 0) == 40) { aa = 0; K = dn(16) | 0; f[K + 8 >> 2] = q; f[K + 12 >> 2] = A; f[K + 4 >> 2] = F; f[K >> 2] = 0; da = $(((f[s >> 2] | 0) + 1 | 0) >>> 0); ea = $(Z >>> 0); fa = $(n[k >> 2]); do if (_ | $(fa * ea) < da) { L = Z << 1 | (Z >>> 0 < 3 | (Z + -1 & Z | 0) != 0) & 1; E = ~~$(W($(da / fa))) >>> 0; ti(g, L >>> 0 < E >>> 0 ? E : L); L = f[m >> 2] | 0; E = L + -1 | 0; if (!(E & L)) { ga = L; ha = E & F; break } if (F >>> 0 < L >>> 0) { ga = L; ha = F } else { ga = L; ha = (F >>> 0) % (L >>> 0) | 0 } } else { ga = Z; ha = Y } while (0); F = (f[g >> 2] | 0) + (ha << 2) | 0; q = f[F >> 2] | 0; if (!q) { f[K >> 2] = f[t >> 2]; f[t >> 2] = K; f[F >> 2] = t; F = f[K >> 2] | 0; if (F | 0) { L = f[F + 4 >> 2] | 0; F = ga + -1 | 0; if (F & ga) if (L >>> 0 < ga >>> 0) ia = L; else ia = (L >>> 0) % (ga >>> 0) | 0; else ia = L & F; ja = (f[g >> 2] | 0) + (ia << 2) | 0; aa = 53 } } else { f[K >> 2] = f[q >> 2]; ja = q; aa = 53 } if ((aa | 0) == 53) { aa = 0; f[ja >> 2] = K } f[s >> 2] = (f[s >> 2] | 0) + 1; aa = 55 } if ((aa | 0) == 55) { aa = 0; q = v; F = f[q >> 2] | 0; L = on(F | 0, f[q + 4 >> 2] | 0, A | 0, 0) | 0; Rg((f[f[w >> 2] >> 2] | 0) + L | 0, i | 0, F | 0) | 0; F = f[j >> 2] | 0; f[F + (z << 2) >> 2] = A; R = F; S = A + 1 | 0; T = F; U = F; V = F } F = z + 1 | 0; ka = f[l >> 2] | 0; if (F >>> 0 >= ka >>> 0) break; d = f[m >> 2] | 0; y = R; z = F; A = S; B = U; C = T; D = V } if ((S | 0) == (ka | 0)) la = U; else { U = a + 84 | 0; if (!(b[U >> 0] | 0)) { V = f[a + 72 >> 2] | 0; D = f[a + 68 >> 2] | 0; C = D; if ((V | 0) == (D | 0)) ma = R; else { B = V - D >> 2; D = 0; do { V = C + (D << 2) | 0; f[V >> 2] = f[T + (f[V >> 2] << 2) >> 2]; D = D + 1 | 0 } while (D >>> 0 < B >>> 0); ma = R } } else { b[U >> 0] = 0; U = a + 68 | 0; R = a + 72 | 0; B = f[R >> 2] | 0; D = f[U >> 2] | 0; T = B - D >> 2; C = D; D = B; if (ka >>> 0 <= T >>> 0) if (ka >>> 0 < T >>> 0 ? (B = C + (ka << 2) | 0, (B | 0) != (D | 0)) : 0) { f[R >> 2] = D + (~((D + -4 - B | 0) >>> 2) << 2); na = ka } else na = ka; else { kh(U, ka - T | 0, 1204); na = f[l >> 2] | 0 } T = f[j >> 2] | 0; if (!na) ma = T; else { j = f[a + 68 >> 2] | 0; a = 0; do { f[j + (a << 2) >> 2] = f[T + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < na >>> 0); ma = T } } f[l >> 2] = S; la = ma } if (!la) oa = S; else { ma = f[o >> 2] | 0; if ((ma | 0) != (la | 0)) f[o >> 2] = ma + (~((ma + -4 - la | 0) >>> 2) << 2); br(la); oa = S } } else oa = 0; S = f[g + 8 >> 2] | 0; if (S | 0) { la = S; do { S = la; la = f[la >> 2] | 0; br(S) } while ((la | 0) != 0) } la = f[g >> 2] | 0; f[g >> 2] = 0; if (!la) { u = e; return oa | 0 } br(la); u = e; return oa | 0 } function fc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0, na = 0, oa = 0, pa = 0, qa = 0, ra = 0, sa = 0, ta = 0; e = u; u = u + 96 | 0; g = e + 92 | 0; h = e + 88 | 0; i = e + 72 | 0; j = e + 48 | 0; k = e + 24 | 0; l = e; m = a + 16 | 0; n = f[m >> 2] | 0; o = f[c >> 2] | 0; f[i >> 2] = n; f[i + 4 >> 2] = o; c = i + 8 | 0; f[c >> 2] = o; b[i + 12 >> 0] = 1; p = f[(f[n + 28 >> 2] | 0) + (o << 2) >> 2] | 0; n = a + 20 | 0; q = f[n >> 2] | 0; r = f[q >> 2] | 0; if ((f[q + 4 >> 2] | 0) - r >> 2 >>> 0 <= p >>> 0) mq(q); q = a + 8 | 0; s = f[(f[q >> 2] | 0) + (f[r + (p << 2) >> 2] << 2) >> 2] | 0; p = a + 4 | 0; r = f[p >> 2] | 0; if (!(b[r + 84 >> 0] | 0)) t = f[(f[r + 68 >> 2] | 0) + (s << 2) >> 2] | 0; else t = s; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; f[j + 12 >> 2] = 0; f[j + 16 >> 2] = 0; f[j + 20 >> 2] = 0; f[h >> 2] = t; t = b[r + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(r, g, t, j) | 0; t = a + 28 | 0; a = (f[t >> 2] | 0) == 0; a: do if ((o | 0) != -1) { r = k + 8 | 0; s = j + 8 | 0; v = k + 16 | 0; w = j + 16 | 0; x = l + 8 | 0; y = l + 16 | 0; z = o; A = o; B = 0; C = 0; D = 0; E = 0; F = 0; G = 0; H = a; J = o; while (1) { do if (H) { K = J + 1 | 0; if ((J | 0) != -1) { L = ((K >>> 0) % 3 | 0 | 0) == 0 ? J + -2 | 0 : K; if ((z | 0) != -1) if (!((z >>> 0) % 3 | 0)) { M = z; N = z + 2 | 0; O = L; P = z; break } else { M = z; N = z + -1 | 0; O = L; P = z; break } else { M = -1; N = -1; O = L; P = -1 } } else { M = z; N = -1; O = -1; P = -1 } } else { L = A + 1 | 0; K = ((L >>> 0) % 3 | 0 | 0) == 0 ? A + -2 | 0 : L; if (!((A >>> 0) % 3 | 0)) { M = z; N = A + 2 | 0; O = K; P = J; break } else { M = z; N = A + -1 | 0; O = K; P = J; break } } while (0); K = f[(f[(f[m >> 2] | 0) + 28 >> 2] | 0) + (O << 2) >> 2] | 0; Q = f[n >> 2] | 0; L = f[Q >> 2] | 0; if ((f[Q + 4 >> 2] | 0) - L >> 2 >>> 0 <= K >>> 0) { R = 17; break } S = f[(f[q >> 2] | 0) + (f[L + (K << 2) >> 2] << 2) >> 2] | 0; K = f[p >> 2] | 0; if (!(b[K + 84 >> 0] | 0)) T = f[(f[K + 68 >> 2] | 0) + (S << 2) >> 2] | 0; else T = S; f[k >> 2] = 0; f[k + 4 >> 2] = 0; f[k + 8 >> 2] = 0; f[k + 12 >> 2] = 0; f[k + 16 >> 2] = 0; f[k + 20 >> 2] = 0; f[h >> 2] = T; S = b[K + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(K, g, S, k) | 0; S = f[(f[(f[m >> 2] | 0) + 28 >> 2] | 0) + (N << 2) >> 2] | 0; U = f[n >> 2] | 0; K = f[U >> 2] | 0; if ((f[U + 4 >> 2] | 0) - K >> 2 >>> 0 <= S >>> 0) { R = 21; break } L = f[(f[q >> 2] | 0) + (f[K + (S << 2) >> 2] << 2) >> 2] | 0; S = f[p >> 2] | 0; if (!(b[S + 84 >> 0] | 0)) V = f[(f[S + 68 >> 2] | 0) + (L << 2) >> 2] | 0; else V = L; f[l >> 2] = 0; f[l + 4 >> 2] = 0; f[l + 8 >> 2] = 0; f[l + 12 >> 2] = 0; f[l + 16 >> 2] = 0; f[l + 20 >> 2] = 0; f[h >> 2] = V; L = b[S + 24 >> 0] | 0; f[g >> 2] = f[h >> 2]; ub(S, g, L, l) | 0; L = k; S = j; K = f[S >> 2] | 0; W = f[S + 4 >> 2] | 0; S = Vn(f[L >> 2] | 0, f[L + 4 >> 2] | 0, K | 0, W | 0) | 0; L = I; X = r; Y = s; Z = f[Y >> 2] | 0; _ = f[Y + 4 >> 2] | 0; Y = Vn(f[X >> 2] | 0, f[X + 4 >> 2] | 0, Z | 0, _ | 0) | 0; X = I; $ = v; aa = w; ba = f[aa >> 2] | 0; ca = f[aa + 4 >> 2] | 0; aa = Vn(f[$ >> 2] | 0, f[$ + 4 >> 2] | 0, ba | 0, ca | 0) | 0; $ = I; da = l; ea = Vn(f[da >> 2] | 0, f[da + 4 >> 2] | 0, K | 0, W | 0) | 0; W = I; K = x; da = Vn(f[K >> 2] | 0, f[K + 4 >> 2] | 0, Z | 0, _ | 0) | 0; _ = I; Z = y; K = Vn(f[Z >> 2] | 0, f[Z + 4 >> 2] | 0, ba | 0, ca | 0) | 0; ca = I; ba = on(K | 0, ca | 0, Y | 0, X | 0) | 0; Z = I; fa = on(da | 0, _ | 0, aa | 0, $ | 0) | 0; ga = I; ha = on(ea | 0, W | 0, aa | 0, $ | 0) | 0; $ = I; aa = on(K | 0, ca | 0, S | 0, L | 0) | 0; ca = I; K = on(da | 0, _ | 0, S | 0, L | 0) | 0; L = I; S = on(ea | 0, W | 0, Y | 0, X | 0) | 0; X = I; Y = Vn(B | 0, C | 0, fa | 0, ga | 0) | 0; ga = Tn(Y | 0, I | 0, ba | 0, Z | 0) | 0; Z = I; ba = Tn(ha | 0, $ | 0, D | 0, E | 0) | 0; $ = Vn(ba | 0, I | 0, aa | 0, ca | 0) | 0; ca = I; aa = Vn(F | 0, G | 0, S | 0, X | 0) | 0; X = Tn(aa | 0, I | 0, K | 0, L | 0) | 0; L = I; xg(i); A = f[c >> 2] | 0; K = (f[t >> 2] | 0) == 0; if ((A | 0) == -1) { ia = K; ja = Z; ka = ga; la = ca; ma = $; na = L; oa = X; break a } else { z = M; B = ga; C = Z; D = $; E = ca; F = X; G = L; H = K; J = P } } if ((R | 0) == 17) mq(Q); else if ((R | 0) == 21) mq(U) } else { ia = a; ja = 0; ka = 0; la = 0; ma = 0; na = 0; oa = 0 } while (0); a = (ja | 0) > -1 | (ja | 0) == -1 & ka >>> 0 > 4294967295; U = Vn(0, 0, ka | 0, ja | 0) | 0; R = a ? ja : I; Q = (la | 0) > -1 | (la | 0) == -1 & ma >>> 0 > 4294967295; P = Vn(0, 0, ma | 0, la | 0) | 0; M = Q ? la : I; t = (na | 0) > -1 | (na | 0) == -1 & oa >>> 0 > 4294967295; c = Vn(0, 0, oa | 0, na | 0) | 0; i = Tn((Q ? ma : P) | 0, M | 0, (t ? oa : c) | 0, (t ? na : I) | 0) | 0; t = Tn(i | 0, I | 0, (a ? ka : U) | 0, R | 0) | 0; R = I; if (ia) { if ((t | 0) <= 536870912) { pa = ka; qa = ma; ra = oa; f[d >> 2] = pa; sa = d + 4 | 0; f[sa >> 2] = qa; ta = d + 8 | 0; f[ta >> 2] = ra; u = e; return } ia = Wn(t | 0, R | 0, 29) | 0; U = ia & 7; ia = zk(ka | 0, ja | 0, U | 0, 0) | 0; a = zk(ma | 0, la | 0, U | 0, 0) | 0; i = zk(oa | 0, na | 0, U | 0, 0) | 0; pa = ia; qa = a; ra = i; f[d >> 2] = pa; sa = d + 4 | 0; f[sa >> 2] = qa; ta = d + 8 | 0; f[ta >> 2] = ra; u = e; return } else { if (!((R | 0) > 0 | (R | 0) == 0 & t >>> 0 > 536870912)) { pa = ka; qa = ma; ra = oa; f[d >> 2] = pa; sa = d + 4 | 0; f[sa >> 2] = qa; ta = d + 8 | 0; f[ta >> 2] = ra; u = e; return } i = Wn(t | 0, R | 0, 29) | 0; R = I; t = zk(ka | 0, ja | 0, i | 0, R | 0) | 0; ja = zk(ma | 0, la | 0, i | 0, R | 0) | 0; la = zk(oa | 0, na | 0, i | 0, R | 0) | 0; pa = t; qa = ja; ra = la; f[d >> 2] = pa; sa = d + 4 | 0; f[sa >> 2] = qa; ta = d + 8 | 0; f[ta >> 2] = ra; u = e; return } } function gc(a, c, e) { a = a | 0; c = c | 0; e = e | 0; var g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = Oa, V = Oa, X = Oa, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0; g = u; u = u + 48 | 0; i = g + 28 | 0; j = g + 8 | 0; k = g; l = g + 16 | 0; m = i + 16 | 0; f[i >> 2] = 0; f[i + 4 >> 2] = 0; f[i + 8 >> 2] = 0; f[i + 12 >> 2] = 0; n[m >> 2] = $(1.0); o = a + 80 | 0; p = f[o >> 2] | 0; f[l >> 2] = 0; q = l + 4 | 0; f[q >> 2] = 0; f[l + 8 >> 2] = 0; if (p) { if (p >>> 0 > 1073741823) mq(l); r = p << 2; s = dn(r) | 0; f[l >> 2] = s; t = s + (p << 2) | 0; f[l + 8 >> 2] = t; hj(s | 0, 0, r | 0) | 0; f[q >> 2] = t; t = f[e >> 2] | 0; e = c + 48 | 0; r = c + 40 | 0; s = i + 4 | 0; p = i + 12 | 0; v = i + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = 0; z = 0; while (1) { A = e; B = f[A >> 2] | 0; C = f[A + 4 >> 2] | 0; A = r; D = on(f[A >> 2] | 0, f[A + 4 >> 2] | 0, t + y | 0, 0) | 0; A = Tn(D | 0, I | 0, B | 0, C | 0) | 0; C = (f[f[c >> 2] >> 2] | 0) + A | 0; A = C; B = h[A >> 0] | h[A + 1 >> 0] << 8 | h[A + 2 >> 0] << 16 | h[A + 3 >> 0] << 24; A = C + 4 | 0; C = h[A >> 0] | h[A + 1 >> 0] << 8 | h[A + 2 >> 0] << 16 | h[A + 3 >> 0] << 24; A = j; f[A >> 2] = B; f[A + 4 >> 2] = C; A = k; f[A >> 2] = B; f[A + 4 >> 2] = C; C = kf(i, k) | 0; if (!C) { A = k; B = f[A >> 2] | 0; D = f[A + 4 >> 2] | 0; A = B & 65535; E = Wn(B | 0, D | 0, 16) | 0; F = E & 65535; G = D & 65535; H = Wn(B | 0, D | 0, 48) | 0; J = H & 65535; K = ((((A ^ 318) & 65535) + 239 ^ E & 65535) + 239 ^ D & 65535) + 239 ^ H & 65535; H = f[s >> 2] | 0; E = (H | 0) == 0; a: do if (!E) { L = H + -1 | 0; M = (L & H | 0) == 0; if (!M) if (K >>> 0 < H >>> 0) N = K; else N = (K >>> 0) % (H >>> 0) | 0; else N = K & L; O = f[(f[i >> 2] | 0) + (N << 2) >> 2] | 0; if ((O | 0) != 0 ? (P = f[O >> 2] | 0, (P | 0) != 0) : 0) { if (M) { M = P; while (1) { O = f[M + 4 >> 2] | 0; if (!((O | 0) == (K | 0) | (O & L | 0) == (N | 0))) { Q = N; R = 31; break a } O = M + 8 | 0; if ((((d[O >> 1] | 0) == A << 16 >> 16 ? (d[O + 2 >> 1] | 0) == F << 16 >> 16 : 0) ? (d[M + 12 >> 1] | 0) == G << 16 >> 16 : 0) ? (d[O + 6 >> 1] | 0) == J << 16 >> 16 : 0) break a; M = f[M >> 2] | 0; if (!M) { Q = N; R = 31; break a } } } else S = P; while (1) { M = f[S + 4 >> 2] | 0; if ((M | 0) != (K | 0)) { if (M >>> 0 < H >>> 0) T = M; else T = (M >>> 0) % (H >>> 0) | 0; if ((T | 0) != (N | 0)) { Q = N; R = 31; break a } } M = S + 8 | 0; if ((((d[M >> 1] | 0) == A << 16 >> 16 ? (d[M + 2 >> 1] | 0) == F << 16 >> 16 : 0) ? (d[S + 12 >> 1] | 0) == G << 16 >> 16 : 0) ? (d[M + 6 >> 1] | 0) == J << 16 >> 16 : 0) break a; S = f[S >> 2] | 0; if (!S) { Q = N; R = 31; break } } } else { Q = N; R = 31 } } else { Q = 0; R = 31 } while (0); if ((R | 0) == 31) { R = 0; J = dn(20) | 0; G = J + 8 | 0; F = G; d[F >> 1] = B; d[F + 2 >> 1] = B >>> 16; F = G + 4 | 0; d[F >> 1] = D; d[F + 2 >> 1] = D >>> 16; f[J + 16 >> 2] = z; f[J + 4 >> 2] = K; f[J >> 2] = 0; U = $(((f[p >> 2] | 0) + 1 | 0) >>> 0); V = $(H >>> 0); X = $(n[m >> 2]); do if (E | $(X * V) < U) { F = H << 1 | (H >>> 0 < 3 | (H + -1 & H | 0) != 0) & 1; G = ~~$(W($(U / X))) >>> 0; Ch(i, F >>> 0 < G >>> 0 ? G : F); F = f[s >> 2] | 0; G = F + -1 | 0; if (!(G & F)) { Y = F; Z = G & K; break } if (K >>> 0 < F >>> 0) { Y = F; Z = K } else { Y = F; Z = (K >>> 0) % (F >>> 0) | 0 } } else { Y = H; Z = Q } while (0); H = (f[i >> 2] | 0) + (Z << 2) | 0; K = f[H >> 2] | 0; if (!K) { f[J >> 2] = f[v >> 2]; f[v >> 2] = J; f[H >> 2] = v; H = f[J >> 2] | 0; if (H | 0) { E = f[H + 4 >> 2] | 0; H = Y + -1 | 0; if (H & Y) if (E >>> 0 < Y >>> 0) _ = E; else _ = (E >>> 0) % (Y >>> 0) | 0; else _ = E & H; aa = (f[i >> 2] | 0) + (_ << 2) | 0; R = 44 } } else { f[J >> 2] = f[K >> 2]; aa = K; R = 44 } if ((R | 0) == 44) { R = 0; f[aa >> 2] = J } f[p >> 2] = (f[p >> 2] | 0) + 1 } K = w; H = f[K >> 2] | 0; E = on(H | 0, f[K + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + E | 0, j | 0, H | 0) | 0; H = f[l >> 2] | 0; f[H + (y << 2) >> 2] = z; ba = z + 1 | 0; ca = H } else { H = f[l >> 2] | 0; f[H + (y << 2) >> 2] = f[C + 16 >> 2]; ba = z; ca = H } y = y + 1 | 0; da = f[o >> 2] | 0; if (y >>> 0 >= da >>> 0) break; else z = ba } if ((ba | 0) == (da | 0)) ea = ca; else { z = a + 84 | 0; if (!(b[z >> 0] | 0)) { y = f[a + 72 >> 2] | 0; j = f[a + 68 >> 2] | 0; x = j; if ((y | 0) == (j | 0)) fa = ca; else { w = y - j >> 2; j = 0; do { y = x + (j << 2) | 0; f[y >> 2] = f[ca + (f[y >> 2] << 2) >> 2]; j = j + 1 | 0 } while (j >>> 0 < w >>> 0); fa = ca } } else { b[z >> 0] = 0; z = a + 68 | 0; ca = a + 72 | 0; w = f[ca >> 2] | 0; j = f[z >> 2] | 0; x = w - j >> 2; y = j; j = w; if (da >>> 0 <= x >>> 0) if (da >>> 0 < x >>> 0 ? (w = y + (da << 2) | 0, (w | 0) != (j | 0)) : 0) { f[ca >> 2] = j + (~((j + -4 - w | 0) >>> 2) << 2); ga = da } else ga = da; else { kh(z, da - x | 0, 1204); ga = f[o >> 2] | 0 } x = f[l >> 2] | 0; if (!ga) fa = x; else { l = f[a + 68 >> 2] | 0; a = 0; do { f[l + (a << 2) >> 2] = f[x + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ga >>> 0); fa = x } } f[o >> 2] = ba; ea = fa } if (!ea) ha = ba; else { fa = f[q >> 2] | 0; if ((fa | 0) != (ea | 0)) f[q >> 2] = fa + (~((fa + -4 - ea | 0) >>> 2) << 2); br(ea); ha = ba } } else ha = 0; ba = f[i + 8 >> 2] | 0; if (ba | 0) { ea = ba; do { ba = ea; ea = f[ea >> 2] | 0; br(ba) } while ((ea | 0) != 0) } ea = f[i >> 2] | 0; f[i >> 2] = 0; if (!ea) { u = g; return ha | 0 } br(ea); u = g; return ha | 0 } function hc(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0; c = u; u = u + 16 | 0; d = c + 8 | 0; e = c; g = c + 4 | 0; h = a + 16 | 0; i = f[h >> 2] | 0; j = a + 20 | 0; k = f[j >> 2] | 0; if ((k | 0) == (i | 0)) l = i; else { m = k + (~((k + -4 - i | 0) >>> 2) << 2) | 0; f[j >> 2] = m; l = m } m = a + 24 | 0; if ((l | 0) == (f[m >> 2] | 0)) { Ci(h, b); n = f[h >> 2] | 0; o = f[j >> 2] | 0 } else { f[l >> 2] = f[b >> 2]; k = l + 4 | 0; f[j >> 2] = k; n = i; o = k } k = f[a + 8 >> 2] | 0; i = (f[k + 100 >> 2] | 0) - (f[k + 96 >> 2] | 0) | 0; k = (i | 0) / 12 | 0; if ((n | 0) == (o | 0)) { u = c; return 1 } n = a + 28 | 0; l = (i | 0) > 0; i = a + 164 | 0; p = a + 12 | 0; q = a + 76 | 0; r = a + 80 | 0; s = a + 72 | 0; t = a + 152 | 0; v = a + 84 | 0; w = a + 272 | 0; x = a + 276 | 0; y = a + 268 | 0; z = a + 168 | 0; A = a + 140 | 0; B = a + 120 | 0; C = o; do { o = f[C + -4 >> 2] | 0; f[b >> 2] = o; a: do if ((o | 0) != -1 ? (D = (o >>> 0) / 3 | 0, E = f[n >> 2] | 0, (f[E + (D >>> 5 << 2) >> 2] & 1 << (D & 31) | 0) == 0) : 0) { if (l) { D = 0; F = E; b: while (1) { E = D + 1 | 0; f[i >> 2] = (f[i >> 2] | 0) + 1; G = f[b >> 2] | 0; H = (G | 0) == -1 ? -1 : (G >>> 0) / 3 | 0; G = F + (H >>> 5 << 2) | 0; f[G >> 2] = 1 << (H & 31) | f[G >> 2]; G = f[q >> 2] | 0; if ((G | 0) == (f[r >> 2] | 0)) Ci(s, b); else { f[G >> 2] = f[b >> 2]; f[q >> 2] = G + 4 } G = f[b >> 2] | 0; if ((G | 0) == -1) I = -1; else I = f[(f[f[p >> 2] >> 2] | 0) + (G << 2) >> 2] | 0; J = (f[(f[t >> 2] | 0) + (I << 2) >> 2] | 0) != -1; K = (f[v >> 2] | 0) + (I >>> 5 << 2) | 0; L = 1 << (I & 31); M = f[K >> 2] | 0; do if (!(M & L)) { f[K >> 2] = M | L; if (J) { N = f[b >> 2] | 0; O = 30; break } f[d >> 2] = 0; P = f[w >> 2] | 0; if ((P | 0) == (f[x >> 2] | 0)) Ci(y, d); else { f[P >> 2] = 0; f[w >> 2] = P + 4 } P = f[b >> 2] | 0; Q = P + 1 | 0; if ((P | 0) != -1 ? (R = ((Q >>> 0) % 3 | 0 | 0) == 0 ? P + -2 | 0 : Q, (R | 0) != -1) : 0) S = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (R << 2) >> 2] | 0; else S = -1; f[b >> 2] = S } else { N = G; O = 30 } while (0); if ((O | 0) == 30) { O = 0; G = N + 1 | 0; if ((N | 0) == -1) { O = 35; break } L = ((G >>> 0) % 3 | 0 | 0) == 0 ? N + -2 | 0 : G; if ((L | 0) == -1) T = -1; else T = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (L << 2) >> 2] | 0; f[e >> 2] = T; L = (((N >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + N | 0; if ((L | 0) == -1) U = -1; else U = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (L << 2) >> 2] | 0; L = (T | 0) == -1; M = L ? -1 : (T >>> 0) / 3 | 0; V = (U | 0) == -1; W = V ? -1 : (U >>> 0) / 3 | 0; K = ((G >>> 0) % 3 | 0 | 0) == 0 ? N + -2 | 0 : G; if (((K | 0) != -1 ? (G = f[(f[p >> 2] | 0) + 12 >> 2] | 0, R = f[G + (K << 2) >> 2] | 0, (R | 0) != -1) : 0) ? (K = (R >>> 0) / 3 | 0, R = f[n >> 2] | 0, (f[R + (K >>> 5 << 2) >> 2] & 1 << (K & 31) | 0) == 0) : 0) { K = (((N >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + N | 0; do if ((K | 0) != -1) { Q = f[G + (K << 2) >> 2] | 0; if ((Q | 0) == -1) break; P = (Q >>> 0) / 3 | 0; if (!(f[R + (P >>> 5 << 2) >> 2] & 1 << (P & 31))) { O = 63; break b } } while (0); if (!V) jf(a, f[i >> 2] | 0, H, 0, W); f[d >> 2] = 3; R = f[w >> 2] | 0; if ((R | 0) == (f[x >> 2] | 0)) Ci(y, d); else { f[R >> 2] = 3; f[w >> 2] = R + 4 } X = f[e >> 2] | 0 } else { if (!L) { jf(a, f[i >> 2] | 0, H, 1, M); R = f[b >> 2] | 0; if ((R | 0) == -1) { O = 44; break } else Y = R } else Y = N; R = (((Y >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + Y | 0; if ((R | 0) == -1) { O = 44; break } K = f[(f[(f[p >> 2] | 0) + 12 >> 2] | 0) + (R << 2) >> 2] | 0; if ((K | 0) == -1) { O = 44; break } R = (K >>> 0) / 3 | 0; if (f[(f[n >> 2] | 0) + (R >>> 5 << 2) >> 2] & 1 << (R & 31) | 0) { O = 44; break } f[d >> 2] = 5; R = f[w >> 2] | 0; if ((R | 0) == (f[x >> 2] | 0)) Ci(y, d); else { f[R >> 2] = 5; f[w >> 2] = R + 4 } X = U } f[b >> 2] = X } if ((E | 0) >= (k | 0)) break a; D = E; F = f[n >> 2] | 0 } do if ((O | 0) == 35) { O = 0; f[e >> 2] = -1; O = 46 } else if ((O | 0) == 44) { O = 0; if (V) O = 46; else { jf(a, f[i >> 2] | 0, H, 0, W); O = 46 } } else if ((O | 0) == 63) { O = 0; f[d >> 2] = 1; F = f[w >> 2] | 0; if ((F | 0) == (f[x >> 2] | 0)) Ci(y, d); else { f[F >> 2] = 1; f[w >> 2] = F + 4 } f[z >> 2] = (f[z >> 2] | 0) + 1; if (J ? (F = f[(f[t >> 2] | 0) + (I << 2) >> 2] | 0, (1 << (F & 31) & f[(f[A >> 2] | 0) + (F >>> 5 << 2) >> 2] | 0) == 0) : 0) { f[g >> 2] = f[b >> 2]; f[d >> 2] = f[g >> 2]; Ce(a, d, 0) | 0 } F = f[i >> 2] | 0; f[d >> 2] = H; D = Sd(B, d) | 0; f[D >> 2] = F; F = f[j >> 2] | 0; f[F + -4 >> 2] = U; if ((F | 0) == (f[m >> 2] | 0)) { Ci(h, e); break } else { f[F >> 2] = f[e >> 2]; f[j >> 2] = F + 4; break } } while (0); if ((O | 0) == 46) { O = 0; f[d >> 2] = 7; F = f[w >> 2] | 0; if ((F | 0) == (f[x >> 2] | 0)) Ci(y, d); else { f[F >> 2] = 7; f[w >> 2] = F + 4 } f[j >> 2] = (f[j >> 2] | 0) + -4 } } } else O = 11; while (0); if ((O | 0) == 11) { O = 0; f[j >> 2] = C + -4 } C = f[j >> 2] | 0 } while ((f[h >> 2] | 0) != (C | 0)); u = c; return 1 } function ic(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = Oa, V = Oa, X = Oa, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0; e = u; u = u + 48 | 0; g = e + 20 | 0; i = e + 16 | 0; j = e + 12 | 0; k = e; l = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[l >> 2] = $(1.0); m = a + 80 | 0; o = f[m >> 2] | 0; f[k >> 2] = 0; p = k + 4 | 0; f[p >> 2] = 0; f[k + 8 >> 2] = 0; if (o) { if (o >>> 0 > 1073741823) mq(k); q = o << 2; r = dn(q) | 0; f[k >> 2] = r; s = r + (o << 2) | 0; f[k + 8 >> 2] = s; hj(r | 0, 0, q | 0) | 0; f[p >> 2] = s; s = f[d >> 2] | 0; d = c + 48 | 0; q = c + 40 | 0; r = g + 4 | 0; o = g + 12 | 0; t = g + 8 | 0; v = a + 40 | 0; w = a + 64 | 0; x = 0; y = 0; while (1) { z = d; A = f[z >> 2] | 0; B = f[z + 4 >> 2] | 0; z = q; C = on(f[z >> 2] | 0, f[z + 4 >> 2] | 0, s + x | 0, 0) | 0; z = Tn(C | 0, I | 0, A | 0, B | 0) | 0; B = (f[f[c >> 2] >> 2] | 0) + z | 0; z = h[B >> 0] | h[B + 1 >> 0] << 8 | h[B + 2 >> 0] << 16 | h[B + 3 >> 0] << 24; f[i >> 2] = z; f[j >> 2] = z; z = pf(g, j) | 0; if (!z) { B = f[j >> 2] | 0; A = B & 255; C = B >>> 8; D = C & 255; E = B >>> 16; F = E & 255; G = B >>> 24; H = G & 255; J = C & 255; C = E & 255; E = (((B & 255 ^ 318) + 239 ^ J) + 239 ^ C) + 239 ^ G; G = f[r >> 2] | 0; K = (G | 0) == 0; a: do if (!K) { L = G + -1 | 0; M = (L & G | 0) == 0; if (!M) if (E >>> 0 < G >>> 0) N = E; else N = (E >>> 0) % (G >>> 0) | 0; else N = E & L; O = f[(f[g >> 2] | 0) + (N << 2) >> 2] | 0; if ((O | 0) != 0 ? (P = f[O >> 2] | 0, (P | 0) != 0) : 0) { if (M) { M = P; while (1) { O = f[M + 4 >> 2] | 0; if (!((O | 0) == (E | 0) | (O & L | 0) == (N | 0))) { Q = N; R = 31; break a } O = M + 8 | 0; if ((((b[O >> 0] | 0) == A << 24 >> 24 ? (b[O + 1 >> 0] | 0) == D << 24 >> 24 : 0) ? (b[O + 2 >> 0] | 0) == F << 24 >> 24 : 0) ? (b[O + 3 >> 0] | 0) == H << 24 >> 24 : 0) break a; M = f[M >> 2] | 0; if (!M) { Q = N; R = 31; break a } } } else S = P; while (1) { M = f[S + 4 >> 2] | 0; if ((M | 0) != (E | 0)) { if (M >>> 0 < G >>> 0) T = M; else T = (M >>> 0) % (G >>> 0) | 0; if ((T | 0) != (N | 0)) { Q = N; R = 31; break a } } M = S + 8 | 0; if ((((b[M >> 0] | 0) == A << 24 >> 24 ? (b[M + 1 >> 0] | 0) == D << 24 >> 24 : 0) ? (b[M + 2 >> 0] | 0) == F << 24 >> 24 : 0) ? (b[M + 3 >> 0] | 0) == H << 24 >> 24 : 0) break a; S = f[S >> 2] | 0; if (!S) { Q = N; R = 31; break } } } else { Q = N; R = 31 } } else { Q = 0; R = 31 } while (0); if ((R | 0) == 31) { R = 0; H = dn(16) | 0; F = H + 8 | 0; D = B & -16776961 | C << 16 | J << 8; b[F >> 0] = D; b[F + 1 >> 0] = D >> 8; b[F + 2 >> 0] = D >> 16; b[F + 3 >> 0] = D >> 24; f[H + 12 >> 2] = y; f[H + 4 >> 2] = E; f[H >> 2] = 0; U = $(((f[o >> 2] | 0) + 1 | 0) >>> 0); V = $(G >>> 0); X = $(n[l >> 2]); do if (K | $(X * V) < U) { D = G << 1 | (G >>> 0 < 3 | (G + -1 & G | 0) != 0) & 1; F = ~~$(W($(U / X))) >>> 0; Jh(g, D >>> 0 < F >>> 0 ? F : D); D = f[r >> 2] | 0; F = D + -1 | 0; if (!(F & D)) { Y = D; Z = F & E; break } if (E >>> 0 < D >>> 0) { Y = D; Z = E } else { Y = D; Z = (E >>> 0) % (D >>> 0) | 0 } } else { Y = G; Z = Q } while (0); G = (f[g >> 2] | 0) + (Z << 2) | 0; E = f[G >> 2] | 0; if (!E) { f[H >> 2] = f[t >> 2]; f[t >> 2] = H; f[G >> 2] = t; G = f[H >> 2] | 0; if (G | 0) { K = f[G + 4 >> 2] | 0; G = Y + -1 | 0; if (G & Y) if (K >>> 0 < Y >>> 0) _ = K; else _ = (K >>> 0) % (Y >>> 0) | 0; else _ = K & G; aa = (f[g >> 2] | 0) + (_ << 2) | 0; R = 44 } } else { f[H >> 2] = f[E >> 2]; aa = E; R = 44 } if ((R | 0) == 44) { R = 0; f[aa >> 2] = H } f[o >> 2] = (f[o >> 2] | 0) + 1 } E = v; G = f[E >> 2] | 0; K = on(G | 0, f[E + 4 >> 2] | 0, y | 0, 0) | 0; Rg((f[f[w >> 2] >> 2] | 0) + K | 0, i | 0, G | 0) | 0; G = f[k >> 2] | 0; f[G + (x << 2) >> 2] = y; ba = y + 1 | 0; ca = G } else { G = f[k >> 2] | 0; f[G + (x << 2) >> 2] = f[z + 12 >> 2]; ba = y; ca = G } x = x + 1 | 0; da = f[m >> 2] | 0; if (x >>> 0 >= da >>> 0) break; else y = ba } if ((ba | 0) == (da | 0)) ea = ca; else { y = a + 84 | 0; if (!(b[y >> 0] | 0)) { x = f[a + 72 >> 2] | 0; i = f[a + 68 >> 2] | 0; w = i; if ((x | 0) == (i | 0)) fa = ca; else { v = x - i >> 2; i = 0; do { x = w + (i << 2) | 0; f[x >> 2] = f[ca + (f[x >> 2] << 2) >> 2]; i = i + 1 | 0 } while (i >>> 0 < v >>> 0); fa = ca } } else { b[y >> 0] = 0; y = a + 68 | 0; ca = a + 72 | 0; v = f[ca >> 2] | 0; i = f[y >> 2] | 0; w = v - i >> 2; x = i; i = v; if (da >>> 0 <= w >>> 0) if (da >>> 0 < w >>> 0 ? (v = x + (da << 2) | 0, (v | 0) != (i | 0)) : 0) { f[ca >> 2] = i + (~((i + -4 - v | 0) >>> 2) << 2); ga = da } else ga = da; else { kh(y, da - w | 0, 1204); ga = f[m >> 2] | 0 } w = f[k >> 2] | 0; if (!ga) fa = w; else { k = f[a + 68 >> 2] | 0; a = 0; do { f[k + (a << 2) >> 2] = f[w + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ga >>> 0); fa = w } } f[m >> 2] = ba; ea = fa } if (!ea) ha = ba; else { fa = f[p >> 2] | 0; if ((fa | 0) != (ea | 0)) f[p >> 2] = fa + (~((fa + -4 - ea | 0) >>> 2) << 2); br(ea); ha = ba } } else ha = 0; ba = f[g + 8 >> 2] | 0; if (ba | 0) { ea = ba; do { ba = ea; ea = f[ea >> 2] | 0; br(ba) } while ((ea | 0) != 0) } ea = f[g >> 2] | 0; f[g >> 2] = 0; if (!ea) { u = e; return ha | 0 } br(ea); u = e; return ha | 0 } function jc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = Oa, V = Oa, X = Oa, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0; e = u; u = u + 80 | 0; g = e + 48 | 0; h = e + 32 | 0; i = e + 16 | 0; j = e; k = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[k >> 2] = $(1.0); l = a + 80 | 0; m = f[l >> 2] | 0; f[j >> 2] = 0; o = j + 4 | 0; f[o >> 2] = 0; f[j + 8 >> 2] = 0; if (m) { if (m >>> 0 > 1073741823) mq(j); p = m << 2; q = dn(p) | 0; f[j >> 2] = q; r = q + (m << 2) | 0; f[j + 8 >> 2] = r; hj(q | 0, 0, p | 0) | 0; f[o >> 2] = r; r = f[d >> 2] | 0; d = c + 48 | 0; p = c + 40 | 0; q = i + 4 | 0; m = i + 8 | 0; s = i + 12 | 0; t = g + 4 | 0; v = g + 12 | 0; w = g + 8 | 0; x = a + 40 | 0; y = a + 64 | 0; z = 0; A = 0; while (1) { B = d; C = f[B >> 2] | 0; D = f[B + 4 >> 2] | 0; B = p; E = on(f[B >> 2] | 0, f[B + 4 >> 2] | 0, r + A | 0, 0) | 0; B = Tn(E | 0, I | 0, C | 0, D | 0) | 0; D = (f[f[c >> 2] >> 2] | 0) + B | 0; B = h; C = D; E = B + 16 | 0; do { b[B >> 0] = b[C >> 0] | 0; B = B + 1 | 0; C = C + 1 | 0 } while ((B | 0) < (E | 0)); Xl(i | 0, D | 0, 16) | 0; C = Ff(g, i) | 0; if (!C) { B = f[i >> 2] | 0; E = f[q >> 2] | 0; F = f[m >> 2] | 0; G = f[s >> 2] | 0; H = (((B ^ 318) + 239 ^ E) + 239 ^ F) + 239 ^ G; J = f[t >> 2] | 0; K = (J | 0) == 0; a: do if (!K) { L = J + -1 | 0; M = (L & J | 0) == 0; if (!M) if (H >>> 0 < J >>> 0) N = H; else N = (H >>> 0) % (J >>> 0) | 0; else N = H & L; O = f[(f[g >> 2] | 0) + (N << 2) >> 2] | 0; if ((O | 0) != 0 ? (P = f[O >> 2] | 0, (P | 0) != 0) : 0) { if (M) { M = P; while (1) { O = f[M + 4 >> 2] | 0; if (!((O | 0) == (H | 0) | (O & L | 0) == (N | 0))) { Q = N; R = 31; break a } if ((((f[M + 8 >> 2] | 0) == (B | 0) ? (f[M + 12 >> 2] | 0) == (E | 0) : 0) ? (f[M + 16 >> 2] | 0) == (F | 0) : 0) ? (f[M + 20 >> 2] | 0) == (G | 0) : 0) break a; M = f[M >> 2] | 0; if (!M) { Q = N; R = 31; break a } } } else S = P; while (1) { M = f[S + 4 >> 2] | 0; if ((M | 0) != (H | 0)) { if (M >>> 0 < J >>> 0) T = M; else T = (M >>> 0) % (J >>> 0) | 0; if ((T | 0) != (N | 0)) { Q = N; R = 31; break a } } if ((((f[S + 8 >> 2] | 0) == (B | 0) ? (f[S + 12 >> 2] | 0) == (E | 0) : 0) ? (f[S + 16 >> 2] | 0) == (F | 0) : 0) ? (f[S + 20 >> 2] | 0) == (G | 0) : 0) break a; S = f[S >> 2] | 0; if (!S) { Q = N; R = 31; break } } } else { Q = N; R = 31 } } else { Q = 0; R = 31 } while (0); if ((R | 0) == 31) { R = 0; D = dn(28) | 0; f[D + 8 >> 2] = B; f[D + 12 >> 2] = E; f[D + 16 >> 2] = F; f[D + 20 >> 2] = G; f[D + 24 >> 2] = z; f[D + 4 >> 2] = H; f[D >> 2] = 0; U = $(((f[v >> 2] | 0) + 1 | 0) >>> 0); V = $(J >>> 0); X = $(n[k >> 2]); do if (K | $(X * V) < U) { P = J << 1 | (J >>> 0 < 3 | (J + -1 & J | 0) != 0) & 1; M = ~~$(W($(U / X))) >>> 0; Gh(g, P >>> 0 < M >>> 0 ? M : P); P = f[t >> 2] | 0; M = P + -1 | 0; if (!(M & P)) { Y = P; Z = M & H; break } if (H >>> 0 < P >>> 0) { Y = P; Z = H } else { Y = P; Z = (H >>> 0) % (P >>> 0) | 0 } } else { Y = J; Z = Q } while (0); J = (f[g >> 2] | 0) + (Z << 2) | 0; H = f[J >> 2] | 0; if (!H) { f[D >> 2] = f[w >> 2]; f[w >> 2] = D; f[J >> 2] = w; J = f[D >> 2] | 0; if (J | 0) { K = f[J + 4 >> 2] | 0; J = Y + -1 | 0; if (J & Y) if (K >>> 0 < Y >>> 0) _ = K; else _ = (K >>> 0) % (Y >>> 0) | 0; else _ = K & J; aa = (f[g >> 2] | 0) + (_ << 2) | 0; R = 44 } } else { f[D >> 2] = f[H >> 2]; aa = H; R = 44 } if ((R | 0) == 44) { R = 0; f[aa >> 2] = D } f[v >> 2] = (f[v >> 2] | 0) + 1 } H = x; J = f[H >> 2] | 0; K = on(J | 0, f[H + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[y >> 2] >> 2] | 0) + K | 0, h | 0, J | 0) | 0; J = f[j >> 2] | 0; f[J + (A << 2) >> 2] = z; ba = z + 1 | 0; ca = J } else { J = f[j >> 2] | 0; f[J + (A << 2) >> 2] = f[C + 24 >> 2]; ba = z; ca = J } A = A + 1 | 0; da = f[l >> 2] | 0; if (A >>> 0 >= da >>> 0) break; else z = ba } if ((ba | 0) == (da | 0)) ea = ca; else { z = a + 84 | 0; if (!(b[z >> 0] | 0)) { A = f[a + 72 >> 2] | 0; h = f[a + 68 >> 2] | 0; y = h; if ((A | 0) == (h | 0)) fa = ca; else { x = A - h >> 2; h = 0; do { A = y + (h << 2) | 0; f[A >> 2] = f[ca + (f[A >> 2] << 2) >> 2]; h = h + 1 | 0 } while (h >>> 0 < x >>> 0); fa = ca } } else { b[z >> 0] = 0; z = a + 68 | 0; ca = a + 72 | 0; x = f[ca >> 2] | 0; h = f[z >> 2] | 0; y = x - h >> 2; A = h; h = x; if (da >>> 0 <= y >>> 0) if (da >>> 0 < y >>> 0 ? (x = A + (da << 2) | 0, (x | 0) != (h | 0)) : 0) { f[ca >> 2] = h + (~((h + -4 - x | 0) >>> 2) << 2); ga = da } else ga = da; else { kh(z, da - y | 0, 1204); ga = f[l >> 2] | 0 } y = f[j >> 2] | 0; if (!ga) fa = y; else { j = f[a + 68 >> 2] | 0; a = 0; do { f[j + (a << 2) >> 2] = f[y + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ga >>> 0); fa = y } } f[l >> 2] = ba; ea = fa } if (!ea) ha = ba; else { fa = f[o >> 2] | 0; if ((fa | 0) != (ea | 0)) f[o >> 2] = fa + (~((fa + -4 - ea | 0) >>> 2) << 2); br(ea); ha = ba } } else ha = 0; ba = f[g + 8 >> 2] | 0; if (ba | 0) { ea = ba; do { ba = ea; ea = f[ea >> 2] | 0; br(ba) } while ((ea | 0) != 0) } ea = f[g >> 2] | 0; f[g >> 2] = 0; if (!ea) { u = e; return ha | 0 } br(ea); u = e; return ha | 0 } function kc(a, c, e) { a = a | 0; c = c | 0; e = e | 0; var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = Oa, T = Oa, U = Oa, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0; g = u; u = u + 48 | 0; h = g + 12 | 0; i = g + 38 | 0; j = g + 32 | 0; k = g; l = h + 16 | 0; f[h >> 2] = 0; f[h + 4 >> 2] = 0; f[h + 8 >> 2] = 0; f[h + 12 >> 2] = 0; n[l >> 2] = $(1.0); m = a + 80 | 0; o = f[m >> 2] | 0; f[k >> 2] = 0; p = k + 4 | 0; f[p >> 2] = 0; f[k + 8 >> 2] = 0; if (o) { if (o >>> 0 > 1073741823) mq(k); q = o << 2; r = dn(q) | 0; f[k >> 2] = r; s = r + (o << 2) | 0; f[k + 8 >> 2] = s; hj(r | 0, 0, q | 0) | 0; f[p >> 2] = s; s = f[e >> 2] | 0; e = c + 48 | 0; q = c + 40 | 0; r = j + 2 | 0; o = j + 4 | 0; t = h + 4 | 0; v = h + 12 | 0; w = h + 8 | 0; x = a + 40 | 0; y = a + 64 | 0; z = 0; A = 0; while (1) { B = e; C = f[B >> 2] | 0; D = f[B + 4 >> 2] | 0; B = q; E = on(f[B >> 2] | 0, f[B + 4 >> 2] | 0, s + A | 0, 0) | 0; B = Tn(E | 0, I | 0, C | 0, D | 0) | 0; D = (f[f[c >> 2] >> 2] | 0) + B | 0; b[i >> 0] = b[D >> 0] | 0; b[i + 1 >> 0] = b[D + 1 >> 0] | 0; b[i + 2 >> 0] = b[D + 2 >> 0] | 0; b[i + 3 >> 0] = b[D + 3 >> 0] | 0; b[i + 4 >> 0] = b[D + 4 >> 0] | 0; b[i + 5 >> 0] = b[D + 5 >> 0] | 0; Xl(j | 0, D | 0, 6) | 0; D = Pf(h, j) | 0; if (!D) { B = d[j >> 1] | 0; C = d[r >> 1] | 0; E = d[o >> 1] | 0; F = (((B ^ 318) & 65535) + 239 ^ C & 65535) + 239 ^ E & 65535; G = f[t >> 2] | 0; H = (G | 0) == 0; a: do if (!H) { J = G + -1 | 0; K = (J & G | 0) == 0; if (!K) if (F >>> 0 < G >>> 0) L = F; else L = (F >>> 0) % (G >>> 0) | 0; else L = F & J; M = f[(f[h >> 2] | 0) + (L << 2) >> 2] | 0; if ((M | 0) != 0 ? (N = f[M >> 2] | 0, (N | 0) != 0) : 0) { if (K) { K = N; while (1) { M = f[K + 4 >> 2] | 0; if (!((M | 0) == (F | 0) | (M & J | 0) == (L | 0))) { O = L; P = 29; break a } M = K + 8 | 0; if (((d[M >> 1] | 0) == B << 16 >> 16 ? (d[M + 2 >> 1] | 0) == C << 16 >> 16 : 0) ? (d[K + 12 >> 1] | 0) == E << 16 >> 16 : 0) break a; K = f[K >> 2] | 0; if (!K) { O = L; P = 29; break a } } } else Q = N; while (1) { K = f[Q + 4 >> 2] | 0; if ((K | 0) != (F | 0)) { if (K >>> 0 < G >>> 0) R = K; else R = (K >>> 0) % (G >>> 0) | 0; if ((R | 0) != (L | 0)) { O = L; P = 29; break a } } K = Q + 8 | 0; if (((d[K >> 1] | 0) == B << 16 >> 16 ? (d[K + 2 >> 1] | 0) == C << 16 >> 16 : 0) ? (d[Q + 12 >> 1] | 0) == E << 16 >> 16 : 0) break a; Q = f[Q >> 2] | 0; if (!Q) { O = L; P = 29; break } } } else { O = L; P = 29 } } else { O = 0; P = 29 } while (0); if ((P | 0) == 29) { P = 0; N = dn(20) | 0; d[N + 8 >> 1] = B; d[N + 10 >> 1] = C; d[N + 12 >> 1] = E; f[N + 16 >> 2] = z; f[N + 4 >> 2] = F; f[N >> 2] = 0; S = $(((f[v >> 2] | 0) + 1 | 0) >>> 0); T = $(G >>> 0); U = $(n[l >> 2]); do if (H | $(U * T) < S) { K = G << 1 | (G >>> 0 < 3 | (G + -1 & G | 0) != 0) & 1; J = ~~$(W($(S / U))) >>> 0; Dh(h, K >>> 0 < J >>> 0 ? J : K); K = f[t >> 2] | 0; J = K + -1 | 0; if (!(J & K)) { V = K; X = J & F; break } if (F >>> 0 < K >>> 0) { V = K; X = F } else { V = K; X = (F >>> 0) % (K >>> 0) | 0 } } else { V = G; X = O } while (0); G = (f[h >> 2] | 0) + (X << 2) | 0; F = f[G >> 2] | 0; if (!F) { f[N >> 2] = f[w >> 2]; f[w >> 2] = N; f[G >> 2] = w; G = f[N >> 2] | 0; if (G | 0) { H = f[G + 4 >> 2] | 0; G = V + -1 | 0; if (G & V) if (H >>> 0 < V >>> 0) Y = H; else Y = (H >>> 0) % (V >>> 0) | 0; else Y = H & G; Z = (f[h >> 2] | 0) + (Y << 2) | 0; P = 42 } } else { f[N >> 2] = f[F >> 2]; Z = F; P = 42 } if ((P | 0) == 42) { P = 0; f[Z >> 2] = N } f[v >> 2] = (f[v >> 2] | 0) + 1 } F = x; G = f[F >> 2] | 0; H = on(G | 0, f[F + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[y >> 2] >> 2] | 0) + H | 0, i | 0, G | 0) | 0; G = f[k >> 2] | 0; f[G + (A << 2) >> 2] = z; _ = z + 1 | 0; aa = G } else { G = f[k >> 2] | 0; f[G + (A << 2) >> 2] = f[D + 16 >> 2]; _ = z; aa = G } A = A + 1 | 0; ba = f[m >> 2] | 0; if (A >>> 0 >= ba >>> 0) break; else z = _ } if ((_ | 0) == (ba | 0)) ca = aa; else { z = a + 84 | 0; if (!(b[z >> 0] | 0)) { A = f[a + 72 >> 2] | 0; i = f[a + 68 >> 2] | 0; y = i; if ((A | 0) == (i | 0)) da = aa; else { x = A - i >> 2; i = 0; do { A = y + (i << 2) | 0; f[A >> 2] = f[aa + (f[A >> 2] << 2) >> 2]; i = i + 1 | 0 } while (i >>> 0 < x >>> 0); da = aa } } else { b[z >> 0] = 0; z = a + 68 | 0; aa = a + 72 | 0; x = f[aa >> 2] | 0; i = f[z >> 2] | 0; y = x - i >> 2; A = i; i = x; if (ba >>> 0 <= y >>> 0) if (ba >>> 0 < y >>> 0 ? (x = A + (ba << 2) | 0, (x | 0) != (i | 0)) : 0) { f[aa >> 2] = i + (~((i + -4 - x | 0) >>> 2) << 2); ea = ba } else ea = ba; else { kh(z, ba - y | 0, 1204); ea = f[m >> 2] | 0 } y = f[k >> 2] | 0; if (!ea) da = y; else { k = f[a + 68 >> 2] | 0; a = 0; do { f[k + (a << 2) >> 2] = f[y + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ea >>> 0); da = y } } f[m >> 2] = _; ca = da } if (!ca) fa = _; else { da = f[p >> 2] | 0; if ((da | 0) != (ca | 0)) f[p >> 2] = da + (~((da + -4 - ca | 0) >>> 2) << 2); br(ca); fa = _ } } else fa = 0; _ = f[h + 8 >> 2] | 0; if (_ | 0) { ca = _; do { _ = ca; ca = f[ca >> 2] | 0; br(_) } while ((ca | 0) != 0) } ca = f[h >> 2] | 0; f[h >> 2] = 0; if (!ca) { u = g; return fa | 0 } br(ca); u = g; return fa | 0 } function lc(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0; d = u; u = u + 80 | 0; e = d + 72 | 0; g = d + 64 | 0; h = d; i = d + 68 | 0; j = d + 60 | 0; k = a + 352 | 0; if (b[k >> 0] | 0 ? (l = Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0, ((f[l + 12 >> 2] | 0) - (f[l + 8 >> 2] | 0) | 0) > 0) : 0) { l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 8 | 0; m = f[f[l >> 2] >> 2] | 0; f[e >> 2] = c; l = m + 4 | 0; n = m + 8 | 0; o = f[n >> 2] | 0; if ((o | 0) == (f[m + 12 >> 2] | 0)) Ci(l, e); else { f[o >> 2] = c; f[n >> 2] = o + 4 } o = f[e >> 2] | 0; p = m + 16 | 0; q = m + 20 | 0; m = f[q >> 2] | 0; r = f[p >> 2] | 0; s = m - r >> 2; t = r; if ((o | 0) < (s | 0)) { v = t; w = o } else { r = o + 1 | 0; f[g >> 2] = -1; x = m; if (r >>> 0 <= s >>> 0) if (r >>> 0 < s >>> 0 ? (m = t + (r << 2) | 0, (m | 0) != (x | 0)) : 0) { f[q >> 2] = x + (~((x + -4 - m | 0) >>> 2) << 2); y = o; z = t } else { y = o; z = t } else { kh(p, r - s | 0, g); y = f[e >> 2] | 0; z = f[p >> 2] | 0 } v = z; w = y } f[v + (w << 2) >> 2] = ((f[n >> 2] | 0) - (f[l >> 2] | 0) >> 2) + -1; A = 1; u = d; return A | 0 } l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 56 | 0; n = f[(f[(f[l >> 2] | 0) + 84 >> 2] | 0) + (c << 2) >> 2] | 0; l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 4 | 0; w = f[(f[(f[l >> 2] | 0) + 8 >> 2] | 0) + (c << 2) >> 2] | 0; f[g >> 2] = -1; l = a + 172 | 0; v = f[a + 176 >> 2] | 0; y = f[l >> 2] | 0; z = y; a: do if ((v | 0) == (y | 0)) B = -1; else { p = (v - y | 0) / 136 | 0; s = 0; while (1) { if ((f[z + (s * 136 | 0) >> 2] | 0) == (c | 0)) break; r = s + 1 | 0; if (r >>> 0 < p >>> 0) s = r; else { B = -1; break a } } f[g >> 2] = s; B = s } while (0); b: do if (!(b[k >> 0] | 0)) { y = (f[w + 56 >> 2] | 0) == 0; do if (!((n | 0) == 0 | y)) { if ((n | 0) == 1 ? b[z + (B * 136 | 0) + 28 >> 0] | 0 : 0) break; v = z + (B * 136 | 0) + 104 | 0; p = z + (B * 136 | 0) + 4 | 0; r = (f[z + (B * 136 | 0) + 60 >> 2] | 0) - (f[z + (B * 136 | 0) + 56 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(z + (B * 136 | 0) + 116 | 0, r, e); r = dn(80) | 0; t = f[a + 8 >> 2] | 0; f[r + 4 >> 2] = 0; f[r >> 2] = 3164; o = r + 8 | 0; m = r + 12 | 0; x = m + 44 | 0; do { f[m >> 2] = 0; m = m + 4 | 0 } while ((m | 0) < (x | 0)); f[o >> 2] = 3188; q = r + 56 | 0; f[q >> 2] = 0; f[r + 60 >> 2] = 0; f[r + 64 >> 2] = 0; f[r + 68 >> 2] = t; f[r + 72 >> 2] = v; C = r + 76 | 0; f[C >> 2] = 0; D = h + 4 | 0; m = D + 4 | 0; x = m + 40 | 0; do { f[m >> 2] = 0; m = m + 4 | 0 } while ((m | 0) < (x | 0)); f[h >> 2] = 3188; m = h + 48 | 0; f[m >> 2] = 0; x = h + 52 | 0; f[x >> 2] = 0; f[h + 56 >> 2] = 0; f[D >> 2] = p; E = f[z + (B * 136 | 0) + 68 >> 2] | 0; F = ((f[E + 4 >> 2] | 0) - (f[E >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[e >> 0] = 0; Xg(h + 24 | 0, F, e); F = f[D >> 2] | 0; E = (f[F + 56 >> 2] | 0) - (f[F + 52 >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(h + 36 | 0, E, e); f[h + 8 >> 2] = p; f[h + 12 >> 2] = v; f[h + 16 >> 2] = t; f[h + 20 >> 2] = r; f[C >> 2] = a + 72; ef(o, h) | 0; Yf(q, f[m >> 2] | 0, f[x >> 2] | 0); E = r; f[h >> 2] = 3188; F = f[m >> 2] | 0; if (F | 0) { m = f[x >> 2] | 0; if ((m | 0) != (F | 0)) f[x >> 2] = m + (~((m + -4 - F | 0) >>> 2) << 2); br(F) } f[h >> 2] = 3208; F = f[h + 36 >> 2] | 0; if (F | 0) br(F); F = f[h + 24 >> 2] | 0; if (F | 0) br(F); G = 0; H = E; I = 42; break b } while (0); if (!y) { s = f[a + 12 >> 2] | 0; E = (f[s + 28 >> 2] | 0) - (f[s + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(z + (B * 136 | 0) + 116 | 0, E, e); b[(f[l >> 2] | 0) + ((f[g >> 2] | 0) * 136 | 0) + 100 >> 0] = 0; J = z + (B * 136 | 0) + 104 | 0; I = 26 } else I = 24 } else I = 24; while (0); if ((I | 0) == 24) { J = a + 40 | 0; I = 26 } if ((I | 0) == 26) { B = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 48 | 0; do if ((Yh(f[B >> 2] | 0) | 0) == 0 ? (f[w + 56 >> 2] | 0) == 0 : 0) { if (b[k >> 0] | 0 ? (z = f[a + 8 >> 2] | 0, ((f[z + 12 >> 2] | 0) - (f[z + 8 >> 2] | 0) | 0) >= 5) : 0) { I = 31; break } uf(e, a, J); K = 1; L = f[e >> 2] | 0 } else I = 31; while (0); if ((I | 0) == 31) { Le(e, a, J); K = 0; L = f[e >> 2] | 0 } if (!L) M = 0; else { G = K; H = L; I = 42 } } if ((I | 0) == 42) { I = f[g >> 2] | 0; if ((I | 0) == -1) N = a + 68 | 0; else N = (f[l >> 2] | 0) + (I * 136 | 0) + 132 | 0; f[N >> 2] = G; G = dn(76) | 0; f[i >> 2] = H; ml(G, i, c); c = G; G = f[i >> 2] | 0; f[i >> 2] = 0; if (G | 0) Va[f[(f[G >> 2] | 0) + 4 >> 2] & 127](G); G = a + 188 | 0; i = f[G >> 2] | 0; if ((i | 0) == (f[a + 192 >> 2] | 0)) Ci(a + 184 | 0, g); else { f[i >> 2] = f[g >> 2]; f[G >> 2] = i + 4 } i = Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0; f[j >> 2] = c; a = i + 12 | 0; G = f[a >> 2] | 0; if (G >>> 0 < (f[i + 16 >> 2] | 0) >>> 0) { f[j >> 2] = 0; f[G >> 2] = c; f[a >> 2] = G + 4; O = j } else { yg(i + 8 | 0, j); O = j } j = f[O >> 2] | 0; f[O >> 2] = 0; if (!j) M = 1; else { Va[f[(f[j >> 2] | 0) + 4 >> 2] & 127](j); M = 1 } } A = M; u = d; return A | 0 } function mc(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0; d = u; u = u + 80 | 0; e = d + 72 | 0; g = d + 64 | 0; h = d; i = d + 68 | 0; j = d + 60 | 0; k = a + 288 | 0; if (b[k >> 0] | 0 ? (l = Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0, ((f[l + 12 >> 2] | 0) - (f[l + 8 >> 2] | 0) | 0) > 0) : 0) { l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 8 | 0; m = f[f[l >> 2] >> 2] | 0; f[e >> 2] = c; l = m + 4 | 0; n = m + 8 | 0; o = f[n >> 2] | 0; if ((o | 0) == (f[m + 12 >> 2] | 0)) Ci(l, e); else { f[o >> 2] = c; f[n >> 2] = o + 4 } o = f[e >> 2] | 0; p = m + 16 | 0; q = m + 20 | 0; m = f[q >> 2] | 0; r = f[p >> 2] | 0; s = m - r >> 2; t = r; if ((o | 0) < (s | 0)) { v = t; w = o } else { r = o + 1 | 0; f[g >> 2] = -1; x = m; if (r >>> 0 <= s >>> 0) if (r >>> 0 < s >>> 0 ? (m = t + (r << 2) | 0, (m | 0) != (x | 0)) : 0) { f[q >> 2] = x + (~((x + -4 - m | 0) >>> 2) << 2); y = o; z = t } else { y = o; z = t } else { kh(p, r - s | 0, g); y = f[e >> 2] | 0; z = f[p >> 2] | 0 } v = z; w = y } f[v + (w << 2) >> 2] = ((f[n >> 2] | 0) - (f[l >> 2] | 0) >> 2) + -1; A = 1; u = d; return A | 0 } l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 56 | 0; n = f[(f[(f[l >> 2] | 0) + 84 >> 2] | 0) + (c << 2) >> 2] | 0; l = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 4 | 0; w = f[(f[(f[l >> 2] | 0) + 8 >> 2] | 0) + (c << 2) >> 2] | 0; f[g >> 2] = -1; l = a + 172 | 0; v = f[a + 176 >> 2] | 0; y = f[l >> 2] | 0; z = y; a: do if ((v | 0) == (y | 0)) B = -1; else { p = (v - y | 0) / 136 | 0; s = 0; while (1) { if ((f[z + (s * 136 | 0) >> 2] | 0) == (c | 0)) break; r = s + 1 | 0; if (r >>> 0 < p >>> 0) s = r; else { B = -1; break a } } f[g >> 2] = s; B = s } while (0); b: do if (!(b[k >> 0] | 0)) { y = (f[w + 56 >> 2] | 0) == 0; do if (!((n | 0) == 0 | y)) { if ((n | 0) == 1 ? b[z + (B * 136 | 0) + 28 >> 0] | 0 : 0) break; v = z + (B * 136 | 0) + 104 | 0; p = z + (B * 136 | 0) + 4 | 0; r = (f[z + (B * 136 | 0) + 60 >> 2] | 0) - (f[z + (B * 136 | 0) + 56 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(z + (B * 136 | 0) + 116 | 0, r, e); r = dn(80) | 0; t = f[a + 8 >> 2] | 0; f[r + 4 >> 2] = 0; f[r >> 2] = 3164; o = r + 8 | 0; m = r + 12 | 0; x = m + 44 | 0; do { f[m >> 2] = 0; m = m + 4 | 0 } while ((m | 0) < (x | 0)); f[o >> 2] = 3188; q = r + 56 | 0; f[q >> 2] = 0; f[r + 60 >> 2] = 0; f[r + 64 >> 2] = 0; f[r + 68 >> 2] = t; f[r + 72 >> 2] = v; C = r + 76 | 0; f[C >> 2] = 0; D = h + 4 | 0; m = D + 4 | 0; x = m + 40 | 0; do { f[m >> 2] = 0; m = m + 4 | 0 } while ((m | 0) < (x | 0)); f[h >> 2] = 3188; m = h + 48 | 0; f[m >> 2] = 0; x = h + 52 | 0; f[x >> 2] = 0; f[h + 56 >> 2] = 0; f[D >> 2] = p; E = f[z + (B * 136 | 0) + 68 >> 2] | 0; F = ((f[E + 4 >> 2] | 0) - (f[E >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[e >> 0] = 0; Xg(h + 24 | 0, F, e); F = f[D >> 2] | 0; E = (f[F + 56 >> 2] | 0) - (f[F + 52 >> 2] | 0) >> 2; b[e >> 0] = 0; Xg(h + 36 | 0, E, e); f[h + 8 >> 2] = p; f[h + 12 >> 2] = v; f[h + 16 >> 2] = t; f[h + 20 >> 2] = r; f[C >> 2] = a + 72; ef(o, h) | 0; Yf(q, f[m >> 2] | 0, f[x >> 2] | 0); E = r; f[h >> 2] = 3188; F = f[m >> 2] | 0; if (F | 0) { m = f[x >> 2] | 0; if ((m | 0) != (F | 0)) f[x >> 2] = m + (~((m + -4 - F | 0) >>> 2) << 2); br(F) } f[h >> 2] = 3208; F = f[h + 36 >> 2] | 0; if (F | 0) br(F); F = f[h + 24 >> 2] | 0; if (F | 0) br(F); G = 0; H = E; I = 42; break b } while (0); if (!y) { s = f[a + 12 >> 2] | 0; E = (f[s + 28 >> 2] | 0) - (f[s + 24 >> 2] | 0) >> 2; f[e >> 2] = -1; Sf(z + (B * 136 | 0) + 116 | 0, E, e); b[(f[l >> 2] | 0) + ((f[g >> 2] | 0) * 136 | 0) + 100 >> 0] = 0; J = z + (B * 136 | 0) + 104 | 0; I = 26 } else I = 24 } else I = 24; while (0); if ((I | 0) == 24) { J = a + 40 | 0; I = 26 } if ((I | 0) == 26) { B = (Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0) + 48 | 0; do if ((Yh(f[B >> 2] | 0) | 0) == 0 ? (f[w + 56 >> 2] | 0) == 0 : 0) { if (b[k >> 0] | 0 ? (z = f[a + 8 >> 2] | 0, ((f[z + 12 >> 2] | 0) - (f[z + 8 >> 2] | 0) | 0) >= 5) : 0) { I = 31; break } uf(e, a, J); K = 1; L = f[e >> 2] | 0 } else I = 31; while (0); if ((I | 0) == 31) { Le(e, a, J); K = 0; L = f[e >> 2] | 0 } if (!L) M = 0; else { G = K; H = L; I = 42 } } if ((I | 0) == 42) { I = f[g >> 2] | 0; if ((I | 0) == -1) N = a + 68 | 0; else N = (f[l >> 2] | 0) + (I * 136 | 0) + 132 | 0; f[N >> 2] = G; G = dn(76) | 0; f[i >> 2] = H; ml(G, i, c); c = G; G = f[i >> 2] | 0; f[i >> 2] = 0; if (G | 0) Va[f[(f[G >> 2] | 0) + 4 >> 2] & 127](G); G = a + 188 | 0; i = f[G >> 2] | 0; if ((i | 0) == (f[a + 192 >> 2] | 0)) Ci(a + 184 | 0, g); else { f[i >> 2] = f[g >> 2]; f[G >> 2] = i + 4 } i = Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0; f[j >> 2] = c; a = i + 12 | 0; G = f[a >> 2] | 0; if (G >>> 0 < (f[i + 16 >> 2] | 0) >>> 0) { f[j >> 2] = 0; f[G >> 2] = c; f[a >> 2] = G + 4; O = j } else { yg(i + 8 | 0, j); O = j } j = f[O >> 2] | 0; f[O >> 2] = 0; if (!j) M = 1; else { Va[f[(f[j >> 2] | 0) + 4 >> 2] & 127](j); M = 1 } } A = M; u = d; return A | 0 } function nc(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0; e = u; u = u + 64 | 0; d = e + 48 | 0; h = e + 40 | 0; i = e + 32 | 0; j = e + 16 | 0; k = e + 8 | 0; l = e; m = e + 28 | 0; n = a + 8 | 0; o = f[n >> 2] | 0; if ((o + -2 | 0) >>> 0 <= 28) { f[a + 72 >> 2] = o; p = 1 << o; f[a + 76 >> 2] = p + -1; o = p + -2 | 0; f[a + 80 >> 2] = o; f[a + 84 >> 2] = (o | 0) / 2 | 0 } o = a + 40 | 0; f[a + 48 >> 2] = g; g = a + 88 | 0; lk(g); p = a + 36 | 0; q = f[p >> 2] | 0; r = (f[q + 4 >> 2] | 0) - (f[q >> 2] | 0) | 0; s = r >> 2; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; t = k; f[t >> 2] = 0; f[t + 4 >> 2] = 0; t = l; f[t >> 2] = 0; f[t + 4 >> 2] = 0; if ((r | 0) <= 0) { u = e; return 1 } r = j + 4 | 0; t = j + 8 | 0; v = a + 84 | 0; w = a + 80 | 0; x = h + 4 | 0; y = i + 4 | 0; z = d + 4 | 0; A = k + 4 | 0; B = h + 4 | 0; C = i + 4 | 0; D = d + 4 | 0; E = l + 4 | 0; F = a + 76 | 0; a = k + 4 | 0; G = l + 4 | 0; H = f[q >> 2] | 0; if ((f[q + 4 >> 2] | 0) == (H | 0)) { J = q; mq(J) } else { K = 0; L = H } while (1) { f[m >> 2] = f[L + (K << 2) >> 2]; f[d >> 2] = f[m >> 2]; fc(o, d, j); H = f[j >> 2] | 0; q = (H | 0) > -1 ? H : 0 - H | 0; M = f[r >> 2] | 0; N = (M | 0) > -1 ? M : 0 - M | 0; O = Tn(N | 0, ((N | 0) < 0) << 31 >> 31 | 0, q | 0, ((q | 0) < 0) << 31 >> 31 | 0) | 0; q = f[t >> 2] | 0; N = (q | 0) > -1; P = N ? q : 0 - q | 0; q = Tn(O | 0, I | 0, P | 0, ((P | 0) < 0) << 31 >> 31 | 0) | 0; P = I; if ((q | 0) == 0 & (P | 0) == 0) { O = f[v >> 2] | 0; Q = O; R = j; S = M; T = O } else { O = f[v >> 2] | 0; U = ((O | 0) < 0) << 31 >> 31; V = on(O | 0, U | 0, H | 0, ((H | 0) < 0) << 31 >> 31 | 0) | 0; H = zk(V | 0, I | 0, q | 0, P | 0) | 0; f[j >> 2] = H; V = on(O | 0, U | 0, M | 0, ((M | 0) < 0) << 31 >> 31 | 0) | 0; M = zk(V | 0, I | 0, q | 0, P | 0) | 0; f[r >> 2] = M; P = O - ((H | 0) > -1 ? H : 0 - H | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; Q = N ? P : 0 - P | 0; R = t; S = M; T = O } f[R >> 2] = Q; O = f[j >> 2] | 0; do if ((O | 0) <= -1) { if ((S | 0) < 0) { M = f[t >> 2] | 0; W = (M | 0) > -1 ? M : 0 - M | 0; X = M } else { M = f[t >> 2] | 0; W = (f[w >> 2] | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; X = M } if ((X | 0) < 0) { Y = (S | 0) > -1 ? S : 0 - S | 0; Z = W; _ = X; break } else { Y = (f[w >> 2] | 0) - ((S | 0) > -1 ? S : 0 - S | 0) | 0; Z = W; _ = X; break } } else { M = f[t >> 2] | 0; Y = M + T | 0; Z = T + S | 0; _ = M } while (0); M = (Z | 0) == 0; P = (Y | 0) == 0; N = f[w >> 2] | 0; do if (Y | Z) { H = (N | 0) == (Y | 0); if (!(M & H)) { q = (N | 0) == (Z | 0); if (!(P & q)) { if (M & (T | 0) < (Y | 0)) { $ = 0; aa = (T << 1) - Y | 0; break } if (q & (T | 0) > (Y | 0)) { $ = Z; aa = (T << 1) - Y | 0; break } if (H & (T | 0) > (Z | 0)) { $ = (T << 1) - Z | 0; aa = Y; break } if (P) { $ = (T | 0) < (Z | 0) ? (T << 1) - Z | 0 : Z; aa = 0 } else { $ = Z; aa = Y } } else { $ = Z; aa = Z } } else { $ = Y; aa = Y } } else { $ = N; aa = N } while (0); P = 0 - S | 0; M = 0 - _ | 0; f[j >> 2] = 0 - O; f[r >> 2] = P; f[t >> 2] = M; if ((O | 0) < 1) { ba = T - _ | 0; ca = T - S | 0 } else { H = (_ | 0) < 1 ? M : _; M = (S | 0) < 1 ? P : S; ba = (_ | 0) > 0 ? M : N - M | 0; ca = (S | 0) > 0 ? H : N - H | 0 } H = (ca | 0) == 0; M = (ba | 0) == 0; do if (((ba | ca | 0) != 0 ? (P = (N | 0) == (ba | 0), !(H & P)) : 0) ? (q = (N | 0) == (ca | 0), !(M & q)) : 0) { if (H & (T | 0) < (ba | 0)) { da = 0; ea = (T << 1) - ba | 0; break } if (q & (T | 0) > (ba | 0)) { da = N; ea = (T << 1) - ba | 0; break } if (P & (T | 0) > (ca | 0)) { da = (T << 1) - ca | 0; ea = N; break } if (M) { da = (T | 0) < (ca | 0) ? (T << 1) - ca | 0 : ca; ea = 0 } else { da = ca; ea = ba } } else { da = N; ea = N } while (0); N = K << 1; M = b + (N << 2) | 0; H = M + 4 | 0; O = f[H >> 2] | 0; f[h >> 2] = f[M >> 2]; f[x >> 2] = O; f[i >> 2] = $; f[y >> 2] = aa; Dd(d, n, h, i); O = f[d >> 2] | 0; f[k >> 2] = O; P = f[z >> 2] | 0; f[A >> 2] = P; q = f[H >> 2] | 0; f[h >> 2] = f[M >> 2]; f[B >> 2] = q; f[i >> 2] = da; f[C >> 2] = ea; Dd(d, n, h, i); q = f[d >> 2] | 0; f[l >> 2] = q; M = f[D >> 2] | 0; f[E >> 2] = M; H = f[v >> 2] | 0; if ((H | 0) >= (O | 0)) if ((O | 0) < (0 - H | 0)) fa = (f[F >> 2] | 0) + O | 0; else fa = O; else fa = O - (f[F >> 2] | 0) | 0; f[k >> 2] = fa; if ((H | 0) >= (P | 0)) if ((P | 0) < (0 - H | 0)) ga = (f[F >> 2] | 0) + P | 0; else ga = P; else ga = P - (f[F >> 2] | 0) | 0; f[a >> 2] = ga; if ((H | 0) >= (q | 0)) if ((q | 0) < (0 - H | 0)) ha = (f[F >> 2] | 0) + q | 0; else ha = q; else ha = q - (f[F >> 2] | 0) | 0; f[l >> 2] = ha; if ((H | 0) >= (M | 0)) if ((M | 0) < (0 - H | 0)) ia = (f[F >> 2] | 0) + M | 0; else ia = M; else ia = M - (f[F >> 2] | 0) | 0; f[G >> 2] = ia; if ((((ga | 0) > -1 ? ga : 0 - ga | 0) + ((fa | 0) > -1 ? fa : 0 - fa | 0) | 0) < (((ha | 0) > -1 ? ha : 0 - ha | 0) + ((ia | 0) > -1 ? ia : 0 - ia | 0) | 0)) { Vi(g, 0); ja = k } else { Vi(g, 1); ja = l } M = f[ja >> 2] | 0; if ((M | 0) < 0) ka = (f[F >> 2] | 0) + M | 0; else ka = M; M = c + (N << 2) | 0; f[M >> 2] = ka; N = f[ja + 4 >> 2] | 0; if ((N | 0) < 0) la = (f[F >> 2] | 0) + N | 0; else la = N; f[M + 4 >> 2] = la; K = K + 1 | 0; if ((K | 0) >= (s | 0)) { ma = 5; break } M = f[p >> 2] | 0; L = f[M >> 2] | 0; if ((f[M + 4 >> 2] | 0) - L >> 2 >>> 0 <= K >>> 0) { J = M; ma = 6; break } } if ((ma | 0) == 5) { u = e; return 1 } else if ((ma | 0) == 6) mq(J); return 0 } function oc(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0; c = u; u = u + 48 | 0; d = c + 24 | 0; e = c + 12 | 0; g = c; if (!b) { h = 0; u = c; return h | 0 } i = a + 12 | 0; j = a + 4 | 0; k = f[j >> 2] | 0; l = f[a >> 2] | 0; m = k - l >> 2; n = a + 16 | 0; o = f[n >> 2] | 0; p = f[i >> 2] | 0; q = o - p >> 2; r = p; p = o; if (m >>> 0 <= q >>> 0) if (m >>> 0 < q >>> 0 ? (o = r + (m << 2) | 0, (o | 0) != (p | 0)) : 0) { f[n >> 2] = p + (~((p + -4 - o | 0) >>> 2) << 2); s = l; t = k } else { s = l; t = k } else { kh(i, m - q | 0, 5828); s = f[a >> 2] | 0; t = f[j >> 2] | 0 } f[d >> 2] = 0; q = d + 4 | 0; f[q >> 2] = 0; f[d + 8 >> 2] = 0; $j(d, t - s >> 2); s = f[j >> 2] | 0; t = f[a >> 2] | 0; if ((s | 0) == (t | 0)) { v = s; w = s } else { m = f[d >> 2] | 0; k = m; l = k; o = 0; p = s; s = k; k = t; t = m; while (1) { m = f[k + (o << 2) >> 2] | 0; n = f[q >> 2] | 0; if (m >>> 0 < n - t >> 2 >>> 0) { x = l; y = s; z = k; A = p } else { r = m + 1 | 0; f[e >> 2] = 0; B = n - t >> 2; C = t; D = n; if (r >>> 0 <= B >>> 0) if (r >>> 0 < B >>> 0 ? (n = C + (r << 2) | 0, (n | 0) != (D | 0)) : 0) { f[q >> 2] = D + (~((D + -4 - n | 0) >>> 2) << 2); E = l; F = p; G = k } else { E = l; F = p; G = k } else { kh(d, r - B | 0, e); E = f[d >> 2] | 0; F = f[j >> 2] | 0; G = f[a >> 2] | 0 } x = E; y = E; z = G; A = F } B = y + (m << 2) | 0; f[B >> 2] = (f[B >> 2] | 0) + 1; o = o + 1 | 0; if (o >>> 0 >= A - z >> 2 >>> 0) { v = z; w = A; break } else { l = x; p = A; s = y; k = z; t = y } } } y = w - v | 0; v = y >> 2; f[e >> 2] = 0; w = e + 4 | 0; f[w >> 2] = 0; f[e + 8 >> 2] = 0; if (!v) { H = 0; I = 0 } else { if (v >>> 0 > 536870911) mq(e); t = dn(y << 1) | 0; f[w >> 2] = t; f[e >> 2] = t; y = t + (v << 3) | 0; f[e + 8 >> 2] = y; z = v; v = t; k = t; while (1) { s = v; f[s >> 2] = -1; f[s + 4 >> 2] = -1; s = k + 8 | 0; A = z + -1 | 0; if (!A) break; else { z = A; v = s; k = s } } f[w >> 2] = y; H = t; I = t } t = f[q >> 2] | 0; y = f[d >> 2] | 0; k = t - y | 0; v = k >> 2; f[g >> 2] = 0; z = g + 4 | 0; f[z >> 2] = 0; f[g + 8 >> 2] = 0; s = y; do if (v) if (v >>> 0 > 1073741823) mq(g); else { A = dn(k) | 0; f[g >> 2] = A; p = A + (v << 2) | 0; f[g + 8 >> 2] = p; hj(A | 0, 0, k | 0) | 0; f[z >> 2] = p; J = A; K = p; L = A; break } else { J = 0; K = 0; L = 0 } while (0); if ((t | 0) != (y | 0)) { y = 0; t = 0; while (1) { f[J + (t << 2) >> 2] = y; k = t + 1 | 0; if (k >>> 0 < v >>> 0) { y = (f[s + (t << 2) >> 2] | 0) + y | 0; t = k } else break } } t = f[j >> 2] | 0; j = f[a >> 2] | 0; y = j; if ((t | 0) != (j | 0)) { k = a + 40 | 0; a = t - j >> 2; j = H; t = H; g = H; A = H; p = H; x = H; l = 0; o = J; while (1) { F = f[y + (l << 2) >> 2] | 0; G = l + 1 | 0; E = ((G >>> 0) % 3 | 0 | 0) == 0 ? l + -2 | 0 : G; if ((E | 0) == -1) M = -1; else M = f[y + (E << 2) >> 2] | 0; E = ((l >>> 0) % 3 | 0 | 0) == 0; G = (E ? 2 : -1) + l | 0; if ((G | 0) == -1) N = -1; else N = f[y + (G << 2) >> 2] | 0; if (E ? (M | 0) == (N | 0) | ((F | 0) == (M | 0) | (F | 0) == (N | 0)) : 0) { f[k >> 2] = (f[k >> 2] | 0) + 1; O = j; P = t; Q = g; R = A; S = p; T = x; U = l + 2 | 0; V = o } else W = 51; a: do if ((W | 0) == 51) { W = 0; E = f[s + (N << 2) >> 2] | 0; b: do if ((E | 0) > 0) { G = 0; B = f[o + (N << 2) >> 2] | 0; while (1) { m = f[p + (B << 3) >> 2] | 0; if ((m | 0) == -1) { X = j; Y = t; Z = A; _ = p; break b } if ((m | 0) == (M | 0)) { m = f[p + (B << 3) + 4 >> 2] | 0; if ((m | 0) == -1) $ = -1; else $ = f[y + (m << 2) >> 2] | 0; if ((F | 0) != ($ | 0)) break } m = G + 1 | 0; if ((m | 0) < (E | 0)) { G = m; B = B + 1 | 0 } else { X = j; Y = t; Z = A; _ = p; break b } } m = f[A + (B << 3) + 4 >> 2] | 0; r = G; n = B; D = t; while (1) { r = r + 1 | 0; if ((r | 0) >= (E | 0)) break; C = n + 1 | 0; f[D + (n << 3) >> 2] = f[D + (C << 3) >> 2]; f[D + (n << 3) + 4 >> 2] = f[D + (C << 3) + 4 >> 2]; if ((f[j + (n << 3) >> 2] | 0) == -1) break; else { n = C; D = j } } f[g + (n << 3) >> 2] = -1; if ((m | 0) == -1) { X = g; Y = g; Z = g; _ = g } else { D = f[i >> 2] | 0; f[D + (l << 2) >> 2] = m; f[D + (m << 2) >> 2] = l; O = g; P = g; Q = g; R = g; S = g; T = x; U = l; V = o; break a } } else { X = j; Y = t; Z = A; _ = p } while (0); E = f[s + (M << 2) >> 2] | 0; if ((E | 0) > 0) { D = 0; r = f[J + (M << 2) >> 2] | 0; while (1) { aa = x + (r << 3) | 0; if ((f[aa >> 2] | 0) == -1) break; D = D + 1 | 0; if ((D | 0) >= (E | 0)) { O = x; P = x; Q = x; R = x; S = x; T = x; U = l; V = J; break a } else r = r + 1 | 0 } f[aa >> 2] = N; f[H + (r << 3) + 4 >> 2] = l; O = H; P = H; Q = H; R = H; S = H; T = H; U = l; V = J } else { O = X; P = Y; Q = g; R = Z; S = _; T = x; U = l; V = o } } while (0); l = U + 1 | 0; if (l >>> 0 >= a >>> 0) break; else { j = O; t = P; g = Q; A = R; p = S; x = T; o = V } } } f[b >> 2] = v; if (!J) { ba = H; ca = I } else { if ((K | 0) != (J | 0)) f[z >> 2] = K + (~((K + -4 - J | 0) >>> 2) << 2); br(L); L = f[e >> 2] | 0; ba = L; ca = L } if (ba | 0) { L = f[w >> 2] | 0; if ((L | 0) != (ba | 0)) f[w >> 2] = L + (~((L + -8 - ba | 0) >>> 3) << 3); br(ca) } ca = f[d >> 2] | 0; if (ca | 0) { d = f[q >> 2] | 0; if ((d | 0) != (ca | 0)) f[q >> 2] = d + (~((d + -4 - ca | 0) >>> 2) << 2); br(ca) } h = 1; u = c; return h | 0 } function pc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = Oa, S = Oa, T = Oa, U = 0, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0; e = u; u = u + 48 | 0; g = e + 12 | 0; h = e + 35 | 0; i = e + 32 | 0; j = e; k = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[k >> 2] = $(1.0); l = a + 80 | 0; m = f[l >> 2] | 0; f[j >> 2] = 0; o = j + 4 | 0; f[o >> 2] = 0; f[j + 8 >> 2] = 0; if (m) { if (m >>> 0 > 1073741823) mq(j); p = m << 2; q = dn(p) | 0; f[j >> 2] = q; r = q + (m << 2) | 0; f[j + 8 >> 2] = r; hj(q | 0, 0, p | 0) | 0; f[o >> 2] = r; r = f[d >> 2] | 0; d = c + 48 | 0; p = c + 40 | 0; q = i + 1 | 0; m = i + 2 | 0; s = g + 4 | 0; t = g + 12 | 0; v = g + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = 0; z = 0; while (1) { A = d; B = f[A >> 2] | 0; C = f[A + 4 >> 2] | 0; A = p; D = on(f[A >> 2] | 0, f[A + 4 >> 2] | 0, r + y | 0, 0) | 0; A = Tn(D | 0, I | 0, B | 0, C | 0) | 0; C = (f[f[c >> 2] >> 2] | 0) + A | 0; b[h >> 0] = b[C >> 0] | 0; b[h + 1 >> 0] = b[C + 1 >> 0] | 0; b[h + 2 >> 0] = b[C + 2 >> 0] | 0; Xl(i | 0, C | 0, 3) | 0; C = Uf(g, i) | 0; if (!C) { A = b[i >> 0] | 0; B = b[q >> 0] | 0; D = b[m >> 0] | 0; E = ((A & 255 ^ 318) + 239 ^ B & 255) + 239 ^ D & 255; F = f[s >> 2] | 0; G = (F | 0) == 0; a: do if (!G) { H = F + -1 | 0; J = (H & F | 0) == 0; if (!J) if (E >>> 0 < F >>> 0) K = E; else K = (E >>> 0) % (F >>> 0) | 0; else K = E & H; L = f[(f[g >> 2] | 0) + (K << 2) >> 2] | 0; if ((L | 0) != 0 ? (M = f[L >> 2] | 0, (M | 0) != 0) : 0) { if (J) { J = M; while (1) { L = f[J + 4 >> 2] | 0; if (!((L | 0) == (E | 0) | (L & H | 0) == (K | 0))) { N = K; O = 29; break a } L = J + 8 | 0; if (((b[L >> 0] | 0) == A << 24 >> 24 ? (b[L + 1 >> 0] | 0) == B << 24 >> 24 : 0) ? (b[L + 2 >> 0] | 0) == D << 24 >> 24 : 0) break a; J = f[J >> 2] | 0; if (!J) { N = K; O = 29; break a } } } else P = M; while (1) { J = f[P + 4 >> 2] | 0; if ((J | 0) != (E | 0)) { if (J >>> 0 < F >>> 0) Q = J; else Q = (J >>> 0) % (F >>> 0) | 0; if ((Q | 0) != (K | 0)) { N = K; O = 29; break a } } J = P + 8 | 0; if (((b[J >> 0] | 0) == A << 24 >> 24 ? (b[J + 1 >> 0] | 0) == B << 24 >> 24 : 0) ? (b[J + 2 >> 0] | 0) == D << 24 >> 24 : 0) break a; P = f[P >> 2] | 0; if (!P) { N = K; O = 29; break } } } else { N = K; O = 29 } } else { N = 0; O = 29 } while (0); if ((O | 0) == 29) { O = 0; M = dn(16) | 0; b[M + 8 >> 0] = A; b[M + 9 >> 0] = B; b[M + 10 >> 0] = D; f[M + 12 >> 2] = z; f[M + 4 >> 2] = E; f[M >> 2] = 0; R = $(((f[t >> 2] | 0) + 1 | 0) >>> 0); S = $(F >>> 0); T = $(n[k >> 2]); do if (G | $(T * S) < R) { J = F << 1 | (F >>> 0 < 3 | (F + -1 & F | 0) != 0) & 1; H = ~~$(W($(R / T))) >>> 0; Kh(g, J >>> 0 < H >>> 0 ? H : J); J = f[s >> 2] | 0; H = J + -1 | 0; if (!(H & J)) { U = J; V = H & E; break } if (E >>> 0 < J >>> 0) { U = J; V = E } else { U = J; V = (E >>> 0) % (J >>> 0) | 0 } } else { U = F; V = N } while (0); F = (f[g >> 2] | 0) + (V << 2) | 0; E = f[F >> 2] | 0; if (!E) { f[M >> 2] = f[v >> 2]; f[v >> 2] = M; f[F >> 2] = v; F = f[M >> 2] | 0; if (F | 0) { G = f[F + 4 >> 2] | 0; F = U + -1 | 0; if (F & U) if (G >>> 0 < U >>> 0) X = G; else X = (G >>> 0) % (U >>> 0) | 0; else X = G & F; Y = (f[g >> 2] | 0) + (X << 2) | 0; O = 42 } } else { f[M >> 2] = f[E >> 2]; Y = E; O = 42 } if ((O | 0) == 42) { O = 0; f[Y >> 2] = M } f[t >> 2] = (f[t >> 2] | 0) + 1 } E = w; F = f[E >> 2] | 0; G = on(F | 0, f[E + 4 >> 2] | 0, z | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + G | 0, h | 0, F | 0) | 0; F = f[j >> 2] | 0; f[F + (y << 2) >> 2] = z; Z = z + 1 | 0; _ = F } else { F = f[j >> 2] | 0; f[F + (y << 2) >> 2] = f[C + 12 >> 2]; Z = z; _ = F } y = y + 1 | 0; aa = f[l >> 2] | 0; if (y >>> 0 >= aa >>> 0) break; else z = Z } if ((Z | 0) == (aa | 0)) ba = _; else { z = a + 84 | 0; if (!(b[z >> 0] | 0)) { y = f[a + 72 >> 2] | 0; h = f[a + 68 >> 2] | 0; x = h; if ((y | 0) == (h | 0)) ca = _; else { w = y - h >> 2; h = 0; do { y = x + (h << 2) | 0; f[y >> 2] = f[_ + (f[y >> 2] << 2) >> 2]; h = h + 1 | 0 } while (h >>> 0 < w >>> 0); ca = _ } } else { b[z >> 0] = 0; z = a + 68 | 0; _ = a + 72 | 0; w = f[_ >> 2] | 0; h = f[z >> 2] | 0; x = w - h >> 2; y = h; h = w; if (aa >>> 0 <= x >>> 0) if (aa >>> 0 < x >>> 0 ? (w = y + (aa << 2) | 0, (w | 0) != (h | 0)) : 0) { f[_ >> 2] = h + (~((h + -4 - w | 0) >>> 2) << 2); da = aa } else da = aa; else { kh(z, aa - x | 0, 1204); da = f[l >> 2] | 0 } x = f[j >> 2] | 0; if (!da) ca = x; else { j = f[a + 68 >> 2] | 0; a = 0; do { f[j + (a << 2) >> 2] = f[x + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < da >>> 0); ca = x } } f[l >> 2] = Z; ba = ca } if (!ba) ea = Z; else { ca = f[o >> 2] | 0; if ((ca | 0) != (ba | 0)) f[o >> 2] = ca + (~((ca + -4 - ba | 0) >>> 2) << 2); br(ba); ea = Z } } else ea = 0; Z = f[g + 8 >> 2] | 0; if (Z | 0) { ba = Z; do { Z = ba; ba = f[ba >> 2] | 0; br(Z) } while ((ba | 0) != 0) } ba = f[g >> 2] | 0; f[g >> 2] = 0; if (!ba) { u = e; return ea | 0 } br(ba); u = e; return ea | 0 } function qc(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0, _ = 0, $ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0, ga = 0, ha = 0, ia = 0, ja = 0, ka = 0, la = 0, ma = 0; e = u; u = u + 64 | 0; d = e + 48 | 0; h = e + 40 | 0; i = e + 32 | 0; j = e + 16 | 0; k = e + 8 | 0; l = e; m = e + 28 | 0; n = a + 8 | 0; o = f[n >> 2] | 0; if ((o + -2 | 0) >>> 0 <= 28) { f[a + 72 >> 2] = o; p = 1 << o; f[a + 76 >> 2] = p + -1; o = p + -2 | 0; f[a + 80 >> 2] = o; f[a + 84 >> 2] = (o | 0) / 2 | 0 } o = a + 40 | 0; f[a + 48 >> 2] = g; g = a + 88 | 0; lk(g); p = a + 36 | 0; q = f[p >> 2] | 0; r = (f[q + 4 >> 2] | 0) - (f[q >> 2] | 0) | 0; s = r >> 2; f[j >> 2] = 0; f[j + 4 >> 2] = 0; f[j + 8 >> 2] = 0; t = k; f[t >> 2] = 0; f[t + 4 >> 2] = 0; t = l; f[t >> 2] = 0; f[t + 4 >> 2] = 0; if ((r | 0) <= 0) { u = e; return 1 } r = j + 4 | 0; t = j + 8 | 0; v = a + 84 | 0; w = a + 80 | 0; x = h + 4 | 0; y = i + 4 | 0; z = d + 4 | 0; A = k + 4 | 0; B = h + 4 | 0; C = i + 4 | 0; D = d + 4 | 0; E = l + 4 | 0; F = a + 76 | 0; a = k + 4 | 0; G = l + 4 | 0; H = f[q >> 2] | 0; if ((f[q + 4 >> 2] | 0) == (H | 0)) { J = q; mq(J) } else { K = 0; L = H } while (1) { f[m >> 2] = f[L + (K << 2) >> 2]; f[d >> 2] = f[m >> 2]; $b(o, d, j); H = f[j >> 2] | 0; q = (H | 0) > -1 ? H : 0 - H | 0; M = f[r >> 2] | 0; N = (M | 0) > -1 ? M : 0 - M | 0; O = Tn(N | 0, ((N | 0) < 0) << 31 >> 31 | 0, q | 0, ((q | 0) < 0) << 31 >> 31 | 0) | 0; q = f[t >> 2] | 0; N = (q | 0) > -1; P = N ? q : 0 - q | 0; q = Tn(O | 0, I | 0, P | 0, ((P | 0) < 0) << 31 >> 31 | 0) | 0; P = I; if ((q | 0) == 0 & (P | 0) == 0) { O = f[v >> 2] | 0; Q = O; R = j; S = M; T = O } else { O = f[v >> 2] | 0; U = ((O | 0) < 0) << 31 >> 31; V = on(O | 0, U | 0, H | 0, ((H | 0) < 0) << 31 >> 31 | 0) | 0; H = zk(V | 0, I | 0, q | 0, P | 0) | 0; f[j >> 2] = H; V = on(O | 0, U | 0, M | 0, ((M | 0) < 0) << 31 >> 31 | 0) | 0; M = zk(V | 0, I | 0, q | 0, P | 0) | 0; f[r >> 2] = M; P = O - ((H | 0) > -1 ? H : 0 - H | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; Q = N ? P : 0 - P | 0; R = t; S = M; T = O } f[R >> 2] = Q; O = f[j >> 2] | 0; do if ((O | 0) <= -1) { if ((S | 0) < 0) { M = f[t >> 2] | 0; W = (M | 0) > -1 ? M : 0 - M | 0; X = M } else { M = f[t >> 2] | 0; W = (f[w >> 2] | 0) - ((M | 0) > -1 ? M : 0 - M | 0) | 0; X = M } if ((X | 0) < 0) { Y = (S | 0) > -1 ? S : 0 - S | 0; Z = W; _ = X; break } else { Y = (f[w >> 2] | 0) - ((S | 0) > -1 ? S : 0 - S | 0) | 0; Z = W; _ = X; break } } else { M = f[t >> 2] | 0; Y = M + T | 0; Z = T + S | 0; _ = M } while (0); M = (Z | 0) == 0; P = (Y | 0) == 0; N = f[w >> 2] | 0; do if (Y | Z) { H = (N | 0) == (Y | 0); if (!(M & H)) { q = (N | 0) == (Z | 0); if (!(P & q)) { if (M & (T | 0) < (Y | 0)) { $ = 0; aa = (T << 1) - Y | 0; break } if (q & (T | 0) > (Y | 0)) { $ = Z; aa = (T << 1) - Y | 0; break } if (H & (T | 0) > (Z | 0)) { $ = (T << 1) - Z | 0; aa = Y; break } if (P) { $ = (T | 0) < (Z | 0) ? (T << 1) - Z | 0 : Z; aa = 0 } else { $ = Z; aa = Y } } else { $ = Z; aa = Z } } else { $ = Y; aa = Y } } else { $ = N; aa = N } while (0); P = 0 - S | 0; M = 0 - _ | 0; f[j >> 2] = 0 - O; f[r >> 2] = P; f[t >> 2] = M; if ((O | 0) < 1) { ba = T - _ | 0; ca = T - S | 0 } else { H = (_ | 0) < 1 ? M : _; M = (S | 0) < 1 ? P : S; ba = (_ | 0) > 0 ? M : N - M | 0; ca = (S | 0) > 0 ? H : N - H | 0 } H = (ca | 0) == 0; M = (ba | 0) == 0; do if (((ba | ca | 0) != 0 ? (P = (N | 0) == (ba | 0), !(H & P)) : 0) ? (q = (N | 0) == (ca | 0), !(M & q)) : 0) { if (H & (T | 0) < (ba | 0)) { da = 0; ea = (T << 1) - ba | 0; break } if (q & (T | 0) > (ba | 0)) { da = N; ea = (T << 1) - ba | 0; break } if (P & (T | 0) > (ca | 0)) { da = (T << 1) - ca | 0; ea = N; break } if (M) { da = (T | 0) < (ca | 0) ? (T << 1) - ca | 0 : ca; ea = 0 } else { da = ca; ea = ba } } else { da = N; ea = N } while (0); N = K << 1; M = b + (N << 2) | 0; H = M + 4 | 0; O = f[H >> 2] | 0; f[h >> 2] = f[M >> 2]; f[x >> 2] = O; f[i >> 2] = $; f[y >> 2] = aa; Dd(d, n, h, i); O = f[d >> 2] | 0; f[k >> 2] = O; P = f[z >> 2] | 0; f[A >> 2] = P; q = f[H >> 2] | 0; f[h >> 2] = f[M >> 2]; f[B >> 2] = q; f[i >> 2] = da; f[C >> 2] = ea; Dd(d, n, h, i); q = f[d >> 2] | 0; f[l >> 2] = q; M = f[D >> 2] | 0; f[E >> 2] = M; H = f[v >> 2] | 0; if ((H | 0) >= (O | 0)) if ((O | 0) < (0 - H | 0)) fa = (f[F >> 2] | 0) + O | 0; else fa = O; else fa = O - (f[F >> 2] | 0) | 0; f[k >> 2] = fa; if ((H | 0) >= (P | 0)) if ((P | 0) < (0 - H | 0)) ga = (f[F >> 2] | 0) + P | 0; else ga = P; else ga = P - (f[F >> 2] | 0) | 0; f[a >> 2] = ga; if ((H | 0) >= (q | 0)) if ((q | 0) < (0 - H | 0)) ha = (f[F >> 2] | 0) + q | 0; else ha = q; else ha = q - (f[F >> 2] | 0) | 0; f[l >> 2] = ha; if ((H | 0) >= (M | 0)) if ((M | 0) < (0 - H | 0)) ia = (f[F >> 2] | 0) + M | 0; else ia = M; else ia = M - (f[F >> 2] | 0) | 0; f[G >> 2] = ia; if ((((ga | 0) > -1 ? ga : 0 - ga | 0) + ((fa | 0) > -1 ? fa : 0 - fa | 0) | 0) < (((ha | 0) > -1 ? ha : 0 - ha | 0) + ((ia | 0) > -1 ? ia : 0 - ia | 0) | 0)) { Vi(g, 0); ja = k } else { Vi(g, 1); ja = l } M = f[ja >> 2] | 0; if ((M | 0) < 0) ka = (f[F >> 2] | 0) + M | 0; else ka = M; M = c + (N << 2) | 0; f[M >> 2] = ka; N = f[ja + 4 >> 2] | 0; if ((N | 0) < 0) la = (f[F >> 2] | 0) + N | 0; else la = N; f[M + 4 >> 2] = la; K = K + 1 | 0; if ((K | 0) >= (s | 0)) { ma = 5; break } M = f[p >> 2] | 0; L = f[M >> 2] | 0; if ((f[M + 4 >> 2] | 0) - L >> 2 >>> 0 <= K >>> 0) { J = M; ma = 6; break } } if ((ma | 0) == 5) { u = e; return 1 } else if ((ma | 0) == 6) mq(J); return 0 } function rc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = Oa, T = Oa, U = Oa, V = 0, X = 0, Y = 0, Z = 0, _ = 0, aa = 0, ba = 0, ca = 0, da = 0, ea = 0, fa = 0; e = u; u = u + 64 | 0; g = e + 36 | 0; h = e + 24 | 0; i = e + 12 | 0; j = e; k = g + 16 | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; f[g + 12 >> 2] = 0; n[k >> 2] = $(1.0); l = a + 80 | 0; m = f[l >> 2] | 0; f[j >> 2] = 0; o = j + 4 | 0; f[o >> 2] = 0; f[j + 8 >> 2] = 0; if (m) { if (m >>> 0 > 1073741823) mq(j); p = m << 2; q = dn(p) | 0; f[j >> 2] = q; r = q + (m << 2) | 0; f[j + 8 >> 2] = r; hj(q | 0, 0, p | 0) | 0; f[o >> 2] = r; r = f[d >> 2] | 0; d = c + 48 | 0; p = c + 40 | 0; q = i + 4 | 0; m = i + 8 | 0; s = g + 4 | 0; t = g + 12 | 0; v = g + 8 | 0; w = a + 40 | 0; x = a + 64 | 0; y = 0; z = 0; while (1) { A = d; B = f[A >> 2] | 0; C = f[A + 4 >> 2] | 0; A = p; D = on(f[A >> 2] | 0, f[A + 4 >> 2] | 0, r + z | 0, 0) | 0; A = Tn(D | 0, I | 0, B | 0, C | 0) | 0; C = (f[f[c >> 2] >> 2] | 0) + A | 0; A = h; B = C; D = A + 12 | 0; do { b[A >> 0] = b[B >> 0] | 0; A = A + 1 | 0; B = B + 1 | 0 } while ((A | 0) < (D | 0)); Xl(i | 0, C | 0, 12) | 0; B = _f(g, i) | 0; if (!B) { A = f[i >> 2] | 0; D = f[q >> 2] | 0; E = f[m >> 2] | 0; F = ((A ^ 318) + 239 ^ D) + 239 ^ E; G = f[s >> 2] | 0; H = (G | 0) == 0; a: do if (!H) { J = G + -1 | 0; K = (J & G | 0) == 0; if (!K) if (F >>> 0 < G >>> 0) L = F; else L = (F >>> 0) % (G >>> 0) | 0; else L = F & J; M = f[(f[g >> 2] | 0) + (L << 2) >> 2] | 0; if ((M | 0) != 0 ? (N = f[M >> 2] | 0, (N | 0) != 0) : 0) { if (K) { K = N; while (1) { M = f[K + 4 >> 2] | 0; if (!((M | 0) == (F | 0) | (M & J | 0) == (L | 0))) { O = L; P = 29; break a } if (((f[K + 8 >> 2] | 0) == (A | 0) ? (f[K + 12 >> 2] | 0) == (D | 0) : 0) ? (f[K + 16 >> 2] | 0) == (E | 0) : 0) break a; K = f[K >> 2] | 0; if (!K) { O = L; P = 29; break a } } } else Q = N; while (1) { K = f[Q + 4 >> 2] | 0; if ((K | 0) != (F | 0)) { if (K >>> 0 < G >>> 0) R = K; else R = (K >>> 0) % (G >>> 0) | 0; if ((R | 0) != (L | 0)) { O = L; P = 29; break a } } if (((f[Q + 8 >> 2] | 0) == (A | 0) ? (f[Q + 12 >> 2] | 0) == (D | 0) : 0) ? (f[Q + 16 >> 2] | 0) == (E | 0) : 0) break a; Q = f[Q >> 2] | 0; if (!Q) { O = L; P = 29; break } } } else { O = L; P = 29 } } else { O = 0; P = 29 } while (0); if ((P | 0) == 29) { P = 0; C = dn(24) | 0; f[C + 8 >> 2] = A; f[C + 12 >> 2] = D; f[C + 16 >> 2] = E; f[C + 20 >> 2] = y; f[C + 4 >> 2] = F; f[C >> 2] = 0; S = $(((f[t >> 2] | 0) + 1 | 0) >>> 0); T = $(G >>> 0); U = $(n[k >> 2]); do if (H | $(U * T) < S) { N = G << 1 | (G >>> 0 < 3 | (G + -1 & G | 0) != 0) & 1; K = ~~$(W($(S / U))) >>> 0; Hh(g, N >>> 0 < K >>> 0 ? K : N); N = f[s >> 2] | 0; K = N + -1 | 0; if (!(K & N)) { V = N; X = K & F; break } if (F >>> 0 < N >>> 0) { V = N; X = F } else { V = N; X = (F >>> 0) % (N >>> 0) | 0 } } else { V = G; X = O } while (0); G = (f[g >> 2] | 0) + (X << 2) | 0; F = f[G >> 2] | 0; if (!F) { f[C >> 2] = f[v >> 2]; f[v >> 2] = C; f[G >> 2] = v; G = f[C >> 2] | 0; if (G | 0) { H = f[G + 4 >> 2] | 0; G = V + -1 | 0; if (G & V) if (H >>> 0 < V >>> 0) Y = H; else Y = (H >>> 0) % (V >>> 0) | 0; else Y = H & G; Z = (f[g >> 2] | 0) + (Y << 2) | 0; P = 42 } } else { f[C >> 2] = f[F >> 2]; Z = F; P = 42 } if ((P | 0) == 42) { P = 0; f[Z >> 2] = C } f[t >> 2] = (f[t >> 2] | 0) + 1 } F = w; G = f[F >> 2] | 0; H = on(G | 0, f[F + 4 >> 2] | 0, y | 0, 0) | 0; Rg((f[f[x >> 2] >> 2] | 0) + H | 0, h | 0, G | 0) | 0; G = f[j >> 2] | 0; f[G + (z << 2) >> 2] = y; _ = y + 1 | 0; aa = G } else { G = f[j >> 2] | 0; f[G + (z << 2) >> 2] = f[B + 20 >> 2]; _ = y; aa = G } z = z + 1 | 0; ba = f[l >> 2] | 0; if (z >>> 0 >= ba >>> 0) break; else y = _ } if ((_ | 0) == (ba | 0)) ca = aa; else { y = a + 84 | 0; if (!(b[y >> 0] | 0)) { z = f[a + 72 >> 2] | 0; h = f[a + 68 >> 2] | 0; x = h; if ((z | 0) == (h | 0)) da = aa; else { w = z - h >> 2; h = 0; do { z = x + (h << 2) | 0; f[z >> 2] = f[aa + (f[z >> 2] << 2) >> 2]; h = h + 1 | 0 } while (h >>> 0 < w >>> 0); da = aa } } else { b[y >> 0] = 0; y = a + 68 | 0; aa = a + 72 | 0; w = f[aa >> 2] | 0; h = f[y >> 2] | 0; x = w - h >> 2; z = h; h = w; if (ba >>> 0 <= x >>> 0) if (ba >>> 0 < x >>> 0 ? (w = z + (ba << 2) | 0, (w | 0) != (h | 0)) : 0) { f[aa >> 2] = h + (~((h + -4 - w | 0) >>> 2) << 2); ea = ba } else ea = ba; else { kh(y, ba - x | 0, 1204); ea = f[l >> 2] | 0 } x = f[j >> 2] | 0; if (!ea) da = x; else { j = f[a + 68 >> 2] | 0; a = 0; do { f[j + (a << 2) >> 2] = f[x + (a << 2) >> 2]; a = a + 1 | 0 } while (a >>> 0 < ea >>> 0); da = x } } f[l >> 2] = _; ca = da } if (!ca) fa = _; else { da = f[o >> 2] | 0; if ((da | 0) != (ca | 0)) f[o >> 2] = da + (~((da + -4 - ca | 0) >>> 2) << 2); br(ca); fa = _ } } else fa = 0; _ = f[g + 8 >> 2] | 0; if (_ | 0) { ca = _; do { _ = ca; ca = f[ca >> 2] | 0; br(_) } while ((ca | 0) != 0) } ca = f[g >> 2] | 0; f[g >> 2] = 0; if (!ca) { u = e; return fa | 0 } br(ca); u = e; return fa | 0 } function sc(a, c) { a = a | 0; c = c | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0; e = u; u = u + 32 | 0; g = e + 4 | 0; h = e; i = e + 16 | 0; j = c + 56 | 0; k = f[j >> 2] | 0; l = (f[k + 100 >> 2] | 0) - (f[k + 96 >> 2] | 0) | 0; k = (l | 0) / 12 | 0; m = c + 44 | 0; Nh(k, f[m >> 2] | 0) | 0; Nh(f[(f[j >> 2] | 0) + 80 >> 2] | 0, f[m >> 2] | 0) | 0; n = f[c + 48 >> 2] | 0; o = dn(32) | 0; f[g >> 2] = o; f[g + 8 >> 2] = -2147483616; f[g + 4 >> 2] = 21; p = o; q = 14562; r = p + 21 | 0; do { b[p >> 0] = b[q >> 0] | 0; p = p + 1 | 0; q = q + 1 | 0 } while ((p | 0) < (r | 0)); b[o + 21 >> 0] = 0; o = Oj(n, g, 0) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); n = f[m >> 2] | 0; if (o) { b[i >> 0] = 0; o = n + 16 | 0; q = f[o + 4 >> 2] | 0; if (!((q | 0) > 0 | (q | 0) == 0 & (f[o >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[n + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(n, g, i, i + 1 | 0) | 0 } Ye(c) | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } b[i >> 0] = 1; c = n + 16 | 0; o = f[c + 4 >> 2] | 0; if (!((o | 0) > 0 | (o | 0) == 0 & (f[c >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[n + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(n, g, i, i + 1 | 0) | 0 } n = f[j >> 2] | 0; c = f[n + 80 >> 2] | 0; if (c >>> 0 < 256) { if (!l) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } o = i + 1 | 0; q = i + 1 | 0; p = i + 1 | 0; r = 0; s = n; while (1) { t = f[s + 96 >> 2] | 0; v = f[m >> 2] | 0; b[i >> 0] = f[t + (r * 12 | 0) >> 2]; w = v + 16 | 0; x = f[w >> 2] | 0; y = f[w + 4 >> 2] | 0; if ((y | 0) > 0 | (y | 0) == 0 & x >>> 0 > 0) { z = x; A = v; B = y } else { f[h >> 2] = f[v + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(v, g, i, p) | 0; v = f[m >> 2] | 0; y = v + 16 | 0; z = f[y >> 2] | 0; A = v; B = f[y + 4 >> 2] | 0 } b[i >> 0] = f[t + (r * 12 | 0) + 4 >> 2]; if ((B | 0) > 0 | (B | 0) == 0 & z >>> 0 > 0) { C = B; D = z; E = A } else { f[h >> 2] = f[A + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(A, g, i, q) | 0; y = f[m >> 2] | 0; v = y + 16 | 0; C = f[v + 4 >> 2] | 0; D = f[v >> 2] | 0; E = y } b[i >> 0] = f[t + (r * 12 | 0) + 8 >> 2]; if (!((C | 0) > 0 | (C | 0) == 0 & D >>> 0 > 0)) { f[h >> 2] = f[E + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(E, g, i, o) | 0 } t = r + 1 | 0; if (t >>> 0 >= k >>> 0) break; r = t; s = f[j >> 2] | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } if (c >>> 0 < 65536) { if (!l) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } s = i + 2 | 0; r = i + 2 | 0; o = i + 2 | 0; E = 0; D = n; while (1) { C = f[D + 96 >> 2] | 0; q = f[m >> 2] | 0; d[i >> 1] = f[C + (E * 12 | 0) >> 2]; A = q + 16 | 0; z = f[A >> 2] | 0; B = f[A + 4 >> 2] | 0; if ((B | 0) > 0 | (B | 0) == 0 & z >>> 0 > 0) { F = B; G = z; H = q } else { f[h >> 2] = f[q + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(q, g, i, o) | 0; q = f[m >> 2] | 0; z = q + 16 | 0; F = f[z + 4 >> 2] | 0; G = f[z >> 2] | 0; H = q } d[i >> 1] = f[C + (E * 12 | 0) + 4 >> 2]; if ((F | 0) > 0 | (F | 0) == 0 & G >>> 0 > 0) { I = F; J = G; K = H } else { f[h >> 2] = f[H + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(H, g, i, r) | 0; q = f[m >> 2] | 0; z = q + 16 | 0; I = f[z + 4 >> 2] | 0; J = f[z >> 2] | 0; K = q } d[i >> 1] = f[C + (E * 12 | 0) + 8 >> 2]; if (!((I | 0) > 0 | (I | 0) == 0 & J >>> 0 > 0)) { f[h >> 2] = f[K + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(K, g, i, s) | 0 } C = E + 1 | 0; if (C >>> 0 >= k >>> 0) break; E = C; D = f[j >> 2] | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } D = (l | 0) != 0; if (c >>> 0 < 2097152) { if (D) { L = 0; M = n } else { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } while (1) { c = f[M + 96 >> 2] | 0; Nh(f[c + (L * 12 | 0) >> 2] | 0, f[m >> 2] | 0) | 0; Nh(f[c + (L * 12 | 0) + 4 >> 2] | 0, f[m >> 2] | 0) | 0; Nh(f[c + (L * 12 | 0) + 8 >> 2] | 0, f[m >> 2] | 0) | 0; c = L + 1 | 0; if (c >>> 0 >= k >>> 0) break; L = c; M = f[j >> 2] | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } if (!D) { f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } D = 0; M = n; while (1) { n = (f[M + 96 >> 2] | 0) + (D * 12 | 0) | 0; L = f[m >> 2] | 0; c = L + 16 | 0; l = f[c + 4 >> 2] | 0; if (!((l | 0) > 0 | (l | 0) == 0 & (f[c >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[L + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(L, g, n, n + 12 | 0) | 0 } n = D + 1 | 0; if (n >>> 0 >= k >>> 0) break; D = n; M = f[j >> 2] | 0 } f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; u = e; return } function tc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0; e = u; u = u + 32 | 0; g = e + 16 | 0; h = e + 12 | 0; i = e + 8 | 0; j = e + 4 | 0; k = e; switch (f[c + 28 >> 2] | 0) { case 9: { l = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = l; f[g >> 2] = f[h >> 2]; m = ec(a, c, g) | 0; break } case 2: { f[i >> 2] = l; f[g >> 2] = f[i >> 2]; m = Xb(a, c, g) | 0; break } case 3: { f[j >> 2] = l; f[g >> 2] = f[j >> 2]; m = rc(a, c, g) | 0; break } case 4: { f[k >> 2] = l; f[g >> 2] = f[k >> 2]; m = jc(a, c, g) | 0; break } default: m = 0 }n = m; break } case 1: { m = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = m; f[g >> 2] = f[h >> 2]; o = dc(a, c, g) | 0; break } case 2: { f[i >> 2] = m; f[g >> 2] = f[i >> 2]; o = Yb(a, c, g) | 0; break } case 3: { f[j >> 2] = m; f[g >> 2] = f[j >> 2]; o = pc(a, c, g) | 0; break } case 4: { f[k >> 2] = m; f[g >> 2] = f[k >> 2]; o = ic(a, c, g) | 0; break } default: o = 0 }n = o; break } case 11: case 2: { o = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = o; f[g >> 2] = f[h >> 2]; p = dc(a, c, g) | 0; break } case 2: { f[i >> 2] = o; f[g >> 2] = f[i >> 2]; p = Yb(a, c, g) | 0; break } case 3: { f[j >> 2] = o; f[g >> 2] = f[j >> 2]; p = pc(a, c, g) | 0; break } case 4: { f[k >> 2] = o; f[g >> 2] = f[k >> 2]; p = ic(a, c, g) | 0; break } default: p = 0 }n = p; break } case 4: { p = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = p; f[g >> 2] = f[h >> 2]; q = bc(a, c, g) | 0; break } case 2: { f[i >> 2] = p; f[g >> 2] = f[i >> 2]; q = Vb(a, c, g) | 0; break } case 3: { f[j >> 2] = p; f[g >> 2] = f[j >> 2]; q = kc(a, c, g) | 0; break } case 4: { f[k >> 2] = p; f[g >> 2] = f[k >> 2]; q = gc(a, c, g) | 0; break } default: q = 0 }n = q; break } case 3: { q = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = q; f[g >> 2] = f[h >> 2]; r = bc(a, c, g) | 0; break } case 2: { f[i >> 2] = q; f[g >> 2] = f[i >> 2]; r = Vb(a, c, g) | 0; break } case 3: { f[j >> 2] = q; f[g >> 2] = f[j >> 2]; r = kc(a, c, g) | 0; break } case 4: { f[k >> 2] = q; f[g >> 2] = f[k >> 2]; r = gc(a, c, g) | 0; break } default: r = 0 }n = r; break } case 6: { r = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = r; f[g >> 2] = f[h >> 2]; s = ec(a, c, g) | 0; break } case 2: { f[i >> 2] = r; f[g >> 2] = f[i >> 2]; s = Xb(a, c, g) | 0; break } case 3: { f[j >> 2] = r; f[g >> 2] = f[j >> 2]; s = rc(a, c, g) | 0; break } case 4: { f[k >> 2] = r; f[g >> 2] = f[k >> 2]; s = jc(a, c, g) | 0; break } default: s = 0 }n = s; break } case 5: { s = f[d >> 2] | 0; switch (b[c + 24 >> 0] | 0) { case 1: { f[h >> 2] = s; f[g >> 2] = f[h >> 2]; t = ec(a, c, g) | 0; break } case 2: { f[i >> 2] = s; f[g >> 2] = f[i >> 2]; t = Xb(a, c, g) | 0; break } case 3: { f[j >> 2] = s; f[g >> 2] = f[j >> 2]; t = rc(a, c, g) | 0; break } case 4: { f[k >> 2] = s; f[g >> 2] = f[k >> 2]; t = jc(a, c, g) | 0; break } default: t = 0 }n = t; break } default: { v = -1; u = e; return v | 0 } }v = (n | 0) == 0 ? -1 : n; u = e; return v | 0 } function uc(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0; e = u; u = u + 32 | 0; g = e + 16 | 0; h = e + 12 | 0; i = e + 29 | 0; j = e; k = e + 28 | 0; if (!(f[(f[a + 8 >> 2] | 0) + 80 >> 2] | 0)) { l = 1; u = e; return l | 0 } b[i >> 0] = -2; m = a + 36 | 0; n = f[m >> 2] | 0; if (n) if (Ra[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a, n) | 0) { n = f[m >> 2] | 0; o = (Qa[f[(f[n >> 2] | 0) + 8 >> 2] & 127](n) | 0) & 255; b[i >> 0] = o; p = 5 } else q = 0; else p = 5; if ((p | 0) == 5) { o = d + 16 | 0; n = o; r = f[n + 4 >> 2] | 0; if (!((r | 0) > 0 | (r | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, i, i + 1 | 0) | 0 } i = f[m >> 2] | 0; if (i | 0 ? (n = (Qa[f[(f[i >> 2] | 0) + 36 >> 2] & 127](i) | 0) & 255, b[j >> 0] = n, n = o, i = f[n + 4 >> 2] | 0, !((i | 0) > 0 | (i | 0) == 0 & (f[n >> 2] | 0) >>> 0 > 0)) : 0) { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, j, j + 1 | 0) | 0 } n = f[a + 32 >> 2] | 0; i = b[n + 24 >> 0] | 0; r = X(f[n + 80 >> 2] | 0, i) | 0; s = (f[f[n >> 2] >> 2] | 0) + (f[n + 48 >> 2] | 0) | 0; f[j >> 2] = 0; n = j + 4 | 0; f[n >> 2] = 0; f[j + 8 >> 2] = 0; t = (r | 0) == 0; do if (!t) if (r >>> 0 > 1073741823) mq(j); else { v = r << 2; w = dn(v) | 0; f[j >> 2] = w; x = w + (r << 2) | 0; f[j + 8 >> 2] = x; hj(w | 0, 0, v | 0) | 0; f[n >> 2] = x; y = w; break } else y = 0; while (0); w = f[m >> 2] | 0; do if (w) { Ta[f[(f[w >> 2] | 0) + 44 >> 2] & 31](w, s, y, r, i, f[c >> 2] | 0) | 0; x = f[m >> 2] | 0; if (!x) { z = s; A = f[j >> 2] | 0; p = 20; break } if (!(Qa[f[(f[x >> 2] | 0) + 32 >> 2] & 127](x) | 0)) { x = f[j >> 2] | 0; z = f[m >> 2] | 0 ? x : s; A = x; p = 20 } } else { z = s; A = y; p = 20 } while (0); if ((p | 0) == 20) km(z, r, A); A = a + 4 | 0; a = f[A >> 2] | 0; do if (a) { z = f[a + 48 >> 2] | 0; f[g >> 2] = 0; f[g + 4 >> 2] = 0; f[g + 8 >> 2] = 0; y = dn(48) | 0; f[g >> 2] = y; f[g + 8 >> 2] = -2147483600; f[g + 4 >> 2] = 34; s = y; w = 9835; x = s + 34 | 0; do { b[s >> 0] = b[w >> 0] | 0; s = s + 1 | 0; w = w + 1 | 0 } while ((s | 0) < (x | 0)); b[y + 34 >> 0] = 0; w = Oj(z, g, 1) | 0; if ((b[g + 11 >> 0] | 0) < 0) br(f[g >> 2] | 0); if (!w) { if (!t) { w = f[j >> 2] | 0; s = 0; x = 0; do { x = f[w + (s << 2) >> 2] | x; s = s + 1 | 0 } while ((s | 0) != (r | 0)); if (x) B = ((_(x | 0) | 0) >>> 3 ^ 3) + 1 | 0; else B = 1 } else B = 1; b[k >> 0] = 0; s = o; w = f[s >> 2] | 0; z = f[s + 4 >> 2] | 0; if ((z | 0) > 0 | (z | 0) == 0 & w >>> 0 > 0) { C = z; D = w } else { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, k, k + 1 | 0) | 0; w = o; C = f[w + 4 >> 2] | 0; D = f[w >> 2] | 0 } b[k >> 0] = B; if (!((C | 0) > 0 | (C | 0) == 0 & D >>> 0 > 0)) { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, k, k + 1 | 0) | 0 } if ((B | 0) == (Ll(5) | 0)) { w = f[j >> 2] | 0; z = o; s = f[z + 4 >> 2] | 0; if (!((s | 0) > 0 | (s | 0) == 0 & (f[z >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, w, w + (r << 2) | 0) | 0 } p = 48; break } if (t) p = 48; else { w = d + 4 | 0; z = 0; do { s = (f[j >> 2] | 0) + (z << 2) | 0; y = o; v = f[y + 4 >> 2] | 0; if (!((v | 0) > 0 | (v | 0) == 0 & (f[y >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[w >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, s, s + B | 0) | 0 } z = z + 1 | 0 } while (z >>> 0 < r >>> 0); p = 48 } } else p = 27 } else p = 27; while (0); if ((p | 0) == 27) { b[k >> 0] = 1; r = o; o = f[r + 4 >> 2] | 0; if (!((o | 0) > 0 | (o | 0) == 0 & (f[r >> 2] | 0) >>> 0 > 0)) { f[h >> 2] = f[d + 4 >> 2]; f[g >> 2] = f[h >> 2]; ye(d, g, k, k + 1 | 0) | 0 } wp(g); k = f[A >> 2] | 0; if (k | 0) Pj(g, 10 - (Yh(f[k + 48 >> 2] | 0) | 0) | 0) | 0; k = Dc(f[j >> 2] | 0, X((f[c + 4 >> 2] | 0) - (f[c >> 2] | 0) >> 2, i) | 0, i, g, d) | 0; sj(g, f[g + 4 >> 2] | 0); if (k) p = 48; else E = 0 } if ((p | 0) == 48) { p = f[m >> 2] | 0; if (!p) E = 1; else { Ra[f[(f[p >> 2] | 0) + 40 >> 2] & 127](p, d) | 0; E = 1 } } d = f[j >> 2] | 0; if (d | 0) { j = f[n >> 2] | 0; if ((j | 0) != (d | 0)) f[n >> 2] = j + (~((j + -4 - d | 0) >>> 2) << 2); br(d) } q = E } l = q; u = e; return l | 0 } function vc(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0; b = u; u = u + 48 | 0; c = b + 24 | 0; d = b + 12 | 0; e = b; g = a + 32 | 0; h = a + 8 | 0; i = a + 12 | 0; j = f[i >> 2] | 0; k = f[h >> 2] | 0; l = j - k >> 2; m = a + 36 | 0; n = f[m >> 2] | 0; o = f[g >> 2] | 0; p = n - o >> 2; q = o; o = n; n = k; if (l >>> 0 <= p >>> 0) if (l >>> 0 < p >>> 0 ? (r = q + (l << 2) | 0, (r | 0) != (o | 0)) : 0) { f[m >> 2] = o + (~((o + -4 - r | 0) >>> 2) << 2); s = n; t = k; v = j } else { s = n; t = k; v = j } else { oi(g, l - p | 0); p = f[h >> 2] | 0; s = p; t = p; v = f[i >> 2] | 0 } p = v - t | 0; l = p >> 2; f[c >> 2] = 0; j = c + 4 | 0; f[j >> 2] = 0; k = c + 8 | 0; f[k >> 2] = 0; if (l | 0) { if ((p | 0) < 0) mq(c); p = ((l + -1 | 0) >>> 5) + 1 | 0; n = dn(p << 2) | 0; f[c >> 2] = n; f[k >> 2] = p; f[j >> 2] = l; j = l >>> 5; hj(n | 0, 0, j << 2 | 0) | 0; p = l & 31; l = n + (j << 2) | 0; if (p | 0) f[l >> 2] = f[l >> 2] & ~(-1 >>> (32 - p | 0)) } p = a + 20 | 0; l = 0; j = s; s = t; t = v; while (1) { if (l >>> 0 < t - s >> 2 >>> 0) { w = 0; x = 0; y = l; z = s; A = j } else { B = 25; break } while (1) { v = x >>> 5; n = 1 << (x & 31); do if (!(f[(f[c >> 2] | 0) + (v << 2) >> 2] & n)) { k = f[A + (x << 2) >> 2] | 0; if ((f[k + 8 >> 2] | 0) != (f[k + 4 >> 2] | 0)) { r = 0; o = 1; m = A; q = k; while (1) { k = f[(f[q + 4 >> 2] | 0) + (r << 2) >> 2] | 0; C = 0; D = m; while (1) { E = f[D + (x << 2) >> 2] | 0; if ((C | 0) >= (Ra[f[(f[E >> 2] | 0) + 24 >> 2] & 127](E, k) | 0)) { F = o; break } E = f[(f[h >> 2] | 0) + (x << 2) >> 2] | 0; G = Sa[f[(f[E >> 2] | 0) + 28 >> 2] & 31](E, k, C) | 0; if ((G | 0) != (x | 0) ? (E = f[(f[p >> 2] | 0) + (G << 2) >> 2] | 0, (1 << (E & 31) & f[(f[c >> 2] | 0) + (E >>> 5 << 2) >> 2] | 0) == 0) : 0) { F = 0; break } C = C + 1 | 0; D = f[h >> 2] | 0 } r = r + 1 | 0; m = f[h >> 2] | 0; q = f[m + (x << 2) >> 2] | 0; if (r >>> 0 >= (f[q + 8 >> 2] | 0) - (f[q + 4 >> 2] | 0) >> 2 >>> 0) break; else o = F } o = m; if (F) H = o; else { I = w; J = y; K = o; break } } else H = z; f[(f[g >> 2] | 0) + (y << 2) >> 2] = x; o = (f[c >> 2] | 0) + (v << 2) | 0; f[o >> 2] = f[o >> 2] | n; I = 1; J = y + 1 | 0; K = H } else { I = w; J = y; K = z } while (0); x = x + 1 | 0; L = f[i >> 2] | 0; M = L - K >> 2; A = K; if (x >>> 0 >= M >>> 0) break; else { w = I; y = J; z = K } } if (J >>> 0 < M >>> 0 & (I ^ 1)) { N = 0; break } else { l = J; j = A; s = K; t = L } } if ((B | 0) == 25) { f[d >> 2] = 0; B = d + 4 | 0; f[B >> 2] = 0; f[d + 8 >> 2] = 0; L = f[a + 4 >> 2] | 0; a = (f[L + 12 >> 2] | 0) - (f[L + 8 >> 2] | 0) | 0; L = a >> 2; f[e >> 2] = 0; K = e + 4 | 0; f[K >> 2] = 0; A = e + 8 | 0; f[A >> 2] = 0; if (L | 0) { if ((a | 0) < 0) mq(e); a = ((L + -1 | 0) >>> 5) + 1 | 0; J = dn(a << 2) | 0; f[e >> 2] = J; f[A >> 2] = a; f[K >> 2] = L; K = L >>> 5; hj(J | 0, 0, K << 2 | 0) | 0; a = L & 31; L = J + (K << 2) | 0; if (a | 0) f[L >> 2] = f[L >> 2] & ~(-1 >>> (32 - a | 0)) } a: do if ((t | 0) == (s | 0)) O = 1; else { a = 0; L = j; K = s; J = t; while (1) { A = f[(f[g >> 2] | 0) + (a << 2) >> 2] | 0; l = f[L + (A << 2) >> 2] | 0; I = (f[l + 8 >> 2] | 0) - (f[l + 4 >> 2] | 0) | 0; l = I >> 2; if ((I | 0) < 8) { P = K; Q = J } else { I = f[B >> 2] | 0; M = f[d >> 2] | 0; z = I - M >> 2; y = M; M = I; if (l >>> 0 <= z >>> 0) if (l >>> 0 < z >>> 0 ? (I = y + (l << 2) | 0, (I | 0) != (M | 0)) : 0) { f[B >> 2] = M + (~((M + -4 - I | 0) >>> 2) << 2); R = 0 } else R = 0; else { oi(d, l - z | 0); R = 0 } while (1) { if ((R | 0) < (l | 0)) { S = 0; T = 0; U = R } else break; while (1) { z = f[(f[h >> 2] | 0) + (A << 2) >> 2] | 0; I = f[(f[z + 4 >> 2] | 0) + (S << 2) >> 2] | 0; M = S >>> 5; y = 1 << (S & 31); if (!(f[(f[e >> 2] | 0) + (M << 2) >> 2] & y)) { w = 0; x = 1; H = z; while (1) { if ((w | 0) >= (Ra[f[(f[H >> 2] | 0) + 24 >> 2] & 127](H, I) | 0)) { V = x; break } z = f[(f[h >> 2] | 0) + (A << 2) >> 2] | 0; F = Sa[f[(f[z >> 2] | 0) + 28 >> 2] & 31](z, I, w) | 0; z = (f[(f[e >> 2] | 0) + (F >>> 5 << 2) >> 2] & 1 << (F & 31) | 0) != 0; F = x & z; if (!z) { V = F; break } w = w + 1 | 0; x = F; H = f[(f[h >> 2] | 0) + (A << 2) >> 2] | 0 } if (V) { f[(f[d >> 2] | 0) + (U << 2) >> 2] = S; H = (f[e >> 2] | 0) + (M << 2) | 0; f[H >> 2] = f[H >> 2] | y; W = 1; X = U + 1 | 0 } else { W = T; X = U } } else { W = T; X = U } S = S + 1 | 0; if ((S | 0) >= (l | 0)) break; else { T = W; U = X } } if (W | (X | 0) >= (l | 0)) R = X; else { O = 0; break a } } Of(f[(f[h >> 2] | 0) + (A << 2) >> 2] | 0, d); P = f[h >> 2] | 0; Q = f[i >> 2] | 0 } a = a + 1 | 0; if (a >>> 0 >= Q - P >> 2 >>> 0) { O = 1; break } else { L = P; K = P; J = Q } } } while (0); Q = f[e >> 2] | 0; if (Q | 0) br(Q); Q = f[d >> 2] | 0; if (Q | 0) { d = f[B >> 2] | 0; if ((d | 0) != (Q | 0)) f[B >> 2] = d + (~((d + -4 - Q | 0) >>> 2) << 2); br(Q) } N = O } O = f[c >> 2] | 0; if (!O) { u = b; return N | 0 } br(O); u = b; return N | 0 }
    function uj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0; e = u; u = u + 16 | 0; g = e; h = a + 4 | 0; f[h >> 2] = c; i = f[c + 64 >> 2] | 0; c = ((f[i + 4 >> 2] | 0) - (f[i >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[g >> 0] = 0; Xg(a + 24 | 0, c, g); c = f[h >> 2] | 0; h = (f[c + 56 >> 2] | 0) - (f[c + 52 >> 2] | 0) >> 2; b[g >> 0] = 0; Xg(a + 36 | 0, h, g); g = a + 8 | 0; f[g >> 2] = f[d >> 2]; f[g + 4 >> 2] = f[d + 4 >> 2]; f[g + 8 >> 2] = f[d + 8 >> 2]; f[g + 12 >> 2] = f[d + 12 >> 2]; u = e; return } function vj(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0; c = a; a: do if (!(c & 3)) { d = a; e = 4 } else { g = a; h = c; while (1) { if (!(b[g >> 0] | 0)) { i = h; break a } j = g + 1 | 0; h = j; if (!(h & 3)) { d = j; e = 4; break } else g = j } } while (0); if ((e | 0) == 4) { e = d; while (1) { k = f[e >> 2] | 0; if (!((k & -2139062144 ^ -2139062144) & k + -16843009)) e = e + 4 | 0; else break } if (!((k & 255) << 24 >> 24)) l = e; else { k = e; while (1) { e = k + 1 | 0; if (!(b[e >> 0] | 0)) { l = e; break } else k = e } } i = l } return i - c | 0 } function wj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; e = u; u = u + 16 | 0; g = e; h = a + 11 | 0; i = b[h >> 0] | 0; j = i << 24 >> 24 < 0; if (j) k = f[a + 4 >> 2] | 0; else k = i & 255; do if (k >>> 0 >= c >>> 0) if (j) { i = (f[a >> 2] | 0) + c | 0; b[g >> 0] = 0; Hp(i, g); f[a + 4 >> 2] = c; break } else { b[g >> 0] = 0; Hp(a + c | 0, g); b[h >> 0] = c; break } else Xi(a, c - k | 0, d) | 0; while (0); u = e; return } function xj(a) { a = a | 0; var b = 0, c = 0, d = 0; if (!a) return; b = a + 88 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) { b = f[c + 8 >> 2] | 0; if (b | 0) { d = c + 12 | 0; if ((f[d >> 2] | 0) != (b | 0)) f[d >> 2] = b; br(b) } br(c) } c = f[a + 68 >> 2] | 0; if (c | 0) { b = a + 72 | 0; d = f[b >> 2] | 0; if ((d | 0) != (c | 0)) f[b >> 2] = d + (~((d + -4 - c | 0) >>> 2) << 2); br(c) } c = a + 64 | 0; d = f[c >> 2] | 0; f[c >> 2] = 0; if (d | 0) { c = f[d >> 2] | 0; if (c | 0) { b = d + 4 | 0; if ((f[b >> 2] | 0) != (c | 0)) f[b >> 2] = c; br(c) } br(d) } br(a); return } function yj(a, c, d, e, g, h, i, j, k, l) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; h = h | 0; i = i | 0; j = j | 0; k = k | 0; l = l | 0; var m = 0, n = 0, o = 0; f[a >> 2] = d; if (d | 0) { m = d + 16 | 0; n = f[m + 4 >> 2] | 0; o = a + 8 | 0; f[o >> 2] = f[m >> 2]; f[o + 4 >> 2] = n; n = d + 24 | 0; d = f[n + 4 >> 2] | 0; o = a + 16 | 0; f[o >> 2] = f[n >> 2]; f[o + 4 >> 2] = d } b[a + 24 >> 0] = e; f[a + 28 >> 2] = g; b[a + 32 >> 0] = h & 1; h = a + 40 | 0; f[h >> 2] = i; f[h + 4 >> 2] = j; j = a + 48 | 0; f[j >> 2] = k; f[j + 4 >> 2] = l; f[a + 56 >> 2] = c; return } function zj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; if ((f[c + 76 >> 2] | 0) >= 0 ? (gr(c) | 0) != 0 : 0) { d = a & 255; e = a & 255; if ((e | 0) != (b[c + 75 >> 0] | 0) ? (g = c + 20 | 0, h = f[g >> 2] | 0, h >>> 0 < (f[c + 16 >> 2] | 0) >>> 0) : 0) { f[g >> 2] = h + 1; b[h >> 0] = d; i = e } else i = Bj(c, a) | 0; fr(c); j = i } else k = 3; do if ((k | 0) == 3) { i = a & 255; e = a & 255; if ((e | 0) != (b[c + 75 >> 0] | 0) ? (d = c + 20 | 0, h = f[d >> 2] | 0, h >>> 0 < (f[c + 16 >> 2] | 0) >>> 0) : 0) { f[d >> 2] = h + 1; b[h >> 0] = i; j = e; break } j = Bj(c, a) | 0 } while (0); return j | 0 } function Aj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = u; u = u + 16 | 0; e = d + 4 | 0; g = d; h = d + 8 | 0; i = f[a + 4 >> 2] | 0; if ((i | 0) == -1) { j = 0; u = d; return j | 0 } b[h >> 0] = i; i = c + 16 | 0; a = f[i + 4 >> 2] | 0; if (!((a | 0) > 0 | (a | 0) == 0 & (f[i >> 2] | 0) >>> 0 > 0)) { f[g >> 2] = f[c + 4 >> 2]; f[e >> 2] = f[g >> 2]; ye(c, e, h, h + 1 | 0) | 0 } j = 1; u = d; return j | 0 } function Bj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0; d = u; u = u + 16 | 0; e = d; g = c & 255; b[e >> 0] = g; i = a + 16 | 0; j = f[i >> 2] | 0; if (!j) if (!(pl(a) | 0)) { k = f[i >> 2] | 0; l = 4 } else m = -1; else { k = j; l = 4 } do if ((l | 0) == 4) { j = a + 20 | 0; i = f[j >> 2] | 0; if (i >>> 0 < k >>> 0 ? (n = c & 255, (n | 0) != (b[a + 75 >> 0] | 0)) : 0) { f[j >> 2] = i + 1; b[i >> 0] = g; m = n; break } if ((Sa[f[a + 36 >> 2] & 31](a, e, 1) | 0) == 1) m = h[e >> 0] | 0; else m = -1 } while (0); u = d; return m | 0 } function Cj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0; c = dn(88) | 0; d = c + 60 | 0; e = c; g = e + 60 | 0; do { f[e >> 2] = 0; e = e + 4 | 0 } while ((e | 0) < (g | 0)); f[d >> 2] = c; d = c + 64 | 0; f[d >> 2] = 0; f[d + 4 >> 2] = 0; f[d + 8 >> 2] = 0; f[d + 12 >> 2] = 0; f[d + 16 >> 2] = 0; f[d + 20 >> 2] = 0; d = Kf(c, b) | 0; f[a >> 2] = d ? c : 0; a = d ? 0 : c; if (d) return; ui(a); br(a); return } function Dj(a, b) { a = a | 0; b = b | 0; if (!b) return; else { Dj(a, f[b >> 2] | 0); Dj(a, f[b + 4 >> 2] | 0); sj(b + 20 | 0, f[b + 24 >> 2] | 0); br(b); return } } function Ej(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0; e = u; u = u + 16 | 0; g = e; h = a + 4 | 0; f[h >> 2] = c; i = ((f[c + 4 >> 2] | 0) - (f[c >> 2] | 0) >> 2 >>> 0) / 3 | 0; b[g >> 0] = 0; Xg(a + 24 | 0, i, g); i = f[h >> 2] | 0; h = (f[i + 28 >> 2] | 0) - (f[i + 24 >> 2] | 0) >> 2; b[g >> 0] = 0; Xg(a + 36 | 0, h, g); g = a + 8 | 0; f[g >> 2] = f[d >> 2]; f[g + 4 >> 2] = f[d + 4 >> 2]; f[g + 8 >> 2] = f[d + 8 >> 2]; f[g + 12 >> 2] = f[d + 12 >> 2]; u = e; return } function Fj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; e = u; u = u + 16 | 0; g = e; h = e + 4 | 0; f[g >> 2] = c; c = a + 4 | 0; a = dn(32) | 0; f[h >> 2] = a; f[h + 8 >> 2] = -2147483616; f[h + 4 >> 2] = 17; i = a; j = 12932; k = i + 17 | 0; do { b[i >> 0] = b[j >> 0] | 0; i = i + 1 | 0; j = j + 1 | 0 } while ((i | 0) < (k | 0)); b[a + 17 >> 0] = 0; Nj(wd(c, g) | 0, h, d); if ((b[h + 11 >> 0] | 0) >= 0) { u = e; return } br(f[h >> 2] | 0); u = e; return } function Gj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; c = f[a + 16 >> 2] | 0; if (((f[a + 20 >> 2] | 0) - c >> 2 | 0) <= (b | 0)) { d = 0; return d | 0 } e = f[c + (b << 2) >> 2] | 0; if ((e | 0) < 0) { d = 0; return d | 0 } b = a + 48 | 0; if ((f[a + 52 >> 2] | 0) >>> 0 <= e >>> 0) pe(b, e + 1 | 0, 0); c = (f[b >> 2] | 0) + (e >>> 5 << 2) | 0; f[c >> 2] = f[c >> 2] | 1 << (e & 31); c = f[a + 36 >> 2] | 0; if ((f[a + 40 >> 2] | 0) - c >> 2 >>> 0 <= e >>> 0) { d = 1; return d | 0 } Pp(f[c + (e << 2) >> 2] | 0); d = 1; return d | 0 } function Hj(a) { a = a | 0; if (!a) return; f[a >> 2] = 1136; sj(a + 28 | 0, f[a + 32 >> 2] | 0); nj(a + 16 | 0, f[a + 20 >> 2] | 0); sj(a + 4 | 0, f[a + 8 >> 2] | 0); br(a); return } function Ij(a) { a = a | 0; f[a >> 2] = 1136; sj(a + 28 | 0, f[a + 32 >> 2] | 0); nj(a + 16 | 0, f[a + 20 >> 2] | 0); sj(a + 4 | 0, f[a + 8 >> 2] | 0); return } function Jj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, f = 0, g = 0, h = 0, i = 0, j = 0; if (c >>> 0 > 0 | (c | 0) == 0 & a >>> 0 > 4294967295) { e = d; f = a; g = c; while (1) { c = an(f | 0, g | 0, 10, 0) | 0; e = e + -1 | 0; b[e >> 0] = c & 255 | 48; c = f; f = up(f | 0, g | 0, 10, 0) | 0; if (!(g >>> 0 > 9 | (g | 0) == 9 & c >>> 0 > 4294967295)) break; else g = I } h = f; i = e } else { h = a; i = d } if (!h) j = i; else { d = h; h = i; while (1) { i = h + -1 | 0; b[i >> 0] = (d >>> 0) % 10 | 0 | 48; if (d >>> 0 < 10) { j = i; break } else { d = (d >>> 0) / 10 | 0; h = i } } } return j | 0 } function Kj(a) { a = a | 0; var c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0; c = a; while (1) { d = c + 1 | 0; if (!(tq(b[c >> 0] | 0) | 0)) break; else c = d } a = b[c >> 0] | 0; switch (a << 24 >> 24 | 0) { case 45: { e = 1; f = 5; break } case 43: { e = 0; f = 5; break } default: { g = 0; h = c; i = a } }if ((f | 0) == 5) { g = e; h = d; i = b[d >> 0] | 0 } if (!(Pq(i << 24 >> 24) | 0)) j = 0; else { i = 0; d = h; while (1) { h = (i * 10 | 0) + 48 - (b[d >> 0] | 0) | 0; d = d + 1 | 0; if (!(Pq(b[d >> 0] | 0) | 0)) { j = h; break } else i = h } } return (g | 0 ? j : 0 - j | 0) | 0 } function Lj(a, c, d) { a = a | 0; c = c | 0; d = $(d); var e = 0, g = 0, h = 0; e = u; u = u + 16 | 0; g = e; cl(g, d); h = mi(a, c) | 0; c = h + 11 | 0; if ((b[c >> 0] | 0) < 0) { b[f[h >> 2] >> 0] = 0; f[h + 4 >> 2] = 0 } else { b[h >> 0] = 0; b[c >> 0] = 0 } Ng(h, 0); f[h >> 2] = f[g >> 2]; f[h + 4 >> 2] = f[g + 4 >> 2]; f[h + 8 >> 2] = f[g + 8 >> 2]; u = e; return } function Mj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0; e = u; u = u + 16 | 0; g = e; fl(g, d & 1); d = mi(a, c) | 0; c = d + 11 | 0; if ((b[c >> 0] | 0) < 0) { b[f[d >> 2] >> 0] = 0; f[d + 4 >> 2] = 0 } else { b[d >> 0] = 0; b[c >> 0] = 0 } Ng(d, 0); f[d >> 2] = f[g >> 2]; f[d + 4 >> 2] = f[g + 4 >> 2]; f[d + 8 >> 2] = f[g + 8 >> 2]; u = e; return } function Nj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0; e = u; u = u + 16 | 0; g = e; fl(g, d); d = mi(a, c) | 0; c = d + 11 | 0; if ((b[c >> 0] | 0) < 0) { b[f[d >> 2] >> 0] = 0; f[d + 4 >> 2] = 0 } else { b[d >> 0] = 0; b[c >> 0] = 0 } Ng(d, 0); f[d >> 2] = f[g >> 2]; f[d + 4 >> 2] = f[g + 4 >> 2]; f[d + 8 >> 2] = f[g + 8 >> 2]; u = e; return } function Oj(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; e = zg(a, c) | 0; if ((e | 0) == (a + 4 | 0)) { g = -1; h = (g | 0) == -1; i = (g | 0) != 0; j = h ? d : i; return j | 0 } a = e + 28 | 0; if ((b[a + 11 >> 0] | 0) < 0) k = f[a >> 2] | 0; else k = a; g = Kj(k) | 0; h = (g | 0) == -1; i = (g | 0) != 0; j = h ? d : i; return j | 0 } function Pj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0, k = 0; d = u; u = u + 16 | 0; e = d; if (c >>> 0 > 10) { g = 0; u = d; return g | 0 } h = dn(48) | 0; f[e >> 2] = h; f[e + 8 >> 2] = -2147483600; f[e + 4 >> 2] = 33; i = h; j = 13067; k = i + 33 | 0; do { b[i >> 0] = b[j >> 0] | 0; i = i + 1 | 0; j = j + 1 | 0 } while ((i | 0) < (k | 0)); b[h + 33 >> 0] = 0; Nj(a, e, c); if ((b[e + 11 >> 0] | 0) < 0) br(f[e >> 2] | 0); g = 1; u = d; return g | 0 } function Qj(a) { a = a | 0; f[a >> 2] = 1136; sj(a + 28 | 0, f[a + 32 >> 2] | 0); nj(a + 16 | 0, f[a + 20 >> 2] | 0); sj(a + 4 | 0, f[a + 8 >> 2] | 0); br(a); return } function Rj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; c = f[b >> 2] | 0; if ((c | 0) == -1) return 1; b = c * 3 | 0; if ((b | 0) == -1) return 1; c = f[a >> 2] | 0; a = f[c + (b << 2) >> 2] | 0; d = b + 1 | 0; e = ((d >>> 0) % 3 | 0 | 0) == 0 ? b + -2 | 0 : d; if ((e | 0) == -1) g = -1; else g = f[c + (e << 2) >> 2] | 0; e = (((b >>> 0) % 3 | 0 | 0) == 0 ? 2 : -1) + b | 0; if ((e | 0) == -1) h = -1; else h = f[c + (e << 2) >> 2] | 0; if ((a | 0) == (g | 0)) return 1; else return (a | 0) == (h | 0) | (g | 0) == (h | 0) | 0; return 0 } function Sj(a) { a = a | 0; f[a >> 2] = 2968; sj(a + 28 | 0, f[a + 32 >> 2] | 0); Dj(a + 16 | 0, f[a + 20 >> 2] | 0); sj(a + 4 | 0, f[a + 8 >> 2] | 0); return } function Tj(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0, j = 0, k = 0; d = 0; while (1) { if ((h[15560 + d >> 0] | 0) == (a | 0)) { e = 2; break } g = d + 1 | 0; if ((g | 0) == 87) { i = 15648; j = 87; e = 5; break } else d = g } if ((e | 0) == 2) if (!d) k = 15648; else { i = 15648; j = d; e = 5 } if ((e | 0) == 5) while (1) { e = 0; d = i; do { a = d; d = d + 1 | 0 } while ((b[a >> 0] | 0) != 0); j = j + -1 | 0; if (!j) { k = d; break } else { i = d; e = 5 } } return yq(k, f[c + 20 >> 2] | 0) | 0 } function Uj(a, b) { a = +a; b = b | 0; var c = 0, d = 0, e = 0, g = 0.0, h = 0.0, i = 0, j = 0.0; p[s >> 3] = a; c = f[s >> 2] | 0; d = f[s + 4 >> 2] | 0; e = Wn(c | 0, d | 0, 52) | 0; switch (e & 2047) { case 0: { if (a != 0.0) { g = +Uj(a * 18446744073709551616.0, b); h = g; i = (f[b >> 2] | 0) + -64 | 0 } else { h = a; i = 0 } f[b >> 2] = i; j = h; break } case 2047: { j = a; break } default: { f[b >> 2] = (e & 2047) + -1022; f[s >> 2] = c; f[s + 4 >> 2] = d & -2146435073 | 1071644672; j = +p[s >> 3] } }return +j } function Vj(a) { a = a | 0; f[a >> 2] = 2968; sj(a + 28 | 0, f[a + 32 >> 2] | 0); Dj(a + 16 | 0, f[a + 20 >> 2] | 0); sj(a + 4 | 0, f[a + 8 >> 2] | 0); br(a); return } function Wj(a, b) { a = +a; b = b | 0; var c = 0.0, d = 0, e = 0, g = 0.0, h = 0; if ((b | 0) <= 1023) if ((b | 0) < -1022) { c = a * 2.2250738585072014e-308; d = (b | 0) < -2044; e = b + 2044 | 0; g = d ? c * 2.2250738585072014e-308 : c; h = d ? ((e | 0) > -1022 ? e : -1022) : b + 1022 | 0 } else { g = a; h = b } else { c = a * 8988465674311579538646525.0e283; e = (b | 0) > 2046; d = b + -2046 | 0; g = e ? c * 8988465674311579538646525.0e283 : c; h = e ? ((d | 0) < 1023 ? d : 1023) : b + -1023 | 0 } b = Rn(h + 1023 | 0, 0, 52) | 0; h = I; f[s >> 2] = b; f[s + 4 >> 2] = h; return +(g * +p[s >> 3]) } function Xj(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; if (!(f[a + 80 >> 2] | 0)) { b = 0; return b | 0 } c = a + 8 | 0; d = a + 12 | 0; a = f[c >> 2] | 0; if (((f[d >> 2] | 0) - a | 0) > 0) { e = 0; g = a } else { b = 1; return b | 0 } while (1) { a = f[g + (e << 2) >> 2] | 0; e = e + 1 | 0; if (!(yl(a, a) | 0)) { b = 0; h = 5; break } g = f[c >> 2] | 0; if ((e | 0) >= ((f[d >> 2] | 0) - g >> 2 | 0)) { b = 1; h = 5; break } } if ((h | 0) == 5) return b | 0; return 0 } function Yj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; c = a + 36 | 0; d = a + 40 | 0; e = f[c >> 2] | 0; if ((f[d >> 2] | 0) == (e | 0)) { g = 1; return g | 0 } h = a + 60 | 0; a = 0; i = e; while (1) { e = f[i + (a << 2) >> 2] | 0; a = a + 1 | 0; if (!(Sa[f[(f[e >> 2] | 0) + 20 >> 2] & 31](e, h, b) | 0)) { g = 0; j = 5; break } i = f[c >> 2] | 0; if (a >>> 0 >= (f[d >> 2] | 0) - i >> 2 >>> 0) { g = 1; j = 5; break } } if ((j | 0) == 5) return g | 0; return 0 } function Zj(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; c = a + 36 | 0; d = a + 40 | 0; a = f[c >> 2] | 0; if ((f[d >> 2] | 0) == (a | 0)) { e = 1; return e | 0 } else { g = 0; h = a } while (1) { a = f[h + (g << 2) >> 2] | 0; g = g + 1 | 0; if (!(Ra[f[(f[a >> 2] | 0) + 24 >> 2] & 127](a, b) | 0)) { e = 0; i = 4; break } h = f[c >> 2] | 0; if (g >>> 0 >= (f[d >> 2] | 0) - h >> 2 >>> 0) { e = 1; i = 4; break } } if ((i | 0) == 4) return e | 0; return 0 } function _j(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; f[a >> 2] = 0; c = a + 4 | 0; f[c >> 2] = 0; f[a + 8 >> 2] = 0; d = b + 4 | 0; e = (f[d >> 2] | 0) - (f[b >> 2] | 0) | 0; g = e >> 2; if (!g) return; if (g >>> 0 > 1073741823) mq(a); h = dn(e) | 0; f[c >> 2] = h; f[a >> 2] = h; f[a + 8 >> 2] = h + (g << 2); g = f[b >> 2] | 0; b = (f[d >> 2] | 0) - g | 0; if ((b | 0) <= 0) return; Rg(h | 0, g | 0, b | 0) | 0; f[c >> 2] = h + (b >>> 2 << 2); return } function $j(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; c = a + 8 | 0; d = f[a >> 2] | 0; if ((f[c >> 2] | 0) - d >> 2 >>> 0 >= b >>> 0) return; e = a + 4 | 0; if (b >>> 0 > 1073741823) { g = ra(8) | 0; Wo(g, 14941); f[g >> 2] = 6944; va(g | 0, 1080, 114) } g = (f[e >> 2] | 0) - d | 0; h = dn(b << 2) | 0; if ((g | 0) > 0) Rg(h | 0, d | 0, g | 0) | 0; f[a >> 2] = h; f[e >> 2] = h + (g >> 2 << 2); f[c >> 2] = h + (b << 2); if (!d) return; br(d); return } function ak(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0, i = 0; b = a + 36 | 0; c = a + 40 | 0; d = f[b >> 2] | 0; if ((f[c >> 2] | 0) == (d | 0)) { e = 1; return e | 0 } g = a + 60 | 0; a = 0; h = d; while (1) { d = f[h + (a << 2) >> 2] | 0; a = a + 1 | 0; if (!(Ra[f[(f[d >> 2] | 0) + 16 >> 2] & 127](d, g) | 0)) { e = 0; i = 5; break } h = f[b >> 2] | 0; if (a >>> 0 >= (f[c >> 2] | 0) - h >> 2 >>> 0) { e = 1; i = 5; break } } if ((i | 0) == 5) return e | 0; return 0 } function bk(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; d = u; u = u + 16 | 0; e = d; g = dn(16) | 0; f[e >> 2] = g; f[e + 8 >> 2] = -2147483632; f[e + 4 >> 2] = 15; h = g; i = 12916; j = h + 15 | 0; do { b[h >> 0] = b[i >> 0] | 0; h = h + 1 | 0; i = i + 1 | 0 } while ((h | 0) < (j | 0)); b[g + 15 >> 0] = 0; Nj(a + 4 | 0, e, c); if ((b[e + 11 >> 0] | 0) >= 0) { u = d; return } br(f[e >> 2] | 0); u = d; return } function ck(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; f[a >> 2] = 0; f[a + 4 >> 2] = b; if (b | 0 ? (c = mh(b, 992, 976, 0) | 0, c | 0) : 0) { d = dn(56) | 0; Gm(d, c); c = f[a >> 2] | 0; f[a >> 2] = d; if (!c) return; Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); return } c = dn(56) | 0; Am(c, b); b = f[a >> 2] | 0; f[a >> 2] = c; if (!b) return; Va[f[(f[b >> 2] | 0) + 4 >> 2] & 127](b); return } function dk(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0; d = f[a + 176 >> 2] | 0; e = f[a + 172 >> 2] | 0; a = e; if ((d | 0) == (e | 0)) return 0; g = (d - e | 0) / 136 | 0; e = 0; while (1) { if ((f[a + (e * 136 | 0) >> 2] | 0) == (c | 0)) { h = 4; break } d = e + 1 | 0; if (d >>> 0 < g >>> 0) e = d; else { h = 6; break } } if ((h | 0) == 4) return ((b[a + (e * 136 | 0) + 100 >> 0] | 0) == 0 ? 0 : a + (e * 136 | 0) + 4 | 0) | 0; else if ((h | 0) == 6) return 0; return 0 } function ek(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; c = f[a + 72 >> 2] | 0; if (!c) { d = 0; return d | 0 } f[c + 4 >> 2] = a + 60; if (!(Qa[f[(f[c >> 2] | 0) + 12 >> 2] & 127](c) | 0)) { d = 0; return d | 0 } if (!(Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0)) { d = 0; return d | 0 } if (!(Ra[f[(f[a >> 2] | 0) + 44 >> 2] & 127](a, b) | 0)) { d = 0; return d | 0 } d = Ra[f[(f[a >> 2] | 0) + 48 >> 2] & 127](a, b) | 0; return d | 0 } function fk(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; f[a >> 2] = 0; d = a + 4 | 0; f[d >> 2] = 0; f[a + 8 >> 2] = 0; if (!b) return; if (b >>> 0 > 357913941) mq(a); e = dn(b * 12 | 0) | 0; f[d >> 2] = e; f[a >> 2] = e; f[a + 8 >> 2] = e + (b * 12 | 0); a = b; b = e; do { _j(b, c); b = (f[d >> 2] | 0) + 12 | 0; f[d >> 2] = b; a = a + -1 | 0 } while ((a | 0) != 0); return } function gk(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0; c = f[b >> 2] | 0; if (!c) { d = 0; return d | 0 } e = a + 44 | 0; g = f[e >> 2] | 0; if (g >>> 0 < (f[a + 48 >> 2] | 0) >>> 0) { f[b >> 2] = 0; f[g >> 2] = c; f[e >> 2] = (f[e >> 2] | 0) + 4; d = 1; return d | 0 } else { Bg(a + 40 | 0, b); d = 1; return d | 0 } return 0 } function hk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2880; f[a + 40 >> 2] = 1180; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 1460; b = a + 36 | 0; d = f[b >> 2] | 0; f[b >> 2] = 0; if (!d) { zi(a); br(a); return } Va[f[(f[d >> 2] | 0) + 4 >> 2] & 127](d); zi(a); br(a); return } function ik(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0, i = 0; f[c >> 2] = 2; d = a + 4 | 0; a = c + 8 | 0; e = f[a >> 2] | 0; g = (f[c + 12 >> 2] | 0) - e | 0; if (g >>> 0 < 4294967292) { Bk(a, g + 4 | 0, 0); i = f[a >> 2] | 0 } else i = e; e = i + g | 0; g = h[d >> 0] | h[d + 1 >> 0] << 8 | h[d + 2 >> 0] << 16 | h[d + 3 >> 0] << 24; b[e >> 0] = g; b[e + 1 >> 0] = g >> 8; b[e + 2 >> 0] = g >> 16; b[e + 3 >> 0] = g >> 24; return } function jk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; f[a >> 2] = 3164; b = a + 8 | 0; f[b >> 2] = 3188; c = f[a + 56 >> 2] | 0; if (c | 0) { d = a + 60 | 0; e = f[d >> 2] | 0; if ((e | 0) != (c | 0)) f[d >> 2] = e + (~((e + -4 - c | 0) >>> 2) << 2); br(c) } f[b >> 2] = 3208; b = f[a + 44 >> 2] | 0; if (b | 0) br(b); b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function kk(a, c, d) { a = a | 0; c = c | 0; d = $(d); var e = 0, g = Oa, h = 0; e = zg(a, c) | 0; if ((e | 0) == (a + 4 | 0)) { g = d; return $(g) } a = e + 28 | 0; if ((b[a + 11 >> 0] | 0) < 0) h = f[a >> 2] | 0; else h = a; g = $(+Xq(h)); return $(g) } function lk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; b = u; u = u + 16 | 0; c = b; d = c; f[d >> 2] = 0; f[d + 4 >> 2] = 0; cf(a, 2, c); c = f[a + 12 >> 2] | 0; d = a + 16 | 0; e = f[d >> 2] | 0; if ((e | 0) == (c | 0)) { g = a + 24 | 0; f[g >> 2] = 0; h = a + 28 | 0; f[h >> 2] = 0; u = b; return } f[d >> 2] = e + (~((e + -4 - c | 0) >>> 2) << 2); g = a + 24 | 0; f[g >> 2] = 0; h = a + 28 | 0; f[h >> 2] = 0; u = b; return } function mk(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0, i = 0, j = 0; c = f[a + 176 >> 2] | 0; d = f[a + 172 >> 2] | 0; e = d; a: do if ((c | 0) != (d | 0)) { g = (c - d | 0) / 136 | 0; h = 0; while (1) { if ((f[e + (h * 136 | 0) >> 2] | 0) == (b | 0)) break; i = h + 1 | 0; if (i >>> 0 < g >>> 0) h = i; else break a } j = e + (h * 136 | 0) + 104 | 0; return j | 0 } while (0); j = a + 40 | 0; return j | 0 } function nk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; f[a >> 2] = 3232; b = a + 8 | 0; f[b >> 2] = 3256; c = f[a + 56 >> 2] | 0; if (c | 0) { d = a + 60 | 0; e = f[d >> 2] | 0; if ((e | 0) != (c | 0)) f[d >> 2] = e + (~((e + -4 - c | 0) >>> 2) << 2); br(c) } f[b >> 2] = 3276; b = f[a + 44 >> 2] | 0; if (b | 0) br(b); b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function ok(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2880; f[a + 40 >> 2] = 1180; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 1460; b = a + 36 | 0; d = f[b >> 2] | 0; f[b >> 2] = 0; if (!d) { zi(a); return } Va[f[(f[d >> 2] | 0) + 4 >> 2] & 127](d); zi(a); return } function pk(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; Ec(a, b); if ((b | 0) <= -1) return; c = a + 88 | 0; d = f[c >> 2] | 0; e = f[a + 84 >> 2] | 0; if ((d - e >> 2 | 0) <= (b | 0)) return; a = e + (b << 2) | 0; b = a + 4 | 0; e = d - b | 0; g = e >> 2; if (!g) h = d; else { Xl(a | 0, b | 0, e | 0) | 0; h = f[c >> 2] | 0 } e = a + (g << 2) | 0; if ((h | 0) == (e | 0)) return; f[c >> 2] = h + (~((h + -4 - e | 0) >>> 2) << 2); return } function qk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0, h = 0; b = f[a + 32 >> 2] | 0; c = f[a + 36 >> 2] | 0; if ((b | 0) == (c | 0)) { d = 1; return d | 0 } e = a + 8 | 0; g = a + 44 | 0; a = b; while (1) { b = f[(f[e >> 2] | 0) + (f[a >> 2] << 2) >> 2] | 0; a = a + 4 | 0; if (!(Ra[f[(f[b >> 2] | 0) + 20 >> 2] & 127](b, f[g >> 2] | 0) | 0)) { d = 0; h = 5; break } if ((a | 0) == (c | 0)) { d = 1; h = 5; break } } if ((h | 0) == 5) return d | 0; return 0 } function rk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; f[a >> 2] = 3164; b = a + 8 | 0; f[b >> 2] = 3188; c = f[a + 56 >> 2] | 0; if (c | 0) { d = a + 60 | 0; e = f[d >> 2] | 0; if ((e | 0) != (c | 0)) f[d >> 2] = e + (~((e + -4 - c | 0) >>> 2) << 2); br(c) } f[b >> 2] = 3208; b = f[a + 44 >> 2] | 0; if (b | 0) br(b); b = f[a + 32 >> 2] | 0; if (!b) return; br(b); return } function sk(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0, i = 0.0; d = u; u = u + 128 | 0; e = d; g = e; h = g + 124 | 0; do { f[g >> 2] = 0; g = g + 4 | 0 } while ((g | 0) < (h | 0)); g = e + 4 | 0; f[g >> 2] = a; h = e + 8 | 0; f[h >> 2] = -1; f[e + 44 >> 2] = a; f[e + 76 >> 2] = -1; Rm(e, 0); i = +Lc(e, c, 1); c = (f[g >> 2] | 0) - (f[h >> 2] | 0) + (f[e + 108 >> 2] | 0) | 0; if (b | 0) f[b >> 2] = c | 0 ? a + c | 0 : a; u = d; return +i } function tk(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var g = 0, h = 0; a = c + 16 | 0; g = f[a >> 2] | 0; do if (g) { if ((g | 0) != (d | 0)) { h = c + 36 | 0; f[h >> 2] = (f[h >> 2] | 0) + 1; f[c + 24 >> 2] = 2; b[c + 54 >> 0] = 1; break } h = c + 24 | 0; if ((f[h >> 2] | 0) == 2) f[h >> 2] = e } else { f[a >> 2] = d; f[c + 24 >> 2] = e; f[c + 36 >> 2] = 1 } while (0); return } function uk(a) { a = a | 0; var c = 0, d = 0, e = 0; c = a + 74 | 0; d = b[c >> 0] | 0; b[c >> 0] = d + 255 | d; d = a + 20 | 0; c = a + 28 | 0; if ((f[d >> 2] | 0) >>> 0 > (f[c >> 2] | 0) >>> 0) Sa[f[a + 36 >> 2] & 31](a, 0, 0) | 0; f[a + 16 >> 2] = 0; f[c >> 2] = 0; f[d >> 2] = 0; d = f[a >> 2] | 0; if (!(d & 4)) { c = (f[a + 44 >> 2] | 0) + (f[a + 48 >> 2] | 0) | 0; f[a + 8 >> 2] = c; f[a + 4 >> 2] = c; e = d << 27 >> 31 } else { f[a >> 2] = d | 32; e = -1 } return e | 0 } function vk(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0; d = zg(a, c) | 0; if ((d | 0) == (a + 4 | 0)) { e = 0; return e | 0 } a = d + 28 | 0; if ((b[a + 11 >> 0] | 0) < 0) g = f[a >> 2] | 0; else g = a; e = ((Kj(g) | 0) + 1 | 0) >>> 0 > 1; return e | 0 } function wk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 5840; b = f[a + 96 >> 2] | 0; if (b | 0) { c = a + 100 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~(((d + -12 - b | 0) >>> 0) / 12 | 0) * 12 | 0); br(b) } b = f[a + 84 >> 2] | 0; if (!b) { wg(a); br(a); return } d = a + 88 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b); wg(a); br(a); return } function xk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0; f[a >> 2] = 3232; b = a + 8 | 0; f[b >> 2] = 3256; c = f[a + 56 >> 2] | 0; if (c | 0) { d = a + 60 | 0; e = f[d >> 2] | 0; if ((e | 0) != (c | 0)) f[d >> 2] = e + (~((e + -4 - c | 0) >>> 2) << 2); br(c) } f[b >> 2] = 3276; b = f[a + 44 >> 2] | 0; if (b | 0) br(b); b = f[a + 32 >> 2] | 0; if (!b) return; br(b); return } function yk(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, g = 0, h = 0; e = zg(a, c) | 0; if ((e | 0) == (a + 4 | 0)) { g = d; return g | 0 } d = e + 28 | 0; if ((b[d + 11 >> 0] | 0) < 0) h = f[d >> 2] | 0; else h = d; g = Kj(h) | 0; return g | 0 } function zk(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, f = 0, g = 0, h = 0, i = 0; e = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1; f = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1; g = d >> 31 | ((d | 0) < 0 ? -1 : 0) << 1; h = ((d | 0) < 0 ? -1 : 0) >> 31 | ((d | 0) < 0 ? -1 : 0) << 1; i = Vn(e ^ a | 0, f ^ b | 0, e | 0, f | 0) | 0; b = I; a = g ^ e; e = h ^ f; return Vn((Bd(i, b, Vn(g ^ c | 0, h ^ d | 0, g | 0, h | 0) | 0, I, 0) | 0) ^ a | 0, I ^ e | 0, a | 0, e | 0) | 0 } function Ak(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0, i = 0, j = 0; f[a >> 2] = b; h = b + 16 | 0; i = f[h + 4 >> 2] | 0; j = a + 8 | 0; f[j >> 2] = f[h >> 2]; f[j + 4 >> 2] = i; i = b + 24 | 0; b = f[i + 4 >> 2] | 0; j = a + 16 | 0; f[j >> 2] = f[i >> 2]; f[j + 4 >> 2] = b; b = a + 40 | 0; f[b >> 2] = c; f[b + 4 >> 2] = d; d = a + 48 | 0; f[d >> 2] = e; f[d + 4 >> 2] = g; return } function Bk(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = f[a >> 2] | 0; g = d - e | 0; h = e; e = d; if (g >>> 0 >= b >>> 0) { if (g >>> 0 > b >>> 0 ? (d = h + b | 0, (d | 0) != (e | 0)) : 0) f[c >> 2] = d } else ri(a, b - g | 0); g = a + 24 | 0; a = g; b = Tn(f[a >> 2] | 0, f[a + 4 >> 2] | 0, 1, 0) | 0; a = g; f[a >> 2] = b; f[a + 4 >> 2] = I; return } function Ck(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, g = 0; d = zg(a, c) | 0; if ((d | 0) == (a + 4 | 0)) { e = -1; return e | 0 } a = d + 28 | 0; if ((b[a + 11 >> 0] | 0) < 0) g = f[a >> 2] | 0; else g = a; e = Kj(g) | 0; return e | 0 } function Dk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 5840; b = f[a + 96 >> 2] | 0; if (b | 0) { c = a + 100 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~(((d + -12 - b | 0) >>> 0) / 12 | 0) * 12 | 0); br(b) } b = f[a + 84 >> 2] | 0; if (!b) { wg(a); return } d = a + 88 | 0; c = f[d >> 2] | 0; if ((c | 0) != (b | 0)) f[d >> 2] = c + (~((c + -4 - b | 0) >>> 2) << 2); br(b); wg(a); return } function Ek(a) { a = a | 0; var c = 0, d = 0, e = 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; f[a + 20 >> 2] = 0; b[a + 24 >> 0] = 1; c = a + 68 | 0; d = a + 28 | 0; e = d + 40 | 0; do { f[d >> 2] = 0; d = d + 4 | 0 } while ((d | 0) < (e | 0)); f[c >> 2] = a; c = a + 72 | 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = 0; f[c + 12 >> 2] = 0; f[c + 16 >> 2] = 0; f[c + 20 >> 2] = 0; return } function Fk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3188; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 3208; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function Gk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2004; b = f[a + 76 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Hk(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; var f = 0, g = 0, h = 0; f = u; u = u + 256 | 0; g = f; if ((c | 0) > (d | 0) & (e & 73728 | 0) == 0) { e = c - d | 0; hj(g | 0, b << 24 >> 24 | 0, (e >>> 0 < 256 ? e : 256) | 0) | 0; if (e >>> 0 > 255) { b = c - d | 0; d = e; do { ep(a, g, 256); d = d + -256 | 0 } while (d >>> 0 > 255); h = b & 255 } else h = e; ep(a, g, h) } u = f; return } function Ik(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3256; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 3276; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function Jk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1696; b = f[a + 76 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Kk(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; var h = 0; if (qp(a, f[b + 8 >> 2] | 0, g) | 0) fj(0, b, c, d, e); else { h = f[a + 8 >> 2] | 0; _a[f[(f[h >> 2] | 0) + 20 >> 2] & 3](h, b, c, d, e, g) } return } function Lk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3188; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 3208; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) return; br(b); return } function Mk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 2060; tj(a + 108 | 0); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Nk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 3256; b = f[a + 48 >> 2] | 0; if (b | 0) { c = a + 52 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } f[a >> 2] = 3276; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) return; br(b); return } function Ok(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1752; tj(a + 108 | 0); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Pk(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, f = 0, g = 0, h = 0, i = 0, j = 0; a: do if (!d) e = 0; else { f = a; g = d; h = c; while (1) { i = b[f >> 0] | 0; j = b[h >> 0] | 0; if (i << 24 >> 24 != j << 24 >> 24) break; g = g + -1 | 0; if (!g) { e = 0; break a } else { f = f + 1 | 0; h = h + 1 | 0 } } e = (i & 255) - (j & 255) | 0 } while (0); return e | 0 } function Qk(a) { a = a | 0; if (!(f[a + 44 >> 2] | 0)) return 0; if (!(f[a + 48 >> 2] | 0)) return 0; if (!(f[a + 24 >> 2] | 0)) return 0; if (!(f[a + 28 >> 2] | 0)) return 0; if (!(f[a + 32 >> 2] | 0)) return 0; else return (f[a + 36 >> 2] | 0) != 0 | 0; return 0 } function Rk(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 2004; b = f[a + 76 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Sk(a) { a = a | 0; var c = 0, d = 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; c = 0; while (1) { if ((c | 0) == 3) break; f[a + (c << 2) >> 2] = 0; c = c + 1 | 0 } if ((b[a + 11 >> 0] | 0) < 0) d = (f[a + 8 >> 2] & 2147483647) + -1 | 0; else d = 10; wj(a, d, 0); return } function Tk(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0.0, g = 0.0; b = f[a + 8 >> 2] | 0; if ((b | 0) < 2) { c = 0; d = 0; I = c; return d | 0 } e = +(b | 0); g = +Fg(e) * e; e = +W(+(g - +p[a >> 3])); c = +K(e) >= 1.0 ? (e > 0.0 ? ~~+Y(+J(e / 4294967296.0), 4294967295.0) >>> 0 : ~~+W((e - +(~~e >>> 0)) / 4294967296.0) >>> 0) : 0; d = ~~e >>> 0; I = c; return d | 0 } function Uk(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1696; b = f[a + 76 >> 2] | 0; if (b | 0) br(b); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Vk(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; c = f[a + 16 >> 2] | 0; if (((f[a + 20 >> 2] | 0) - c >> 2 | 0) <= (b | 0)) { d = 0; return d | 0 } e = f[c + (b << 2) >> 2] | 0; if ((e | 0) < 0) { d = 0; return d | 0 } b = f[(f[a + 36 >> 2] | 0) + (e << 2) >> 2] | 0; e = f[b + 32 >> 2] | 0; if (e | 0) { d = e; return d | 0 } d = f[b + 8 >> 2] | 0; return d | 0 } function Wk(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1216; b = f[a + 16 >> 2] | 0; if (b | 0) { c = a + 20 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b) } b = f[a + 4 >> 2] | 0; if (!b) return; d = a + 8 | 0; a = f[d >> 2] | 0; if ((a | 0) != (b | 0)) f[d >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Xk(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 2060; tj(a + 108 | 0); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Yk(a) { a = a | 0; if (!(f[a + 64 >> 2] | 0)) return 0; if (!(f[a + 68 >> 2] | 0)) return 0; if (!(f[a + 44 >> 2] | 0)) return 0; if (!(f[a + 48 >> 2] | 0)) return 0; if (!(f[a + 52 >> 2] | 0)) return 0; else return (f[a + 56 >> 2] | 0) != 0 | 0; return 0 } function Zk(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0; if (qp(a, f[b + 8 >> 2] | 0, 0) | 0) tk(0, b, c, d); else { e = f[a + 8 >> 2] | 0; Ya[f[(f[e >> 2] | 0) + 28 >> 2] & 7](e, b, c, d) } return } function _k(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1752; tj(a + 108 | 0); f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function $k(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; if ((b | 0) < 0) { c = 0; return c | 0 } d = f[a + 4 >> 2] | 0; if (((f[d + 12 >> 2] | 0) - (f[d + 8 >> 2] | 0) >> 2 | 0) <= (b | 0)) { c = 0; return c | 0 } d = f[(f[a + 8 >> 2] | 0) + (f[(f[a + 20 >> 2] | 0) + (b << 2) >> 2] << 2) >> 2] | 0; c = Ra[f[(f[d >> 2] | 0) + 36 >> 2] & 127](d, b) | 0; return c | 0 } function al(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; if ((b | 0) < 0) { c = 0; return c | 0 } d = f[a + 4 >> 2] | 0; if (((f[d + 12 >> 2] | 0) - (f[d + 8 >> 2] | 0) >> 2 | 0) <= (b | 0)) { c = 0; return c | 0 } d = f[(f[a + 8 >> 2] | 0) + (f[(f[a + 20 >> 2] | 0) + (b << 2) >> 2] << 2) >> 2] | 0; c = Ra[f[(f[d >> 2] | 0) + 32 >> 2] & 127](d, b) | 0; return c | 0 } function bl(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0, f = 0, g = 0; d = b[a >> 0] | 0; e = b[c >> 0] | 0; if (d << 24 >> 24 == 0 ? 1 : d << 24 >> 24 != e << 24 >> 24) { f = e; g = d } else { d = c; c = a; do { c = c + 1 | 0; d = d + 1 | 0; a = b[c >> 0] | 0; e = b[d >> 0] | 0 } while (!(a << 24 >> 24 == 0 ? 1 : a << 24 >> 24 != e << 24 >> 24)); f = e; g = a } return (g & 255) - (f & 255) | 0 } function cl(a, b) { a = a | 0; b = $(b); var c = 0, d = 0; c = u; u = u + 16 | 0; d = c; Sk(d); qi(a, d, b); Go(d); u = c; return } function dl(a) { a = a | 0; var b = 0, c = 0, d = 0, e = 0, g = 0; b = f[a >> 2] | 0; c = a + 4 | 0; d = f[c >> 2] | 0; if ((d | 0) == (b | 0)) e = b; else { g = d + (~((d + -4 - b | 0) >>> 2) << 2) | 0; f[c >> 2] = g; e = g } f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; if (!b) return; if ((e | 0) != (b | 0)) f[c >> 2] = e + (~((e + -4 - b | 0) >>> 2) << 2); br(b); return } function el(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0; d = f[a + 16 >> 2] | 0; if (((f[a + 20 >> 2] | 0) - d >> 2 | 0) <= (b | 0)) { e = -1; return e | 0 } g = f[d + (b << 2) >> 2] | 0; if ((g | 0) < 0) { e = -1; return e | 0 } e = f[(f[(f[(f[a + 36 >> 2] | 0) + (g << 2) >> 2] | 0) + 16 >> 2] | 0) + (c << 2) >> 2] | 0; return e | 0 } function fl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; c = u; u = u + 16 | 0; d = c; Sk(d); vi(a, d, b); Go(d); u = c; return } function gl(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0, h = 0; d = u; u = u + 32 | 0; e = d; g = d + 20 | 0; f[e >> 2] = f[a + 60 >> 2]; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = b; f[e + 12 >> 2] = g; f[e + 16 >> 2] = c; if ((ro(za(140, e | 0) | 0) | 0) < 0) { f[g >> 2] = -1; h = -1 } else h = f[g >> 2] | 0; u = d; return h | 0 } function hl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; if ((b | 0) == -1 | (b | 0) > 4) { c = 0; return c | 0 } d = f[a + 20 + (b * 12 | 0) >> 2] | 0; if (((f[a + 20 + (b * 12 | 0) + 4 >> 2] | 0) - d | 0) <= 0) { c = 0; return c | 0 } b = f[d >> 2] | 0; if ((b | 0) == -1) { c = 0; return c | 0 } c = f[(f[a + 8 >> 2] | 0) + (b << 2) >> 2] | 0; return c | 0 } function il(a) { a = a | 0; if (!(f[a + 40 >> 2] | 0)) return 0; if (!(f[a + 24 >> 2] | 0)) return 0; if (!(f[a + 28 >> 2] | 0)) return 0; if (!(f[a + 32 >> 2] | 0)) return 0; else return (f[a + 36 >> 2] | 0) != 0 | 0; return 0 } function jl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; c = f[a + 16 >> 2] | 0; if (((f[a + 20 >> 2] | 0) - c >> 2 | 0) <= (b | 0)) { d = 0; return d | 0 } e = f[c + (b << 2) >> 2] | 0; if ((e | 0) < 0) { d = 0; return d | 0 } b = f[(f[a + 36 >> 2] | 0) + (e << 2) >> 2] | 0; d = (f[b + 20 >> 2] | 0) - (f[b + 16 >> 2] | 0) >> 2; return d | 0 } function kl(a) { a = a | 0; var b = 0; if (!(f[a + 24 >> 2] | 0)) { b = 0; return b | 0 } if (!(f[a + 28 >> 2] | 0)) { b = 0; return b | 0 } if (!(f[a + 32 >> 2] | 0)) { b = 0; return b | 0 } b = (f[a + 36 >> 2] | 0) != 0; return b | 0 } function ll(a) { a = a | 0; if (!(f[a + 60 >> 2] | 0)) return 0; if (!(f[a + 44 >> 2] | 0)) return 0; if (!(f[a + 48 >> 2] | 0)) return 0; if (!(f[a + 52 >> 2] | 0)) return 0; else return (f[a + 56 >> 2] | 0) != 0 | 0; return 0 } function ml(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0; Sg(a, c); f[a >> 2] = 1392; c = a + 72 | 0; d = a + 36 | 0; a = d + 36 | 0; do { f[d >> 2] = 0; d = d + 4 | 0 } while ((d | 0) < (a | 0)); d = f[b >> 2] | 0; f[b >> 2] = 0; f[c >> 2] = d; return } function nl(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0; d = a; e = c; c = d + 64 | 0; do { f[d >> 2] = f[e >> 2]; d = d + 4 | 0; e = e + 4 | 0 } while ((d | 0) < (c | 0)); e = a + 64 | 0; f[a + 88 >> 2] = 0; f[e >> 2] = 0; f[e + 4 >> 2] = 0; f[e + 8 >> 2] = 0; f[e + 12 >> 2] = 0; f[e + 16 >> 2] = 0; b[e + 20 >> 0] = 0; return } function ol(a, c, d, e) { a = a | 0; c = c | 0; d = d | 0; e = e | 0; var f = 0, g = 0; if ((a | 0) == 0 & (c | 0) == 0) f = d; else { g = d; d = c; c = a; while (1) { a = g + -1 | 0; b[a >> 0] = h[15542 + (c & 15) >> 0] | 0 | e; c = Wn(c | 0, d | 0, 4) | 0; d = I; if ((c | 0) == 0 & (d | 0) == 0) { f = a; break } else g = a } } return f | 0 } function pl(a) { a = a | 0; var c = 0, d = 0, e = 0; c = a + 74 | 0; d = b[c >> 0] | 0; b[c >> 0] = d + 255 | d; d = f[a >> 2] | 0; if (!(d & 8)) { f[a + 8 >> 2] = 0; f[a + 4 >> 2] = 0; c = f[a + 44 >> 2] | 0; f[a + 28 >> 2] = c; f[a + 20 >> 2] = c; f[a + 16 >> 2] = c + (f[a + 48 >> 2] | 0); e = 0 } else { f[a >> 2] = d | 32; e = -1 } return e | 0 } function ql(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; c = f[b + 88 >> 2] | 0; if (!c) { d = 0; return d | 0 } if ((f[c >> 2] | 0) != 2) { d = 0; return d | 0 } b = f[c + 8 >> 2] | 0; f[a + 4 >> 2] = h[b >> 0] | h[b + 1 >> 0] << 8 | h[b + 2 >> 0] << 16 | h[b + 3 >> 0] << 24; d = 1; return d | 0 } function rl(a) { a = a | 0; var b = 0; if (!(f[a + 44 >> 2] | 0)) { b = 0; return b | 0 } if (!(f[a + 48 >> 2] | 0)) { b = 0; return b | 0 } if (!(f[a + 52 >> 2] | 0)) { b = 0; return b | 0 } b = (f[a + 56 >> 2] | 0) != 0; return b | 0 } function sl(a) { a = a | 0; kj(a); br(a); return } function tl(a, c) { a = a | 0; c = c | 0; var d = 0; if (f[c + 56 >> 2] | 0) { d = 0; return d | 0 } if ((b[c + 24 >> 0] | 0) != 3) { d = 0; return d | 0 } f[a + 40 >> 2] = c; d = 1; return d | 0 } function ul(a, c) { a = a | 0; c = c | 0; var d = 0; if (f[c + 56 >> 2] | 0) { d = 0; return d | 0 } if ((b[c + 24 >> 0] | 0) != 3) { d = 0; return d | 0 } f[a + 44 >> 2] = c; d = 1; return d | 0 } function vl(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0; c = a + 4 | 0; d = f[c >> 2] | 0; e = f[a >> 2] | 0; g = d - e | 0; if (g >>> 0 < b >>> 0) { ri(a, b - g | 0); return } if (g >>> 0 <= b >>> 0) return; g = e + b | 0; if ((g | 0) == (d | 0)) return; f[c >> 2] = g; return } function wl(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = $(e); f[a + 4 >> 2] = b; Jf(a + 8 | 0, c, c + (d << 2) | 0); n[a + 20 >> 2] = e; return } function xl(a, b) { a = a | 0; b = b | 0; var c = 0; if (!(Qa[f[(f[a >> 2] | 0) + 40 >> 2] & 127](a) | 0)) { c = 0; return c | 0 } if (!(Ra[f[(f[a >> 2] | 0) + 44 >> 2] & 127](a, b) | 0)) { c = 0; return c | 0 } c = Ra[f[(f[a >> 2] | 0) + 48 >> 2] & 127](a, b) | 0; return c | 0 } function yl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; c = u; u = u + 16 | 0; d = c + 4 | 0; e = c; f[e >> 2] = 0; f[d >> 2] = f[e >> 2]; e = tc(a, b, d) | 0; u = c; return e | 0 } function zl(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0; d = f[c >> 2] | 0; c = a; e = b - a >> 2; while (1) { if (!e) break; a = (e | 0) / 2 | 0; b = c + (a << 2) | 0; g = (f[b >> 2] | 0) >>> 0 < d >>> 0; c = g ? b + 4 | 0 : c; e = g ? e + -1 - a | 0 : a } return c | 0 } function Al(a) { a = a | 0; var c = 0; f[a >> 2] = 0; c = a + 8 | 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = 0; f[c + 12 >> 2] = 0; b[a + 24 >> 0] = 1; f[a + 28 >> 2] = 9; c = a + 40 | 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = 0; f[c + 12 >> 2] = 0; f[a + 56 >> 2] = -1; f[a + 60 >> 2] = 0; return } function Bl(a) { a = a | 0; mj(a); br(a); return } function Cl(a) { a = a | 0; var c = 0, d = 0, e = 0, g = 0, h = 0; if (!(Pq(b[f[a >> 2] >> 0] | 0) | 0)) c = 0; else { d = 0; while (1) { e = f[a >> 2] | 0; g = (d * 10 | 0) + -48 + (b[e >> 0] | 0) | 0; h = e + 1 | 0; f[a >> 2] = h; if (!(Pq(b[h >> 0] | 0) | 0)) { c = g; break } else d = g } } return c | 0 } function Dl(a, c) { a = a | 0; c = c | 0; var d = 0; if (f[c + 56 >> 2] | 0) { d = 0; return d | 0 } if ((b[c + 24 >> 0] | 0) != 3) { d = 0; return d | 0 } f[a + 60 >> 2] = c; d = 1; return d | 0 } function El(a, c) { a = a | 0; c = c | 0; var d = 0; if (f[c + 56 >> 2] | 0) { d = 0; return d | 0 } if ((b[c + 24 >> 0] | 0) != 3) { d = 0; return d | 0 } f[a + 64 >> 2] = c; d = 1; return d | 0 } function Fl(a) { a = a | 0; var b = 0, c = 0; b = f[r >> 2] | 0; c = b + a | 0; if ((a | 0) > 0 & (c | 0) < (b | 0) | (c | 0) < 0) { ea() | 0; ya(12); return -1 } f[r >> 2] = c; if ((c | 0) > (da() | 0) ? (ca() | 0) == 0 : 0) { f[r >> 2] = b; ya(12); return -1 } return b | 0 } function Gl(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0, f = 0; if ((a | 0) == 0 & (c | 0) == 0) e = d; else { f = d; d = c; c = a; while (1) { a = f + -1 | 0; b[a >> 0] = c & 7 | 48; c = Wn(c | 0, d | 0, 3) | 0; d = I; if ((c | 0) == 0 & (d | 0) == 0) { e = a; break } else f = a } } return e | 0 } function Hl(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) { br(a); return } c = a + 36 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Il(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = g | 0; if (qp(a, f[b + 8 >> 2] | 0, g) | 0) fj(0, b, c, d, e); return } function Jl(a) { a = a | 0; var b = 0, c = 0; b = f[a + 64 >> 2] | 0; if (!b) return; c = Qa[f[(f[b >> 2] | 0) + 32 >> 2] & 127](b) | 0; if (!c) return; f[a + 60 >> 2] = (((f[c + 4 >> 2] | 0) - (f[c >> 2] | 0) >> 2 >>> 0) / 3 | 0) - (f[c + 40 >> 2] | 0); return } function Kl(a) { a = a | 0; Ii(a); br(a); return } function Ll(a) { a = a | 0; var b = 0; switch (a | 0) { case 11: case 2: case 1: { b = 1; break } case 4: case 3: { b = 2; break } case 6: case 5: { b = 4; break } case 8: case 7: { b = 8; break } case 9: { b = 4; break } case 10: { b = 8; break } default: b = -1 }return b | 0 } function Ml() { var a = 0, b = 0; a = dn(40) | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; n[a + 16 >> 2] = $(1.0); b = a + 20 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; f[b + 12 >> 2] = 0; n[a + 36 >> 2] = $(1.0); return a | 0 } function Nl(a, b) { a = +a; b = +b; var c = 0, d = 0, e = 0; p[s >> 3] = a; c = f[s >> 2] | 0; d = f[s + 4 >> 2] | 0; p[s >> 3] = b; e = f[s + 4 >> 2] & -2147483648 | d & 2147483647; f[s >> 2] = c; f[s + 4 >> 2] = e; return +(+p[s >> 3]) } function Ol(a, b, c) { a = a | 0; b = b | 0; c = +c; var d = 0, e = 0; d = u; u = u + 16 | 0; e = d; p[e >> 3] = c; _b(a, b, e); u = d; return } function Pl(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; d = u; u = u + 16 | 0; e = d; f[e >> 2] = c; cc(a, b, e); u = d; return } function Ql(a, c) { a = a | 0; c = c | 0; var d = 0, e = 0; if ((a | 0) != (c | 0)) { d = b[c + 11 >> 0] | 0; e = d << 24 >> 24 < 0; Zi(a, e ? f[c >> 2] | 0 : c, e ? f[c + 4 >> 2] | 0 : d & 255) | 0 } return a | 0 } function Rl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0, f = 0; c = a & 65535; d = b & 65535; e = X(d, c) | 0; f = a >>> 16; a = (e >>> 16) + (X(d, f) | 0) | 0; d = b >>> 16; b = X(d, c) | 0; return (I = (a >>> 16) + (X(d, f) | 0) + (((a & 65535) + b | 0) >>> 16) | 0, a + b << 16 | e & 65535 | 0) | 0 } function Sl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; c = vj(b) | 0; d = dn(c + 13 | 0) | 0; f[d >> 2] = c; f[d + 4 >> 2] = c; f[d + 8 >> 2] = 0; e = Sp(d) | 0; Rg(e | 0, b | 0, c + 1 | 0) | 0; f[a >> 2] = e; return } function Tl(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; if ((b | 0) == -1 | (b | 0) > 4) { c = -1; return c | 0 } d = f[a + 20 + (b * 12 | 0) >> 2] | 0; if (((f[a + 20 + (b * 12 | 0) + 4 >> 2] | 0) - d | 0) <= 0) { c = -1; return c | 0 } c = f[d >> 2] | 0; return c | 0 } function Ul(a) { a = a | 0; Li(a); br(a); return } function Vl(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1528; b = f[a + 32 >> 2] | 0; if (!b) return; c = a + 36 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Wl(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; if (qp(a, f[b + 8 >> 2] | 0, 0) | 0) tk(0, b, c, d); return } function Xl(a, c, d) { a = a | 0; c = c | 0; d = d | 0; var e = 0; if ((c | 0) < (a | 0) & (a | 0) < (c + d | 0)) { e = a; c = c + d | 0; a = a + d | 0; while ((d | 0) > 0) { a = a - 1 | 0; c = c - 1 | 0; d = d - 1 | 0; b[a >> 0] = b[c >> 0] | 0 } a = e } else Rg(a, c, d) | 0; return a | 0 } function Yl(a) { a = a | 0; var b = 0, c = 0, d = 0; f[a >> 2] = 1180; b = f[a + 8 >> 2] | 0; if (!b) { br(a); return } c = a + 12 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); br(b); br(a); return } function Zl(a) { a = a | 0; var b = 0; f[a >> 2] = 2740; b = f[a + 56 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function _l(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0; d = u; u = u + 16 | 0; e = d; f[e >> 2] = f[c >> 2]; g = Sa[f[(f[a >> 2] | 0) + 16 >> 2] & 31](a, b, e) | 0; if (g) f[c >> 2] = f[e >> 2]; u = d; return g & 1 | 0 } function $l(a, b) { a = a | 0; b = b | 0; var c = 0; if (b >>> 0 >= 2) { c = 0; return c | 0 } f[a + 28 >> 2] = b; c = 1; return c | 0 } function am(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 3e3; b = a + 64 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (!c) { aj(a); return } Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); aj(a); return } function bm() { var a = 0, b = 0; a = mn() | 0; if ((a | 0 ? (b = f[a >> 2] | 0, b | 0) : 0) ? (a = b + 48 | 0, (f[a >> 2] & -256 | 0) == 1126902528 ? (f[a + 4 >> 2] | 0) == 1129074247 : 0) : 0) Qo(f[b + 12 >> 2] | 0); Qo(bq() | 0) } function cm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Bf(a, b, c, d, e, f, 6) | 0 } function dm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Af(a, b, c, d, e, f, 4) | 0 } function em(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Gf(a, b, c, d, e, f, 2) | 0 } function fm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Af(a, b, c, d, e, f, 3) | 0 } function gm(a) { a = a | 0; var b = 0; f[a >> 2] = 2488; b = f[a + 56 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function hm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Gf(a, b, c, d, e, f, 1) | 0 } function im(a) { a = a | 0; var c = 0; c = b[w + (a & 255) >> 0] | 0; if ((c | 0) < 8) return c | 0; c = b[w + (a >> 8 & 255) >> 0] | 0; if ((c | 0) < 8) return c + 8 | 0; c = b[w + (a >> 16 & 255) >> 0] | 0; if ((c | 0) < 8) return c + 16 | 0; return (b[w + (a >>> 24) >> 0] | 0) + 24 | 0 } function jm(a, b) { a = a | 0; b = b | 0; var c = 0.0, d = 0.0, e = 0.0, f = 0.0; if (!a) { c = 0.0; return +c } if ((b | 0) == 0 | (a | 0) == (b | 0)) { c = 0.0; return +c } d = +(b >>> 0) / +(a >>> 0); e = 1.0 - d; f = d * +Fg(d); c = -(f + e * +Fg(e)); return +c } function km(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0; if ((b | 0) > 0) d = 0; else return; do { e = f[a + (d << 2) >> 2] | 0; f[c + (d << 2) >> 2] = e << 1 ^ e >> 31; d = d + 1 | 0 } while ((d | 0) != (b | 0)); return } function lm(a) { a = a | 0; var b = 0, c = 0; if (Eq(a) | 0 ? (b = Zp(f[a >> 2] | 0) | 0, a = b + 8 | 0, c = f[a >> 2] | 0, f[a >> 2] = c + -1, (c + -1 | 0) < 0) : 0) br(b); return } function mm(a) { a = a | 0; var b = 0; Ao(a); f[a >> 2] = 2880; f[a + 40 >> 2] = 1180; f[a + 44 >> 2] = -1; b = a + 48 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; f[b + 12 >> 2] = 0; return } function nm(a, c) { a = a | 0; c = c | 0; var d = 0; b[c + 84 >> 0] = 1; a = f[c + 68 >> 2] | 0; d = c + 72 | 0; c = f[d >> 2] | 0; if ((c | 0) == (a | 0)) return 1; f[d >> 2] = c + (~((c + -4 - a | 0) >>> 2) << 2); return 1 } function om(a) { a = a | 0; var b = 0, c = 0; b = f[a + 16 >> 2] | 0; c = (((f[a + 12 >> 2] | 0) + 1 - b | 0) / 64 | 0) + b << 3; a = b << 3; b = Tn(c | 0, ((c | 0) < 0) << 31 >> 31 | 0, a | 0, ((a | 0) < 0) << 31 >> 31 | 0) | 0; return b | 0 } function pm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Bf(a, b, c, d, e, f, 5) | 0 } function qm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return Bf(a, b, c, d, e, f, 9) | 0 } function rm(a) { a = a | 0; var b = 0; f[a >> 2] = 3208; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function sm(a) { a = a | 0; var b = 0; f[a >> 2] = 2740; b = f[a + 56 >> 2] | 0; if (!b) return; br(b); return } function tm(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1460; b = a + 36 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); zi(a); br(a); return } function um(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1180; b = f[a + 8 >> 2] | 0; if (!b) return; c = a + 12 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function vm(a) { a = a | 0; var b = 0; f[a >> 2] = 3276; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) { br(a); return } br(b); br(a); return } function wm(a) { a = a | 0; var c = 0; f[a >> 2] = 1336; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = -1; c = a + 16 | 0; f[a + 32 >> 2] = 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = 0; b[c + 12 >> 0] = 0; return } function xm(a) { a = a | 0; f[a >> 2] = 3296; Gi(a + 8 | 0); br(a); return } function ym(a) { a = a | 0; var b = 0; f[a >> 2] = 2488; b = f[a + 56 >> 2] | 0; if (!b) return; br(b); return } function zm(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 1460; b = a + 36 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); zi(a); return } function Am(a, b) { a = a | 0; b = b | 0; f[a >> 2] = 2968; Vh(a + 4 | 0); f[a + 40 >> 2] = 0; f[a + 44 >> 2] = 0; f[a >> 2] = 2984; f[a + 48 >> 2] = b; f[a + 52 >> 2] = 0; return } function Bm(a) { a = a | 0; var b = 0, c = 0; f[a >> 2] = 3e3; b = a + 64 | 0; c = f[b >> 2] | 0; f[b >> 2] = 0; if (c | 0) Va[f[(f[c >> 2] | 0) + 4 >> 2] & 127](c); aj(a); br(a); return } function Cm(a) { a = a | 0; var b = 0, c = 0, d = 0; b = f[a >> 2] | 0; c = a + 4 | 0; d = f[c >> 2] | 0; if ((d | 0) != (b | 0)) f[c >> 2] = d + (~((d + -4 - b | 0) >>> 2) << 2); f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; return } function Dm(a, b, c) { a = a | 0; b = b | 0; c = c | 0; var d = 0, e = 0, g = 0; d = a + 20 | 0; e = f[d >> 2] | 0; g = (f[a + 16 >> 2] | 0) - e | 0; a = g >>> 0 > c >>> 0 ? c : g; Rg(e | 0, b | 0, a | 0) | 0; f[d >> 2] = (f[d >> 2] | 0) + a; return c | 0 } function Em(a) { a = a | 0; var b = 0; f[a >> 2] = 3208; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) return; br(b); return } function Fm(a) { a = a | 0; f[a >> 2] = 3296; Gi(a + 8 | 0); return } function Gm(a, b) { a = a | 0; b = b | 0; f[a >> 2] = 2968; Vh(a + 4 | 0); f[a + 40 >> 2] = 0; f[a + 44 >> 2] = 0; f[a >> 2] = 2984; f[a + 48 >> 2] = b; f[a + 52 >> 2] = b; return } function Hm(a) { a = a | 0; var b = 0, c = 0; b = f[a >> 2] | 0; if (!b) return; c = a + 4 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -8 - b | 0) >>> 3) << 3); br(b); return } function Im(a) { a = a | 0; var b = 0, c = 0; b = f[a >> 2] | 0; if (!b) return; c = a + 4 | 0; a = f[c >> 2] | 0; if ((a | 0) != (b | 0)) f[c >> 2] = a + (~((a + -4 - b | 0) >>> 2) << 2); br(b); return } function Jm(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[b >> 2] | 0; return (1 << (c & 31) & f[(f[a + 28 >> 2] | 0) + (c >>> 5 << 2) >> 2] | 0) != 0 | 0 } function Km(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Sa[f[(f[a >> 2] | 0) + 44 >> 2] & 31](a, b, c) | 0 } function Lm(a) { a = a | 0; var c = 0; Al(a); c = a + 64 | 0; f[a + 88 >> 2] = 0; f[c >> 2] = 0; f[c + 4 >> 2] = 0; f[c + 8 >> 2] = 0; f[c + 12 >> 2] = 0; f[c + 16 >> 2] = 0; b[c + 20 >> 0] = 0; return } function Mm(a) { a = a | 0; f[a >> 2] = 2796; tj(a + 88 | 0); br(a); return } function Nm(a) { a = a | 0; var b = 0; f[a >> 2] = 3276; b = f[a + 36 >> 2] | 0; if (b | 0) br(b); b = f[a + 24 >> 2] | 0; if (!b) return; br(b); return } function Om(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; if ((f[b + 4 >> 2] | 0) == (c | 0) ? (c = b + 28 | 0, (f[c >> 2] | 0) != 1) : 0) f[c >> 2] = d; return } function Pm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = $(f); pg(a, b, c, d, e, f); return } function Qm(a) { a = a | 0; var b = 0, c = 0, d = 0; b = u; u = u + 16 | 0; c = b; if ((uk(a) | 0) == 0 ? (Sa[f[a + 32 >> 2] & 31](a, c, 1) | 0) == 1 : 0) d = h[c >> 0] | 0; else d = -1; u = b; return d | 0 } function Rm(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0, e = 0; f[a + 104 >> 2] = b; c = f[a + 8 >> 2] | 0; d = f[a + 4 >> 2] | 0; e = c - d | 0; f[a + 108 >> 2] = e; f[a + 100 >> 2] = (b | 0) != 0 & (e | 0) > (b | 0) ? d + b | 0 : c; return } function Sm(a) { a = a | 0; var b = 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; b = a + 16 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; f[b + 12 >> 2] = 0; f[b + 16 >> 2] = 0; return } function Tm(a, b, c, d, e, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; g = $(g); pg(f[a >> 2] | 0, b, c, d, e, g); return } function Um(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = $(f); Pm(a, b, c, d, e, f); return } function Vm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return cm(a, b, c, d, e, f) | 0 } function Wm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return dm(a, b, c, d, e, f) | 0 } function Xm(a) { a = a | 0; var b = 0, c = 0; if (!a) return; b = f[a >> 2] | 0; if (b | 0) { c = a + 4 | 0; if ((f[c >> 2] | 0) != (b | 0)) f[c >> 2] = b; br(b) } br(a); return } function Ym(a) { a = a | 0; f[a >> 2] = 2544; tj(a + 88 | 0); br(a); return } function Zm(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return em(a, b, c, d, e, f) | 0 } function _m(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return fm(a, b, c, d, e, f) | 0 } function $m(a) { a = a | 0; f[a >> 2] = 2796; tj(a + 88 | 0); return } function an(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0; e = u; u = u + 16 | 0; g = e | 0; Bd(a, b, c, d, g) | 0; u = e; return (I = f[g + 4 >> 2] | 0, f[g >> 2] | 0) | 0 } function bn(a) { a = a | 0; var b = 0; $n(a); f[a >> 2] = 5840; b = a + 84 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; f[b + 12 >> 2] = 0; f[b + 16 >> 2] = 0; f[b + 20 >> 2] = 0; return } function cn(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return hm(a, b, c, d, e, f) | 0 } function dn(a) { a = a | 0; var b = 0, c = 0; b = (a | 0) == 0 ? 1 : a; while (1) { a = $a(b) | 0; if (a | 0) { c = a; break } a = $p() | 0; if (!a) { c = 0; break } Ua[a & 3]() } return c | 0 } function en(a, b, c) { a = a | 0; b = b | 0; c = c | 0; ac(a, b, c); return } function fn(a, b, c) { a = a | 0; b = b | 0; c = c | 0; f[a + 4 >> 2] = b; f[a + 8 >> 2] = f[(f[(f[b + 4 >> 2] | 0) + 8 >> 2] | 0) + (c << 2) >> 2]; f[a + 12 >> 2] = c; return 1 } function gn(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return pm(a, b, c, d, e, f) | 0 } function hn(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; return qm(a, b, c, d, e, f) | 0 } function jn(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = $(f); Tm(a, b, c, d, e, f); return } function kn(a) { a = a | 0; f[a >> 2] = 2544; tj(a + 88 | 0); return } function ln(a) { a = a | 0; var b = 0, c = 0, d = 0; b = u; u = u + 16 | 0; c = b; d = dr(f[a + 60 >> 2] | 0) | 0; f[c >> 2] = d; d = ro(Ba(6, c | 0) | 0) | 0; u = b; return d | 0 } function mn() { var a = 0, b = 0; a = u; u = u + 16 | 0; if (!(Ka(18612, 3) | 0)) { b = Ia(f[4654] | 0) | 0; u = a; return b | 0 } else Dn(17746, a); return 0 } function nn(a) { a = a | 0; var b = 0; if (!a) return; b = f[a >> 2] | 0; f[a >> 2] = 0; if (b | 0) Va[f[(f[b >> 2] | 0) + 4 >> 2] & 127](b); br(a); return } function on(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, f = 0; e = a; a = c; c = Rl(e, a) | 0; f = I; return (I = (X(b, a) | 0) + (X(d, e) | 0) + f | f & 0, c | 0 | 0) | 0 } function pn(a, b) { a = a | 0; b = b | 0; Sg(a, b); f[a >> 2] = 1276; b = a + 36 | 0; a = b + 40 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (a | 0)); return } function qn(a) { a = a | 0; Gi(a); br(a); return } function rn(a) { a = a | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; f[a + 20 >> 2] = 0; f[a + 24 >> 2] = 0; f[a + 28 >> 2] = 0; return } function sn(a) { a = a | 0; var b = 0; b = u; u = u + 16 | 0; wc(a); if (!(La(f[4654] | 0, 0) | 0)) { u = b; return } else Dn(17845, b) } function tn(a) { a = a | 0; var b = 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; b = a + 16 | 0; f[b >> 2] = 0; f[b + 4 >> 2] = 0; f[b + 8 >> 2] = 0; f[b + 12 >> 2] = 0; return } function un(a, b) { a = a | 0; b = b | 0; return eg(a + 40 | 0, b) | 0 } function vn(a, b) { a = a | 0; b = b | 0; return $i(a, b, Aq(b) | 0) | 0 } function wn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0, g = 0; e = u; u = u + 16 | 0; g = e; f[g >> 2] = d; d = Mi(a, b, c, g) | 0; u = e; return d | 0 } function xn(a, b) { a = a | 0; b = b | 0; return Aj(a + 40 | 0, b) | 0 } function yn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return zh(a, b, c, d) | 0 } function zn(a) { a = a | 0; var b = 0; f[a >> 2] = 3608; f[a + 52 >> 2] = 0; b = a + 4 | 0; a = b + 44 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (a | 0)); return } function An(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return $g(a, b, c, d) | 0 } function Bn(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[a + 64 >> 2] | 0; return Ra[f[(f[c >> 2] | 0) + 24 >> 2] & 127](c, b) | 0 } function Cn(a) { a = a | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; f[a + 20 >> 2] = 0; b[a + 24 >> 0] = 0; return } function Dn(a, b) { a = a | 0; b = b | 0; var c = 0, d = 0; c = u; u = u + 16 | 0; d = c; f[d >> 2] = b; b = f[1478] | 0; hh(b, a, d) | 0; zj(10, b) | 0; Ca() } function En(a, b, c, d, e, f, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; g = g | 0; return Ta[a & 31](b | 0, c | 0, d | 0, e | 0, f | 0, g | 0) | 0 } function Fn(a) { a = a | 0; var b = 0; b = f[a + 56 >> 2] | 0; f[a + 60 >> 2] = ((f[b + 100 >> 2] | 0) - (f[b + 96 >> 2] | 0) | 0) / 12 | 0; return } function Gn(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[a + 64 >> 2] | 0; return Ra[f[(f[c >> 2] | 0) + 16 >> 2] & 127](c, b) | 0 } function Hn(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[a + 64 >> 2] | 0; return Ra[f[(f[c >> 2] | 0) + 20 >> 2] & 127](c, b) | 0 } function In(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[a + 64 >> 2] | 0; return Ra[f[(f[c >> 2] | 0) + 12 >> 2] & 127](c, b) | 0 } function Jn() { var a = 0; a = u; u = u + 16 | 0; if (!(Ja(18616, 117) | 0)) { u = a; return } else Dn(17795, a) } function Kn(a) { a = a | 0; f[a >> 2] = 1136; Vh(a + 4 | 0); f[a + 40 >> 2] = 0; f[a + 44 >> 2] = 0; f[a >> 2] = 2944; return } function Ln(a) { a = a | 0; Se(a); br(a); return } function Mn(a, b, c, d, e, f, g) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; g = g | 0; _a[a & 3](b | 0, c | 0, d | 0, e | 0, f | 0, g | 0) } function Nn(a, b) { a = a | 0; b = b | 0; var c = 0; c = f[b + 64 >> 2] | 0; Wa[f[(f[c >> 2] | 0) + 28 >> 2] & 15](a, c); return } function On(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if (b | 0) hj(a | 0, (zq(c) | 0) & 255 | 0, b | 0) | 0; return a | 0 } function Pn(a) { a = a | 0; return 4 } function Qn(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Ui(0, b, c) | 0 } function Rn(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if ((c | 0) < 32) { I = b << c | (a & (1 << c) - 1 << 32 - c) >>> 32 - c; return a << c } I = a << c - 32; return 0 } function Sn() { } function Tn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0; e = a + c >>> 0; return (I = b + d + (e >>> 0 < a >>> 0 | 0) >>> 0, e | 0) | 0 } function Un(a, b) { a = a | 0; b = b | 0; var c = 0; if (!b) c = 0; else c = lh(f[b >> 2] | 0, f[b + 4 >> 2] | 0, a) | 0; return (c | 0 ? c : a) | 0 } function Vn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; var e = 0; e = b - d >>> 0; e = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0; return (I = e, a - c >>> 0 | 0) | 0 } function Wn(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if ((c | 0) < 32) { I = b >>> c; return a >>> c | (b & (1 << c) - 1) << 32 - c } I = 0; return b >>> c - 32 | 0 } function Xn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return qe(a, b, c, d) | 0 } function Yn(a) { a = a | 0; Ve(a); br(a); return } function Zn(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = +d; return Oi(a, b, c, d) | 0 } function _n(a) { a = a | 0; return 5 } function $n(a) { a = a | 0; var b = 0; f[a >> 2] = 5880; b = a + 4 | 0; a = b + 80 | 0; do { f[b >> 2] = 0; b = b + 4 | 0 } while ((b | 0) < (a | 0)); return } function ao(a) { a = a | 0; return 6 } function bo(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return Pi(a, b, c, d) | 0 } function co(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Fj(a, b, c); return } function eo(a, b) { a = a | 0; b = b | 0; xi(f[a >> 2] | 0, b); return } function fo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; co(a, b, c); return } function go(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; He(a, b, c, d, 1); return } function ho(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; He(a, b, c, d, 0); return } function io(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return Eg(a, b, c, d) | 0 } function jo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Qh(a, b, c) | 0 } function ko(a) { a = a | 0; var b = 0; b = f[a + 64 >> 2] | 0; return Qa[f[(f[b >> 2] | 0) + 32 >> 2] & 127](b) | 0 } function lo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; f[a + 28 >> 2] = b; f[a + 32 >> 2] = c; return 1 } function mo(a, b) { a = a | 0; b = b | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; return } function no(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Fj(f[a >> 2] | 0, b, c); return } function oo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Ui(a, b, c) | 0 } function po(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Qn(a, b, c) | 0 } function qo(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; Za[a & 3](b | 0, c | 0, d | 0, e | 0, f | 0) } function ro(a) { a = a | 0; var b = 0, c = 0; if (a >>> 0 > 4294963200) { b = ir() | 0; f[b >> 2] = 0 - a; c = -1 } else c = a; return c | 0 } function so(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return rh(a, b, c) | 0 } function to(a) { a = a | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a + 12 >> 2] = 0; f[a + 16 >> 2] = 0; return } function uo(a, b) { a = a | 0; b = b | 0; f[a + 8 >> 2] = b; f[a + 12 >> 2] = -1; return 1 } function vo(a, b) { a = a | 0; b = b | 0; f[a + 56 >> 2] = b; tp(a, b); return } function wo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; no(a, b, c); return } function xo(a) { a = +a; var b = 0; p[s >> 3] = a; b = f[s >> 2] | 0; I = f[s + 4 >> 2] | 0; return b | 0 } function yo(a, b, c) { a = a | 0; b = $(b); c = c | 0; var d = Oa; d = $($(c | 0) / b); n[a >> 2] = d; return } function zo(a, b) { a = a | 0; b = b | 0; xi(a, b); return } function Ao(a) { a = a | 0; wm(a); f[a >> 2] = 1460; f[a + 36 >> 2] = 0; return } function Bo(a) { a = a | 0; zn(a); f[a >> 2] = 3424; f[a + 56 >> 2] = 0; f[a + 60 >> 2] = 0; return } function Co(a) { a = a | 0; var b = 0; if (!a) b = 0; else b = (mh(a, 1024, 1112, 0) | 0) != 0 & 1; return b | 0 } function Do(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Eo(f[a >> 2] | 0, b, c); return } function Eo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Fi(a + 4 | 0, b, c); return } function Fo(a) { a = a | 0; var b = 0; b = dn(8) | 0; ck(b, a); return b | 0 } function Go(a) { a = a | 0; if ((b[a + 11 >> 0] | 0) < 0) br(f[a >> 2] | 0); return } function Ho(a) { a = a | 0; if (!a) return; Va[f[(f[a >> 2] | 0) + 4 >> 2] & 127](a); return } function Io(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; Ya[a & 7](b | 0, c | 0, d | 0, e | 0) } function Jo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if (c | 0) Xl(a | 0, b | 0, c | 0) | 0; return a | 0 } function Ko(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Do(a, b, c); return } function Lo(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if (c | 0) Rg(a | 0, b | 0, c | 0) | 0; return a | 0 } function Mo(a) { a = a | 0; f[a + 52 >> 2] = f[(f[a + 4 >> 2] | 0) + 80 >> 2]; return } function No(a, b) { a = a | 0; b = b | 0; eo(a, b); return } function Oo(a) { a = a | 0; f[a + 52 >> 2] = f[(f[a + 56 >> 2] | 0) + 80 >> 2]; return } function Po(a, b) { a = a | 0; b = b | 0; return -1 } function Qo(a) { a = a | 0; var b = 0; b = u; u = u + 16 | 0; Ua[a & 3](); Dn(17898, b) } function Ro(a) { a = a | 0; wh(a); br(a); return } function So(a, b, c) { a = a | 0; b = b | 0; c = c | 0; $o(a, b, c); return } function To(a, b) { a = a | 0; b = b | 0; bk(f[a >> 2] | 0, b); return } function Uo(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return Sa[a & 31](b | 0, c | 0, d | 0) | 0 } function Vo(a, b) { a = a | 0; b = b | 0; return (Jp(a, b) | 0) << 24 >> 24 | 0 } function Wo(a, b) { a = a | 0; b = b | 0; f[a >> 2] = 6924; Sl(a + 4 | 0, b); return } function Xo(a) { a = a | 0; Bo(a); f[a >> 2] = 3e3; f[a + 64 >> 2] = 0; return } function Yo(a, b) { a = a | 0; b = b | 0; var c = 0; if (!a) c = 0; else c = Bi(a, b, 0) | 0; return c | 0 } function Zo(a, b) { a = a | 0; b = b | 0; zo(a, b); return } function _o(a) { a = a | 0; return f[a + 12 >> 2] | 0 } function $o(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Eo(a, b, c); return } function ap() { var a = 0; a = dn(64) | 0; Al(a); return a | 0 } function bp(a, b) { a = a | 0; b = b | 0; To(a, b); return } function cp(a) { a = a | 0; if (!a) return; Qi(a); br(a); return } function dp(a) { a = a | 0; return f[a + 4 >> 2] | 0 } function ep(a, b, c) { a = a | 0; b = b | 0; c = c | 0; if (!(f[a >> 2] & 32)) ai(b, c, a) | 0; return } function fp(a) { a = a | 0; return Mp(a) | 0 } function gp(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; Xa[a & 15](b | 0, c | 0, d | 0) } function hp() { var a = 0; a = dn(96) | 0; Lm(a); return a | 0 } function ip(a) { a = a | 0; return Np(a) | 0 } function jp(a) { a = a | 0; var b = 0; b = u; u = u + a | 0; u = u + 15 & -16; return b | 0 } function kp(a) { a = a | 0; var b = 0; b = (Yq() | 0) + 188 | 0; return Tj(a, f[b >> 2] | 0) | 0 } function lp(a) { a = a | 0; return ((f[a + 100 >> 2] | 0) - (f[a + 96 >> 2] | 0) | 0) / 12 | 0 | 0 } function mp(a, b) { a = a | 0; b = b | 0; vp(a, b); return } function np(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; aa(3); return 0 } function op() { var a = 0; a = dn(12) | 0; Bp(a); return a | 0 } function pp(a) { a = a | 0; zi(a); br(a); return } function qp(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return (a | 0) == (b | 0) | 0 } function rp(a, b) { a = a | 0; b = b | 0; var c = 0; c = Fp(a | 0) | 0; return ((b | 0) == 0 ? a : c) | 0 } function sp(a) { a = a | 0; return (f[a + 12 >> 2] | 0) - (f[a + 8 >> 2] | 0) >> 2 | 0 } function tp(a, b) { a = a | 0; b = b | 0; f[a + 4 >> 2] = b; return } function up(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; return Bd(a, b, c, d, 0) | 0 } function vp(a, b) { a = a | 0; b = b | 0; bk(a, b); return } function wp(a) { a = a | 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; f[a >> 2] = a + 4; return } function xp(a) { a = a | 0; return nq(a) | 0 } function yp() { var a = 0; a = dn(84) | 0; $n(a); return a | 0 } function zp(a) { a = a | 0; gi(a); br(a); return } function Ap(a) { a = a | 0; return oq(a) | 0 } function Bp(a) { a = a | 0; f[a >> 2] = 0; f[a + 4 >> 2] = 0; f[a + 8 >> 2] = 0; return } function Cp(a) { a = a | 0; f[a >> 2] = 6924; lm(a + 4 | 0); return } function Dp(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return Ra[a & 127](b | 0, c | 0) | 0 } function Ep(a, b, c, d, e, f) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; f = f | 0; aa(10) } function Fp(a) { a = a | 0; return (a & 255) << 24 | (a >> 8 & 255) << 16 | (a >> 16 & 255) << 8 | a >>> 24 | 0 } function Gp(a) { a = a | 0; Bo(a); f[a >> 2] = 3504; return } function Hp(a, c) { a = a | 0; c = c | 0; b[a >> 0] = b[c >> 0] | 0; return } function Ip(a, b, c) { a = a | 0; b = b | 0; c = c | 0; return -1 } function Jp(a, c) { a = a | 0; c = c | 0; return b[(f[a >> 2] | 0) + c >> 0] | 0 } function Kp(a) { a = a | 0; return (f[a + 4 >> 2] | 0) - (f[a >> 2] | 0) | 0 } function Lp(a) { a = a | 0; aj(a); br(a); return } function Mp(a) { a = a | 0; return f[(f[a >> 2] | 0) + 40 >> 2] | 0 } function Np(a) { a = a | 0; return f[(f[a >> 2] | 0) + 44 >> 2] | 0 } function Op(a) { a = a | 0; if (!a) return; br(a); return } function Pp(a) { a = a | 0; b[a + 28 >> 0] = 1; return } function Qp(a, b) { a = a | 0; b = b | 0; if (!x) { x = a; y = b } } function Rp(a, b) { a = a | 0; b = b | 0; return 1 } function Sp(a) { a = a | 0; return a + 12 | 0 } function Tp(a, b, c) { a = a | 0; b = b | 0; c = c | 0; Wa[a & 15](b | 0, c | 0) } function Up(a, b) { a = a | 0; b = b | 0; f[a + 80 >> 2] = b; return } function Vp() { var a = 0; a = dn(48) | 0; Fq(a); return a | 0 } function Wp(a) { a = a | 0; return vq(a + 4 | 0) | 0 } function Xp() { var a = 0; a = dn(108) | 0; bn(a); return a | 0 } function Yp(a) { a = a | 0; return (b[a + 32 >> 0] | 0) != 0 | 0 } function Zp(a) { a = a | 0; return a + -12 | 0 } function _p(a, b, c, d, e) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; e = e | 0; aa(9) } function $p() { var a = 0; a = f[4655] | 0; f[4655] = a + 0; return a | 0 } function aq(a) { a = a | 0; return f[a + 56 >> 2] | 0 } function bq() { var a = 0; a = f[1708] | 0; f[1708] = a + 0; return a | 0 } function cq(a) { a = a | 0; wg(a); br(a); return } function dq(a) { a = a | 0; fr(a); br(a); return } function eq(a) { a = a | 0; return b[a + 24 >> 0] | 0 } function fq(a, b) { a = a | 0; b = b | 0; return 0 } function gq(a) { a = a | 0; return f[a + 48 >> 2] | 0 } function hq(a, b) { a = a | 0; b = b | 0; return Qa[a & 127](b | 0) | 0 } function iq(a) { a = a | 0; return f[a + 60 >> 2] | 0 } function jq(a) { a = a | 0; return f[a + 28 >> 2] | 0 } function kq(a) { a = a | 0; sa(a | 0) | 0; bm() } function lq(a) { a = a | 0; Cp(a); br(a); return } function mq(a) { a = a | 0; Ca() } function nq(a) { a = a | 0; return f[a + 40 >> 2] | 0 } function oq(a) { a = a | 0; return f[a + 44 >> 2] | 0 } function pq(a, b) { a = a | 0; b = b | 0; return $(+sk(a, b, 0)) } function qq(a) { a = a | 0; return 3 } function rq(a, b) { a = a | 0; b = b | 0; u = a; v = b } function sq(a) { a = a | 0; n[a >> 2] = $(1.0); return } function tq(a) { a = a | 0; return ((a | 0) == 32 | (a + -9 | 0) >>> 0 < 5) & 1 | 0 } function uq(a) { a = a | 0; return f[a + 80 >> 2] | 0 } function vq(a) { a = a | 0; return f[a >> 2] | 0 } function wq(a, b, c, d) { a = a | 0; b = b | 0; c = c | 0; d = d | 0; aa(8) } function xq(a, b) { a = a | 0; b = b | 0; Va[a & 127](b | 0) } function yq(a, b) { a = a | 0; b = b | 0; return Un(a, b) | 0 } function zq(a) { a = a | 0; return a & 255 | 0 } function Aq(a) { a = a | 0; return vj(a) | 0 } function Bq(a, b) { a = a | 0; b = b | 0; return +(+sk(a, b, 1)) } function Cq(a, b, c) { a = a | 0; b = b | 0; c = c | 0; aa(2); return 0 } function Dq(a) { a = a | 0; return 2 } function Eq(a) { a = a | 0; return 1 } function Fq(a) { a = a | 0; Kn(a); return } function Gq(a, b) { a = +a; b = +b; return +(+Nl(a, b)) } function Hq(a, b) { a = +a; b = b | 0; return +(+Wj(a, b)) } function Iq(a, b) { a = +a; b = b | 0; return +(+Uj(a, b)) } function Jq() { return 3 } function Kq(a, b, c) { a = a | 0; b = b | 0; c = c | 0; aa(7) } function Lq() { return 0 } function Mq() { return -1 } function Nq() { return dn(1) | 0 } function Oq() { return 4 } function Pq(a) { a = a | 0; return (a + -48 | 0) >>> 0 < 10 | 0 } function Qq() { return 1 } function Rq() { return 2 } function Sq(a, b) { a = +a; b = +b; return +(+pd(a, b)) } function Tq(a, b) { a = a | 0; b = b | 0; aa(1); return 0 } function Uq(a) { a = a | 0; Ha() } function Vq(a) { a = a | 0; Ua[a & 3]() } function Wq() { ua() } function Xq(a) { a = a | 0; return +(+Bq(a, 0)) } function Yq() { return lr() | 0 } function Zq(a, b) { a = a | 0; b = b | 0; aa(6) } function _q(a) { a = a | 0; return dn(a) | 0 } function $q(a) { a = a | 0; br(a); return } function ar(a) { a = a | 0; u = a } function br(a) { a = a | 0; wc(a); return } function cr(a) { a = a | 0; I = a } function dr(a) { a = a | 0; return a | 0 } function er(a) { a = a | 0; aa(0); return 0 } function fr(a) { a = a | 0; return } function gr(a) { a = a | 0; return 0 } function hr() { return I | 0 } function ir() { return 18544 } function jr() { return u | 0 } function kr(a) { a = a | 0; aa(5) } function lr() { return 6040 } function mr() { aa(4) }

    // EMSCRIPTEN_END_FUNCS
    var Qa = [er, Dq, Eq, Eq, Dq, gb, gr, gr, gr, ak, Vf, Eq, dp, gr, gr, Eq, gr, Eq, Eq, rl, _n, ll, Eq, ao, Yk, Eq, jq, Pn, rl, Eq, rl, _n, ll, Eq, ao, Yk, Eq, jq, Pn, rl, Eq, qq, gr, dp, Eq, gr, Eq, qq, Eq, kl, Pn, kl, _n, il, Eq, ao, Qk, Eq, jq, Eq, kl, Pn, kl, _n, il, Eq, ao, Qk, Eq, jq, Eq, Dq, Eq, Eq, Cd, Eq, Je, Tg, qk, ko, _o, dp, lg, sg, $e, _o, dp, Eq, gr, gr, wi, gr, Eq, gr, Xj, ln, Wp, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er, er]; var Ra = [Tq, ql, Ug, ve, xl, fq, fq, fq, Rp, kb, gj, uo, Rp, Rp, fi, bj, Uh, ek, jl, Gj, Vk, Yj, Zj, Fe, Po, fq, Zh, fq, Dl, _e, fq, El, Zg, $l, td, fq, Dl, _e, fq, El, Zg, $l, td, xn, Po, fq, Xh, sd, fq, tl, We, fq, ul, Yg, $l, sd, fq, tl, We, fq, ul, Yg, $l, un, Hn, Bn, In, Gn, Kg, dk, mk, mc, le, Jm, wf, af, Ze, Ig, dk, mk, lc, le, Jm, Rp, fq, fq, bf, nm, Xf, bf, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq, Tq]; var Sa = [Cq, lo, Ip, fn, Km, fg, cj, el, ih, uc, vh, $f, Rh, Qb, Oh, vg, gl, Dm, qj, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq, Cq]; var Ta = [np, Ld, Bc, ne, Sb, bb, Cc, me, Rb, ab, Lg, ed, eb, sf, qc, id, db, qf, nc, np, np, np, np, np, np, np, np, np, np, np, np, np]; var Ua = [mr, Wq, Ai, Jn]; var Va = [kr, Ij, Qj, fr, $q, um, Yl, Wk, Uq, gi, zp, zi, pp, wh, Ro, zm, tm, Vl, Uq, Hl, Hl, Uk, Jk, _k, Ok, fr, $q, Uq, Li, Ul, Hl, Rk, Gk, Xk, Mk, fr, $q, Uq, Ii, Kl, zm, tm, fr, $q, $q, mj, Bl, ym, gm, kn, Ym, fr, $q, $q, kj, sl, sm, Zl, $m, Mm, fr, $q, ok, hk, Qj, Sj, Vj, Vj, am, Bm, Mc, Jl, Ve, Yn, rk, jk, Lk, Fk, Em, rm, xk, nk, Nk, Ik, Nm, vm, Fm, xm, Gi, qn, Se, Ln, aj, Uq, Lp, Oo, Fn, fr, $q, Uq, Lp, Mo, Lp, Mo, Dk, wk, rb, wg, cq, fr, dq, fr, fr, dq, Cp, lq, lq, sn, kr, kr, kr, kr, kr, kr, kr, kr, kr, kr]; var Wa = [Zq, ik, Rf, Ri, Nn, ib, lb, sc, mo, ej, ej, pk, Ec, Zq, Zq, Zq]; var Xa = [Kq, ze, Yi, $b, fc, Fc, $b, fc, uj, Ej, Hg, oj, ug, If, Kq, Kq]; var Ya = [wq, Dg, Zf, Wl, Zk, wq, wq, wq]; var Za = [_p, ij, Vg, _p]; var _a = [Ep, Il, Kk, Ep]; return { ___cxa_can_catch: _l, ___cxa_is_pointer_type: Co, ___divdi3: zk, ___muldi3: on, ___udivdi3: up, ___uremdi3: an, _bitshift64Lshr: Wn, _bitshift64Shl: Rn, _emscripten_bind_DracoInt8Array_DracoInt8Array_0: op, _emscripten_bind_DracoInt8Array_GetValue_1: Vo, _emscripten_bind_DracoInt8Array___destroy___0: Xm, _emscripten_bind_DracoInt8Array_size_0: Kp, _emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2: jo, _emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3: An, _emscripten_bind_Encoder_Encoder_0: Vp, _emscripten_bind_Encoder_GetNumberOfEncodedFaces_0: Ap, _emscripten_bind_Encoder_GetNumberOfEncodedPoints_0: xp, _emscripten_bind_Encoder_SetAttributeExplicitQuantization_5: Um, _emscripten_bind_Encoder_SetAttributeQuantization_2: fo, _emscripten_bind_Encoder_SetEncodingMethod_1: mp, _emscripten_bind_Encoder_SetSpeedOptions_2: So, _emscripten_bind_Encoder_SetTrackEncodedProperties_1: Zo, _emscripten_bind_Encoder___destroy___0: Hj, _emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2: so, _emscripten_bind_ExpertEncoder_ExpertEncoder_1: Fo, _emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0: ip, _emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0: fp, _emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5: jn, _emscripten_bind_ExpertEncoder_SetAttributeQuantization_2: wo, _emscripten_bind_ExpertEncoder_SetEncodingMethod_1: bp, _emscripten_bind_ExpertEncoder_SetSpeedOptions_2: Ko, _emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1: No, _emscripten_bind_ExpertEncoder___destroy___0: nn, _emscripten_bind_GeometryAttribute_GeometryAttribute_0: ap, _emscripten_bind_GeometryAttribute___destroy___0: Op, _emscripten_bind_MeshBuilder_AddFacesToMesh_3: io, _emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5: hn, _emscripten_bind_MeshBuilder_AddFloatAttribute_5: hn, _emscripten_bind_MeshBuilder_AddInt16Attribute_5: _m, _emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5: gn, _emscripten_bind_MeshBuilder_AddInt32Attribute_5: gn, _emscripten_bind_MeshBuilder_AddInt8Attribute_5: cn, _emscripten_bind_MeshBuilder_AddMetadataToMesh_2: po, _emscripten_bind_MeshBuilder_AddMetadata_2: oo, _emscripten_bind_MeshBuilder_AddUInt16Attribute_5: Wm, _emscripten_bind_MeshBuilder_AddUInt32Attribute_5: Vm, _emscripten_bind_MeshBuilder_AddUInt8Attribute_5: Zm, _emscripten_bind_MeshBuilder_MeshBuilder_0: Nq, _emscripten_bind_MeshBuilder_SetMetadataForAttribute_3: yn, _emscripten_bind_MeshBuilder___destroy___0: Op, _emscripten_bind_Mesh_Mesh_0: Xp, _emscripten_bind_Mesh___destroy___0: Ho, _emscripten_bind_Mesh_num_attributes_0: sp, _emscripten_bind_Mesh_num_faces_0: lp, _emscripten_bind_Mesh_num_points_0: uq, _emscripten_bind_Mesh_set_num_points_1: Up, _emscripten_bind_MetadataBuilder_AddDoubleEntry_3: Zn, _emscripten_bind_MetadataBuilder_AddIntEntry_3: bo, _emscripten_bind_MetadataBuilder_AddStringEntry_3: Xn, _emscripten_bind_MetadataBuilder_MetadataBuilder_0: Nq, _emscripten_bind_MetadataBuilder___destroy___0: Op, _emscripten_bind_Metadata_Metadata_0: Ml, _emscripten_bind_Metadata___destroy___0: cp, _emscripten_bind_PointAttribute_PointAttribute_0: hp, _emscripten_bind_PointAttribute___destroy___0: xj, _emscripten_bind_PointAttribute_attribute_type_0: aq, _emscripten_bind_PointAttribute_byte_offset_0: gq, _emscripten_bind_PointAttribute_byte_stride_0: nq, _emscripten_bind_PointAttribute_data_type_0: jq, _emscripten_bind_PointAttribute_normalized_0: Yp, _emscripten_bind_PointAttribute_num_components_0: eq, _emscripten_bind_PointAttribute_size_0: uq, _emscripten_bind_PointAttribute_unique_id_0: iq, _emscripten_bind_PointCloudBuilder_AddFloatAttribute_5: hn, _emscripten_bind_PointCloudBuilder_AddInt16Attribute_5: _m, _emscripten_bind_PointCloudBuilder_AddInt32Attribute_5: gn, _emscripten_bind_PointCloudBuilder_AddInt8Attribute_5: cn, _emscripten_bind_PointCloudBuilder_AddMetadata_2: oo, _emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5: Wm, _emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5: Vm, _emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5: Zm, _emscripten_bind_PointCloudBuilder_PointCloudBuilder_0: Nq, _emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3: yn, _emscripten_bind_PointCloudBuilder___destroy___0: Op, _emscripten_bind_PointCloud_PointCloud_0: yp, _emscripten_bind_PointCloud___destroy___0: Ho, _emscripten_bind_PointCloud_num_attributes_0: sp, _emscripten_bind_PointCloud_num_points_0: uq, _emscripten_bind_VoidPtr___destroy___0: Op, _emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE: Mq, _emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD: Lq, _emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH: Qq, _emscripten_enum_draco_GeometryAttribute_Type_COLOR: Rq, _emscripten_enum_draco_GeometryAttribute_Type_GENERIC: Oq, _emscripten_enum_draco_GeometryAttribute_Type_INVALID: Mq, _emscripten_enum_draco_GeometryAttribute_Type_NORMAL: Qq, _emscripten_enum_draco_GeometryAttribute_Type_POSITION: Lq, _emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD: Jq, _emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING: Qq, _emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING: Lq, _emscripten_replace_memory: Pa, _free: wc, _i64Add: Tn, _i64Subtract: Vn, _llvm_bswap_i32: Fp, _malloc: $a, _memcpy: Rg, _memmove: Xl, _memset: hj, _sbrk: Fl, dynCall_ii: hq, dynCall_iii: Dp, dynCall_iiii: Uo, dynCall_iiiiiii: En, dynCall_v: Vq, dynCall_vi: xq, dynCall_vii: Tp, dynCall_viii: gp, dynCall_viiii: Io, dynCall_viiiii: qo, dynCall_viiiiii: Mn, establishStackSpace: rq, getTempRet0: hr, runPostSets: Sn, setTempRet0: cr, setThrew: Qp, stackAlloc: jp, stackRestore: ar, stackSave: jr }
  })


    // EMSCRIPTEN_END_ASM
    (Module.asmGlobalArg, Module.asmLibraryArg, buffer); var ___cxa_can_catch = Module["___cxa_can_catch"] = asm["___cxa_can_catch"]; var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = asm["___cxa_is_pointer_type"]; var ___divdi3 = Module["___divdi3"] = asm["___divdi3"]; var ___muldi3 = Module["___muldi3"] = asm["___muldi3"]; var ___udivdi3 = Module["___udivdi3"] = asm["___udivdi3"]; var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"]; var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"]; var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"]; var _emscripten_bind_DracoInt8Array_DracoInt8Array_0 = Module["_emscripten_bind_DracoInt8Array_DracoInt8Array_0"] = asm["_emscripten_bind_DracoInt8Array_DracoInt8Array_0"]; var _emscripten_bind_DracoInt8Array_GetValue_1 = Module["_emscripten_bind_DracoInt8Array_GetValue_1"] = asm["_emscripten_bind_DracoInt8Array_GetValue_1"]; var _emscripten_bind_DracoInt8Array___destroy___0 = Module["_emscripten_bind_DracoInt8Array___destroy___0"] = asm["_emscripten_bind_DracoInt8Array___destroy___0"]; var _emscripten_bind_DracoInt8Array_size_0 = Module["_emscripten_bind_DracoInt8Array_size_0"] = asm["_emscripten_bind_DracoInt8Array_size_0"]; var _emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = Module["_emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2"] = asm["_emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2"]; var _emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = Module["_emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3"] = asm["_emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3"]; var _emscripten_bind_Encoder_Encoder_0 = Module["_emscripten_bind_Encoder_Encoder_0"] = asm["_emscripten_bind_Encoder_Encoder_0"]; var _emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = Module["_emscripten_bind_Encoder_GetNumberOfEncodedFaces_0"] = asm["_emscripten_bind_Encoder_GetNumberOfEncodedFaces_0"]; var _emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = Module["_emscripten_bind_Encoder_GetNumberOfEncodedPoints_0"] = asm["_emscripten_bind_Encoder_GetNumberOfEncodedPoints_0"]; var _emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = Module["_emscripten_bind_Encoder_SetAttributeExplicitQuantization_5"] = asm["_emscripten_bind_Encoder_SetAttributeExplicitQuantization_5"]; var _emscripten_bind_Encoder_SetAttributeQuantization_2 = Module["_emscripten_bind_Encoder_SetAttributeQuantization_2"] = asm["_emscripten_bind_Encoder_SetAttributeQuantization_2"]; var _emscripten_bind_Encoder_SetEncodingMethod_1 = Module["_emscripten_bind_Encoder_SetEncodingMethod_1"] = asm["_emscripten_bind_Encoder_SetEncodingMethod_1"]; var _emscripten_bind_Encoder_SetSpeedOptions_2 = Module["_emscripten_bind_Encoder_SetSpeedOptions_2"] = asm["_emscripten_bind_Encoder_SetSpeedOptions_2"]; var _emscripten_bind_Encoder_SetTrackEncodedProperties_1 = Module["_emscripten_bind_Encoder_SetTrackEncodedProperties_1"] = asm["_emscripten_bind_Encoder_SetTrackEncodedProperties_1"]; var _emscripten_bind_Encoder___destroy___0 = Module["_emscripten_bind_Encoder___destroy___0"] = asm["_emscripten_bind_Encoder___destroy___0"]; var _emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = Module["_emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2"] = asm["_emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2"]; var _emscripten_bind_ExpertEncoder_ExpertEncoder_1 = Module["_emscripten_bind_ExpertEncoder_ExpertEncoder_1"] = asm["_emscripten_bind_ExpertEncoder_ExpertEncoder_1"]; var _emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = Module["_emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0"] = asm["_emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0"]; var _emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = Module["_emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0"] = asm["_emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0"]; var _emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = Module["_emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5"] = asm["_emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5"]; var _emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = Module["_emscripten_bind_ExpertEncoder_SetAttributeQuantization_2"] = asm["_emscripten_bind_ExpertEncoder_SetAttributeQuantization_2"]; var _emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = Module["_emscripten_bind_ExpertEncoder_SetEncodingMethod_1"] = asm["_emscripten_bind_ExpertEncoder_SetEncodingMethod_1"]; var _emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = Module["_emscripten_bind_ExpertEncoder_SetSpeedOptions_2"] = asm["_emscripten_bind_ExpertEncoder_SetSpeedOptions_2"]; var _emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = Module["_emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1"] = asm["_emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1"]; var _emscripten_bind_ExpertEncoder___destroy___0 = Module["_emscripten_bind_ExpertEncoder___destroy___0"] = asm["_emscripten_bind_ExpertEncoder___destroy___0"]; var _emscripten_bind_GeometryAttribute_GeometryAttribute_0 = Module["_emscripten_bind_GeometryAttribute_GeometryAttribute_0"] = asm["_emscripten_bind_GeometryAttribute_GeometryAttribute_0"]; var _emscripten_bind_GeometryAttribute___destroy___0 = Module["_emscripten_bind_GeometryAttribute___destroy___0"] = asm["_emscripten_bind_GeometryAttribute___destroy___0"]; var _emscripten_bind_MeshBuilder_AddFacesToMesh_3 = Module["_emscripten_bind_MeshBuilder_AddFacesToMesh_3"] = asm["_emscripten_bind_MeshBuilder_AddFacesToMesh_3"]; var _emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = Module["_emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5"] = asm["_emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5"]; var _emscripten_bind_MeshBuilder_AddFloatAttribute_5 = Module["_emscripten_bind_MeshBuilder_AddFloatAttribute_5"] = asm["_emscripten_bind_MeshBuilder_AddFloatAttribute_5"]; var _emscripten_bind_MeshBuilder_AddInt16Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddInt16Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddInt16Attribute_5"]; var _emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = Module["_emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5"] = asm["_emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5"]; var _emscripten_bind_MeshBuilder_AddInt32Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddInt32Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddInt32Attribute_5"]; var _emscripten_bind_MeshBuilder_AddInt8Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddInt8Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddInt8Attribute_5"]; var _emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = Module["_emscripten_bind_MeshBuilder_AddMetadataToMesh_2"] = asm["_emscripten_bind_MeshBuilder_AddMetadataToMesh_2"]; var _emscripten_bind_MeshBuilder_AddMetadata_2 = Module["_emscripten_bind_MeshBuilder_AddMetadata_2"] = asm["_emscripten_bind_MeshBuilder_AddMetadata_2"]; var _emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddUInt16Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddUInt16Attribute_5"]; var _emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddUInt32Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddUInt32Attribute_5"]; var _emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = Module["_emscripten_bind_MeshBuilder_AddUInt8Attribute_5"] = asm["_emscripten_bind_MeshBuilder_AddUInt8Attribute_5"]; var _emscripten_bind_MeshBuilder_MeshBuilder_0 = Module["_emscripten_bind_MeshBuilder_MeshBuilder_0"] = asm["_emscripten_bind_MeshBuilder_MeshBuilder_0"]; var _emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = Module["_emscripten_bind_MeshBuilder_SetMetadataForAttribute_3"] = asm["_emscripten_bind_MeshBuilder_SetMetadataForAttribute_3"]; var _emscripten_bind_MeshBuilder___destroy___0 = Module["_emscripten_bind_MeshBuilder___destroy___0"] = asm["_emscripten_bind_MeshBuilder___destroy___0"]; var _emscripten_bind_Mesh_Mesh_0 = Module["_emscripten_bind_Mesh_Mesh_0"] = asm["_emscripten_bind_Mesh_Mesh_0"]; var _emscripten_bind_Mesh___destroy___0 = Module["_emscripten_bind_Mesh___destroy___0"] = asm["_emscripten_bind_Mesh___destroy___0"]; var _emscripten_bind_Mesh_num_attributes_0 = Module["_emscripten_bind_Mesh_num_attributes_0"] = asm["_emscripten_bind_Mesh_num_attributes_0"]; var _emscripten_bind_Mesh_num_faces_0 = Module["_emscripten_bind_Mesh_num_faces_0"] = asm["_emscripten_bind_Mesh_num_faces_0"]; var _emscripten_bind_Mesh_num_points_0 = Module["_emscripten_bind_Mesh_num_points_0"] = asm["_emscripten_bind_Mesh_num_points_0"]; var _emscripten_bind_Mesh_set_num_points_1 = Module["_emscripten_bind_Mesh_set_num_points_1"] = asm["_emscripten_bind_Mesh_set_num_points_1"]; var _emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = Module["_emscripten_bind_MetadataBuilder_AddDoubleEntry_3"] = asm["_emscripten_bind_MetadataBuilder_AddDoubleEntry_3"]; var _emscripten_bind_MetadataBuilder_AddIntEntry_3 = Module["_emscripten_bind_MetadataBuilder_AddIntEntry_3"] = asm["_emscripten_bind_MetadataBuilder_AddIntEntry_3"]; var _emscripten_bind_MetadataBuilder_AddStringEntry_3 = Module["_emscripten_bind_MetadataBuilder_AddStringEntry_3"] = asm["_emscripten_bind_MetadataBuilder_AddStringEntry_3"]; var _emscripten_bind_MetadataBuilder_MetadataBuilder_0 = Module["_emscripten_bind_MetadataBuilder_MetadataBuilder_0"] = asm["_emscripten_bind_MetadataBuilder_MetadataBuilder_0"]; var _emscripten_bind_MetadataBuilder___destroy___0 = Module["_emscripten_bind_MetadataBuilder___destroy___0"] = asm["_emscripten_bind_MetadataBuilder___destroy___0"]; var _emscripten_bind_Metadata_Metadata_0 = Module["_emscripten_bind_Metadata_Metadata_0"] = asm["_emscripten_bind_Metadata_Metadata_0"]; var _emscripten_bind_Metadata___destroy___0 = Module["_emscripten_bind_Metadata___destroy___0"] = asm["_emscripten_bind_Metadata___destroy___0"]; var _emscripten_bind_PointAttribute_PointAttribute_0 = Module["_emscripten_bind_PointAttribute_PointAttribute_0"] = asm["_emscripten_bind_PointAttribute_PointAttribute_0"]; var _emscripten_bind_PointAttribute___destroy___0 = Module["_emscripten_bind_PointAttribute___destroy___0"] = asm["_emscripten_bind_PointAttribute___destroy___0"]; var _emscripten_bind_PointAttribute_attribute_type_0 = Module["_emscripten_bind_PointAttribute_attribute_type_0"] = asm["_emscripten_bind_PointAttribute_attribute_type_0"]; var _emscripten_bind_PointAttribute_byte_offset_0 = Module["_emscripten_bind_PointAttribute_byte_offset_0"] = asm["_emscripten_bind_PointAttribute_byte_offset_0"]; var _emscripten_bind_PointAttribute_byte_stride_0 = Module["_emscripten_bind_PointAttribute_byte_stride_0"] = asm["_emscripten_bind_PointAttribute_byte_stride_0"]; var _emscripten_bind_PointAttribute_data_type_0 = Module["_emscripten_bind_PointAttribute_data_type_0"] = asm["_emscripten_bind_PointAttribute_data_type_0"]; var _emscripten_bind_PointAttribute_normalized_0 = Module["_emscripten_bind_PointAttribute_normalized_0"] = asm["_emscripten_bind_PointAttribute_normalized_0"]; var _emscripten_bind_PointAttribute_num_components_0 = Module["_emscripten_bind_PointAttribute_num_components_0"] = asm["_emscripten_bind_PointAttribute_num_components_0"]; var _emscripten_bind_PointAttribute_size_0 = Module["_emscripten_bind_PointAttribute_size_0"] = asm["_emscripten_bind_PointAttribute_size_0"]; var _emscripten_bind_PointAttribute_unique_id_0 = Module["_emscripten_bind_PointAttribute_unique_id_0"] = asm["_emscripten_bind_PointAttribute_unique_id_0"]; var _emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddFloatAttribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddFloatAttribute_5"]; var _emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddInt16Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddInt16Attribute_5"]; var _emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddInt32Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddInt32Attribute_5"]; var _emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddInt8Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddInt8Attribute_5"]; var _emscripten_bind_PointCloudBuilder_AddMetadata_2 = Module["_emscripten_bind_PointCloudBuilder_AddMetadata_2"] = asm["_emscripten_bind_PointCloudBuilder_AddMetadata_2"]; var _emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5"]; var _emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5"]; var _emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = Module["_emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5"] = asm["_emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5"]; var _emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = Module["_emscripten_bind_PointCloudBuilder_PointCloudBuilder_0"] = asm["_emscripten_bind_PointCloudBuilder_PointCloudBuilder_0"]; var _emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = Module["_emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3"] = asm["_emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3"]; var _emscripten_bind_PointCloudBuilder___destroy___0 = Module["_emscripten_bind_PointCloudBuilder___destroy___0"] = asm["_emscripten_bind_PointCloudBuilder___destroy___0"]; var _emscripten_bind_PointCloud_PointCloud_0 = Module["_emscripten_bind_PointCloud_PointCloud_0"] = asm["_emscripten_bind_PointCloud_PointCloud_0"]; var _emscripten_bind_PointCloud___destroy___0 = Module["_emscripten_bind_PointCloud___destroy___0"] = asm["_emscripten_bind_PointCloud___destroy___0"]; var _emscripten_bind_PointCloud_num_attributes_0 = Module["_emscripten_bind_PointCloud_num_attributes_0"] = asm["_emscripten_bind_PointCloud_num_attributes_0"]; var _emscripten_bind_PointCloud_num_points_0 = Module["_emscripten_bind_PointCloud_num_points_0"] = asm["_emscripten_bind_PointCloud_num_points_0"]; var _emscripten_bind_VoidPtr___destroy___0 = Module["_emscripten_bind_VoidPtr___destroy___0"] = asm["_emscripten_bind_VoidPtr___destroy___0"]; var _emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = Module["_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE"] = asm["_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE"]; var _emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = Module["_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD"] = asm["_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD"]; var _emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = Module["_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH"] = asm["_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH"]; var _emscripten_enum_draco_GeometryAttribute_Type_COLOR = Module["_emscripten_enum_draco_GeometryAttribute_Type_COLOR"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_COLOR"]; var _emscripten_enum_draco_GeometryAttribute_Type_GENERIC = Module["_emscripten_enum_draco_GeometryAttribute_Type_GENERIC"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_GENERIC"]; var _emscripten_enum_draco_GeometryAttribute_Type_INVALID = Module["_emscripten_enum_draco_GeometryAttribute_Type_INVALID"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_INVALID"]; var _emscripten_enum_draco_GeometryAttribute_Type_NORMAL = Module["_emscripten_enum_draco_GeometryAttribute_Type_NORMAL"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_NORMAL"]; var _emscripten_enum_draco_GeometryAttribute_Type_POSITION = Module["_emscripten_enum_draco_GeometryAttribute_Type_POSITION"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_POSITION"]; var _emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = Module["_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD"] = asm["_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD"]; var _emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = Module["_emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING"] = asm["_emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING"]; var _emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = Module["_emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING"] = asm["_emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING"]; var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"]; var _free = Module["_free"] = asm["_free"]; var _i64Add = Module["_i64Add"] = asm["_i64Add"]; var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"]; var _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = asm["_llvm_bswap_i32"]; var _malloc = Module["_malloc"] = asm["_malloc"]; var _memcpy = Module["_memcpy"] = asm["_memcpy"]; var _memmove = Module["_memmove"] = asm["_memmove"]; var _memset = Module["_memset"] = asm["_memset"]; var _sbrk = Module["_sbrk"] = asm["_sbrk"]; var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"]; var getTempRet0 = Module["getTempRet0"] = asm["getTempRet0"]; var runPostSets = Module["runPostSets"] = asm["runPostSets"]; var setTempRet0 = Module["setTempRet0"] = asm["setTempRet0"]; var setThrew = Module["setThrew"] = asm["setThrew"]; var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"]; var stackRestore = Module["stackRestore"] = asm["stackRestore"]; var stackSave = Module["stackSave"] = asm["stackSave"]; var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"]; var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"]; var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"]; var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = asm["dynCall_iiiiiii"]; var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"]; var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"]; var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"]; var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"]; var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"]; var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"]; var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"]; Module["asm"] = asm; if (memoryInitializer) { if (!isDataURI(memoryInitializer)) { if (typeof Module["locateFile"] === "function") { memoryInitializer = Module["locateFile"](memoryInitializer) } else if (Module["memoryInitializerPrefixURL"]) { memoryInitializer = Module["memoryInitializerPrefixURL"] + memoryInitializer } } if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) { var data = Module["readBinary"](memoryInitializer); HEAPU8.set(data, GLOBAL_BASE) } else { addRunDependency("memory initializer"); var applyMemoryInitializer = (function (data) { if (data.byteLength) data = new Uint8Array(data); HEAPU8.set(data, GLOBAL_BASE); if (Module["memoryInitializerRequest"]) delete Module["memoryInitializerRequest"].response; removeRunDependency("memory initializer") }); function doBrowserLoad() { Module["readAsync"](memoryInitializer, applyMemoryInitializer, (function () { throw "could not load memory initializer " + memoryInitializer })) } var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer); if (memoryInitializerBytes) { applyMemoryInitializer(memoryInitializerBytes.buffer) } else if (Module["memoryInitializerRequest"]) { function useRequest() { var request = Module["memoryInitializerRequest"]; var response = request.response; if (request.status !== 200 && request.status !== 0) { var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]); if (data) { response = data.buffer } else { console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer); doBrowserLoad(); return } } applyMemoryInitializer(response) } if (Module["memoryInitializerRequest"].response) { setTimeout(useRequest, 0) } else { Module["memoryInitializerRequest"].addEventListener("load", useRequest) } } else { doBrowserLoad() } } } Module["then"] = (function (func) { if (Module["calledRun"]) { func(Module) } else { var old = Module["onRuntimeInitialized"]; Module["onRuntimeInitialized"] = (function () { if (old) old(); func(Module) }) } return Module }); function ExitStatus(status) { this.name = "ExitStatus"; this.message = "Program terminated with exit(" + status + ")"; this.status = status } ExitStatus.prototype = new Error; ExitStatus.prototype.constructor = ExitStatus; var initialStackTop; dependenciesFulfilled = function runCaller() { if (!Module["calledRun"]) run(); if (!Module["calledRun"]) dependenciesFulfilled = runCaller }; function run(args) { args = args || Module["arguments"]; if (runDependencies > 0) { return } preRun(); if (runDependencies > 0) return; if (Module["calledRun"]) return; function doRun() { if (Module["calledRun"]) return; Module["calledRun"] = true; if (ABORT) return; ensureInitRuntime(); preMain(); if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"](); postRun() } if (Module["setStatus"]) { Module["setStatus"]("Running..."); setTimeout((function () { setTimeout((function () { Module["setStatus"]("") }), 1); doRun() }), 1) } else { doRun() } } Module["run"] = run; function exit(status, implicit) { if (implicit && Module["noExitRuntime"] && status === 0) { return } if (Module["noExitRuntime"]) { } else { ABORT = true; EXITSTATUS = status; STACKTOP = initialStackTop; exitRuntime(); if (Module["onExit"]) Module["onExit"](status) } if (ENVIRONMENT_IS_NODE) { process["exit"](status) } Module["quit"](status, new ExitStatus(status)) } Module["exit"] = exit; function abort(what) { if (Module["onAbort"]) { Module["onAbort"](what) } if (what !== undefined) { Module.print(what); Module.printErr(what); what = JSON.stringify(what) } else { what = "" } ABORT = true; EXITSTATUS = 1; throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info." } Module["abort"] = abort; if (Module["preInit"]) { if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]]; while (Module["preInit"].length > 0) { Module["preInit"].pop()() } } Module["noExitRuntime"] = true; run(); function WrapperObject() { } WrapperObject.prototype = Object.create(WrapperObject.prototype); WrapperObject.prototype.constructor = WrapperObject; WrapperObject.prototype.__class__ = WrapperObject; WrapperObject.__cache__ = {}; Module["WrapperObject"] = WrapperObject; function getCache(__class__) { return (__class__ || WrapperObject).__cache__ } Module["getCache"] = getCache; function wrapPointer(ptr, __class__) { var cache = getCache(__class__); var ret = cache[ptr]; if (ret) return ret; ret = Object.create((__class__ || WrapperObject).prototype); ret.ptr = ptr; return cache[ptr] = ret } Module["wrapPointer"] = wrapPointer; function castObject(obj, __class__) { return wrapPointer(obj.ptr, __class__) } Module["castObject"] = castObject; Module["NULL"] = wrapPointer(0); function destroy(obj) { if (!obj["__destroy__"]) throw "Error: Cannot destroy object. (Did you create it yourself?)"; obj["__destroy__"](); delete getCache(obj.__class__)[obj.ptr] } Module["destroy"] = destroy; function compare(obj1, obj2) { return obj1.ptr === obj2.ptr } Module["compare"] = compare; function getPointer(obj) { return obj.ptr } Module["getPointer"] = getPointer; function getClass(obj) { return obj.__class__ } Module["getClass"] = getClass; var ensureCache = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare: (function () { if (ensureCache.needed) { for (var i = 0; i < ensureCache.temps.length; i++) { Module["_free"](ensureCache.temps[i]) } ensureCache.temps.length = 0; Module["_free"](ensureCache.buffer); ensureCache.buffer = 0; ensureCache.size += ensureCache.needed; ensureCache.needed = 0 } if (!ensureCache.buffer) { ensureCache.size += 128; ensureCache.buffer = Module["_malloc"](ensureCache.size); assert(ensureCache.buffer) } ensureCache.pos = 0 }), alloc: (function (array, view) { assert(ensureCache.buffer); var bytes = view.BYTES_PER_ELEMENT; var len = array.length * bytes; len = len + 7 & -8; var ret; if (ensureCache.pos + len >= ensureCache.size) { assert(len > 0); ensureCache.needed += len; ret = Module["_malloc"](len); ensureCache.temps.push(ret) } else { ret = ensureCache.buffer + ensureCache.pos; ensureCache.pos += len } return ret }), copy: (function (array, view, offset) { var offsetShifted = offset; var bytes = view.BYTES_PER_ELEMENT; switch (bytes) { case 2: offsetShifted >>= 1; break; case 4: offsetShifted >>= 2; break; case 8: offsetShifted >>= 3; break }for (var i = 0; i < array.length; i++) { view[offsetShifted + i] = array[i] } }) }; function ensureString(value) { if (typeof value === "string") { var intArray = intArrayFromString(value); var offset = ensureCache.alloc(intArray, HEAP8); ensureCache.copy(intArray, HEAP8, offset); return offset } return value } function ensureInt8(value) { if (typeof value === "object") { var offset = ensureCache.alloc(value, HEAP8); ensureCache.copy(value, HEAP8, offset); return offset } return value } function ensureInt16(value) { if (typeof value === "object") { var offset = ensureCache.alloc(value, HEAP16); ensureCache.copy(value, HEAP16, offset); return offset } return value } function ensureInt32(value) { if (typeof value === "object") { var offset = ensureCache.alloc(value, HEAP32); ensureCache.copy(value, HEAP32, offset); return offset } return value } function ensureFloat32(value) { if (typeof value === "object") { var offset = ensureCache.alloc(value, HEAPF32); ensureCache.copy(value, HEAPF32, offset); return offset } return value } function PointCloud() { this.ptr = _emscripten_bind_PointCloud_PointCloud_0(); getCache(PointCloud)[this.ptr] = this } PointCloud.prototype = Object.create(WrapperObject.prototype); PointCloud.prototype.constructor = PointCloud; PointCloud.prototype.__class__ = PointCloud; PointCloud.__cache__ = {}; Module["PointCloud"] = PointCloud; PointCloud.prototype["num_attributes"] = PointCloud.prototype.num_attributes = (function () { var self = this.ptr; return _emscripten_bind_PointCloud_num_attributes_0(self) }); PointCloud.prototype["num_points"] = PointCloud.prototype.num_points = (function () { var self = this.ptr; return _emscripten_bind_PointCloud_num_points_0(self) }); PointCloud.prototype["__destroy__"] = PointCloud.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_PointCloud___destroy___0(self) }); function ExpertEncoder(arg0) { if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; this.ptr = _emscripten_bind_ExpertEncoder_ExpertEncoder_1(arg0); getCache(ExpertEncoder)[this.ptr] = this } ExpertEncoder.prototype = Object.create(WrapperObject.prototype); ExpertEncoder.prototype.constructor = ExpertEncoder; ExpertEncoder.prototype.__class__ = ExpertEncoder; ExpertEncoder.__cache__ = {}; Module["ExpertEncoder"] = ExpertEncoder; ExpertEncoder.prototype["SetEncodingMethod"] = ExpertEncoder.prototype.SetEncodingMethod = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; _emscripten_bind_ExpertEncoder_SetEncodingMethod_1(self, arg0) }); ExpertEncoder.prototype["SetAttributeQuantization"] = ExpertEncoder.prototype.SetAttributeQuantization = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; _emscripten_bind_ExpertEncoder_SetAttributeQuantization_2(self, arg0, arg1) }); ExpertEncoder.prototype["SetAttributeExplicitQuantization"] = ExpertEncoder.prototype.SetAttributeExplicitQuantization = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (typeof arg3 == "object") { arg3 = ensureFloat32(arg3) } if (arg4 && typeof arg4 === "object") arg4 = arg4.ptr; _emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5(self, arg0, arg1, arg2, arg3, arg4) }); ExpertEncoder.prototype["SetSpeedOptions"] = ExpertEncoder.prototype.SetSpeedOptions = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; _emscripten_bind_ExpertEncoder_SetSpeedOptions_2(self, arg0, arg1) }); ExpertEncoder.prototype["SetTrackEncodedProperties"] = ExpertEncoder.prototype.SetTrackEncodedProperties = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; _emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1(self, arg0) }); ExpertEncoder.prototype["EncodeToDracoBuffer"] = ExpertEncoder.prototype.EncodeToDracoBuffer = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; return _emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2(self, arg0, arg1) }); ExpertEncoder.prototype["GetNumberOfEncodedPoints"] = ExpertEncoder.prototype.GetNumberOfEncodedPoints = (function () { var self = this.ptr; return _emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0(self) }); ExpertEncoder.prototype["GetNumberOfEncodedFaces"] = ExpertEncoder.prototype.GetNumberOfEncodedFaces = (function () { var self = this.ptr; return _emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0(self) }); ExpertEncoder.prototype["__destroy__"] = ExpertEncoder.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_ExpertEncoder___destroy___0(self) }); function PointAttribute() { this.ptr = _emscripten_bind_PointAttribute_PointAttribute_0(); getCache(PointAttribute)[this.ptr] = this } PointAttribute.prototype = Object.create(WrapperObject.prototype); PointAttribute.prototype.constructor = PointAttribute; PointAttribute.prototype.__class__ = PointAttribute; PointAttribute.__cache__ = {}; Module["PointAttribute"] = PointAttribute; PointAttribute.prototype["size"] = PointAttribute.prototype.size = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_size_0(self) }); PointAttribute.prototype["attribute_type"] = PointAttribute.prototype.attribute_type = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_attribute_type_0(self) }); PointAttribute.prototype["data_type"] = PointAttribute.prototype.data_type = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_data_type_0(self) }); PointAttribute.prototype["num_components"] = PointAttribute.prototype.num_components = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_num_components_0(self) }); PointAttribute.prototype["normalized"] = PointAttribute.prototype.normalized = (function () { var self = this.ptr; return !!_emscripten_bind_PointAttribute_normalized_0(self) }); PointAttribute.prototype["byte_stride"] = PointAttribute.prototype.byte_stride = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_byte_stride_0(self) }); PointAttribute.prototype["byte_offset"] = PointAttribute.prototype.byte_offset = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_byte_offset_0(self) }); PointAttribute.prototype["unique_id"] = PointAttribute.prototype.unique_id = (function () { var self = this.ptr; return _emscripten_bind_PointAttribute_unique_id_0(self) }); PointAttribute.prototype["__destroy__"] = PointAttribute.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_PointAttribute___destroy___0(self) }); function Encoder() { this.ptr = _emscripten_bind_Encoder_Encoder_0(); getCache(Encoder)[this.ptr] = this } Encoder.prototype = Object.create(WrapperObject.prototype); Encoder.prototype.constructor = Encoder; Encoder.prototype.__class__ = Encoder; Encoder.__cache__ = {}; Module["Encoder"] = Encoder; Encoder.prototype["SetEncodingMethod"] = Encoder.prototype.SetEncodingMethod = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; _emscripten_bind_Encoder_SetEncodingMethod_1(self, arg0) }); Encoder.prototype["SetAttributeQuantization"] = Encoder.prototype.SetAttributeQuantization = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; _emscripten_bind_Encoder_SetAttributeQuantization_2(self, arg0, arg1) }); Encoder.prototype["SetAttributeExplicitQuantization"] = Encoder.prototype.SetAttributeExplicitQuantization = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (typeof arg3 == "object") { arg3 = ensureFloat32(arg3) } if (arg4 && typeof arg4 === "object") arg4 = arg4.ptr; _emscripten_bind_Encoder_SetAttributeExplicitQuantization_5(self, arg0, arg1, arg2, arg3, arg4) }); Encoder.prototype["SetSpeedOptions"] = Encoder.prototype.SetSpeedOptions = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; _emscripten_bind_Encoder_SetSpeedOptions_2(self, arg0, arg1) }); Encoder.prototype["SetTrackEncodedProperties"] = Encoder.prototype.SetTrackEncodedProperties = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; _emscripten_bind_Encoder_SetTrackEncodedProperties_1(self, arg0) }); Encoder.prototype["EncodeMeshToDracoBuffer"] = Encoder.prototype.EncodeMeshToDracoBuffer = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; return _emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2(self, arg0, arg1) }); Encoder.prototype["EncodePointCloudToDracoBuffer"] = Encoder.prototype.EncodePointCloudToDracoBuffer = (function (arg0, arg1, arg2) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; return _emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3(self, arg0, arg1, arg2) }); Encoder.prototype["GetNumberOfEncodedPoints"] = Encoder.prototype.GetNumberOfEncodedPoints = (function () { var self = this.ptr; return _emscripten_bind_Encoder_GetNumberOfEncodedPoints_0(self) }); Encoder.prototype["GetNumberOfEncodedFaces"] = Encoder.prototype.GetNumberOfEncodedFaces = (function () { var self = this.ptr; return _emscripten_bind_Encoder_GetNumberOfEncodedFaces_0(self) }); Encoder.prototype["__destroy__"] = Encoder.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_Encoder___destroy___0(self) }); function MeshBuilder() { this.ptr = _emscripten_bind_MeshBuilder_MeshBuilder_0(); getCache(MeshBuilder)[this.ptr] = this } MeshBuilder.prototype = Object.create(WrapperObject.prototype); MeshBuilder.prototype.constructor = MeshBuilder; MeshBuilder.prototype.__class__ = MeshBuilder; MeshBuilder.__cache__ = {}; Module["MeshBuilder"] = MeshBuilder; MeshBuilder.prototype["AddFacesToMesh"] = MeshBuilder.prototype.AddFacesToMesh = (function (arg0, arg1, arg2) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (typeof arg2 == "object") { arg2 = ensureInt32(arg2) } return !!_emscripten_bind_MeshBuilder_AddFacesToMesh_3(self, arg0, arg1, arg2) }); MeshBuilder.prototype["AddFloatAttributeToMesh"] = MeshBuilder.prototype.AddFloatAttributeToMesh = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureFloat32(arg4) } return _emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddInt32AttributeToMesh"] = MeshBuilder.prototype.AddInt32AttributeToMesh = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt32(arg4) } return _emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddMetadataToMesh"] = MeshBuilder.prototype.AddMetadataToMesh = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; return !!_emscripten_bind_MeshBuilder_AddMetadataToMesh_2(self, arg0, arg1) }); MeshBuilder.prototype["AddFloatAttribute"] = MeshBuilder.prototype.AddFloatAttribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureFloat32(arg4) } return _emscripten_bind_MeshBuilder_AddFloatAttribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddInt8Attribute"] = MeshBuilder.prototype.AddInt8Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt8(arg4) } return _emscripten_bind_MeshBuilder_AddInt8Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddUInt8Attribute"] = MeshBuilder.prototype.AddUInt8Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt8(arg4) } return _emscripten_bind_MeshBuilder_AddUInt8Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddInt16Attribute"] = MeshBuilder.prototype.AddInt16Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt16(arg4) } return _emscripten_bind_MeshBuilder_AddInt16Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddUInt16Attribute"] = MeshBuilder.prototype.AddUInt16Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt16(arg4) } return _emscripten_bind_MeshBuilder_AddUInt16Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddInt32Attribute"] = MeshBuilder.prototype.AddInt32Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt32(arg4) } return _emscripten_bind_MeshBuilder_AddInt32Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddUInt32Attribute"] = MeshBuilder.prototype.AddUInt32Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt32(arg4) } return _emscripten_bind_MeshBuilder_AddUInt32Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); MeshBuilder.prototype["AddMetadata"] = MeshBuilder.prototype.AddMetadata = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; return !!_emscripten_bind_MeshBuilder_AddMetadata_2(self, arg0, arg1) }); MeshBuilder.prototype["SetMetadataForAttribute"] = MeshBuilder.prototype.SetMetadataForAttribute = (function (arg0, arg1, arg2) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; return !!_emscripten_bind_MeshBuilder_SetMetadataForAttribute_3(self, arg0, arg1, arg2) }); MeshBuilder.prototype["__destroy__"] = MeshBuilder.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_MeshBuilder___destroy___0(self) }); function DracoInt8Array() { this.ptr = _emscripten_bind_DracoInt8Array_DracoInt8Array_0(); getCache(DracoInt8Array)[this.ptr] = this } DracoInt8Array.prototype = Object.create(WrapperObject.prototype); DracoInt8Array.prototype.constructor = DracoInt8Array; DracoInt8Array.prototype.__class__ = DracoInt8Array; DracoInt8Array.__cache__ = {}; Module["DracoInt8Array"] = DracoInt8Array; DracoInt8Array.prototype["GetValue"] = DracoInt8Array.prototype.GetValue = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; return _emscripten_bind_DracoInt8Array_GetValue_1(self, arg0) }); DracoInt8Array.prototype["size"] = DracoInt8Array.prototype.size = (function () { var self = this.ptr; return _emscripten_bind_DracoInt8Array_size_0(self) }); DracoInt8Array.prototype["__destroy__"] = DracoInt8Array.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_DracoInt8Array___destroy___0(self) }); function MetadataBuilder() { this.ptr = _emscripten_bind_MetadataBuilder_MetadataBuilder_0(); getCache(MetadataBuilder)[this.ptr] = this } MetadataBuilder.prototype = Object.create(WrapperObject.prototype); MetadataBuilder.prototype.constructor = MetadataBuilder; MetadataBuilder.prototype.__class__ = MetadataBuilder; MetadataBuilder.__cache__ = {}; Module["MetadataBuilder"] = MetadataBuilder; MetadataBuilder.prototype["AddStringEntry"] = MetadataBuilder.prototype.AddStringEntry = (function (arg0, arg1, arg2) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; else arg1 = ensureString(arg1); if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; else arg2 = ensureString(arg2); return !!_emscripten_bind_MetadataBuilder_AddStringEntry_3(self, arg0, arg1, arg2) }); MetadataBuilder.prototype["AddIntEntry"] = MetadataBuilder.prototype.AddIntEntry = (function (arg0, arg1, arg2) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; else arg1 = ensureString(arg1); if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; return !!_emscripten_bind_MetadataBuilder_AddIntEntry_3(self, arg0, arg1, arg2) }); MetadataBuilder.prototype["AddDoubleEntry"] = MetadataBuilder.prototype.AddDoubleEntry = (function (arg0, arg1, arg2) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; else arg1 = ensureString(arg1); if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; return !!_emscripten_bind_MetadataBuilder_AddDoubleEntry_3(self, arg0, arg1, arg2) }); MetadataBuilder.prototype["__destroy__"] = MetadataBuilder.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_MetadataBuilder___destroy___0(self) }); function GeometryAttribute() { this.ptr = _emscripten_bind_GeometryAttribute_GeometryAttribute_0(); getCache(GeometryAttribute)[this.ptr] = this } GeometryAttribute.prototype = Object.create(WrapperObject.prototype); GeometryAttribute.prototype.constructor = GeometryAttribute; GeometryAttribute.prototype.__class__ = GeometryAttribute; GeometryAttribute.__cache__ = {}; Module["GeometryAttribute"] = GeometryAttribute; GeometryAttribute.prototype["__destroy__"] = GeometryAttribute.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_GeometryAttribute___destroy___0(self) }); function Mesh() { this.ptr = _emscripten_bind_Mesh_Mesh_0(); getCache(Mesh)[this.ptr] = this } Mesh.prototype = Object.create(WrapperObject.prototype); Mesh.prototype.constructor = Mesh; Mesh.prototype.__class__ = Mesh; Mesh.__cache__ = {}; Module["Mesh"] = Mesh; Mesh.prototype["num_faces"] = Mesh.prototype.num_faces = (function () { var self = this.ptr; return _emscripten_bind_Mesh_num_faces_0(self) }); Mesh.prototype["num_attributes"] = Mesh.prototype.num_attributes = (function () { var self = this.ptr; return _emscripten_bind_Mesh_num_attributes_0(self) }); Mesh.prototype["num_points"] = Mesh.prototype.num_points = (function () { var self = this.ptr; return _emscripten_bind_Mesh_num_points_0(self) }); Mesh.prototype["set_num_points"] = Mesh.prototype.set_num_points = (function (arg0) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; _emscripten_bind_Mesh_set_num_points_1(self, arg0) }); Mesh.prototype["__destroy__"] = Mesh.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_Mesh___destroy___0(self) }); function PointCloudBuilder() { this.ptr = _emscripten_bind_PointCloudBuilder_PointCloudBuilder_0(); getCache(PointCloudBuilder)[this.ptr] = this } PointCloudBuilder.prototype = Object.create(WrapperObject.prototype); PointCloudBuilder.prototype.constructor = PointCloudBuilder; PointCloudBuilder.prototype.__class__ = PointCloudBuilder; PointCloudBuilder.__cache__ = {}; Module["PointCloudBuilder"] = PointCloudBuilder; PointCloudBuilder.prototype["AddFloatAttribute"] = PointCloudBuilder.prototype.AddFloatAttribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureFloat32(arg4) } return _emscripten_bind_PointCloudBuilder_AddFloatAttribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddInt8Attribute"] = PointCloudBuilder.prototype.AddInt8Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt8(arg4) } return _emscripten_bind_PointCloudBuilder_AddInt8Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddUInt8Attribute"] = PointCloudBuilder.prototype.AddUInt8Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt8(arg4) } return _emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddInt16Attribute"] = PointCloudBuilder.prototype.AddInt16Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt16(arg4) } return _emscripten_bind_PointCloudBuilder_AddInt16Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddUInt16Attribute"] = PointCloudBuilder.prototype.AddUInt16Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt16(arg4) } return _emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddInt32Attribute"] = PointCloudBuilder.prototype.AddInt32Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt32(arg4) } return _emscripten_bind_PointCloudBuilder_AddInt32Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddUInt32Attribute"] = PointCloudBuilder.prototype.AddUInt32Attribute = (function (arg0, arg1, arg2, arg3, arg4) { var self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; if (arg3 && typeof arg3 === "object") arg3 = arg3.ptr; if (typeof arg4 == "object") { arg4 = ensureInt32(arg4) } return _emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5(self, arg0, arg1, arg2, arg3, arg4) }); PointCloudBuilder.prototype["AddMetadata"] = PointCloudBuilder.prototype.AddMetadata = (function (arg0, arg1) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; return !!_emscripten_bind_PointCloudBuilder_AddMetadata_2(self, arg0, arg1) }); PointCloudBuilder.prototype["SetMetadataForAttribute"] = PointCloudBuilder.prototype.SetMetadataForAttribute = (function (arg0, arg1, arg2) { var self = this.ptr; if (arg0 && typeof arg0 === "object") arg0 = arg0.ptr; if (arg1 && typeof arg1 === "object") arg1 = arg1.ptr; if (arg2 && typeof arg2 === "object") arg2 = arg2.ptr; return !!_emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3(self, arg0, arg1, arg2) }); PointCloudBuilder.prototype["__destroy__"] = PointCloudBuilder.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_PointCloudBuilder___destroy___0(self) }); function VoidPtr() { throw "cannot construct a VoidPtr, no constructor in IDL" } VoidPtr.prototype = Object.create(WrapperObject.prototype); VoidPtr.prototype.constructor = VoidPtr; VoidPtr.prototype.__class__ = VoidPtr; VoidPtr.__cache__ = {}; Module["VoidPtr"] = VoidPtr; VoidPtr.prototype["__destroy__"] = VoidPtr.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_VoidPtr___destroy___0(self) }); function Metadata() { this.ptr = _emscripten_bind_Metadata_Metadata_0(); getCache(Metadata)[this.ptr] = this } Metadata.prototype = Object.create(WrapperObject.prototype); Metadata.prototype.constructor = Metadata; Metadata.prototype.__class__ = Metadata; Metadata.__cache__ = {}; Module["Metadata"] = Metadata; Metadata.prototype["__destroy__"] = Metadata.prototype.__destroy__ = (function () { var self = this.ptr; _emscripten_bind_Metadata___destroy___0(self) }); ((function () { function setupEnums() { Module["MESH_SEQUENTIAL_ENCODING"] = _emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING(); Module["MESH_EDGEBREAKER_ENCODING"] = _emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING(); Module["INVALID_GEOMETRY_TYPE"] = _emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE(); Module["POINT_CLOUD"] = _emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD(); Module["TRIANGULAR_MESH"] = _emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH(); Module["INVALID"] = _emscripten_enum_draco_GeometryAttribute_Type_INVALID(); Module["POSITION"] = _emscripten_enum_draco_GeometryAttribute_Type_POSITION(); Module["NORMAL"] = _emscripten_enum_draco_GeometryAttribute_Type_NORMAL(); Module["COLOR"] = _emscripten_enum_draco_GeometryAttribute_Type_COLOR(); Module["TEX_COORD"] = _emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD(); Module["GENERIC"] = _emscripten_enum_draco_GeometryAttribute_Type_GENERIC() } if (Module["calledRun"]) setupEnums(); else addOnPreMain(setupEnums) }))(); if (typeof Module["onModuleParsed"] === "function") { Module["onModuleParsed"]() }






  return DracoEncoderModule;
};
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = DracoEncoderModule;
else if (typeof define === 'function' && define['amd'])
  define([], function () { return DracoEncoderModule; });
else if (typeof exports === 'object')
  exports["DracoEncoderModule"] = DracoEncoderModule;


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
      (global = global || self, global.CodeMirror = factory());
}(this, (function () {
  'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function (node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) {
    range = function (node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r
    };
  }
  else {
    range = function (node, start, end) {
      var r = document.body.createTextRange();
      try { r.moveToElementText(node.parentNode); }
      catch (e) { return r }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r
    };
  }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
    { child = child.parentNode; }
    if (parent.contains) { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++) { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function (node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
  { selectInput = function (node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
  { selectInput = function (node) { try { node.select(); } catch (_e) { } }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () { return f.apply(null, args) }
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) { target[prop] = obj[prop]; }
    }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0; ;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end) { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function () {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = { toString: function () { return "CodeMirror.Pass" } };

  // Reused option objects for setSelection & friends
  var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0; ;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length - 1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() { }

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (; ;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i) { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3 + 1] &&
          (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) { }
          var replace = (i$4 && types[i$4 - 1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) { }
          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) { }
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) { }
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) { }
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function (emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, { passive: false });
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") { e = { type: e, preventDefault: function () { this.defaultPrevented = true; } }; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) { set.push(arr[i]); }
    }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) { on(this, type, f); };
    ctor.prototype.off = function (type, f) { off(this, type, f); };
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) { e_preventDefault(e); e_stopPropagation(e); }

  function e_target(e) { return e.target || e.srcElement }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch (e) { return false }
  } : function (te) {
    var range;
    try { range = te.ownerDocument.selection.createRange(); }
    catch (e) { }
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2) { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = { name: found }; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return { name: spec } }
    else { return spec || { name: "null" } }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) { modeObj[prop$1] = spec.modeProps[prop$1]; }
    }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || { mode: mode, state: state }
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function (string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () { return this.pos >= this.string.length };
  StringStream.prototype.sol = function () { return this.pos == this.lineStart };
  StringStream.prototype.peek = function () { return this.string.charAt(this.pos) || undefined };
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) { ++this.pos; return ch }
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)) { }
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () { this.pos = this.string.length; };
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) { this.pos = found; return true }
  };
  StringStream.prototype.backUp = function (n) { this.pos -= n; };
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function () { return this.string.slice(this.start, this.pos) };
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0; ; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0; ; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) { return l >= doc.first && l < doc.first + doc.size }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) { return Pos(x.line, x.ch) }
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) { return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1)) }
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function (state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function (doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n) { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    }
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
      lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function (o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end) { st.splice(i, 1, end, st[i + 1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);

    return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null }
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier) { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function (stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) {
      for (; ;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) { break }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null) { output[prop] = lineClass[2]; }
        else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop])) { output[prop] += " " + lineClass[2]; }
      }
    }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) { return span }
      }
    }
  }

  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i) { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }

  // Add a span to a line.
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
    if (inThisOp && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) { inThisOp.add(line.markedSpans); }
    }
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
            ; (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
            ; (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
              span.to == null ? null : span.to - endCh));
        }
      }
    }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); }
        }
      }
      for (var i$3 = 0; i$3 < gap; ++i$3) { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) { (markers || (markers = [])).push(mark); }
        }
      }
    });
    if (!markers) { return null }
    var parts = [{ from: from, to: to }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) { newParts.push({ from: p.from, to: m.from }); }
        if (dto > 0 || !mk.inclusiveRight && !dto) { newParts.push({ from: m.to, to: p.to }); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i) { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i) { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var sp = (void 0), i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
      }
    }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
      }
    }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) { continue }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) { return true }
      }
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
        ; (lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line)) { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = (void 0), i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) { continue }
        if (sp.from == null) { return true }
        if (sp.marker.widgetNode) { continue }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) { return true }
      }
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
        (sp.to == null || sp.to != span.from) &&
        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
        lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function (text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"), content: content,
      col: 0, pos: 0, cm: cm,
      trailingSpace: false,
      splitSpaces: cm.getOption("lineWrapping")
    };
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass) { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0) { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
          ; (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab"))) { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") { token.setAttribute(attr, attributes[attr]); }
        }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (; ;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (; ;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes) { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } }
        }

        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
            collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
              spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) { text = text.slice(upto - pos); pos = upto; break }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++) { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); }
        }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function (i) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop(i);
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text) { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
        ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px")));
      }
      if (markers) {
        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px")));
          }
        }
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); }
    }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll) { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
        (n.parentNode == display.sizer && n != display.mover)) { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) { return display.lineSpace.offsetTop }
  function paddingVert(display) { return display.mover.offsetHeight - display.lineSpace.offsetHeight }
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) { return { map: lineView.measure.map, cache: lineView.measure.cache } }
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        if (lineView.rest[i] == line) { return { map: lineView.measure.maps[i], cache: lineView.measure.caches[i] } }
      }
      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
        if (lineNo(lineView.rest[i$1]) > lineN) { return { map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true } }
      }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {
      left: found.left, right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    }
  }

  var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) { collapse = bias; }
        if (bias == "left" && start == 0) {
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        }
        break
      }
    }
    return { node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd }
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) { break }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) { break }
      }
    }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) { rect = node.parentNode.getBoundingClientRect(); }
        else { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) { rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom }; }
      else { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++) { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top, bottom: bot
    };
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX, right: rect.right * scaleX,
      top: rect.top * scaleY, bottom: rect.bottom * scaleY
    }
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) { lineView.measure.caches[i] = {}; }
      }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++) { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) {
      for (var i = 0; i < widgets.length; ++i) {
        if (widgets[i].above) { height += widgetHeight(widgets[i]); }
      }
    }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top }
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return { left: left, right: left, top: top, bottom: top + lineObj.height }
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last) { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (; ;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return { begin: begin, end: end }
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
        (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
          "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
        "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
        "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y) { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = { from: begin, to: part.to, level: part.level }; }
    if (part.to > end) { part = { from: part.from, to: end, level: part.level }; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    }
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
        }
      }

      if (wrapping) { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers > from)) { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size) { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) { return { index: index, lineN: newN } }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++) { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return { index: index, lineN: newN }
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from) { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to) { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to) { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    var customCursor = cm.options.$customCursor;
    if (customCursor) { primary = true; }
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (customCursor) {
        var head = customCursor(cm, range);
        if (head) { drawSelectionCursor(cm, head, curFragment); }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range.head, curFragment);
      }
      if (!collapsed) { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return { start: start, end: end }
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    }
    else if (cm.options.cursorBlinkRate < 0) { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        if (cm.state.focused) { onBlur(cm); }
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild) { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        if (oldHeight < viewTop) { mustScroll -= diff; }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) { updateWidgetHeight(cur.rest[j]); }
        }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i], parent = w.node.parentNode;
        if (parent) { w.height = parent.offsetHeight; }
      }
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return { from: from, to: Math.max(to, from + 1) }
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10) { result.scrollLeft = 0; }
    else if (rect.left < screenleft) { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3) { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, { top: val }); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function (place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 }
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () { };

  NullScrollbars.prototype.update = function () { return { bottom: 0, right: 0 } };
  NullScrollbars.prototype.setScrollLeft = function () { };
  NullScrollbars.prototype.setScrollTop = function () { };
  NullScrollbars.prototype.clear = function () { };

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass) { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,          // Unique ID
      markArrays: null         // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) {
      finishOperation(op, function (group) {
        for (var i = 0; i < group.ops.length; i++) { group.ops[i].cm.curOp = null; }
        endOperations(group);
      });
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
    { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
        op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged) { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection) { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay) { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput) { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
        clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } }
    }
    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } }
    }

    if (display.wrapper.offsetHeight) { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs) { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update) { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) { regLineChange(cm, changedLines[i], "text"); }
      });
    }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function (cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++) { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = { activeElt: active };
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
      snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
      display.renderedView == display.view && countDirtyView(cm) == 0) { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true; ; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) { viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) }; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node) { node.style.display = "none"; }
      else { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden); else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    // Send an event to consumers responding to changes in gutter width.
    signalLater(display, "gutterChanged", display);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) { view[i].gutter.style.left = left; }
          if (view[i].gutterBackground) { view[i].gutterBackground.style.left = left; }
        }
        var align = view[i].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) { align[j].style.left = left; }
        }
      }
    }
    if (cm.options.fixedGutter) { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
        "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({ className: name, style: style });
    }
    if (lineNumbers && !sawLineNumbers) { result.push({ className: "CodeMirror-linenumbers", style: null }); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // This attribute is respected by automatic translation systems such as Google Translate,
    // and may also be respected by tools used by human translators.
    d.wrapper.setAttribute('translate', 'no');

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1 / 3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return { x: dx, y: dy }
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY) { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY)) { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, { top: top, bottom: bot });
    }

    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function (ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++) { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++) { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) { return i }
    }
    return -1
  };

  var Range = function (anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
      lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
        adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) { return markedSpans ? markedSpans[n] : null }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i) { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) { continue }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) { continue }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc.direction;
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(prev) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
      hist.lastOrigin == change.origin && change.origin &&
      ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
        change.origin.charAt(0) == "*")) &&
      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges) { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
      (origin && hist.lastSelOrigin == origin &&
        (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))) { hist.done[hist.done.length - 1] = sel; }
    else { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i) { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({ from: change.from, to: change.to, text: change.text });
        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++) { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function (ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++) {
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
            clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i], m = sp.marker;

        // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
        // is with selectLeft/Right
        var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) { break }
              else { --i; continue }
            }
          }
          if (!m.atomic) { continue }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
            if (dir < 0 ? preventCursorRight : preventCursorLeft) { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) { return skipAtomicInner(doc, near, pos, dir, mayClear) }
          }

          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? preventCursorLeft : preventCursorRight) { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
        }
      }
    }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) { obj.from = clipPos(doc, from); }
        if (to) { obj.to = clipPos(doc, to); }
        if (text) { obj.text = text; }
        if (origin !== undefined) { obj.origin = origin; }
      };
    }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin }
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i) { makeChangeInner(doc, { from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin }); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (; ;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, { clearRedo: false });
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({ changes: antiChanges, generation: hist.generation });
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function (i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) }); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);

      if (returned) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(
        Pos(range.anchor.line + distance, range.anchor.ch),
        Pos(range.head.line + distance, range.head.ch)
      );
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)], origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from, to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]], origin: change.origin
      };
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1) { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full) { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) { regLineChange(cm, from.line, "text"); }
    else { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, { from: from, to: to, text: code, origin: origin });
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function () { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function (lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at) { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function () { return this.size },

    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function (lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function () {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function (at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function (doc, node, options) {
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) { this[opt] = options[opt]; }
      }
    }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
    var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop)) { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function (doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && { from: from, to: to }
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
        ; (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory) { addChangeToHistory(doc, { from: from, to: to, origin: "markText" }, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
        curLine == from.line ? from.ch : null,
        curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
      });
    }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length) { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed) { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
        marker.attributes || marker.title) { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function (markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i) { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i) { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i) { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function (i) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop(i);
  }

  var nextDocId = 0;
  var Doc = function (text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, { from: start, to: start, text: text });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function (from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top, to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code), origin: "setValue", full: true
      }, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      if (lineSep === '') { return lines.join('') }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function (line) { var l = this.getLineHandle(line); return l && l.text },

    getLineHandle: function (line) { if (isLine(this, line)) { return getLine(this, line) } },
    getLineNumber: function (line) { return lineNo(line) },

    getLineHandleVisualStart: function (line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function () { return this.size },
    firstLine: function () { return this.first },
    lastLine: function () { return this.first + this.size - 1 },

    clipPos: function (pos) { return clipPos(this, pos) },

    getCursor: function (start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function () { return this.sel.ranges },
    somethingSelected: function () { return this.sel.somethingSelected() },

    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(clipPos(this, ranges[i].anchor),
          clipPos(this, ranges[i].head || ranges[i].anchor));
      }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function (lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function (lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function (code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++) { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = { from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function () { makeChangeFromHistory(this, "undo"); }),
    redo: docMethodOp(function () { makeChangeFromHistory(this, "redo"); }),
    undoSelection: docMethodOp(function () { makeChangeFromHistory(this, "undo", true); }),
    redoSelection: docMethodOp(function () { makeChangeFromHistory(this, "redo", true); }),

    setExtending: function (val) { this.extend = val; },
    getExtending: function () { return this.extend },

    historySize: function () {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return { undo: done, redo: undone }
    },
    clearHistory: function () {
      var this$1 = this;

      this.history = new History(this.history);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function () {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function (forceSplit) {
      if (forceSplit) { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      }
    },
    setHistory: function (histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function (line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {
        line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
        textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
        widgets: line.widgets
      }
    },

    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
          : where == "background" ? "bgClass"
            : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
          : where == "background" ? "bgClass"
            : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function (widget) { widget.clear(); },

    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function (pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false, shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch)) { markers.push(span.marker.parent || span.marker); }
        }
      }
      return markers
    },
    findMarks: function (from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
              span.from == null && lineNo != from.line ||
              span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker))) { found.push(span.marker.parent || span.marker); }
          }
        }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) { if (sps[i].from != null) { markers.push(sps[i].marker); } }
        }
      });
      return markers
    },

    posFromIndex: function (off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function (options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history
        ;
      } (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
      copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other) { continue }
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break
        }
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) { linkedDocs(this, f); },

    getMode: function () { return this.mode },
    getEditor: function () { return this.cm },

    splitLines: function (str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function () { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {
              from: pos, to: pos,
              text: cm.doc.splitLines(
                text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
          indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); }
          }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch (e$1) { }
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) {
      editors[0].operation(function () {
        for (var i = 0; i < editors.length; i++) { f(editors[i]); }
      });
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
        if (value == "...") { delete keymap[keyname]; continue }

        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = (void 0), name = (void 0);
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) { copy[name] = val; }
          else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
        }
        delete keymap[keyname];
      }
    }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return { begin: 0, end: line.text.length } }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) {
        return moveInStorageOrder
          ? new Pos(start.line, mv(ch, 1), "before")
          : new Pos(start.line, ch, "after");
      };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine()) { return { from: range.head, to: Pos(range.head.line + 1, 0) } }
          else { return { from: range.head, to: Pos(range.head.line, len) } }
        } else {
          return { from: range.from(), to: range.to() }
        }
      });
    },
    deleteLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return ({
          from: Pos(range.from().line, 0),
          to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
        });
      });
    },
    delLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return ({
          from: Pos(range.from().line, 0), to: range.from()
        });
      });
    },
    delWrappedLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({ left: 0, top: top }, "div");
        return { from: leftPos, to: range.from() }
      });
    },
    delWrappedLineRight: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div");
        return { from: range.from(), to: rightPos }
      });
    },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) {
      return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
        { origin: "+move", bias: 1 }
      );
    },
    goLineStartSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
        { origin: "+move", bias: 1 }
      );
    },
    goLineEnd: function (cm) {
      return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
        { origin: "+move", bias: -1 }
      );
    },
    goLineRight: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div")
      }, sel_move);
    },
    goLineLeft: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({ left: 0, top: top }, "div")
      }, sel_move);
    },
    goLineLeftSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({ left: 0, top: top }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
        return pos
      }, sel_move);
    },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) { continue }
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                  prev.charAt(prev.length - 1),
                  Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function (cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--) { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++) { cm.indentLine(sels[i$1].from().line, null, true); }
        ensureCursorVisible(cm);
      });
    },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name)) { cm.state.keySeq = null; }
      else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi") { cm.state.keySeq = name; }
    if (result == "handled") { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
        || dispatchKey(cm, name, e, function (b) {
          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) { return doHandleBinding(cm, b) }
        })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) { lastStoppedKey = null; e_preventDefault(e); return }
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function (time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText) { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
      (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) { leftButtonStartDrag(cm, event, pos, behavior); }
    else { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9) { setTimeout(function () { display.wrapper.ownerDocument.body.focus({ preventScroll: true }); display.input.focus(); }, 20); }
        else { display.input.focus(); }
      }
    });
    var mouseMove = function (e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1) { ourRange = ranges[ourIndex]; }
      else { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
        { scroll: false, origin: "*mouse" });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
        { scroll: false, origin: "*mouse" });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
          line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right) { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos) { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
          { origin: "*mouse", scroll: false });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from) { setTimeout(operation(cm, function () { if (counter == curCount) { extend(e); } }), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) { return }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) { leftSide = dir < 0; }
      else { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch (e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = { toString: function () { return "CodeMirror.Init" } };

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) {
        optionHandlers[name] =
        notOnInit ? function (cm, val, old) { if (old != Init) { handle(cm, val, old); } } : handle;
      }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0; ;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--) { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) { if (!val) { cm.display.input.reset(); } }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping) { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus()) {
      setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20);
    }
    else { onBlur(this); }

    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) { optionHandlers[opt](this, options[opt], Init); }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    }
    else { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = { end: 0 };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {
          start: now, moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
        !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
        { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
        { range = cm.findWordAt(pos); }
        else // Triple tap
        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) { if (!signalDOMEvent(cm, e)) { e_stop(e); } },
      over: function (e) { if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); } },
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) { if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); } }
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n - 1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs) { for (var i = Math.floor(indentation / tabSize); i; --i) { pos += tabSize; indentString += "\t"; } }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++) { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
        { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {
        from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput) { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return { text: text, ranges: ranges }
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function () { window.focus(); this.display.input.focus(); },

      setOption: function (option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option)) { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function (option) { return this.options[option] },
      getDoc: function () { return this.doc },

      addKeyMap: function (map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function (map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          }
        }
      },

      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
          {
            mode: mode, modeSpec: spec, opaque: options && options.opaque,
            priority: (options && options.priority) || 0
          },
          function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function (how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function (pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function (line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function (pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else {
          for (; ;) {
            var mid = (before + after) >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
            else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
            else { type = styles[mid * 2 + 2]; break }
          }
        }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function (pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function (pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function (pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function (line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function (start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function (pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function (coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function (height, mode) {
        height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function (line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function () { return textHeight(this.display) },
      defaultCharWidth: function () { return charWidth(this.display) },

      getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } },

      addWidget: function (pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace) { top = pos.bottom; }
          if (left + node.offsetWidth > hspace) { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll) { scrollIntoView(this, { left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight }); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function (cmd) {
        if (commands.hasOwnProperty(cmd)) { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function (text) { triggerElectric(this, text); }),

      findPosH: function (from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function (dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty()) { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected()) { doc.replaceSelection("", null, "+delete"); }
        else {
          deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? { from: other, to: range.head } : { from: range.head, to: other }
          });
        }
      }),

      findPosV: function (from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function (dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse) { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary()) { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) { doc.sel.ranges[i].goalColumn = goals[i]; }
        }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function (pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
              : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function (value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite) { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function () { return this.display.input.getField() == activeElt() },
      isReadOnly: function () { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function () {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft, top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this), clientWidth: displayWidth(this)
        }
      },

      scrollIntoView: methodOp(function (range, margin) {
        if (range == null) {
          range = { from: this.doc.sel.primary().head, to: null };
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = { from: Pos(range, 0), to: null };
        } else if (range.from == null) {
          range = { from: range, to: null };
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function (width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } }
          }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function (f) { return runInOp(this, f) },
      startOperation: function () { return startOperation(this) },
      endOperation: function () { return endOperation(this) },

      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function (phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function () { return this.display.input.getField() },
      getWrapperElement: function () { return this.display.wrapper },
      getScrollerElement: function () { return this.display.scroller },
      getGutterElement: function () { return this.display.gutters }
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = { _global: [] }; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({ pred: predicate, val: value });
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true; ; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
            : !group || /\s/.test(cur) ? null
              : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) { dir = 1; moveOnce(); pos.sticky = "after"; }
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (; ;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function (cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = { data: e.data, done: false };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = { data: e.data, done: false }; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = activeElt();
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if (label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt() == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
      cmp(minPos(curAnchor, curFocus), from) == 0 &&
      cmp(maxPos(curAnchor, curFocus), to) == 0) { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
      { node: view[0].measure.map[2], offset: 0 };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = { node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3] };
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch (e) { } // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged()) { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt() != this.div) { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var this$1 = this;

    var input = this;
    if (this.selectionInEditor()) { setTimeout(function () { return this$1.pollSelection(); }, 20); }
    else { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
      });
    }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
      oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
      newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
        newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent()) { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly()) { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () { };
  ContentEditableInput.prototype.resetPosition = function () { };

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0))) { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++) { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (; ;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node; ; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode) { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) { return badPos(Pos(found.line, found.ch - dist), bad) }
      else { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function (cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
    var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if (label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
        headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
        headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) { } // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) { missed = true; input.polling.set(60, p); }
      else { input.pollingFast = false; input.slowPoll(); }
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
    var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
      (hasSelection(input) && !prevInput && !this.composing) ||
      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
      mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
        null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
          { className: "CodeMirror-composing" });
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
            te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () { };

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder) { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() { textarea.value = cm.getValue(); }

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) { }
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror.prototype[prop] = (function (method) {
        return function () { return method.apply(this.doc, arguments) }
      })(Doc.prototype[prop]);
    }
  }

  eventMixin(Doc);
  CodeMirror.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function (name/*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({ token: function (stream) { return stream.skipToEnd(); } }); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.65.2";

  return CodeMirror;

})));


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("javascript", function (config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var trackScope = parserConfig.trackScope !== false
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

    // Tokenizer

    var keywords = function () {
      function kw(type) { return { type: type, style: "keyword" }; }
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
      var operator = kw("operator"), atom = { type: "atom", style: "atom" };

      return {
        "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
        "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
        "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
        "function": kw("function"), "catch": kw("catch"),
        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
        "in": operator, "typeof": operator, "instanceof": operator,
        "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
        "this": kw("this"), "class": kw("class"), "super": kw("atom"),
        "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
        "await": C
      };
    }();

    var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;
          else if (inSet && next == "]") inSet = false;
        }
        escaped = !escaped && next == "\\";
      }
    }

    // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.
    var type, content;
    function ret(tp, style, cont) {
      type = tp; content = cont;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#" && stream.peek() == "!") {
        stream.skipToEnd();
        return ret("meta", "meta");
      } else if (ch == "#" && stream.eatWhile(wordRE)) {
        return ret("variable", "property")
      } else if (ch == "<" && stream.match("!--") ||
        (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
        stream.skipToEnd()
        return ret("comment", "comment")
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=")
          } else if (/[<>*+\-|&?]/.test(ch)) {
            stream.eat(ch)
            if (ch == ">") stream.eat(ch)
          }
        }
        if (ch == "?" && stream.eat(".")) return ret(".")
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current()
        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word]
            return ret(kw.type, kw.style, word)
          }
          if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
            return ret("async", "keyword", word)
        }
        return ret("variable", "variable", word)
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\";
        }
        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])";
    // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.
    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;

      if (isTS) { // Try to skip TypeScript return type declarations after the arguments
        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
        if (m) arrow = m.index
      }

      var depth = 0, sawSomething = false;
      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) { ++pos; break; }
          if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/`]/.test(ch)) {
          for (; ; --pos) {
            if (pos == 0) return
            var next = stream.string.charAt(pos - 1)
            if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth) state.fatArrowAt = pos;
    }

    // Parser

    var atomicTypes = {
      "atom": true, "number": true, "variable": true, "string": true,
      "regexp": true, "this": true, "import": true, "jsonld-keyword": true
    };

    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }

    function inScope(state, varname) {
      if (!trackScope) return false
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname) return true;
      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next)
          if (v.name == varname) return true;
      }
    }

    function parseJS(state, style, type, content, stream) {
      var cc = state.cc;
      // Communicate our context to the combinators.
      // (Less wasteful than consing up a hundred closures on every call.)
      cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;

      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type, content)) {
          while (cc.length && cc[cc.length - 1].lex)
            cc.pop()();
          if (cx.marked) return cx.marked;
          if (type == "variable" && inScope(state, content)) return "variable-2";
          return style;
        }
      }
    }

    // Combinator utils

    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name, list) {
      for (var v = list; v; v = v.next) if (v.name == name) return true
      return false;
    }
    function register(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (!trackScope) return
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          // FIXME function decls are also not block scoped
          var newContext = registerVarScoped(varname, state.context)
          if (newContext != null) {
            state.context = newContext
            return
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars)
          return
        }
      }
      // Fall through means this is global
      if (parserConfig.globalVars && !inList(varname, state.globalVars))
        state.globalVars = new Var(varname, state.globalVars)
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev)
        if (!inner) return null
        if (inner == context.prev) return context
        return new Context(inner, context.vars, true)
      } else if (inList(varname, context.vars)) {
        return context
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false)
      }
    }

    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
    }

    // Combinators

    function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
    function Var(name, next) { this.name = name; this.next = next }

    var defaultVars = new Var("this", new Var("arguments", null))
    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
      cx.state.localVars = defaultVars
    }
    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
      cx.state.localVars = null
    }
    function popcontext() {
      cx.state.localVars = cx.state.context.vars
      cx.state.context = cx.state.context.prev
    }
    popcontext.lex = true
    function pushlex(type, info) {
      var result = function () {
        var state = cx.state, indent = state.indented;
        if (state.lexical.type == "stat") indent = state.lexical.indented;
        else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
          indent = outer.indented;
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;

    function expect(wanted) {
      function exp(type) {
        if (type == wanted) return cont();
        else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
        else return cont(exp);
      };
      return exp;
    }

    function statement(type, value) {
      if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type == "debugger") return cont(expect(";"));
      if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type == ";") return cont();
      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type == "function") return cont(functiondef);
      if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
      if (type == "class" || (isTS && value == "interface")) {
        cx.marked = "keyword"
        return cont(pushlex("form", type == "class" ? type : value), className, poplex)
      }
      if (type == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword"
          return cont(statement)
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
          cx.marked = "keyword"
          if (value == "enum") return cont(enumdef);
          else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
          else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword"
          return cont(pushlex("form"), expression, statement, poplex)
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword"
          return cont(statement)
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
        block, poplex, poplex, popcontext);
      if (type == "case") return cont(expression, expect(":"));
      if (type == "default") return cont(expect(":"));
      if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type == "async") return cont(statement)
      if (value == "@") return cont(expression, statement)
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type) {
      if (type == "(") return cont(funarg, expect(")"))
    }
    function expression(type, value) {
      return expressionInner(type, value, false);
    }
    function expressionNoComma(type, value) {
      return expressionInner(type, value, true);
    }
    function parenExpr(type) {
      if (type != "(") return pass()
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
    }
    function expressionInner(type, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
        else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }

      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
      if (type == "function") return cont(functiondef, maybeop);
      if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
      if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
      if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi") return pass(quasi, maybeop);
      if (type == "new") return cont(maybeTarget(noComma));
      return cont();
    }
    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expression);
    }

    function maybeoperatorComma(type, value) {
      if (type == ",") return cont(maybeexpression);
      return maybeoperatorNoComma(type, value, false);
    }
    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type == "operator") {
        if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type == "quasi") { return pass(quasi, me); }
      if (type == ";") return;
      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".") return cont(property, me);
      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
      if (type == "regexp") {
        cx.state.lastType = cx.marked = "operator"
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
        return cont(expr)
      }
    }
    function quasi(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasi);
      return cont(maybeexpression, continueQuasi);
    }
    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function (type) {
        if (type == ".") return cont(noComma ? targetNoComma : target);
        else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
        else return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value) {
      if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
    }
    function targetNoComma(_, value) {
      if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
    }
    function maybelabel(type) {
      if (type == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type) {
      if (type == "variable") { cx.marked = "property"; return cont(); }
    }
    function objprop(type, value) {
      if (type == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
          cx.state.fatArrowAt = cx.stream.pos + m[0].length
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : (cx.style + " property");
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword"
        return cont(objprop)
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == ":") {
        return pass(afterprop)
      }
    }
    function getterSetter(type) {
      if (type != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type) {
      if (type == ":") return cont(expressionNoComma);
      if (type == "(") return pass(functiondef);
    }
    function commasep(what, end, sep) {
      function proceed(type, value) {
        if (sep ? sep.indexOf(type) > -1 : type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function (type, value) {
            if (type == end || value == end) return pass()
            return pass(what)
          }, proceed);
        }
        if (type == end || value == end) return cont();
        if (sep && sep.indexOf(";") > -1) return pass(what)
        return cont(expect(end));
      }
      return function (type, value) {
        if (type == end || value == end) return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++)
        cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type) {
      if (type == "}") return cont();
      return pass(statement, block);
    }
    function maybetype(type, value) {
      if (isTS) {
        if (type == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }
    function maybetypeOrIn(type, value) {
      if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
    }
    function mayberettype(type) {
      if (isTS && type == ":") {
        if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
        else return cont(typeexpr)
      }
    }
    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword"
        return cont()
      }
    }
    function typeexpr(type, value) {
      if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
        cx.marked = "keyword"
        return cont(value == "typeof" ? expressionNoComma : typeexpr)
      }
      if (type == "variable" || value == "void") {
        cx.marked = "type"
        return cont(afterType)
      }
      if (value == "|" || value == "&") return cont(typeexpr)
      if (type == "string" || type == "number" || type == "atom") return cont(afterType);
      if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
      if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)
      if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
      if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
      if (type == "quasi") { return pass(quasiType, afterType); }
    }
    function maybeReturnType(type) {
      if (type == "=>") return cont(typeexpr)
    }
    function typeprops(type) {
      if (type.match(/[\}\)\]]/)) return cont()
      if (type == "," || type == ";") return cont(typeprops)
      return pass(typeprop, typeprops)
    }
    function typeprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property"
        return cont(typeprop)
      } else if (value == "?" || type == "number" || type == "string") {
        return cont(typeprop)
      } else if (type == ":") {
        return cont(typeexpr)
      } else if (type == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
      } else if (type == "(") {
        return pass(functiondecl, typeprop)
      } else if (!type.match(/[;\}\)\],]/)) {
        return cont()
      }
    }
    function quasiType(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasiType);
      return cont(typeexpr, continueQuasiType);
    }
    function continueQuasiType(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasiType);
      }
    }
    function typearg(type, value) {
      if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
      if (type == ":") return cont(typeexpr)
      if (type == "spread") return cont(typearg)
      return pass(typeexpr)
    }
    function afterType(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
      if (value == "|" || type == "." || value == "&") return cont(typeexpr)
      if (type == "[") return cont(typeexpr, expect("]"), afterType)
      if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
      if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
    }
    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault)
    }
    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr)
    }
    function vardef(_, value) {
      if (value == "enum") { cx.marked = "keyword"; return cont(enumdef) }
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type, value) {
      if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
      if (type == "variable") { register(value); return cont(); }
      if (type == "spread") return cont(pattern);
      if (type == "[") return contCommasep(eltpattern, "]");
      if (type == "{") return contCommasep(proppattern, "}");
    }
    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type == "variable") cx.marked = "property";
      if (type == "spread") return cont(pattern);
      if (type == "}") return pass();
      if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern, maybeAssign)
    }
    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type) {
      if (type == ",") return cont(vardef);
    }
    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type, value) {
      if (value == "await") return cont(forspec);
      if (type == "(") return cont(pushlex(")"), forspec1, poplex);
    }
    function forspec1(type) {
      if (type == "var") return cont(vardef, forspec2);
      if (type == "variable") return cont(forspec2);
      return pass(forspec2)
    }
    function forspec2(type, value) {
      if (type == ")") return cont()
      if (type == ";") return cont(forspec2)
      if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
      return pass(expression, forspec2)
    }
    function functiondef(type, value) {
      if (value == "*") { cx.marked = "keyword"; return cont(functiondef); }
      if (type == "variable") { register(value); return cont(functiondef); }
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
    }
    function functiondecl(type, value) {
      if (value == "*") { cx.marked = "keyword"; return cont(functiondecl); }
      if (type == "variable") { register(value); return cont(functiondecl); }
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
    }
    function typename(type, value) {
      if (type == "keyword" || type == "variable") {
        cx.marked = "type"
        return cont(typename)
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
      }
    }
    function funarg(type, value) {
      if (value == "@") cont(expression, funarg)
      if (type == "spread") return cont(funarg);
      if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
      if (isTS && type == "this") return cont(maybetype, maybeAssign)
      return pass(pattern, maybetype, maybeAssign);
    }
    function classExpression(type, value) {
      // Class expressions may have an optional name.
      if (type == "variable") return className(type, value);
      return classNameAfter(type, value);
    }
    function className(type, value) {
      if (type == "variable") { register(value); return cont(classNameAfter); }
    }
    function classNameAfter(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
      if (value == "extends" || value == "implements" || (isTS && type == ",")) {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type == "{") return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type, value) {
      if (type == "async" ||
        (type == "variable" &&
          (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
          cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(classfield, classBody);
      }
      if (type == "number" || type == "string") return cont(classfield, classBody);
      if (type == "[")
        return cont(expression, maybetype, expect("]"), classfield, classBody)
      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type == "(") return pass(functiondecl, classBody)
      if (type == ";" || type == ",") return cont(classBody);
      if (type == "}") return cont();
      if (value == "@") return cont(expression, classBody)
    }
    function classfield(type, value) {
      if (value == "!") return cont(classfield)
      if (value == "?") return cont(classfield)
      if (type == ":") return cont(typeexpr, maybeAssign)
      if (value == "=") return cont(expressionNoComma)
      var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
      return pass(isInterface ? functiondecl : functiondef)
    }
    function afterExport(type, value) {
      if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
      if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
      if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type, value) {
      if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
      if (type == "variable") return pass(expressionNoComma, exportField);
    }
    function afterImport(type) {
      if (type == "string") return cont();
      if (type == "(") return pass(expression);
      if (type == ".") return pass(maybeoperatorComma);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type, value) {
      if (type == "{") return contCommasep(importSpec, "}");
      if (type == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type) {
      if (type == ",") return cont(importSpec, maybeMoreImports)
    }
    function maybeAs(_type, value) {
      if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
    }
    function maybeFrom(_type, value) {
      if (value == "from") { cx.marked = "keyword"; return cont(expression); }
    }
    function arrayLiteral(type) {
      if (type == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
    }
    function enummember() {
      return pass(pattern, maybeAssign);
    }

    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," ||
        isOperatorChar.test(textAfter.charAt(0)) ||
        /[,.]/.test(textAfter.charAt(0));
    }

    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase &&
        /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
        (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
    }

    // Interface

    return {
      startState: function (basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },

      token: function (stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type == "comment") return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },

      indent: function (state, textAfter) {
        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
        // Kludge to prevent 'maybelse' from blocking lexical scope pops
        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;
          else if (c != maybeelse && c != popcontext) break;
        }
        while ((lexical.type == "stat" || lexical.type == "form") &&
          (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
            (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
            !/^[,\.=+\-*:?[\(]/.test(textAfter))))
          lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type = lexical.type, closing = firstChar == type;

        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
        else if (type == "form" && firstChar == "{") return lexical.indented;
        else if (type == "form") return lexical.indented + indentUnit;
        else if (type == "stat")
          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
        else if (lexical.align) return lexical.column + (closing ? 0 : 1);
        else return lexical.indented + (closing ? 0 : indentUnit);
      },

      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",

      helperType: jsonMode ? "json" : "javascript",
      jsonldMode: jsonldMode,
      jsonMode: jsonMode,

      expressionAllowed: expressionAllowed,

      skipExpression: function (state) {
        parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null))
      }
    };
  });

  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
  CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
  CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true });
  CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
  CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});


// Full source: 
//
// 		https://github.com/hughsk/glsl-editor 
//
// (C) Copyright Hugh Kennedy
//
// This software is released under the MIT license:
//
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEAL-
// INGS IN THE SOFTWARE.

// The original source code has been slightly modified for the purpose of
// integration (tschw).

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("glsl", function (config, parserConfig) {
    var indentUnit = config.indentUnit,
      keywords = parserConfig.keywords || words(glslKeywords),
      builtins = parserConfig.builtins || words(glslBuiltins),
      blockKeywords = parserConfig.blockKeywords || words("case do else for if switch while struct"),
      atoms = parserConfig.atoms || words("null"),
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;

    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return "bracket";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (ch == "#") {
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        return "comment";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(cur)) {
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      return "word";
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) { end = true; break; }
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = tokenBase;
        return "string";
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      return state.context = new Context(state.indented, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    // Interface

    return {
      startState: function (basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function (stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },

      indent: function (state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return 0;
        var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
        else if (ctx.align) return ctx.column + (closing ? 0 : 1);
        else return ctx.indented + (closing ? 0 : indentUnit);
      },

      electricChars: "{}"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var glslKeywords = "attribute const uniform varying break continue " +
    "do for while if else in out inout float int void bool true false " +
    "lowp mediump highp precision invariant discard return mat2 mat3 " +
    "mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D " +
    "samplerCube struct gl_FragCoord gl_FragColor gl_Position";
  var glslBuiltins = "radians degrees sin cos tan asin acos atan pow " +
    "exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod " +
    "min max clamp mix step smoothstep length distance dot cross " +
    "normalize faceforward reflect refract matrixCompMult lessThan " +
    "lessThanEqual greaterThan greaterThanEqual equal notEqual any all " +
    "not dFdx dFdy fwidth texture2D texture2DProj texture2DLod " +
    "texture2DProjLod textureCube textureCubeLod require export";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  ; (function () {
    CodeMirror.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: words(glslKeywords),
      builtins: words(glslBuiltins),
      blockKeywords: words("case do else for if switch while struct"),
      atoms: words("null"),
      hooks: { "#": cppHook }
    });
  }());
});


(function webpackUniversalModuleDefinition(root, factory) {
  /* istanbul ignore next */
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define([], factory);
  /* istanbul ignore next */
  else if (typeof exports === 'object')
    exports["esprima"] = factory();
  else
    root["esprima"] = factory();
})(this, function () {
  return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if (installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
        /******/
};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
    /******/
})
/************************************************************************/
/******/([
/* 0 */
/***/ function (module, exports, __webpack_require__) {

      /*
        Copyright JS Foundation and other contributors, https://js.foundation/
    
        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are met:
    
          * Redistributions of source code must retain the above copyright
            notice, this list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright
            notice, this list of conditions and the following disclaimer in the
            documentation and/or other materials provided with the distribution.
    
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
        DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
        ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
        THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      */
      "use strict";
      var comment_handler_1 = __webpack_require__(1);
      var parser_1 = __webpack_require__(3);
      var jsx_parser_1 = __webpack_require__(11);
      var tokenizer_1 = __webpack_require__(15);
      function parse(code, options, delegate) {
        var commentHandler = null;
        var proxyDelegate = function (node, metadata) {
          if (delegate) {
            delegate(node, metadata);
          }
          if (commentHandler) {
            commentHandler.visit(node, metadata);
          }
        };
        var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
        var collectComment = false;
        if (options) {
          collectComment = (typeof options.comment === 'boolean' && options.comment);
          var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
          if (collectComment || attachComment) {
            commentHandler = new comment_handler_1.CommentHandler();
            commentHandler.attach = attachComment;
            options.comment = true;
            parserDelegate = proxyDelegate;
          }
        }
        var parser;
        if (options && typeof options.jsx === 'boolean' && options.jsx) {
          parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
        }
        else {
          parser = new parser_1.Parser(code, options, parserDelegate);
        }
        var ast = (parser.parseProgram());
        if (collectComment) {
          ast.comments = commentHandler.comments;
        }
        if (parser.config.tokens) {
          ast.tokens = parser.tokens;
        }
        if (parser.config.tolerant) {
          ast.errors = parser.errorHandler.errors;
        }
        return ast;
      }
      exports.parse = parse;
      function tokenize(code, options, delegate) {
        var tokenizer = new tokenizer_1.Tokenizer(code, options);
        var tokens;
        tokens = [];
        try {
          while (true) {
            var token = tokenizer.getNextToken();
            if (!token) {
              break;
            }
            if (delegate) {
              token = delegate(token);
            }
            tokens.push(token);
          }
        }
        catch (e) {
          tokenizer.errorHandler.tolerate(e);
        }
        if (tokenizer.errorHandler.tolerant) {
          tokens.errors = tokenizer.errors();
        }
        return tokens;
      }
      exports.tokenize = tokenize;
      var syntax_1 = __webpack_require__(2);
      exports.Syntax = syntax_1.Syntax;
      // Sync with *.json manifests.
      exports.version = '3.1.3';


      /***/
},
/* 1 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var syntax_1 = __webpack_require__(2);
      var CommentHandler = (function () {
        function CommentHandler() {
          this.attach = false;
          this.comments = [];
          this.stack = [];
          this.leading = [];
          this.trailing = [];
        }
        CommentHandler.prototype.insertInnerComments = function (node, metadata) {
          //  innnerComments for properties empty block
          //  `function a() {/** comments **\/}`
          if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
            var innerComments = [];
            for (var i = this.leading.length - 1; i >= 0; --i) {
              var entry = this.leading[i];
              if (metadata.end.offset >= entry.start) {
                innerComments.unshift(entry.comment);
                this.leading.splice(i, 1);
                this.trailing.splice(i, 1);
              }
            }
            if (innerComments.length) {
              node.innerComments = innerComments;
            }
          }
        };
        CommentHandler.prototype.findTrailingComments = function (node, metadata) {
          var trailingComments = [];
          if (this.trailing.length > 0) {
            for (var i = this.trailing.length - 1; i >= 0; --i) {
              var entry_1 = this.trailing[i];
              if (entry_1.start >= metadata.end.offset) {
                trailingComments.unshift(entry_1.comment);
              }
            }
            this.trailing.length = 0;
            return trailingComments;
          }
          var entry = this.stack[this.stack.length - 1];
          if (entry && entry.node.trailingComments) {
            var firstComment = entry.node.trailingComments[0];
            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
              trailingComments = entry.node.trailingComments;
              delete entry.node.trailingComments;
            }
          }
          return trailingComments;
        };
        CommentHandler.prototype.findLeadingComments = function (node, metadata) {
          var leadingComments = [];
          var target;
          while (this.stack.length > 0) {
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.start >= metadata.start.offset) {
              target = this.stack.pop().node;
            }
            else {
              break;
            }
          }
          if (target) {
            var count = target.leadingComments ? target.leadingComments.length : 0;
            for (var i = count - 1; i >= 0; --i) {
              var comment = target.leadingComments[i];
              if (comment.range[1] <= metadata.start.offset) {
                leadingComments.unshift(comment);
                target.leadingComments.splice(i, 1);
              }
            }
            if (target.leadingComments && target.leadingComments.length === 0) {
              delete target.leadingComments;
            }
            return leadingComments;
          }
          for (var i = this.leading.length - 1; i >= 0; --i) {
            var entry = this.leading[i];
            if (entry.start <= metadata.start.offset) {
              leadingComments.unshift(entry.comment);
              this.leading.splice(i, 1);
            }
          }
          return leadingComments;
        };
        CommentHandler.prototype.visitNode = function (node, metadata) {
          if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
            return;
          }
          this.insertInnerComments(node, metadata);
          var trailingComments = this.findTrailingComments(node, metadata);
          var leadingComments = this.findLeadingComments(node, metadata);
          if (leadingComments.length > 0) {
            node.leadingComments = leadingComments;
          }
          if (trailingComments.length > 0) {
            node.trailingComments = trailingComments;
          }
          this.stack.push({
            node: node,
            start: metadata.start.offset
          });
        };
        CommentHandler.prototype.visitComment = function (node, metadata) {
          var type = (node.type[0] === 'L') ? 'Line' : 'Block';
          var comment = {
            type: type,
            value: node.value
          };
          if (node.range) {
            comment.range = node.range;
          }
          if (node.loc) {
            comment.loc = node.loc;
          }
          this.comments.push(comment);
          if (this.attach) {
            var entry = {
              comment: {
                type: type,
                value: node.value,
                range: [metadata.start.offset, metadata.end.offset]
              },
              start: metadata.start.offset
            };
            if (node.loc) {
              entry.comment.loc = node.loc;
            }
            node.type = type;
            this.leading.push(entry);
            this.trailing.push(entry);
          }
        };
        CommentHandler.prototype.visit = function (node, metadata) {
          if (node.type === 'LineComment') {
            this.visitComment(node, metadata);
          }
          else if (node.type === 'BlockComment') {
            this.visitComment(node, metadata);
          }
          else if (this.attach) {
            this.visitNode(node, metadata);
          }
        };
        return CommentHandler;
      }());
      exports.CommentHandler = CommentHandler;


      /***/
},
/* 2 */
/***/ function (module, exports) {

      "use strict";
      exports.Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };


      /***/
},
/* 3 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var assert_1 = __webpack_require__(4);
      var messages_1 = __webpack_require__(5);
      var error_handler_1 = __webpack_require__(6);
      var token_1 = __webpack_require__(7);
      var scanner_1 = __webpack_require__(8);
      var syntax_1 = __webpack_require__(2);
      var Node = __webpack_require__(10);
      var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
      var Parser = (function () {
        function Parser(code, options, delegate) {
          if (options === void 0) { options = {}; }
          this.config = {
            range: (typeof options.range === 'boolean') && options.range,
            loc: (typeof options.loc === 'boolean') && options.loc,
            source: null,
            tokens: (typeof options.tokens === 'boolean') && options.tokens,
            comment: (typeof options.comment === 'boolean') && options.comment,
            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
          };
          if (this.config.loc && options.source && options.source !== null) {
            this.config.source = String(options.source);
          }
          this.delegate = delegate;
          this.errorHandler = new error_handler_1.ErrorHandler();
          this.errorHandler.tolerant = this.config.tolerant;
          this.scanner = new scanner_1.Scanner(code, this.errorHandler);
          this.scanner.trackComment = this.config.comment;
          this.operatorPrecedence = {
            ')': 0,
            ';': 0,
            ',': 0,
            '=': 0,
            ']': 0,
            '||': 1,
            '&&': 2,
            '|': 3,
            '^': 4,
            '&': 5,
            '==': 6,
            '!=': 6,
            '===': 6,
            '!==': 6,
            '<': 7,
            '>': 7,
            '<=': 7,
            '>=': 7,
            '<<': 8,
            '>>': 8,
            '>>>': 8,
            '+': 9,
            '-': 9,
            '*': 11,
            '/': 11,
            '%': 11
          };
          this.sourceType = (options && options.sourceType === 'module') ? 'module' : 'script';
          this.lookahead = null;
          this.hasLineTerminator = false;
          this.context = {
            allowIn: true,
            allowYield: true,
            firstCoverInitializedNameError: null,
            isAssignmentTarget: false,
            isBindingElement: false,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            labelSet: {},
            strict: (this.sourceType === 'module')
          };
          this.tokens = [];
          this.startMarker = {
            index: 0,
            lineNumber: this.scanner.lineNumber,
            lineStart: 0
          };
          this.lastMarker = {
            index: 0,
            lineNumber: this.scanner.lineNumber,
            lineStart: 0
          };
          this.nextToken();
          this.lastMarker = {
            index: this.scanner.index,
            lineNumber: this.scanner.lineNumber,
            lineStart: this.scanner.lineStart
          };
        }
        Parser.prototype.throwError = function (messageFormat) {
          var values = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
          }
          var args = Array.prototype.slice.call(arguments, 1);
          var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert_1.assert(idx < args.length, 'Message reference must be in range');
            return args[idx];
          });
          var index = this.lastMarker.index;
          var line = this.lastMarker.lineNumber;
          var column = this.lastMarker.index - this.lastMarker.lineStart + 1;
          throw this.errorHandler.createError(index, line, column, msg);
        };
        Parser.prototype.tolerateError = function (messageFormat) {
          var values = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
          }
          var args = Array.prototype.slice.call(arguments, 1);
          var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
            assert_1.assert(idx < args.length, 'Message reference must be in range');
            return args[idx];
          });
          var index = this.lastMarker.index;
          var line = this.scanner.lineNumber;
          var column = this.lastMarker.index - this.lastMarker.lineStart + 1;
          this.errorHandler.tolerateError(index, line, column, msg);
        };
        // Throw an exception because of the token.
        Parser.prototype.unexpectedTokenError = function (token, message) {
          var msg = message || messages_1.Messages.UnexpectedToken;
          var value;
          if (token) {
            if (!message) {
              msg = (token.type === token_1.Token.EOF) ? messages_1.Messages.UnexpectedEOS :
                (token.type === token_1.Token.Identifier) ? messages_1.Messages.UnexpectedIdentifier :
                  (token.type === token_1.Token.NumericLiteral) ? messages_1.Messages.UnexpectedNumber :
                    (token.type === token_1.Token.StringLiteral) ? messages_1.Messages.UnexpectedString :
                      (token.type === token_1.Token.Template) ? messages_1.Messages.UnexpectedTemplate :
                        messages_1.Messages.UnexpectedToken;
              if (token.type === token_1.Token.Keyword) {
                if (this.scanner.isFutureReservedWord(token.value)) {
                  msg = messages_1.Messages.UnexpectedReserved;
                }
                else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                  msg = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            value = (token.type === token_1.Token.Template) ? token.value.raw : token.value;
          }
          else {
            value = 'ILLEGAL';
          }
          msg = msg.replace('%0', value);
          if (token && typeof token.lineNumber === 'number') {
            var index = token.start;
            var line = token.lineNumber;
            var column = token.start - this.lastMarker.lineStart + 1;
            return this.errorHandler.createError(index, line, column, msg);
          }
          else {
            var index = this.lastMarker.index;
            var line = this.lastMarker.lineNumber;
            var column = index - this.lastMarker.lineStart + 1;
            return this.errorHandler.createError(index, line, column, msg);
          }
        };
        Parser.prototype.throwUnexpectedToken = function (token, message) {
          throw this.unexpectedTokenError(token, message);
        };
        Parser.prototype.tolerateUnexpectedToken = function (token, message) {
          this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
        };
        Parser.prototype.collectComments = function () {
          if (!this.config.comment) {
            this.scanner.scanComments();
          }
          else {
            var comments = this.scanner.scanComments();
            if (comments.length > 0 && this.delegate) {
              for (var i = 0; i < comments.length; ++i) {
                var e = comments[i];
                var node = void 0;
                node = {
                  type: e.multiLine ? 'BlockComment' : 'LineComment',
                  value: this.scanner.source.slice(e.slice[0], e.slice[1])
                };
                if (this.config.range) {
                  node.range = e.range;
                }
                if (this.config.loc) {
                  node.loc = e.loc;
                }
                var metadata = {
                  start: {
                    line: e.loc.start.line,
                    column: e.loc.start.column,
                    offset: e.range[0]
                  },
                  end: {
                    line: e.loc.end.line,
                    column: e.loc.end.column,
                    offset: e.range[1]
                  }
                };
                this.delegate(node, metadata);
              }
            }
          }
        };
        // From internal representation to an external structure
        Parser.prototype.getTokenRaw = function (token) {
          return this.scanner.source.slice(token.start, token.end);
        };
        Parser.prototype.convertToken = function (token) {
          var t;
          t = {
            type: token_1.TokenName[token.type],
            value: this.getTokenRaw(token)
          };
          if (this.config.range) {
            t.range = [token.start, token.end];
          }
          if (this.config.loc) {
            t.loc = {
              start: {
                line: this.startMarker.lineNumber,
                column: this.startMarker.index - this.startMarker.lineStart
              },
              end: {
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              }
            };
          }
          if (token.regex) {
            t.regex = token.regex;
          }
          return t;
        };
        Parser.prototype.nextToken = function () {
          var token = this.lookahead;
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.lineNumber = this.scanner.lineNumber;
          this.lastMarker.lineStart = this.scanner.lineStart;
          this.collectComments();
          this.startMarker.index = this.scanner.index;
          this.startMarker.lineNumber = this.scanner.lineNumber;
          this.startMarker.lineStart = this.scanner.lineStart;
          var next;
          next = this.scanner.lex();
          this.hasLineTerminator = (token && next) ? (token.lineNumber !== next.lineNumber) : false;
          if (next && this.context.strict && next.type === token_1.Token.Identifier) {
            if (this.scanner.isStrictModeReservedWord(next.value)) {
              next.type = token_1.Token.Keyword;
            }
          }
          this.lookahead = next;
          if (this.config.tokens && next.type !== token_1.Token.EOF) {
            this.tokens.push(this.convertToken(next));
          }
          return token;
        };
        Parser.prototype.nextRegexToken = function () {
          this.collectComments();
          var token = this.scanner.scanRegExp();
          if (this.config.tokens) {
            // Pop the previous token, '/' or '/='
            // This is added from the lookahead token.
            this.tokens.pop();
            this.tokens.push(this.convertToken(token));
          }
          // Prime the next lookahead.
          this.lookahead = token;
          this.nextToken();
          return token;
        };
        Parser.prototype.createNode = function () {
          return {
            index: this.startMarker.index,
            line: this.startMarker.lineNumber,
            column: this.startMarker.index - this.startMarker.lineStart
          };
        };
        Parser.prototype.startNode = function (token) {
          return {
            index: token.start,
            line: token.lineNumber,
            column: token.start - token.lineStart
          };
        };
        Parser.prototype.finalize = function (meta, node) {
          if (this.config.range) {
            node.range = [meta.index, this.lastMarker.index];
          }
          if (this.config.loc) {
            node.loc = {
              start: {
                line: meta.line,
                column: meta.column
              },
              end: {
                line: this.lastMarker.lineNumber,
                column: this.lastMarker.index - this.lastMarker.lineStart
              }
            };
            if (this.config.source) {
              node.loc.source = this.config.source;
            }
          }
          if (this.delegate) {
            var metadata = {
              start: {
                line: meta.line,
                column: meta.column,
                offset: meta.index
              },
              end: {
                line: this.lastMarker.lineNumber,
                column: this.lastMarker.index - this.lastMarker.lineStart,
                offset: this.lastMarker.index
              }
            };
            this.delegate(node, metadata);
          }
          return node;
        };
        // Expect the next token to match the specified punctuator.
        // If not, an exception will be thrown.
        Parser.prototype.expect = function (value) {
          var token = this.nextToken();
          if (token.type !== token_1.Token.Punctuator || token.value !== value) {
            this.throwUnexpectedToken(token);
          }
        };
        // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
        Parser.prototype.expectCommaSeparator = function () {
          if (this.config.tolerant) {
            var token = this.lookahead;
            if (token.type === token_1.Token.Punctuator && token.value === ',') {
              this.nextToken();
            }
            else if (token.type === token_1.Token.Punctuator && token.value === ';') {
              this.nextToken();
              this.tolerateUnexpectedToken(token);
            }
            else {
              this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
            }
          }
          else {
            this.expect(',');
          }
        };
        // Expect the next token to match the specified keyword.
        // If not, an exception will be thrown.
        Parser.prototype.expectKeyword = function (keyword) {
          var token = this.nextToken();
          if (token.type !== token_1.Token.Keyword || token.value !== keyword) {
            this.throwUnexpectedToken(token);
          }
        };
        // Return true if the next token matches the specified punctuator.
        Parser.prototype.match = function (value) {
          return this.lookahead.type === token_1.Token.Punctuator && this.lookahead.value === value;
        };
        // Return true if the next token matches the specified keyword
        Parser.prototype.matchKeyword = function (keyword) {
          return this.lookahead.type === token_1.Token.Keyword && this.lookahead.value === keyword;
        };
        // Return true if the next token matches the specified contextual keyword
        // (where an identifier is sometimes a keyword depending on the context)
        Parser.prototype.matchContextualKeyword = function (keyword) {
          return this.lookahead.type === token_1.Token.Identifier && this.lookahead.value === keyword;
        };
        // Return true if the next token is an assignment operator
        Parser.prototype.matchAssign = function () {
          if (this.lookahead.type !== token_1.Token.Punctuator) {
            return false;
          }
          var op = this.lookahead.value;
          return op === '=' ||
            op === '*=' ||
            op === '**=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
        };
        // Cover grammar support.
        //
        // When an assignment expression position starts with an left parenthesis, the determination of the type
        // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
        // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
        //
        // There are three productions that can be parsed in a parentheses pair that needs to be determined
        // after the outermost pair is closed. They are:
        //
        //   1. AssignmentExpression
        //   2. BindingElements
        //   3. AssignmentTargets
        //
        // In order to avoid exponential backtracking, we use two flags to denote if the production can be
        // binding element or assignment target.
        //
        // The three productions have the relationship:
        //
        //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
        //
        // with a single exception that CoverInitializedName when used directly in an Expression, generates
        // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
        // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
        //
        // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
        // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
        // the CoverInitializedName check is conducted.
        //
        // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
        // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
        // pattern. The CoverInitializedName check is deferred.
        Parser.prototype.isolateCoverGrammar = function (parseFunction) {
          var previousIsBindingElement = this.context.isBindingElement;
          var previousIsAssignmentTarget = this.context.isAssignmentTarget;
          var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
          this.context.isBindingElement = true;
          this.context.isAssignmentTarget = true;
          this.context.firstCoverInitializedNameError = null;
          var result = parseFunction.call(this);
          if (this.context.firstCoverInitializedNameError !== null) {
            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
          }
          this.context.isBindingElement = previousIsBindingElement;
          this.context.isAssignmentTarget = previousIsAssignmentTarget;
          this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
          return result;
        };
        Parser.prototype.inheritCoverGrammar = function (parseFunction) {
          var previousIsBindingElement = this.context.isBindingElement;
          var previousIsAssignmentTarget = this.context.isAssignmentTarget;
          var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
          this.context.isBindingElement = true;
          this.context.isAssignmentTarget = true;
          this.context.firstCoverInitializedNameError = null;
          var result = parseFunction.call(this);
          this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
          this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
          this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
          return result;
        };
        Parser.prototype.consumeSemicolon = function () {
          if (this.match(';')) {
            this.nextToken();
          }
          else if (!this.hasLineTerminator) {
            if (this.lookahead.type !== token_1.Token.EOF && !this.match('}')) {
              this.throwUnexpectedToken(this.lookahead);
            }
            this.lastMarker.index = this.startMarker.index;
            this.lastMarker.lineNumber = this.startMarker.lineNumber;
            this.lastMarker.lineStart = this.startMarker.lineStart;
          }
        };
        // ECMA-262 12.2 Primary Expressions
        Parser.prototype.parsePrimaryExpression = function () {
          var node = this.createNode();
          var expr;
          var value, token, raw;
          switch (this.lookahead.type) {
            case token_1.Token.Identifier:
              if (this.sourceType === 'module' && this.lookahead.value === 'await') {
                this.tolerateUnexpectedToken(this.lookahead);
              }
              expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
              break;
            case token_1.Token.NumericLiteral:
            case token_1.Token.StringLiteral:
              if (this.context.strict && this.lookahead.octal) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
              }
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              token = this.nextToken();
              raw = this.getTokenRaw(token);
              expr = this.finalize(node, new Node.Literal(token.value, raw));
              break;
            case token_1.Token.BooleanLiteral:
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              token = this.nextToken();
              token.value = (token.value === 'true');
              raw = this.getTokenRaw(token);
              expr = this.finalize(node, new Node.Literal(token.value, raw));
              break;
            case token_1.Token.NullLiteral:
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              token = this.nextToken();
              token.value = null;
              raw = this.getTokenRaw(token);
              expr = this.finalize(node, new Node.Literal(token.value, raw));
              break;
            case token_1.Token.Template:
              expr = this.parseTemplateLiteral();
              break;
            case token_1.Token.Punctuator:
              value = this.lookahead.value;
              switch (value) {
                case '(':
                  this.context.isBindingElement = false;
                  expr = this.inheritCoverGrammar(this.parseGroupExpression);
                  break;
                case '[':
                  expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                  break;
                case '{':
                  expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                  break;
                case '/':
                case '/=':
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  this.scanner.index = this.startMarker.index;
                  token = this.nextRegexToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node, new Node.RegexLiteral(token.value, raw, token.regex));
                  break;
                default:
                  this.throwUnexpectedToken(this.nextToken());
              }
              break;
            case token_1.Token.Keyword:
              if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
                expr = this.parseIdentifierName();
              }
              else if (!this.context.strict && this.matchKeyword('let')) {
                expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
              }
              else {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                if (this.matchKeyword('function')) {
                  expr = this.parseFunctionExpression();
                }
                else if (this.matchKeyword('this')) {
                  this.nextToken();
                  expr = this.finalize(node, new Node.ThisExpression());
                }
                else if (this.matchKeyword('class')) {
                  expr = this.parseClassExpression();
                }
                else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              break;
            default:
              this.throwUnexpectedToken(this.nextToken());
          }
          return expr;
        };
        // ECMA-262 12.2.5 Array Initializer
        Parser.prototype.parseSpreadElement = function () {
          var node = this.createNode();
          this.expect('...');
          var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
          return this.finalize(node, new Node.SpreadElement(arg));
        };
        Parser.prototype.parseArrayInitializer = function () {
          var node = this.createNode();
          var elements = [];
          this.expect('[');
          while (!this.match(']')) {
            if (this.match(',')) {
              this.nextToken();
              elements.push(null);
            }
            else if (this.match('...')) {
              var element = this.parseSpreadElement();
              if (!this.match(']')) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                this.expect(',');
              }
              elements.push(element);
            }
            else {
              elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
              if (!this.match(']')) {
                this.expect(',');
              }
            }
          }
          this.expect(']');
          return this.finalize(node, new Node.ArrayExpression(elements));
        };
        // ECMA-262 12.2.6 Object Initializer
        Parser.prototype.parsePropertyMethod = function (params) {
          this.context.isAssignmentTarget = false;
          this.context.isBindingElement = false;
          var previousStrict = this.context.strict;
          var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
          if (this.context.strict && params.firstRestricted) {
            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
          }
          if (this.context.strict && params.stricted) {
            this.tolerateUnexpectedToken(params.stricted, params.message);
          }
          this.context.strict = previousStrict;
          return body;
        };
        Parser.prototype.parsePropertyMethodFunction = function () {
          var isGenerator = false;
          var node = this.createNode();
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = false;
          var params = this.parseFormalParameters();
          var method = this.parsePropertyMethod(params);
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
        };
        Parser.prototype.parseObjectPropertyKey = function () {
          var node = this.createNode();
          var token = this.nextToken();
          var key = null;
          switch (token.type) {
            case token_1.Token.StringLiteral:
            case token_1.Token.NumericLiteral:
              if (this.context.strict && token.octal) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
              }
              var raw = this.getTokenRaw(token);
              key = this.finalize(node, new Node.Literal(token.value, raw));
              break;
            case token_1.Token.Identifier:
            case token_1.Token.BooleanLiteral:
            case token_1.Token.NullLiteral:
            case token_1.Token.Keyword:
              key = this.finalize(node, new Node.Identifier(token.value));
              break;
            case token_1.Token.Punctuator:
              if (token.value === '[') {
                key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.expect(']');
              }
              else {
                this.throwUnexpectedToken(token);
              }
              break;
            default:
              this.throwUnexpectedToken(token);
          }
          return key;
        };
        Parser.prototype.isPropertyKey = function (key, value) {
          return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
            (key.type === syntax_1.Syntax.Literal && key.value === value);
        };
        Parser.prototype.parseObjectProperty = function (hasProto) {
          var node = this.createNode();
          var token = this.lookahead;
          var kind;
          var key;
          var value;
          var computed = false;
          var method = false;
          var shorthand = false;
          if (token.type === token_1.Token.Identifier) {
            this.nextToken();
            key = this.finalize(node, new Node.Identifier(token.value));
          }
          else if (this.match('*')) {
            this.nextToken();
          }
          else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
          }
          var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
          if (token.type === token_1.Token.Identifier && token.value === 'get' && lookaheadPropertyKey) {
            kind = 'get';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            this.context.allowYield = false;
            value = this.parseGetterMethod();
          }
          else if (token.type === token_1.Token.Identifier && token.value === 'set' && lookaheadPropertyKey) {
            kind = 'set';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseSetterMethod();
          }
          else if (token.type === token_1.Token.Punctuator && token.value === '*' && lookaheadPropertyKey) {
            kind = 'init';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseGeneratorMethod();
            method = true;
          }
          else {
            if (!key) {
              this.throwUnexpectedToken(this.lookahead);
            }
            kind = 'init';
            if (this.match(':')) {
              if (!computed && this.isPropertyKey(key, '__proto__')) {
                if (hasProto.value) {
                  this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                }
                hasProto.value = true;
              }
              this.nextToken();
              value = this.inheritCoverGrammar(this.parseAssignmentExpression);
            }
            else if (this.match('(')) {
              value = this.parsePropertyMethodFunction();
              method = true;
            }
            else if (token.type === token_1.Token.Identifier) {
              var id = this.finalize(node, new Node.Identifier(token.value));
              if (this.match('=')) {
                this.context.firstCoverInitializedNameError = this.lookahead;
                this.nextToken();
                shorthand = true;
                var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                value = this.finalize(node, new Node.AssignmentPattern(id, init));
              }
              else {
                shorthand = true;
                value = id;
              }
            }
            else {
              this.throwUnexpectedToken(this.nextToken());
            }
          }
          return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
        };
        Parser.prototype.parseObjectInitializer = function () {
          var node = this.createNode();
          this.expect('{');
          var properties = [];
          var hasProto = { value: false };
          while (!this.match('}')) {
            properties.push(this.parseObjectProperty(hasProto));
            if (!this.match('}')) {
              this.expectCommaSeparator();
            }
          }
          this.expect('}');
          return this.finalize(node, new Node.ObjectExpression(properties));
        };
        // ECMA-262 12.2.9 Template Literals
        Parser.prototype.parseTemplateHead = function () {
          assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
          var node = this.createNode();
          var token = this.nextToken();
          var value = {
            raw: token.value.raw,
            cooked: token.value.cooked
          };
          return this.finalize(node, new Node.TemplateElement(value, token.tail));
        };
        Parser.prototype.parseTemplateElement = function () {
          if (this.lookahead.type !== token_1.Token.Template) {
            this.throwUnexpectedToken();
          }
          var node = this.createNode();
          var token = this.nextToken();
          var value = {
            raw: token.value.raw,
            cooked: token.value.cooked
          };
          return this.finalize(node, new Node.TemplateElement(value, token.tail));
        };
        Parser.prototype.parseTemplateLiteral = function () {
          var node = this.createNode();
          var expressions = [];
          var quasis = [];
          var quasi = this.parseTemplateHead();
          quasis.push(quasi);
          while (!quasi.tail) {
            expressions.push(this.parseExpression());
            quasi = this.parseTemplateElement();
            quasis.push(quasi);
          }
          return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
        };
        // ECMA-262 12.2.10 The Grouping Operator
        Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
          switch (expr.type) {
            case syntax_1.Syntax.Identifier:
            case syntax_1.Syntax.MemberExpression:
            case syntax_1.Syntax.RestElement:
            case syntax_1.Syntax.AssignmentPattern:
              break;
            case syntax_1.Syntax.SpreadElement:
              expr.type = syntax_1.Syntax.RestElement;
              this.reinterpretExpressionAsPattern(expr.argument);
              break;
            case syntax_1.Syntax.ArrayExpression:
              expr.type = syntax_1.Syntax.ArrayPattern;
              for (var i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                  this.reinterpretExpressionAsPattern(expr.elements[i]);
                }
              }
              break;
            case syntax_1.Syntax.ObjectExpression:
              expr.type = syntax_1.Syntax.ObjectPattern;
              for (var i = 0; i < expr.properties.length; i++) {
                this.reinterpretExpressionAsPattern(expr.properties[i].value);
              }
              break;
            case syntax_1.Syntax.AssignmentExpression:
              expr.type = syntax_1.Syntax.AssignmentPattern;
              delete expr.operator;
              this.reinterpretExpressionAsPattern(expr.left);
              break;
            default:
              // Allow other node type for tolerant parsing.
              break;
          }
        };
        Parser.prototype.parseGroupExpression = function () {
          var expr;
          this.expect('(');
          if (this.match(')')) {
            this.nextToken();
            if (!this.match('=>')) {
              this.expect('=>');
            }
            expr = {
              type: ArrowParameterPlaceHolder,
              params: []
            };
          }
          else {
            var startToken = this.lookahead;
            var params = [];
            if (this.match('...')) {
              expr = this.parseRestElement(params);
              this.expect(')');
              if (!this.match('=>')) {
                this.expect('=>');
              }
              expr = {
                type: ArrowParameterPlaceHolder,
                params: [expr]
              };
            }
            else {
              var arrow = false;
              this.context.isBindingElement = true;
              expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
              if (this.match(',')) {
                var expressions = [];
                this.context.isAssignmentTarget = false;
                expressions.push(expr);
                while (this.startMarker.index < this.scanner.length) {
                  if (!this.match(',')) {
                    break;
                  }
                  this.nextToken();
                  if (this.match('...')) {
                    if (!this.context.isBindingElement) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    expressions.push(this.parseRestElement(params));
                    this.expect(')');
                    if (!this.match('=>')) {
                      this.expect('=>');
                    }
                    this.context.isBindingElement = false;
                    for (var i = 0; i < expressions.length; i++) {
                      this.reinterpretExpressionAsPattern(expressions[i]);
                    }
                    arrow = true;
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: expressions
                    };
                  }
                  else {
                    expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  }
                  if (arrow) {
                    break;
                  }
                }
                if (!arrow) {
                  expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                }
              }
              if (!arrow) {
                this.expect(')');
                if (this.match('=>')) {
                  if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
                    arrow = true;
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr]
                    };
                  }
                  if (!arrow) {
                    if (!this.context.isBindingElement) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    if (expr.type === syntax_1.Syntax.SequenceExpression) {
                      for (var i = 0; i < expr.expressions.length; i++) {
                        this.reinterpretExpressionAsPattern(expr.expressions[i]);
                      }
                    }
                    else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    var params_1 = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: params_1
                    };
                  }
                }
                this.context.isBindingElement = false;
              }
            }
          }
          return expr;
        };
        // ECMA-262 12.3 Left-Hand-Side Expressions
        Parser.prototype.parseArguments = function () {
          this.expect('(');
          var args = [];
          if (!this.match(')')) {
            while (true) {
              var expr = this.match('...') ? this.parseSpreadElement() :
                this.isolateCoverGrammar(this.parseAssignmentExpression);
              args.push(expr);
              if (this.match(')')) {
                break;
              }
              this.expectCommaSeparator();
            }
          }
          this.expect(')');
          return args;
        };
        Parser.prototype.isIdentifierName = function (token) {
          return token.type === token_1.Token.Identifier ||
            token.type === token_1.Token.Keyword ||
            token.type === token_1.Token.BooleanLiteral ||
            token.type === token_1.Token.NullLiteral;
        };
        Parser.prototype.parseIdentifierName = function () {
          var node = this.createNode();
          var token = this.nextToken();
          if (!this.isIdentifierName(token)) {
            this.throwUnexpectedToken(token);
          }
          return this.finalize(node, new Node.Identifier(token.value));
        };
        Parser.prototype.parseNewExpression = function () {
          var node = this.createNode();
          var id = this.parseIdentifierName();
          assert_1.assert(id.name === 'new', 'New expression must start with `new`');
          var expr;
          if (this.match('.')) {
            this.nextToken();
            if (this.lookahead.type === token_1.Token.Identifier && this.context.inFunctionBody && this.lookahead.value === 'target') {
              var property = this.parseIdentifierName();
              expr = new Node.MetaProperty(id, property);
            }
            else {
              this.throwUnexpectedToken(this.lookahead);
            }
          }
          else {
            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
            var args = this.match('(') ? this.parseArguments() : [];
            expr = new Node.NewExpression(callee, args);
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
          }
          return this.finalize(node, expr);
        };
        Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
          var startToken = this.lookahead;
          var previousAllowIn = this.context.allowIn;
          this.context.allowIn = true;
          var expr;
          if (this.matchKeyword('super') && this.context.inFunctionBody) {
            expr = this.createNode();
            this.nextToken();
            expr = this.finalize(expr, new Node.Super());
            if (!this.match('(') && !this.match('.') && !this.match('[')) {
              this.throwUnexpectedToken(this.lookahead);
            }
          }
          else {
            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
          }
          while (true) {
            if (this.match('.')) {
              this.context.isBindingElement = false;
              this.context.isAssignmentTarget = true;
              this.expect('.');
              var property = this.parseIdentifierName();
              expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
            }
            else if (this.match('(')) {
              this.context.isBindingElement = false;
              this.context.isAssignmentTarget = false;
              var args = this.parseArguments();
              expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
            }
            else if (this.match('[')) {
              this.context.isBindingElement = false;
              this.context.isAssignmentTarget = true;
              this.expect('[');
              var property = this.isolateCoverGrammar(this.parseExpression);
              this.expect(']');
              expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
            }
            else if (this.lookahead.type === token_1.Token.Template && this.lookahead.head) {
              var quasi = this.parseTemplateLiteral();
              expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
            }
            else {
              break;
            }
          }
          this.context.allowIn = previousAllowIn;
          return expr;
        };
        Parser.prototype.parseSuper = function () {
          var node = this.createNode();
          this.expectKeyword('super');
          if (!this.match('[') && !this.match('.')) {
            this.throwUnexpectedToken(this.lookahead);
          }
          return this.finalize(node, new Node.Super());
        };
        Parser.prototype.parseLeftHandSideExpression = function () {
          assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
          var node = this.startNode(this.lookahead);
          var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
          while (true) {
            if (this.match('[')) {
              this.context.isBindingElement = false;
              this.context.isAssignmentTarget = true;
              this.expect('[');
              var property = this.isolateCoverGrammar(this.parseExpression);
              this.expect(']');
              expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
            }
            else if (this.match('.')) {
              this.context.isBindingElement = false;
              this.context.isAssignmentTarget = true;
              this.expect('.');
              var property = this.parseIdentifierName();
              expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
            }
            else if (this.lookahead.type === token_1.Token.Template && this.lookahead.head) {
              var quasi = this.parseTemplateLiteral();
              expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
            }
            else {
              break;
            }
          }
          return expr;
        };
        // ECMA-262 12.4 Update Expressions
        Parser.prototype.parseUpdateExpression = function () {
          var expr;
          var startToken = this.lookahead;
          if (this.match('++') || this.match('--')) {
            var node = this.startNode(startToken);
            var token = this.nextToken();
            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
              this.tolerateError(messages_1.Messages.StrictLHSPrefix);
            }
            if (!this.context.isAssignmentTarget) {
              this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
            }
            var prefix = true;
            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
          }
          else {
            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            if (!this.hasLineTerminator && this.lookahead.type === token_1.Token.Punctuator) {
              if (this.match('++') || this.match('--')) {
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var operator = this.nextToken().value;
                var prefix = false;
                expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
              }
            }
          }
          return expr;
        };
        // ECMA-262 12.5 Unary Operators
        Parser.prototype.parseUnaryExpression = function () {
          var expr;
          if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
            var node = this.startNode(this.lookahead);
            var token = this.nextToken();
            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
              this.tolerateError(messages_1.Messages.StrictDelete);
            }
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
          }
          else {
            expr = this.parseUpdateExpression();
          }
          return expr;
        };
        Parser.prototype.parseExponentiationExpression = function () {
          var startToken = this.lookahead;
          var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
          if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
            this.nextToken();
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var left = expr;
            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
          }
          return expr;
        };
        // ECMA-262 12.6 Exponentiation Operators
        // ECMA-262 12.7 Multiplicative Operators
        // ECMA-262 12.8 Additive Operators
        // ECMA-262 12.9 Bitwise Shift Operators
        // ECMA-262 12.10 Relational Operators
        // ECMA-262 12.11 Equality Operators
        // ECMA-262 12.12 Binary Bitwise Operators
        // ECMA-262 12.13 Binary Logical Operators
        Parser.prototype.binaryPrecedence = function (token) {
          var op = token.value;
          var precedence;
          if (token.type === token_1.Token.Punctuator) {
            precedence = this.operatorPrecedence[op] || 0;
          }
          else if (token.type === token_1.Token.Keyword) {
            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
          }
          else {
            precedence = 0;
          }
          return precedence;
        };
        Parser.prototype.parseBinaryExpression = function () {
          var startToken = this.lookahead;
          var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
          var token = this.lookahead;
          var prec = this.binaryPrecedence(token);
          if (prec > 0) {
            this.nextToken();
            token.prec = prec;
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var markers = [startToken, this.lookahead];
            var left = expr;
            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
            var stack = [left, token, right];
            while (true) {
              prec = this.binaryPrecedence(this.lookahead);
              if (prec <= 0) {
                break;
              }
              // Reduce: make a binary expression from the three topmost entries.
              while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                var operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                var node = this.startNode(markers[markers.length - 1]);
                stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
              }
              // Shift.
              token = this.nextToken();
              token.prec = prec;
              stack.push(token);
              markers.push(this.lookahead);
              stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
            }
            // Final reduce to clean-up the stack.
            var i = stack.length - 1;
            expr = stack[i];
            markers.pop();
            while (i > 1) {
              var node = this.startNode(markers.pop());
              expr = this.finalize(node, new Node.BinaryExpression(stack[i - 1].value, stack[i - 2], expr));
              i -= 2;
            }
          }
          return expr;
        };
        // ECMA-262 12.14 Conditional Operator
        Parser.prototype.parseConditionalExpression = function () {
          var startToken = this.lookahead;
          var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
          if (this.match('?')) {
            this.nextToken();
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowIn = previousAllowIn;
            this.expect(':');
            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
          }
          return expr;
        };
        // ECMA-262 12.15 Assignment Operators
        Parser.prototype.checkPatternParam = function (options, param) {
          switch (param.type) {
            case syntax_1.Syntax.Identifier:
              this.validateParam(options, param, param.name);
              break;
            case syntax_1.Syntax.RestElement:
              this.checkPatternParam(options, param.argument);
              break;
            case syntax_1.Syntax.AssignmentPattern:
              this.checkPatternParam(options, param.left);
              break;
            case syntax_1.Syntax.ArrayPattern:
              for (var i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                  this.checkPatternParam(options, param.elements[i]);
                }
              }
              break;
            case syntax_1.Syntax.YieldExpression:
              break;
            default:
              assert_1.assert(param.type === syntax_1.Syntax.ObjectPattern, 'Invalid type');
              for (var i = 0; i < param.properties.length; i++) {
                this.checkPatternParam(options, param.properties[i].value);
              }
              break;
          }
        };
        Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
          var params = [expr];
          var options;
          switch (expr.type) {
            case syntax_1.Syntax.Identifier:
              break;
            case ArrowParameterPlaceHolder:
              params = expr.params;
              break;
            default:
              return null;
          }
          options = {
            paramSet: {}
          };
          for (var i = 0; i < params.length; ++i) {
            var param = params[i];
            if (param.type === syntax_1.Syntax.AssignmentPattern) {
              if (param.right.type === syntax_1.Syntax.YieldExpression) {
                if (param.right.argument) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                param.right.type = syntax_1.Syntax.Identifier;
                param.right.name = 'yield';
                delete param.right.argument;
                delete param.right.delegate;
              }
            }
            this.checkPatternParam(options, param);
            params[i] = param;
          }
          if (this.context.strict || !this.context.allowYield) {
            for (var i = 0; i < params.length; ++i) {
              var param = params[i];
              if (param.type === syntax_1.Syntax.YieldExpression) {
                this.throwUnexpectedToken(this.lookahead);
              }
            }
          }
          if (options.message === messages_1.Messages.StrictParamDupe) {
            var token = this.context.strict ? options.stricted : options.firstRestricted;
            this.throwUnexpectedToken(token, options.message);
          }
          return {
            params: params,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
          };
        };
        Parser.prototype.parseAssignmentExpression = function () {
          var expr;
          if (!this.context.allowYield && this.matchKeyword('yield')) {
            expr = this.parseYieldExpression();
          }
          else {
            var startToken = this.lookahead;
            var token = startToken;
            expr = this.parseConditionalExpression();
            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
              // ECMA-262 14.2 Arrow Function Definitions
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var list = this.reinterpretAsCoverFormalsList(expr);
              if (list) {
                if (this.hasLineTerminator) {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                this.context.firstCoverInitializedNameError = null;
                var previousStrict = this.context.strict;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var node = this.startNode(startToken);
                this.expect('=>');
                var body = this.match('{') ? this.parseFunctionSourceElements() :
                  this.isolateCoverGrammar(this.parseAssignmentExpression);
                var expression = body.type !== syntax_1.Syntax.BlockStatement;
                if (this.context.strict && list.firstRestricted) {
                  this.throwUnexpectedToken(list.firstRestricted, list.message);
                }
                if (this.context.strict && list.stricted) {
                  this.tolerateUnexpectedToken(list.stricted, list.message);
                }
                expr = this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                this.context.strict = previousStrict;
                this.context.allowYield = previousAllowYield;
              }
            }
            else {
              if (this.matchAssign()) {
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                  var id = (expr);
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                  }
                  if (this.scanner.isStrictModeReservedWord(id.name)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  }
                }
                if (!this.match('=')) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                else {
                  this.reinterpretExpressionAsPattern(expr);
                }
                token = this.nextToken();
                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(token.value, expr, right));
                this.context.firstCoverInitializedNameError = null;
              }
            }
          }
          return expr;
        };
        // ECMA-262 12.16 Comma Operator
        Parser.prototype.parseExpression = function () {
          var startToken = this.lookahead;
          var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
          if (this.match(',')) {
            var expressions = [];
            expressions.push(expr);
            while (this.startMarker.index < this.scanner.length) {
              if (!this.match(',')) {
                break;
              }
              this.nextToken();
              expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
            }
            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
          }
          return expr;
        };
        // ECMA-262 13.2 Block
        Parser.prototype.parseStatementListItem = function () {
          var statement = null;
          this.context.isAssignmentTarget = true;
          this.context.isBindingElement = true;
          if (this.lookahead.type === token_1.Token.Keyword) {
            switch (this.lookahead.value) {
              case 'export':
                if (this.sourceType !== 'module') {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                }
                statement = this.parseExportDeclaration();
                break;
              case 'import':
                if (this.sourceType !== 'module') {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                }
                statement = this.parseImportDeclaration();
                break;
              case 'const':
                statement = this.parseLexicalDeclaration({ inFor: false });
                break;
              case 'function':
                statement = this.parseFunctionDeclaration();
                break;
              case 'class':
                statement = this.parseClassDeclaration();
                break;
              case 'let':
                statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                break;
              default:
                statement = this.parseStatement();
                break;
            }
          }
          else {
            statement = this.parseStatement();
          }
          return statement;
        };
        Parser.prototype.parseBlock = function () {
          var node = this.createNode();
          this.expect('{');
          var block = [];
          while (true) {
            if (this.match('}')) {
              break;
            }
            block.push(this.parseStatementListItem());
          }
          this.expect('}');
          return this.finalize(node, new Node.BlockStatement(block));
        };
        // ECMA-262 13.3.1 Let and Const Declarations
        Parser.prototype.parseLexicalBinding = function (kind, options) {
          var node = this.createNode();
          var params = [];
          var id = this.parsePattern(params, kind);
          // ECMA-262 12.2.1
          if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord((id).name)) {
              this.tolerateError(messages_1.Messages.StrictVarName);
            }
          }
          var init = null;
          if (kind === 'const') {
            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
              this.expect('=');
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            }
          }
          else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
            this.expect('=');
            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
          }
          return this.finalize(node, new Node.VariableDeclarator(id, init));
        };
        Parser.prototype.parseBindingList = function (kind, options) {
          var list = [this.parseLexicalBinding(kind, options)];
          while (this.match(',')) {
            this.nextToken();
            list.push(this.parseLexicalBinding(kind, options));
          }
          return list;
        };
        Parser.prototype.isLexicalDeclaration = function () {
          var previousIndex = this.scanner.index;
          var previousLineNumber = this.scanner.lineNumber;
          var previousLineStart = this.scanner.lineStart;
          this.collectComments();
          var next = this.scanner.lex();
          this.scanner.index = previousIndex;
          this.scanner.lineNumber = previousLineNumber;
          this.scanner.lineStart = previousLineStart;
          return (next.type === token_1.Token.Identifier) ||
            (next.type === token_1.Token.Punctuator && next.value === '[') ||
            (next.type === token_1.Token.Punctuator && next.value === '{') ||
            (next.type === token_1.Token.Keyword && next.value === 'let') ||
            (next.type === token_1.Token.Keyword && next.value === 'yield');
        };
        Parser.prototype.parseLexicalDeclaration = function (options) {
          var node = this.createNode();
          var kind = this.nextToken().value;
          assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
          var declarations = this.parseBindingList(kind, options);
          this.consumeSemicolon();
          return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
        };
        // ECMA-262 13.3.3 Destructuring Binding Patterns
        Parser.prototype.parseBindingRestElement = function (params, kind) {
          var node = this.createNode();
          this.expect('...');
          var arg = this.parsePattern(params, kind);
          return this.finalize(node, new Node.RestElement(arg));
        };
        Parser.prototype.parseArrayPattern = function (params, kind) {
          var node = this.createNode();
          this.expect('[');
          var elements = [];
          while (!this.match(']')) {
            if (this.match(',')) {
              this.nextToken();
              elements.push(null);
            }
            else {
              if (this.match('...')) {
                elements.push(this.parseBindingRestElement(params, kind));
                break;
              }
              else {
                elements.push(this.parsePatternWithDefault(params, kind));
              }
              if (!this.match(']')) {
                this.expect(',');
              }
            }
          }
          this.expect(']');
          return this.finalize(node, new Node.ArrayPattern(elements));
        };
        Parser.prototype.parsePropertyPattern = function (params, kind) {
          var node = this.createNode();
          var computed = false;
          var shorthand = false;
          var method = false;
          var key;
          var value;
          if (this.lookahead.type === token_1.Token.Identifier) {
            var keyToken = this.lookahead;
            key = this.parseVariableIdentifier();
            var init = this.finalize(node, new Node.Identifier(keyToken.value));
            if (this.match('=')) {
              params.push(keyToken);
              shorthand = true;
              this.nextToken();
              var expr = this.parseAssignmentExpression();
              value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
            }
            else if (!this.match(':')) {
              params.push(keyToken);
              shorthand = true;
              value = init;
            }
            else {
              this.expect(':');
              value = this.parsePatternWithDefault(params, kind);
            }
          }
          else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            this.expect(':');
            value = this.parsePatternWithDefault(params, kind);
          }
          return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
        };
        Parser.prototype.parseObjectPattern = function (params, kind) {
          var node = this.createNode();
          var properties = [];
          this.expect('{');
          while (!this.match('}')) {
            properties.push(this.parsePropertyPattern(params, kind));
            if (!this.match('}')) {
              this.expect(',');
            }
          }
          this.expect('}');
          return this.finalize(node, new Node.ObjectPattern(properties));
        };
        Parser.prototype.parsePattern = function (params, kind) {
          var pattern;
          if (this.match('[')) {
            pattern = this.parseArrayPattern(params, kind);
          }
          else if (this.match('{')) {
            pattern = this.parseObjectPattern(params, kind);
          }
          else {
            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
              this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.UnexpectedToken);
            }
            params.push(this.lookahead);
            pattern = this.parseVariableIdentifier(kind);
          }
          return pattern;
        };
        Parser.prototype.parsePatternWithDefault = function (params, kind) {
          var startToken = this.lookahead;
          var pattern = this.parsePattern(params, kind);
          if (this.match('=')) {
            this.nextToken();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
            this.context.allowYield = previousAllowYield;
            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
          }
          return pattern;
        };
        // ECMA-262 13.3.2 Variable Statement
        Parser.prototype.parseVariableIdentifier = function (kind) {
          var node = this.createNode();
          var token = this.nextToken();
          if (token.type === token_1.Token.Keyword && token.value === 'yield') {
            if (this.context.strict) {
              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
            }
            if (!this.context.allowYield) {
              this.throwUnexpectedToken(token);
            }
          }
          else if (token.type !== token_1.Token.Identifier) {
            if (this.context.strict && token.type === token_1.Token.Keyword && this.scanner.isStrictModeReservedWord(token.value)) {
              this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
            }
            else {
              if (this.context.strict || token.value !== 'let' || kind !== 'var') {
                this.throwUnexpectedToken(token);
              }
            }
          }
          else if (this.sourceType === 'module' && token.type === token_1.Token.Identifier && token.value === 'await') {
            this.tolerateUnexpectedToken(token);
          }
          return this.finalize(node, new Node.Identifier(token.value));
        };
        Parser.prototype.parseVariableDeclaration = function (options) {
          var node = this.createNode();
          var params = [];
          var id = this.parsePattern(params, 'var');
          // ECMA-262 12.2.1
          if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord((id).name)) {
              this.tolerateError(messages_1.Messages.StrictVarName);
            }
          }
          var init = null;
          if (this.match('=')) {
            this.nextToken();
            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
          }
          else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
            this.expect('=');
          }
          return this.finalize(node, new Node.VariableDeclarator(id, init));
        };
        Parser.prototype.parseVariableDeclarationList = function (options) {
          var opt = { inFor: options.inFor };
          var list = [];
          list.push(this.parseVariableDeclaration(opt));
          while (this.match(',')) {
            this.nextToken();
            list.push(this.parseVariableDeclaration(opt));
          }
          return list;
        };
        Parser.prototype.parseVariableStatement = function () {
          var node = this.createNode();
          this.expectKeyword('var');
          var declarations = this.parseVariableDeclarationList({ inFor: false });
          this.consumeSemicolon();
          return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
        };
        // ECMA-262 13.4 Empty Statement
        Parser.prototype.parseEmptyStatement = function () {
          var node = this.createNode();
          this.expect(';');
          return this.finalize(node, new Node.EmptyStatement());
        };
        // ECMA-262 13.5 Expression Statement
        Parser.prototype.parseExpressionStatement = function () {
          var node = this.createNode();
          var expr = this.parseExpression();
          this.consumeSemicolon();
          return this.finalize(node, new Node.ExpressionStatement(expr));
        };
        // ECMA-262 13.6 If statement
        Parser.prototype.parseIfStatement = function () {
          var node = this.createNode();
          var consequent;
          var alternate = null;
          this.expectKeyword('if');
          this.expect('(');
          var test = this.parseExpression();
          if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
          }
          else {
            this.expect(')');
            consequent = this.parseStatement();
            if (this.matchKeyword('else')) {
              this.nextToken();
              alternate = this.parseStatement();
            }
          }
          return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
        };
        // ECMA-262 13.7.2 The do-while Statement
        Parser.prototype.parseDoWhileStatement = function () {
          var node = this.createNode();
          this.expectKeyword('do');
          var previousInIteration = this.context.inIteration;
          this.context.inIteration = true;
          var body = this.parseStatement();
          this.context.inIteration = previousInIteration;
          this.expectKeyword('while');
          this.expect('(');
          var test = this.parseExpression();
          this.expect(')');
          if (this.match(';')) {
            this.nextToken();
          }
          return this.finalize(node, new Node.DoWhileStatement(body, test));
        };
        // ECMA-262 13.7.3 The while Statement
        Parser.prototype.parseWhileStatement = function () {
          var node = this.createNode();
          var body;
          this.expectKeyword('while');
          this.expect('(');
          var test = this.parseExpression();
          if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            body = this.finalize(this.createNode(), new Node.EmptyStatement());
          }
          else {
            this.expect(')');
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            body = this.parseStatement();
            this.context.inIteration = previousInIteration;
          }
          return this.finalize(node, new Node.WhileStatement(test, body));
        };
        // ECMA-262 13.7.4 The for Statement
        // ECMA-262 13.7.5 The for-in and for-of Statements
        Parser.prototype.parseForStatement = function () {
          var init = null;
          var test = null;
          var update = null;
          var forIn = true;
          var left, right;
          var node = this.createNode();
          this.expectKeyword('for');
          this.expect('(');
          if (this.match(';')) {
            this.nextToken();
          }
          else {
            if (this.matchKeyword('var')) {
              init = this.createNode();
              this.nextToken();
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = false;
              var declarations = this.parseVariableDeclarationList({ inFor: true });
              this.context.allowIn = previousAllowIn;
              if (declarations.length === 1 && this.matchKeyword('in')) {
                var decl = declarations[0];
                if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                  this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
                }
                init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                this.nextToken();
                left = init;
                right = this.parseExpression();
                init = null;
              }
              else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
                init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                this.nextToken();
                left = init;
                right = this.parseAssignmentExpression();
                init = null;
                forIn = false;
              }
              else {
                init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
                this.expect(';');
              }
            }
            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
              init = this.createNode();
              var kind = this.nextToken().value;
              if (!this.context.strict && this.lookahead.value === 'in') {
                init = this.finalize(init, new Node.Identifier(kind));
                this.nextToken();
                left = init;
                right = this.parseExpression();
                init = null;
              }
              else {
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseBindingList(kind, { inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                }
                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                  this.nextToken();
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                }
                else {
                  this.consumeSemicolon();
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                }
              }
            }
            else {
              var initStartToken = this.lookahead;
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = false;
              init = this.inheritCoverGrammar(this.parseAssignmentExpression);
              this.context.allowIn = previousAllowIn;
              if (this.matchKeyword('in')) {
                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                }
                this.nextToken();
                this.reinterpretExpressionAsPattern(init);
                left = init;
                right = this.parseExpression();
                init = null;
              }
              else if (this.matchContextualKeyword('of')) {
                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                }
                this.nextToken();
                this.reinterpretExpressionAsPattern(init);
                left = init;
                right = this.parseAssignmentExpression();
                init = null;
                forIn = false;
              }
              else {
                if (this.match(',')) {
                  var initSeq = [init];
                  while (this.match(',')) {
                    this.nextToken();
                    initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  }
                  init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                }
                this.expect(';');
              }
            }
          }
          if (typeof left === 'undefined') {
            if (!this.match(';')) {
              test = this.parseExpression();
            }
            this.expect(';');
            if (!this.match(')')) {
              update = this.parseExpression();
            }
          }
          var body;
          if (!this.match(')') && this.config.tolerant) {
            this.tolerateUnexpectedToken(this.nextToken());
            body = this.finalize(this.createNode(), new Node.EmptyStatement());
          }
          else {
            this.expect(')');
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            body = this.isolateCoverGrammar(this.parseStatement);
            this.context.inIteration = previousInIteration;
          }
          return (typeof left === 'undefined') ?
            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
              this.finalize(node, new Node.ForOfStatement(left, right, body));
        };
        // ECMA-262 13.8 The continue statement
        Parser.prototype.parseContinueStatement = function () {
          var node = this.createNode();
          this.expectKeyword('continue');
          var label = null;
          if (this.lookahead.type === token_1.Token.Identifier && !this.hasLineTerminator) {
            label = this.parseVariableIdentifier();
            var key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
              this.throwError(messages_1.Messages.UnknownLabel, label.name);
            }
          }
          this.consumeSemicolon();
          if (label === null && !this.context.inIteration) {
            this.throwError(messages_1.Messages.IllegalContinue);
          }
          return this.finalize(node, new Node.ContinueStatement(label));
        };
        // ECMA-262 13.9 The break statement
        Parser.prototype.parseBreakStatement = function () {
          var node = this.createNode();
          this.expectKeyword('break');
          var label = null;
          if (this.lookahead.type === token_1.Token.Identifier && !this.hasLineTerminator) {
            label = this.parseVariableIdentifier();
            var key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
              this.throwError(messages_1.Messages.UnknownLabel, label.name);
            }
          }
          this.consumeSemicolon();
          if (label === null && !this.context.inIteration && !this.context.inSwitch) {
            this.throwError(messages_1.Messages.IllegalBreak);
          }
          return this.finalize(node, new Node.BreakStatement(label));
        };
        // ECMA-262 13.10 The return statement
        Parser.prototype.parseReturnStatement = function () {
          if (!this.context.inFunctionBody) {
            this.tolerateError(messages_1.Messages.IllegalReturn);
          }
          var node = this.createNode();
          this.expectKeyword('return');
          var hasArgument = !this.match(';') && !this.match('}') &&
            !this.hasLineTerminator && this.lookahead.type !== token_1.Token.EOF;
          var argument = hasArgument ? this.parseExpression() : null;
          this.consumeSemicolon();
          return this.finalize(node, new Node.ReturnStatement(argument));
        };
        // ECMA-262 13.11 The with statement
        Parser.prototype.parseWithStatement = function () {
          if (this.context.strict) {
            this.tolerateError(messages_1.Messages.StrictModeWith);
          }
          var node = this.createNode();
          this.expectKeyword('with');
          this.expect('(');
          var object = this.parseExpression();
          this.expect(')');
          var body = this.parseStatement();
          return this.finalize(node, new Node.WithStatement(object, body));
        };
        // ECMA-262 13.12 The switch statement
        Parser.prototype.parseSwitchCase = function () {
          var node = this.createNode();
          var test;
          if (this.matchKeyword('default')) {
            this.nextToken();
            test = null;
          }
          else {
            this.expectKeyword('case');
            test = this.parseExpression();
          }
          this.expect(':');
          var consequent = [];
          while (true) {
            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
              break;
            }
            consequent.push(this.parseStatementListItem());
          }
          return this.finalize(node, new Node.SwitchCase(test, consequent));
        };
        Parser.prototype.parseSwitchStatement = function () {
          var node = this.createNode();
          this.expectKeyword('switch');
          this.expect('(');
          var discriminant = this.parseExpression();
          this.expect(')');
          var previousInSwitch = this.context.inSwitch;
          this.context.inSwitch = true;
          var cases = [];
          var defaultFound = false;
          this.expect('{');
          while (true) {
            if (this.match('}')) {
              break;
            }
            var clause = this.parseSwitchCase();
            if (clause.test === null) {
              if (defaultFound) {
                this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
              }
              defaultFound = true;
            }
            cases.push(clause);
          }
          this.expect('}');
          this.context.inSwitch = previousInSwitch;
          return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
        };
        // ECMA-262 13.13 Labelled Statements
        Parser.prototype.parseLabelledStatement = function () {
          var node = this.createNode();
          var expr = this.parseExpression();
          var statement;
          if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
            this.nextToken();
            var id = (expr);
            var key = '$' + id.name;
            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
              this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
            }
            this.context.labelSet[key] = true;
            var labeledBody = this.parseStatement();
            delete this.context.labelSet[key];
            statement = new Node.LabeledStatement(id, labeledBody);
          }
          else {
            this.consumeSemicolon();
            statement = new Node.ExpressionStatement(expr);
          }
          return this.finalize(node, statement);
        };
        // ECMA-262 13.14 The throw statement
        Parser.prototype.parseThrowStatement = function () {
          var node = this.createNode();
          this.expectKeyword('throw');
          if (this.hasLineTerminator) {
            this.throwError(messages_1.Messages.NewlineAfterThrow);
          }
          var argument = this.parseExpression();
          this.consumeSemicolon();
          return this.finalize(node, new Node.ThrowStatement(argument));
        };
        // ECMA-262 13.15 The try statement
        Parser.prototype.parseCatchClause = function () {
          var node = this.createNode();
          this.expectKeyword('catch');
          this.expect('(');
          if (this.match(')')) {
            this.throwUnexpectedToken(this.lookahead);
          }
          var params = [];
          var param = this.parsePattern(params);
          var paramMap = {};
          for (var i = 0; i < params.length; i++) {
            var key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
              this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
          }
          if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
            if (this.scanner.isRestrictedWord((param).name)) {
              this.tolerateError(messages_1.Messages.StrictCatchVariable);
            }
          }
          this.expect(')');
          var body = this.parseBlock();
          return this.finalize(node, new Node.CatchClause(param, body));
        };
        Parser.prototype.parseFinallyClause = function () {
          this.expectKeyword('finally');
          return this.parseBlock();
        };
        Parser.prototype.parseTryStatement = function () {
          var node = this.createNode();
          this.expectKeyword('try');
          var block = this.parseBlock();
          var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
          var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
          if (!handler && !finalizer) {
            this.throwError(messages_1.Messages.NoCatchOrFinally);
          }
          return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
        };
        // ECMA-262 13.16 The debugger statement
        Parser.prototype.parseDebuggerStatement = function () {
          var node = this.createNode();
          this.expectKeyword('debugger');
          this.consumeSemicolon();
          return this.finalize(node, new Node.DebuggerStatement());
        };
        // ECMA-262 13 Statements
        Parser.prototype.parseStatement = function () {
          var statement = null;
          switch (this.lookahead.type) {
            case token_1.Token.BooleanLiteral:
            case token_1.Token.NullLiteral:
            case token_1.Token.NumericLiteral:
            case token_1.Token.StringLiteral:
            case token_1.Token.Template:
            case token_1.Token.RegularExpression:
              statement = this.parseExpressionStatement();
              break;
            case token_1.Token.Punctuator:
              var value = this.lookahead.value;
              if (value === '{') {
                statement = this.parseBlock();
              }
              else if (value === '(') {
                statement = this.parseExpressionStatement();
              }
              else if (value === ';') {
                statement = this.parseEmptyStatement();
              }
              else {
                statement = this.parseExpressionStatement();
              }
              break;
            case token_1.Token.Identifier:
              statement = this.parseLabelledStatement();
              break;
            case token_1.Token.Keyword:
              switch (this.lookahead.value) {
                case 'break':
                  statement = this.parseBreakStatement();
                  break;
                case 'continue':
                  statement = this.parseContinueStatement();
                  break;
                case 'debugger':
                  statement = this.parseDebuggerStatement();
                  break;
                case 'do':
                  statement = this.parseDoWhileStatement();
                  break;
                case 'for':
                  statement = this.parseForStatement();
                  break;
                case 'function':
                  statement = this.parseFunctionDeclaration();
                  break;
                case 'if':
                  statement = this.parseIfStatement();
                  break;
                case 'return':
                  statement = this.parseReturnStatement();
                  break;
                case 'switch':
                  statement = this.parseSwitchStatement();
                  break;
                case 'throw':
                  statement = this.parseThrowStatement();
                  break;
                case 'try':
                  statement = this.parseTryStatement();
                  break;
                case 'var':
                  statement = this.parseVariableStatement();
                  break;
                case 'while':
                  statement = this.parseWhileStatement();
                  break;
                case 'with':
                  statement = this.parseWithStatement();
                  break;
                default:
                  statement = this.parseExpressionStatement();
                  break;
              }
              break;
            default:
              this.throwUnexpectedToken(this.lookahead);
          }
          return statement;
        };
        // ECMA-262 14.1 Function Definition
        Parser.prototype.parseFunctionSourceElements = function () {
          var node = this.createNode();
          this.expect('{');
          var body = this.parseDirectivePrologues();
          var previousLabelSet = this.context.labelSet;
          var previousInIteration = this.context.inIteration;
          var previousInSwitch = this.context.inSwitch;
          var previousInFunctionBody = this.context.inFunctionBody;
          this.context.labelSet = {};
          this.context.inIteration = false;
          this.context.inSwitch = false;
          this.context.inFunctionBody = true;
          while (this.startMarker.index < this.scanner.length) {
            if (this.match('}')) {
              break;
            }
            body.push(this.parseStatementListItem());
          }
          this.expect('}');
          this.context.labelSet = previousLabelSet;
          this.context.inIteration = previousInIteration;
          this.context.inSwitch = previousInSwitch;
          this.context.inFunctionBody = previousInFunctionBody;
          return this.finalize(node, new Node.BlockStatement(body));
        };
        Parser.prototype.validateParam = function (options, param, name) {
          var key = '$' + name;
          if (this.context.strict) {
            if (this.scanner.isRestrictedWord(name)) {
              options.stricted = param;
              options.message = messages_1.Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
              options.stricted = param;
              options.message = messages_1.Messages.StrictParamDupe;
            }
          }
          else if (!options.firstRestricted) {
            if (this.scanner.isRestrictedWord(name)) {
              options.firstRestricted = param;
              options.message = messages_1.Messages.StrictParamName;
            }
            else if (this.scanner.isStrictModeReservedWord(name)) {
              options.firstRestricted = param;
              options.message = messages_1.Messages.StrictReservedWord;
            }
            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
              options.stricted = param;
              options.message = messages_1.Messages.StrictParamDupe;
            }
          }
          /* istanbul ignore next */
          if (typeof Object.defineProperty === 'function') {
            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
          }
          else {
            options.paramSet[key] = true;
          }
        };
        Parser.prototype.parseRestElement = function (params) {
          var node = this.createNode();
          this.expect('...');
          var arg = this.parsePattern(params);
          if (this.match('=')) {
            this.throwError(messages_1.Messages.DefaultRestParameter);
          }
          if (!this.match(')')) {
            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
          }
          return this.finalize(node, new Node.RestElement(arg));
        };
        Parser.prototype.parseFormalParameter = function (options) {
          var params = [];
          var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
          for (var i = 0; i < params.length; i++) {
            this.validateParam(options, params[i], params[i].value);
          }
          options.params.push(param);
          return !this.match(')');
        };
        Parser.prototype.parseFormalParameters = function (firstRestricted) {
          var options;
          options = {
            params: [],
            firstRestricted: firstRestricted
          };
          this.expect('(');
          if (!this.match(')')) {
            options.paramSet = {};
            while (this.startMarker.index < this.scanner.length) {
              if (!this.parseFormalParameter(options)) {
                break;
              }
              this.expect(',');
            }
          }
          this.expect(')');
          return {
            params: options.params,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
          };
        };
        Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
          var node = this.createNode();
          this.expectKeyword('function');
          var isGenerator = this.match('*');
          if (isGenerator) {
            this.nextToken();
          }
          var message;
          var id = null;
          var firstRestricted = null;
          if (!identifierIsOptional || !this.match('(')) {
            var token = this.lookahead;
            id = this.parseVariableIdentifier();
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
              }
            }
            else {
              if (this.scanner.isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = messages_1.Messages.StrictFunctionName;
              }
              else if (this.scanner.isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = messages_1.Messages.StrictReservedWord;
              }
            }
          }
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = !isGenerator;
          var formalParameters = this.parseFormalParameters(firstRestricted);
          var params = formalParameters.params;
          var stricted = formalParameters.stricted;
          firstRestricted = formalParameters.firstRestricted;
          if (formalParameters.message) {
            message = formalParameters.message;
          }
          var previousStrict = this.context.strict;
          var body = this.parseFunctionSourceElements();
          if (this.context.strict && firstRestricted) {
            this.throwUnexpectedToken(firstRestricted, message);
          }
          if (this.context.strict && stricted) {
            this.tolerateUnexpectedToken(stricted, message);
          }
          this.context.strict = previousStrict;
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
        };
        Parser.prototype.parseFunctionExpression = function () {
          var node = this.createNode();
          this.expectKeyword('function');
          var isGenerator = this.match('*');
          if (isGenerator) {
            this.nextToken();
          }
          var message;
          var id = null;
          var firstRestricted;
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = !isGenerator;
          if (!this.match('(')) {
            var token = this.lookahead;
            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
              }
            }
            else {
              if (this.scanner.isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = messages_1.Messages.StrictFunctionName;
              }
              else if (this.scanner.isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = messages_1.Messages.StrictReservedWord;
              }
            }
          }
          var formalParameters = this.parseFormalParameters(firstRestricted);
          var params = formalParameters.params;
          var stricted = formalParameters.stricted;
          firstRestricted = formalParameters.firstRestricted;
          if (formalParameters.message) {
            message = formalParameters.message;
          }
          var previousStrict = this.context.strict;
          var body = this.parseFunctionSourceElements();
          if (this.context.strict && firstRestricted) {
            this.throwUnexpectedToken(firstRestricted, message);
          }
          if (this.context.strict && stricted) {
            this.tolerateUnexpectedToken(stricted, message);
          }
          this.context.strict = previousStrict;
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
        };
        // ECMA-262 14.1.1 Directive Prologues
        Parser.prototype.parseDirective = function () {
          var token = this.lookahead;
          var directive = null;
          var node = this.createNode();
          var expr = this.parseExpression();
          if (expr.type === syntax_1.Syntax.Literal) {
            directive = this.getTokenRaw(token).slice(1, -1);
          }
          this.consumeSemicolon();
          return this.finalize(node, directive ? new Node.Directive(expr, directive) :
            new Node.ExpressionStatement(expr));
        };
        Parser.prototype.parseDirectivePrologues = function () {
          var firstRestricted = null;
          var body = [];
          while (true) {
            var token = this.lookahead;
            if (token.type !== token_1.Token.StringLiteral) {
              break;
            }
            var statement = this.parseDirective();
            body.push(statement);
            var directive = statement.directive;
            if (typeof directive !== 'string') {
              break;
            }
            if (directive === 'use strict') {
              this.context.strict = true;
              if (firstRestricted) {
                this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
              }
            }
            else {
              if (!firstRestricted && token.octal) {
                firstRestricted = token;
              }
            }
          }
          return body;
        };
        // ECMA-262 14.3 Method Definitions
        Parser.prototype.qualifiedPropertyName = function (token) {
          switch (token.type) {
            case token_1.Token.Identifier:
            case token_1.Token.StringLiteral:
            case token_1.Token.BooleanLiteral:
            case token_1.Token.NullLiteral:
            case token_1.Token.NumericLiteral:
            case token_1.Token.Keyword:
              return true;
            case token_1.Token.Punctuator:
              return token.value === '[';
          }
          return false;
        };
        Parser.prototype.parseGetterMethod = function () {
          var node = this.createNode();
          this.expect('(');
          this.expect(')');
          var isGenerator = false;
          var params = {
            params: [],
            stricted: null,
            firstRestricted: null,
            message: null
          };
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = false;
          var method = this.parsePropertyMethod(params);
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
        };
        Parser.prototype.parseSetterMethod = function () {
          var node = this.createNode();
          var options = {
            params: [],
            firstRestricted: null,
            paramSet: {}
          };
          var isGenerator = false;
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = false;
          this.expect('(');
          if (this.match(')')) {
            this.tolerateUnexpectedToken(this.lookahead);
          }
          else {
            this.parseFormalParameter(options);
          }
          this.expect(')');
          var method = this.parsePropertyMethod(options);
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionExpression(null, options.params, method, isGenerator));
        };
        Parser.prototype.parseGeneratorMethod = function () {
          var node = this.createNode();
          var isGenerator = true;
          var previousAllowYield = this.context.allowYield;
          this.context.allowYield = true;
          var params = this.parseFormalParameters();
          this.context.allowYield = false;
          var method = this.parsePropertyMethod(params);
          this.context.allowYield = previousAllowYield;
          return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
        };
        // ECMA-262 14.4 Generator Function Definitions
        Parser.prototype.isStartOfExpression = function () {
          var start = true;
          var value = this.lookahead.value;
          switch (this.lookahead.type) {
            case token_1.Token.Punctuator:
              start = (value === '[') || (value === '(') || (value === '{') ||
                (value === '+') || (value === '-') ||
                (value === '!') || (value === '~') ||
                (value === '++') || (value === '--') ||
                (value === '/') || (value === '/='); // regular expression literal
              break;
            case token_1.Token.Keyword:
              start = (value === 'class') || (value === 'delete') ||
                (value === 'function') || (value === 'let') || (value === 'new') ||
                (value === 'super') || (value === 'this') || (value === 'typeof') ||
                (value === 'void') || (value === 'yield');
              break;
            default:
              break;
          }
          return start;
        };
        Parser.prototype.parseYieldExpression = function () {
          var node = this.createNode();
          this.expectKeyword('yield');
          var argument = null;
          var delegate = false;
          if (!this.hasLineTerminator) {
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = false;
            delegate = this.match('*');
            if (delegate) {
              this.nextToken();
              argument = this.parseAssignmentExpression();
            }
            else if (this.isStartOfExpression()) {
              argument = this.parseAssignmentExpression();
            }
            this.context.allowYield = previousAllowYield;
          }
          return this.finalize(node, new Node.YieldExpression(argument, delegate));
        };
        // ECMA-262 14.5 Class Definitions
        Parser.prototype.parseClassElement = function (hasConstructor) {
          var token = this.lookahead;
          var node = this.createNode();
          var kind;
          var key;
          var value;
          var computed = false;
          var method = false;
          var isStatic = false;
          if (this.match('*')) {
            this.nextToken();
          }
          else {
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            var id = key;
            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
              token = this.lookahead;
              isStatic = true;
              computed = this.match('[');
              if (this.match('*')) {
                this.nextToken();
              }
              else {
                key = this.parseObjectPropertyKey();
              }
            }
          }
          var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
          if (token.type === token_1.Token.Identifier) {
            if (token.value === 'get' && lookaheadPropertyKey) {
              kind = 'get';
              computed = this.match('[');
              key = this.parseObjectPropertyKey();
              this.context.allowYield = false;
              value = this.parseGetterMethod();
            }
            else if (token.value === 'set' && lookaheadPropertyKey) {
              kind = 'set';
              computed = this.match('[');
              key = this.parseObjectPropertyKey();
              value = this.parseSetterMethod();
            }
          }
          else if (token.type === token_1.Token.Punctuator && token.value === '*' && lookaheadPropertyKey) {
            kind = 'init';
            computed = this.match('[');
            key = this.parseObjectPropertyKey();
            value = this.parseGeneratorMethod();
            method = true;
          }
          if (!kind && key && this.match('(')) {
            kind = 'init';
            value = this.parsePropertyMethodFunction();
            method = true;
          }
          if (!kind) {
            this.throwUnexpectedToken(this.lookahead);
          }
          if (kind === 'init') {
            kind = 'method';
          }
          if (!computed) {
            if (isStatic && this.isPropertyKey(key, 'prototype')) {
              this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
            }
            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
              if (kind !== 'method' || !method || value.generator) {
                this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
              }
              if (hasConstructor.value) {
                this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
              }
              else {
                hasConstructor.value = true;
              }
              kind = 'constructor';
            }
          }
          return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
        };
        Parser.prototype.parseClassElementList = function () {
          var body = [];
          var hasConstructor = { value: false };
          this.expect('{');
          while (!this.match('}')) {
            if (this.match(';')) {
              this.nextToken();
            }
            else {
              body.push(this.parseClassElement(hasConstructor));
            }
          }
          this.expect('}');
          return body;
        };
        Parser.prototype.parseClassBody = function () {
          var node = this.createNode();
          var elementList = this.parseClassElementList();
          return this.finalize(node, new Node.ClassBody(elementList));
        };
        Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
          var node = this.createNode();
          var previousStrict = this.context.strict;
          this.context.strict = true;
          this.expectKeyword('class');
          var id = (identifierIsOptional && (this.lookahead.type !== token_1.Token.Identifier)) ? null : this.parseVariableIdentifier();
          var superClass = null;
          if (this.matchKeyword('extends')) {
            this.nextToken();
            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
          }
          var classBody = this.parseClassBody();
          this.context.strict = previousStrict;
          return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
        };
        Parser.prototype.parseClassExpression = function () {
          var node = this.createNode();
          var previousStrict = this.context.strict;
          this.context.strict = true;
          this.expectKeyword('class');
          var id = (this.lookahead.type === token_1.Token.Identifier) ? this.parseVariableIdentifier() : null;
          var superClass = null;
          if (this.matchKeyword('extends')) {
            this.nextToken();
            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
          }
          var classBody = this.parseClassBody();
          this.context.strict = previousStrict;
          return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
        };
        // ECMA-262 15.1 Scripts
        // ECMA-262 15.2 Modules
        Parser.prototype.parseProgram = function () {
          var node = this.createNode();
          var body = this.parseDirectivePrologues();
          while (this.startMarker.index < this.scanner.length) {
            body.push(this.parseStatementListItem());
          }
          return this.finalize(node, new Node.Program(body, this.sourceType));
        };
        // ECMA-262 15.2.2 Imports
        Parser.prototype.parseModuleSpecifier = function () {
          var node = this.createNode();
          if (this.lookahead.type !== token_1.Token.StringLiteral) {
            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
          }
          var token = this.nextToken();
          var raw = this.getTokenRaw(token);
          return this.finalize(node, new Node.Literal(token.value, raw));
        };
        // import {<foo as bar>} ...;
        Parser.prototype.parseImportSpecifier = function () {
          var node = this.createNode();
          var imported;
          var local;
          if (this.lookahead.type === token_1.Token.Identifier) {
            imported = this.parseVariableIdentifier();
            local = imported;
            if (this.matchContextualKeyword('as')) {
              this.nextToken();
              local = this.parseVariableIdentifier();
            }
          }
          else {
            imported = this.parseIdentifierName();
            local = imported;
            if (this.matchContextualKeyword('as')) {
              this.nextToken();
              local = this.parseVariableIdentifier();
            }
            else {
              this.throwUnexpectedToken(this.nextToken());
            }
          }
          return this.finalize(node, new Node.ImportSpecifier(local, imported));
        };
        // {foo, bar as bas}
        Parser.prototype.parseNamedImports = function () {
          this.expect('{');
          var specifiers = [];
          while (!this.match('}')) {
            specifiers.push(this.parseImportSpecifier());
            if (!this.match('}')) {
              this.expect(',');
            }
          }
          this.expect('}');
          return specifiers;
        };
        // import <foo> ...;
        Parser.prototype.parseImportDefaultSpecifier = function () {
          var node = this.createNode();
          var local = this.parseIdentifierName();
          return this.finalize(node, new Node.ImportDefaultSpecifier(local));
        };
        // import <* as foo> ...;
        Parser.prototype.parseImportNamespaceSpecifier = function () {
          var node = this.createNode();
          this.expect('*');
          if (!this.matchContextualKeyword('as')) {
            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
          }
          this.nextToken();
          var local = this.parseIdentifierName();
          return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
        };
        Parser.prototype.parseImportDeclaration = function () {
          if (this.context.inFunctionBody) {
            this.throwError(messages_1.Messages.IllegalImportDeclaration);
          }
          var node = this.createNode();
          this.expectKeyword('import');
          var src;
          var specifiers = [];
          if (this.lookahead.type === token_1.Token.StringLiteral) {
            // import 'foo';
            src = this.parseModuleSpecifier();
          }
          else {
            if (this.match('{')) {
              // import {bar}
              specifiers = specifiers.concat(this.parseNamedImports());
            }
            else if (this.match('*')) {
              // import * as foo
              specifiers.push(this.parseImportNamespaceSpecifier());
            }
            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
              // import foo
              specifiers.push(this.parseImportDefaultSpecifier());
              if (this.match(',')) {
                this.nextToken();
                if (this.match('*')) {
                  // import foo, * as foo
                  specifiers.push(this.parseImportNamespaceSpecifier());
                }
                else if (this.match('{')) {
                  // import foo, {bar}
                  specifiers = specifiers.concat(this.parseNamedImports());
                }
                else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            }
            else {
              this.throwUnexpectedToken(this.nextToken());
            }
            if (!this.matchContextualKeyword('from')) {
              var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
              this.throwError(message, this.lookahead.value);
            }
            this.nextToken();
            src = this.parseModuleSpecifier();
          }
          this.consumeSemicolon();
          return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
        };
        // ECMA-262 15.2.3 Exports
        Parser.prototype.parseExportSpecifier = function () {
          var node = this.createNode();
          var local = this.parseIdentifierName();
          var exported = local;
          if (this.matchContextualKeyword('as')) {
            this.nextToken();
            exported = this.parseIdentifierName();
          }
          return this.finalize(node, new Node.ExportSpecifier(local, exported));
        };
        Parser.prototype.parseExportDeclaration = function () {
          if (this.context.inFunctionBody) {
            this.throwError(messages_1.Messages.IllegalExportDeclaration);
          }
          var node = this.createNode();
          this.expectKeyword('export');
          var exportDeclaration;
          if (this.matchKeyword('default')) {
            // export default ...
            this.nextToken();
            if (this.matchKeyword('function')) {
              // export default function foo () {}
              // export default function () {}
              var declaration = this.parseFunctionDeclaration(true);
              exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
            else if (this.matchKeyword('class')) {
              // export default class foo {}
              var declaration = this.parseClassDeclaration(true);
              exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
            else {
              if (this.matchContextualKeyword('from')) {
                this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
              }
              // export default {};
              // export default [];
              // export default (1 + 2);
              var declaration = this.match('{') ? this.parseObjectInitializer() :
                this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
              this.consumeSemicolon();
              exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
            }
          }
          else if (this.match('*')) {
            // export * from 'foo';
            this.nextToken();
            if (!this.matchContextualKeyword('from')) {
              var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
              this.throwError(message, this.lookahead.value);
            }
            this.nextToken();
            var src = this.parseModuleSpecifier();
            this.consumeSemicolon();
            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
          }
          else if (this.lookahead.type === token_1.Token.Keyword) {
            // export var f = 1;
            var declaration = void 0;
            switch (this.lookahead.value) {
              case 'let':
              case 'const':
                declaration = this.parseLexicalDeclaration({ inFor: false });
                break;
              case 'var':
              case 'class':
              case 'function':
                declaration = this.parseStatementListItem();
                break;
              default:
                this.throwUnexpectedToken(this.lookahead);
            }
            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
          }
          else {
            var specifiers = [];
            var source = null;
            var isExportFromIdentifier = false;
            this.expect('{');
            while (!this.match('}')) {
              isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
              specifiers.push(this.parseExportSpecifier());
              if (!this.match('}')) {
                this.expect(',');
              }
            }
            this.expect('}');
            if (this.matchContextualKeyword('from')) {
              // export {default} from 'foo';
              // export {foo} from 'foo';
              this.nextToken();
              source = this.parseModuleSpecifier();
              this.consumeSemicolon();
            }
            else if (isExportFromIdentifier) {
              // export {default}; // missing fromClause
              var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
              this.throwError(message, this.lookahead.value);
            }
            else {
              // export {foo};
              this.consumeSemicolon();
            }
            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
          }
          return exportDeclaration;
        };
        return Parser;
      }());
      exports.Parser = Parser;


      /***/
},
/* 4 */
/***/ function (module, exports) {

      // Ensure the condition is true, otherwise throw an error.
      // This is only to have a better contract semantic, i.e. another safety net
      // to catch a logic error. The condition shall be fulfilled in normal case.
      // Do NOT use this to enforce a certain condition on any user input.
      "use strict";
      function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
          throw new Error('ASSERT: ' + message);
        }
      }
      exports.assert = assert;


      /***/
},
/* 5 */
/***/ function (module, exports) {

      "use strict";
      // Error messages should be identical to V8.
      exports.Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0',
        ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer'
      };


      /***/
},
/* 6 */
/***/ function (module, exports) {

      "use strict";
      var ErrorHandler = (function () {
        function ErrorHandler() {
          this.errors = [];
          this.tolerant = false;
        }
        ;
        ErrorHandler.prototype.recordError = function (error) {
          this.errors.push(error);
        };
        ;
        ErrorHandler.prototype.tolerate = function (error) {
          if (this.tolerant) {
            this.recordError(error);
          }
          else {
            throw error;
          }
        };
        ;
        ErrorHandler.prototype.constructError = function (msg, column) {
          var error = new Error(msg);
          try {
            throw error;
          }
          catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
              error = Object.create(base);
              Object.defineProperty(error, 'column', { value: column });
            }
          }
          finally {
            return error;
          }
        };
        ;
        ErrorHandler.prototype.createError = function (index, line, col, description) {
          var msg = 'Line ' + line + ': ' + description;
          var error = this.constructError(msg, col);
          error.index = index;
          error.lineNumber = line;
          error.description = description;
          return error;
        };
        ;
        ErrorHandler.prototype.throwError = function (index, line, col, description) {
          throw this.createError(index, line, col, description);
        };
        ;
        ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
          var error = this.createError(index, line, col, description);
          if (this.tolerant) {
            this.recordError(error);
          }
          else {
            throw error;
          }
        };
        ;
        return ErrorHandler;
      }());
      exports.ErrorHandler = ErrorHandler;


      /***/
},
/* 7 */
/***/ function (module, exports) {

      "use strict";
      (function (Token) {
        Token[Token["BooleanLiteral"] = 1] = "BooleanLiteral";
        Token[Token["EOF"] = 2] = "EOF";
        Token[Token["Identifier"] = 3] = "Identifier";
        Token[Token["Keyword"] = 4] = "Keyword";
        Token[Token["NullLiteral"] = 5] = "NullLiteral";
        Token[Token["NumericLiteral"] = 6] = "NumericLiteral";
        Token[Token["Punctuator"] = 7] = "Punctuator";
        Token[Token["StringLiteral"] = 8] = "StringLiteral";
        Token[Token["RegularExpression"] = 9] = "RegularExpression";
        Token[Token["Template"] = 10] = "Template";
      })(exports.Token || (exports.Token = {}));
      var Token = exports.Token;
      ;
      exports.TokenName = {};
      exports.TokenName[Token.BooleanLiteral] = 'Boolean';
      exports.TokenName[Token.EOF] = '<end>';
      exports.TokenName[Token.Identifier] = 'Identifier';
      exports.TokenName[Token.Keyword] = 'Keyword';
      exports.TokenName[Token.NullLiteral] = 'Null';
      exports.TokenName[Token.NumericLiteral] = 'Numeric';
      exports.TokenName[Token.Punctuator] = 'Punctuator';
      exports.TokenName[Token.StringLiteral] = 'String';
      exports.TokenName[Token.RegularExpression] = 'RegularExpression';
      exports.TokenName[Token.Template] = 'Template';


      /***/
},
/* 8 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var assert_1 = __webpack_require__(4);
      var messages_1 = __webpack_require__(5);
      var character_1 = __webpack_require__(9);
      var token_1 = __webpack_require__(7);
      function hexValue(ch) {
        return '0123456789abcdef'.indexOf(ch.toLowerCase());
      }
      function octalValue(ch) {
        return '01234567'.indexOf(ch);
      }
      var Scanner = (function () {
        function Scanner(code, handler) {
          this.source = code;
          this.errorHandler = handler;
          this.trackComment = false;
          this.length = code.length;
          this.index = 0;
          this.lineNumber = (code.length > 0) ? 1 : 0;
          this.lineStart = 0;
          this.curlyStack = [];
        }
        ;
        Scanner.prototype.eof = function () {
          return this.index >= this.length;
        };
        ;
        Scanner.prototype.throwUnexpectedToken = function (message) {
          if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
          this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
        };
        ;
        Scanner.prototype.tolerateUnexpectedToken = function () {
          this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, messages_1.Messages.UnexpectedTokenIllegal);
        };
        ;
        // ECMA-262 11.4 Comments
        Scanner.prototype.skipSingleLineComment = function (offset) {
          var comments;
          var start, loc;
          if (this.trackComment) {
            comments = [];
            start = this.index - offset;
            loc = {
              start: {
                line: this.lineNumber,
                column: this.index - this.lineStart - offset
              },
              end: {}
            };
          }
          while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            ++this.index;
            if (character_1.Character.isLineTerminator(ch)) {
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 1
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index - 1],
                  range: [start, this.index - 1],
                  loc: loc
                };
                comments.push(entry);
              }
              if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                ++this.index;
              }
              ++this.lineNumber;
              this.lineStart = this.index;
              return comments;
            }
          }
          if (this.trackComment) {
            loc.end = {
              line: this.lineNumber,
              column: this.index - this.lineStart
            };
            var entry = {
              multiLine: false,
              slice: [start + offset, this.index],
              range: [start, this.index],
              loc: loc
            };
            comments.push(entry);
          }
          return comments;
        };
        ;
        Scanner.prototype.skipMultiLineComment = function () {
          var comments;
          var start, loc;
          if (this.trackComment) {
            comments = [];
            start = this.index - 2;
            loc = {
              start: {
                line: this.lineNumber,
                column: this.index - this.lineStart - 2
              },
              end: {}
            };
          }
          while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (character_1.Character.isLineTerminator(ch)) {
              if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
                ++this.index;
              }
              ++this.lineNumber;
              ++this.index;
              this.lineStart = this.index;
            }
            else if (ch === 0x2A) {
              // Block comment ends with '*/'.
              if (this.source.charCodeAt(this.index + 1) === 0x2F) {
                this.index += 2;
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: true,
                    slice: [start + 2, this.index - 2],
                    range: [start, this.index],
                    loc: loc
                  };
                  comments.push(entry);
                }
                return comments;
              }
              ++this.index;
            }
            else {
              ++this.index;
            }
          }
          // Ran off the end of the file - the whole thing is a comment
          if (this.trackComment) {
            loc.end = {
              line: this.lineNumber,
              column: this.index - this.lineStart
            };
            var entry = {
              multiLine: true,
              slice: [start + 2, this.index],
              range: [start, this.index],
              loc: loc
            };
            comments.push(entry);
          }
          this.tolerateUnexpectedToken();
          return comments;
        };
        ;
        Scanner.prototype.scanComments = function () {
          var comments;
          if (this.trackComment) {
            comments = [];
          }
          var start = (this.index === 0);
          while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (character_1.Character.isWhiteSpace(ch)) {
              ++this.index;
            }
            else if (character_1.Character.isLineTerminator(ch)) {
              ++this.index;
              if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
                ++this.index;
              }
              ++this.lineNumber;
              this.lineStart = this.index;
              start = true;
            }
            else if (ch === 0x2F) {
              ch = this.source.charCodeAt(this.index + 1);
              if (ch === 0x2F) {
                this.index += 2;
                var comment = this.skipSingleLineComment(2);
                if (this.trackComment) {
                  comments = comments.concat(comment);
                }
                start = true;
              }
              else if (ch === 0x2A) {
                this.index += 2;
                var comment = this.skipMultiLineComment();
                if (this.trackComment) {
                  comments = comments.concat(comment);
                }
              }
              else {
                break;
              }
            }
            else if (start && ch === 0x2D) {
              // U+003E is '>'
              if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
                // '-->' is a single-line comment
                this.index += 3;
                var comment = this.skipSingleLineComment(3);
                if (this.trackComment) {
                  comments = comments.concat(comment);
                }
              }
              else {
                break;
              }
            }
            else if (ch === 0x3C) {
              if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
                this.index += 4; // `<!--`
                var comment = this.skipSingleLineComment(4);
                if (this.trackComment) {
                  comments = comments.concat(comment);
                }
              }
              else {
                break;
              }
            }
            else {
              break;
            }
          }
          return comments;
        };
        ;
        // ECMA-262 11.6.2.2 Future Reserved Words
        Scanner.prototype.isFutureReservedWord = function (id) {
          switch (id) {
            case 'enum':
            case 'export':
            case 'import':
            case 'super':
              return true;
            default:
              return false;
          }
        };
        ;
        Scanner.prototype.isStrictModeReservedWord = function (id) {
          switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
              return true;
            default:
              return false;
          }
        };
        ;
        Scanner.prototype.isRestrictedWord = function (id) {
          return id === 'eval' || id === 'arguments';
        };
        ;
        // ECMA-262 11.6.2.1 Keywords
        Scanner.prototype.isKeyword = function (id) {
          switch (id.length) {
            case 2:
              return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
              return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
            case 4:
              return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
              return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
            case 6:
              return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
              return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
              return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
              return (id === 'instanceof');
            default:
              return false;
          }
        };
        ;
        Scanner.prototype.codePointAt = function (i) {
          var cp = this.source.charCodeAt(i);
          if (cp >= 0xD800 && cp <= 0xDBFF) {
            var second = this.source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
              var first = cp;
              cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
          }
          return cp;
        };
        ;
        Scanner.prototype.scanHexEscape = function (prefix) {
          var len = (prefix === 'u') ? 4 : 2;
          var code = 0;
          for (var i = 0; i < len; ++i) {
            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
              code = code * 16 + hexValue(this.source[this.index++]);
            }
            else {
              return '';
            }
          }
          return String.fromCharCode(code);
        };
        ;
        Scanner.prototype.scanUnicodeCodePointEscape = function () {
          var ch = this.source[this.index];
          var code = 0;
          // At least, one hex digit is required.
          if (ch === '}') {
            this.throwUnexpectedToken();
          }
          while (!this.eof()) {
            ch = this.source[this.index++];
            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
              break;
            }
            code = code * 16 + hexValue(ch);
          }
          if (code > 0x10FFFF || ch !== '}') {
            this.throwUnexpectedToken();
          }
          return character_1.Character.fromCodePoint(code);
        };
        ;
        Scanner.prototype.getIdentifier = function () {
          var start = this.index++;
          while (!this.eof()) {
            var ch = this.source.charCodeAt(this.index);
            if (ch === 0x5C) {
              // Blackslash (U+005C) marks Unicode escape sequence.
              this.index = start;
              return this.getComplexIdentifier();
            }
            else if (ch >= 0xD800 && ch < 0xDFFF) {
              // Need to handle surrogate pairs.
              this.index = start;
              return this.getComplexIdentifier();
            }
            if (character_1.Character.isIdentifierPart(ch)) {
              ++this.index;
            }
            else {
              break;
            }
          }
          return this.source.slice(start, this.index);
        };
        ;
        Scanner.prototype.getComplexIdentifier = function () {
          var cp = this.codePointAt(this.index);
          var id = character_1.Character.fromCodePoint(cp);
          this.index += id.length;
          // '\u' (U+005C, U+0075) denotes an escaped character.
          var ch;
          if (cp === 0x5C) {
            if (this.source.charCodeAt(this.index) !== 0x75) {
              this.throwUnexpectedToken();
            }
            ++this.index;
            if (this.source[this.index] === '{') {
              ++this.index;
              ch = this.scanUnicodeCodePointEscape();
            }
            else {
              ch = this.scanHexEscape('u');
              cp = ch.charCodeAt(0);
              if (!ch || ch === '\\' || !character_1.Character.isIdentifierStart(cp)) {
                this.throwUnexpectedToken();
              }
            }
            id = ch;
          }
          while (!this.eof()) {
            cp = this.codePointAt(this.index);
            if (!character_1.Character.isIdentifierPart(cp)) {
              break;
            }
            ch = character_1.Character.fromCodePoint(cp);
            id += ch;
            this.index += ch.length;
            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
              id = id.substr(0, id.length - 1);
              if (this.source.charCodeAt(this.index) !== 0x75) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if (this.source[this.index] === '{') {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
              }
              else {
                ch = this.scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !character_1.Character.isIdentifierPart(cp)) {
                  this.throwUnexpectedToken();
                }
              }
              id += ch;
            }
          }
          return id;
        };
        ;
        Scanner.prototype.octalToDecimal = function (ch) {
          // \0 is not octal escape sequence
          var octal = (ch !== '0');
          var code = octalValue(ch);
          if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
            octal = true;
            code = code * 8 + octalValue(this.source[this.index++]);
            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              code = code * 8 + octalValue(this.source[this.index++]);
            }
          }
          return {
            code: code,
            octal: octal
          };
        };
        ;
        // ECMA-262 11.6 Names and Keywords
        Scanner.prototype.scanIdentifier = function () {
          var type;
          var start = this.index;
          // Backslash (U+005C) starts an escaped character.
          var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
          // There is no keyword or literal with only one character.
          // Thus, it must be an identifier.
          if (id.length === 1) {
            type = token_1.Token.Identifier;
          }
          else if (this.isKeyword(id)) {
            type = token_1.Token.Keyword;
          }
          else if (id === 'null') {
            type = token_1.Token.NullLiteral;
          }
          else if (id === 'true' || id === 'false') {
            type = token_1.Token.BooleanLiteral;
          }
          else {
            type = token_1.Token.Identifier;
          }
          return {
            type: type,
            value: id,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        // ECMA-262 11.7 Punctuators
        Scanner.prototype.scanPunctuator = function () {
          var token = {
            type: token_1.Token.Punctuator,
            value: '',
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: this.index,
            end: this.index
          };
          // Check for most common single-character punctuators.
          var str = this.source[this.index];
          switch (str) {
            case '(':
            case '{':
              if (str === '{') {
                this.curlyStack.push('{');
              }
              ++this.index;
              break;
            case '.':
              ++this.index;
              if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
                // Spread operator: ...
                this.index += 2;
                str = '...';
              }
              break;
            case '}':
              ++this.index;
              this.curlyStack.pop();
              break;
            case ')':
            case ';':
            case ',':
            case '[':
            case ']':
            case ':':
            case '?':
            case '~':
              ++this.index;
              break;
            default:
              // 4-character punctuator.
              str = this.source.substr(this.index, 4);
              if (str === '>>>=') {
                this.index += 4;
              }
              else {
                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                  str === '<<=' || str === '>>=' || str === '**=') {
                  this.index += 3;
                }
                else {
                  // 2-character punctuators.
                  str = str.substr(0, 2);
                  if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                    str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                    str === '++' || str === '--' || str === '<<' || str === '>>' ||
                    str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                    str === '<=' || str === '>=' || str === '=>' || str === '**') {
                    this.index += 2;
                  }
                  else {
                    // 1-character punctuators.
                    str = this.source[this.index];
                    if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                      ++this.index;
                    }
                  }
                }
              }
          }
          if (this.index === token.start) {
            this.throwUnexpectedToken();
          }
          token.end = this.index;
          token.value = str;
          return token;
        };
        ;
        // ECMA-262 11.8.3 Numeric Literals
        Scanner.prototype.scanHexLiteral = function (start) {
          var number = '';
          while (!this.eof()) {
            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
              break;
            }
            number += this.source[this.index++];
          }
          if (number.length === 0) {
            this.throwUnexpectedToken();
          }
          if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: token_1.Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        Scanner.prototype.scanBinaryLiteral = function (start) {
          var number = '';
          var ch;
          while (!this.eof()) {
            ch = this.source[this.index];
            if (ch !== '0' && ch !== '1') {
              break;
            }
            number += this.source[this.index++];
          }
          if (number.length === 0) {
            // only 0b or 0B
            this.throwUnexpectedToken();
          }
          if (!this.eof()) {
            ch = this.source.charCodeAt(this.index);
            /* istanbul ignore else */
            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
              this.throwUnexpectedToken();
            }
          }
          return {
            type: token_1.Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        Scanner.prototype.scanOctalLiteral = function (prefix, start) {
          var number = '';
          var octal = false;
          if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
            octal = true;
            number = '0' + this.source[this.index++];
          }
          else {
            ++this.index;
          }
          while (!this.eof()) {
            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              break;
            }
            number += this.source[this.index++];
          }
          if (!octal && number.length === 0) {
            // only 0o or 0O
            this.throwUnexpectedToken();
          }
          if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: token_1.Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        Scanner.prototype.isImplicitOctalLiteral = function () {
          // Implicit octal, unless there is a non-octal digit.
          // (Annex B.1.1 on Numeric Literals)
          for (var i = this.index + 1; i < this.length; ++i) {
            var ch = this.source[i];
            if (ch === '8' || ch === '9') {
              return false;
            }
            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
              return true;
            }
          }
          return true;
        };
        ;
        Scanner.prototype.scanNumericLiteral = function () {
          var start = this.index;
          var ch = this.source[start];
          assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
          var number = '';
          if (ch !== '.') {
            number = this.source[this.index++];
            ch = this.source[this.index];
            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
              if (ch === 'x' || ch === 'X') {
                ++this.index;
                return this.scanHexLiteral(start);
              }
              if (ch === 'b' || ch === 'B') {
                ++this.index;
                return this.scanBinaryLiteral(start);
              }
              if (ch === 'o' || ch === 'O') {
                return this.scanOctalLiteral(ch, start);
              }
              if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                if (this.isImplicitOctalLiteral()) {
                  return this.scanOctalLiteral(ch, start);
                }
              }
            }
            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              number += this.source[this.index++];
            }
            ch = this.source[this.index];
          }
          if (ch === '.') {
            number += this.source[this.index++];
            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              number += this.source[this.index++];
            }
            ch = this.source[this.index];
          }
          if (ch === 'e' || ch === 'E') {
            number += this.source[this.index++];
            ch = this.source[this.index];
            if (ch === '+' || ch === '-') {
              number += this.source[this.index++];
            }
            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                number += this.source[this.index++];
              }
            }
            else {
              this.throwUnexpectedToken();
            }
          }
          if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
            this.throwUnexpectedToken();
          }
          return {
            type: token_1.Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        // ECMA-262 11.8.4 String Literals
        Scanner.prototype.scanStringLiteral = function () {
          var start = this.index;
          var quote = this.source[start];
          assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
          ++this.index;
          var octal = false;
          var str = '';
          while (!this.eof()) {
            var ch = this.source[this.index++];
            if (ch === quote) {
              quote = '';
              break;
            }
            else if (ch === '\\') {
              ch = this.source[this.index++];
              if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                switch (ch) {
                  case 'u':
                  case 'x':
                    if (this.source[this.index] === '{') {
                      ++this.index;
                      str += this.scanUnicodeCodePointEscape();
                    }
                    else {
                      var unescaped = this.scanHexEscape(ch);
                      if (!unescaped) {
                        this.throwUnexpectedToken();
                      }
                      str += unescaped;
                    }
                    break;
                  case 'n':
                    str += '\n';
                    break;
                  case 'r':
                    str += '\r';
                    break;
                  case 't':
                    str += '\t';
                    break;
                  case 'b':
                    str += '\b';
                    break;
                  case 'f':
                    str += '\f';
                    break;
                  case 'v':
                    str += '\x0B';
                    break;
                  case '8':
                  case '9':
                    str += ch;
                    this.tolerateUnexpectedToken();
                    break;
                  default:
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      var octToDec = this.octalToDecimal(ch);
                      octal = octToDec.octal || octal;
                      str += String.fromCharCode(octToDec.code);
                    }
                    else {
                      str += ch;
                    }
                    break;
                }
              }
              else {
                ++this.lineNumber;
                if (ch === '\r' && this.source[this.index] === '\n') {
                  ++this.index;
                }
                this.lineStart = this.index;
              }
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
              break;
            }
            else {
              str += ch;
            }
          }
          if (quote !== '') {
            this.index = start;
            this.throwUnexpectedToken();
          }
          return {
            type: token_1.Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        // ECMA-262 11.8.6 Template Literal Lexical Components
        Scanner.prototype.scanTemplate = function () {
          var cooked = '';
          var terminated = false;
          var start = this.index;
          var head = (this.source[start] === '`');
          var tail = false;
          var rawOffset = 2;
          ++this.index;
          while (!this.eof()) {
            var ch = this.source[this.index++];
            if (ch === '`') {
              rawOffset = 1;
              tail = true;
              terminated = true;
              break;
            }
            else if (ch === '$') {
              if (this.source[this.index] === '{') {
                this.curlyStack.push('${');
                ++this.index;
                terminated = true;
                break;
              }
              cooked += ch;
            }
            else if (ch === '\\') {
              ch = this.source[this.index++];
              if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                switch (ch) {
                  case 'n':
                    cooked += '\n';
                    break;
                  case 'r':
                    cooked += '\r';
                    break;
                  case 't':
                    cooked += '\t';
                    break;
                  case 'u':
                  case 'x':
                    if (this.source[this.index] === '{') {
                      ++this.index;
                      cooked += this.scanUnicodeCodePointEscape();
                    }
                    else {
                      var restore = this.index;
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped) {
                        cooked += unescaped;
                      }
                      else {
                        this.index = restore;
                        cooked += ch;
                      }
                    }
                    break;
                  case 'b':
                    cooked += '\b';
                    break;
                  case 'f':
                    cooked += '\f';
                    break;
                  case 'v':
                    cooked += '\v';
                    break;
                  default:
                    if (ch === '0') {
                      if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        // Illegal: \01 \02 and so on
                        this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                      }
                      cooked += '\0';
                    }
                    else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      // Illegal: \1 \2
                      this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                    }
                    else {
                      cooked += ch;
                    }
                    break;
                }
              }
              else {
                ++this.lineNumber;
                if (ch === '\r' && this.source[this.index] === '\n') {
                  ++this.index;
                }
                this.lineStart = this.index;
              }
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
              ++this.lineNumber;
              if (ch === '\r' && this.source[this.index] === '\n') {
                ++this.index;
              }
              this.lineStart = this.index;
              cooked += '\n';
            }
            else {
              cooked += ch;
            }
          }
          if (!terminated) {
            this.throwUnexpectedToken();
          }
          if (!head) {
            this.curlyStack.pop();
          }
          return {
            type: token_1.Token.Template,
            value: {
              cooked: cooked,
              raw: this.source.slice(start + 1, this.index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        // ECMA-262 11.8.5 Regular Expression Literals
        Scanner.prototype.testRegExp = function (pattern, flags) {
          // The BMP character to use as a replacement for astral symbols when
          // translating an ES6 "u"-flagged pattern to an ES5-compatible
          // approximation.
          // Note: replacing with '\uFFFF' enables false positives in unlikely
          // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
          // pattern that would not be detected by this substitution.
          var astralSubstitute = '\uFFFF';
          var tmp = pattern;
          var self = this;
          if (flags.indexOf('u') >= 0) {
            tmp = tmp
              .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                var codePoint = parseInt($1 || $2, 16);
                if (codePoint > 0x10FFFF) {
                  self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 0xFFFF) {
                  return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
              })
              .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
          }
          // First, detect invalid regular expressions.
          try {
            RegExp(tmp);
          }
          catch (e) {
            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
          }
          // Return a regular expression object for this pattern-flag pair, or
          // `null` in case the current environment doesn't support the flags it
          // uses.
          try {
            return new RegExp(pattern, flags);
          }
          catch (exception) {
            /* istanbul ignore next */
            return null;
          }
        };
        ;
        Scanner.prototype.scanRegExpBody = function () {
          var ch = this.source[this.index];
          assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
          var str = this.source[this.index++];
          var classMarker = false;
          var terminated = false;
          while (!this.eof()) {
            ch = this.source[this.index++];
            str += ch;
            if (ch === '\\') {
              ch = this.source[this.index++];
              // ECMA-262 7.8.5
              if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              str += ch;
            }
            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
              this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            else if (classMarker) {
              if (ch === ']') {
                classMarker = false;
              }
            }
            else {
              if (ch === '/') {
                terminated = true;
                break;
              }
              else if (ch === '[') {
                classMarker = true;
              }
            }
          }
          if (!terminated) {
            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
          }
          // Exclude leading and trailing slash.
          var body = str.substr(1, str.length - 2);
          return {
            value: body,
            literal: str
          };
        };
        ;
        Scanner.prototype.scanRegExpFlags = function () {
          var str = '';
          var flags = '';
          while (!this.eof()) {
            var ch = this.source[this.index];
            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
              break;
            }
            ++this.index;
            if (ch === '\\' && !this.eof()) {
              ch = this.source[this.index];
              if (ch === 'u') {
                ++this.index;
                var restore = this.index;
                ch = this.scanHexEscape('u');
                if (ch) {
                  flags += ch;
                  for (str += '\\u'; restore < this.index; ++restore) {
                    str += this.source[restore];
                  }
                }
                else {
                  this.index = restore;
                  flags += 'u';
                  str += '\\u';
                }
                this.tolerateUnexpectedToken();
              }
              else {
                str += '\\';
                this.tolerateUnexpectedToken();
              }
            }
            else {
              flags += ch;
              str += ch;
            }
          }
          return {
            value: flags,
            literal: str
          };
        };
        ;
        Scanner.prototype.scanRegExp = function () {
          var start = this.index;
          var body = this.scanRegExpBody();
          var flags = this.scanRegExpFlags();
          var value = this.testRegExp(body.value, flags.value);
          return {
            type: token_1.Token.RegularExpression,
            value: value,
            literal: body.literal + flags.literal,
            regex: {
              pattern: body.value,
              flags: flags.value
            },
            lineNumber: this.lineNumber,
            lineStart: this.lineStart,
            start: start,
            end: this.index
          };
        };
        ;
        Scanner.prototype.lex = function () {
          if (this.eof()) {
            return {
              type: token_1.Token.EOF,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start: this.index,
              end: this.index
            };
          }
          var cp = this.source.charCodeAt(this.index);
          if (character_1.Character.isIdentifierStart(cp)) {
            return this.scanIdentifier();
          }
          // Very common: ( and ) and ;
          if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return this.scanPunctuator();
          }
          // String literal starts with single quote (U+0027) or double quote (U+0022).
          if (cp === 0x27 || cp === 0x22) {
            return this.scanStringLiteral();
          }
          // Dot (.) U+002E can also start a floating-point number, hence the need
          // to check the next character.
          if (cp === 0x2E) {
            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
              return this.scanNumericLiteral();
            }
            return this.scanPunctuator();
          }
          if (character_1.Character.isDecimalDigit(cp)) {
            return this.scanNumericLiteral();
          }
          // Template literals start with ` (U+0060) for template head
          // or } (U+007D) for template middle or template tail.
          if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
            return this.scanTemplate();
          }
          // Possible identifier start in a surrogate pair.
          if (cp >= 0xD800 && cp < 0xDFFF) {
            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
              return this.scanIdentifier();
            }
          }
          return this.scanPunctuator();
        };
        ;
        return Scanner;
      }());
      exports.Scanner = Scanner;


      /***/
},
/* 9 */
/***/ function (module, exports) {

      "use strict";
      // See also tools/generate-unicode-regex.js.
      var Regex = {
        // Unicode v8.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // Unicode v8.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      exports.Character = {
        fromCodePoint: function (cp) {
          return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
        },
        // ECMA-262 11.2 White Space
        isWhiteSpace: function (cp) {
          return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
        },
        // ECMA-262 11.3 Line Terminators
        isLineTerminator: function (cp) {
          return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
        },
        // ECMA-262 11.6 Identifier Names and Identifiers
        isIdentifierStart: function (cp) {
          return (cp === 0x24) || (cp === 0x5F) ||
            (cp >= 0x41 && cp <= 0x5A) ||
            (cp >= 0x61 && cp <= 0x7A) ||
            (cp === 0x5C) ||
            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
        },
        isIdentifierPart: function (cp) {
          return (cp === 0x24) || (cp === 0x5F) ||
            (cp >= 0x41 && cp <= 0x5A) ||
            (cp >= 0x61 && cp <= 0x7A) ||
            (cp >= 0x30 && cp <= 0x39) ||
            (cp === 0x5C) ||
            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
        },
        // ECMA-262 11.8.3 Numeric Literals
        isDecimalDigit: function (cp) {
          return (cp >= 0x30 && cp <= 0x39); // 0..9
        },
        isHexDigit: function (cp) {
          return (cp >= 0x30 && cp <= 0x39) ||
            (cp >= 0x41 && cp <= 0x46) ||
            (cp >= 0x61 && cp <= 0x66); // a..f
        },
        isOctalDigit: function (cp) {
          return (cp >= 0x30 && cp <= 0x37); // 0..7
        }
      };


      /***/
},
/* 10 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var syntax_1 = __webpack_require__(2);
      var ArrayExpression = (function () {
        function ArrayExpression(elements) {
          this.type = syntax_1.Syntax.ArrayExpression;
          this.elements = elements;
        }
        return ArrayExpression;
      }());
      exports.ArrayExpression = ArrayExpression;
      var ArrayPattern = (function () {
        function ArrayPattern(elements) {
          this.type = syntax_1.Syntax.ArrayPattern;
          this.elements = elements;
        }
        return ArrayPattern;
      }());
      exports.ArrayPattern = ArrayPattern;
      var ArrowFunctionExpression = (function () {
        function ArrowFunctionExpression(params, body, expression) {
          this.type = syntax_1.Syntax.ArrowFunctionExpression;
          this.id = null;
          this.params = params;
          this.body = body;
          this.generator = false;
          this.expression = expression;
        }
        return ArrowFunctionExpression;
      }());
      exports.ArrowFunctionExpression = ArrowFunctionExpression;
      var AssignmentExpression = (function () {
        function AssignmentExpression(operator, left, right) {
          this.type = syntax_1.Syntax.AssignmentExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
        }
        return AssignmentExpression;
      }());
      exports.AssignmentExpression = AssignmentExpression;
      var AssignmentPattern = (function () {
        function AssignmentPattern(left, right) {
          this.type = syntax_1.Syntax.AssignmentPattern;
          this.left = left;
          this.right = right;
        }
        return AssignmentPattern;
      }());
      exports.AssignmentPattern = AssignmentPattern;
      var BinaryExpression = (function () {
        function BinaryExpression(operator, left, right) {
          var logical = (operator === '||' || operator === '&&');
          this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
          this.operator = operator;
          this.left = left;
          this.right = right;
        }
        return BinaryExpression;
      }());
      exports.BinaryExpression = BinaryExpression;
      var BlockStatement = (function () {
        function BlockStatement(body) {
          this.type = syntax_1.Syntax.BlockStatement;
          this.body = body;
        }
        return BlockStatement;
      }());
      exports.BlockStatement = BlockStatement;
      var BreakStatement = (function () {
        function BreakStatement(label) {
          this.type = syntax_1.Syntax.BreakStatement;
          this.label = label;
        }
        return BreakStatement;
      }());
      exports.BreakStatement = BreakStatement;
      var CallExpression = (function () {
        function CallExpression(callee, args) {
          this.type = syntax_1.Syntax.CallExpression;
          this.callee = callee;
          this.arguments = args;
        }
        return CallExpression;
      }());
      exports.CallExpression = CallExpression;
      var CatchClause = (function () {
        function CatchClause(param, body) {
          this.type = syntax_1.Syntax.CatchClause;
          this.param = param;
          this.body = body;
        }
        return CatchClause;
      }());
      exports.CatchClause = CatchClause;
      var ClassBody = (function () {
        function ClassBody(body) {
          this.type = syntax_1.Syntax.ClassBody;
          this.body = body;
        }
        return ClassBody;
      }());
      exports.ClassBody = ClassBody;
      var ClassDeclaration = (function () {
        function ClassDeclaration(id, superClass, body) {
          this.type = syntax_1.Syntax.ClassDeclaration;
          this.id = id;
          this.superClass = superClass;
          this.body = body;
        }
        return ClassDeclaration;
      }());
      exports.ClassDeclaration = ClassDeclaration;
      var ClassExpression = (function () {
        function ClassExpression(id, superClass, body) {
          this.type = syntax_1.Syntax.ClassExpression;
          this.id = id;
          this.superClass = superClass;
          this.body = body;
        }
        return ClassExpression;
      }());
      exports.ClassExpression = ClassExpression;
      var ComputedMemberExpression = (function () {
        function ComputedMemberExpression(object, property) {
          this.type = syntax_1.Syntax.MemberExpression;
          this.computed = true;
          this.object = object;
          this.property = property;
        }
        return ComputedMemberExpression;
      }());
      exports.ComputedMemberExpression = ComputedMemberExpression;
      var ConditionalExpression = (function () {
        function ConditionalExpression(test, consequent, alternate) {
          this.type = syntax_1.Syntax.ConditionalExpression;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
        }
        return ConditionalExpression;
      }());
      exports.ConditionalExpression = ConditionalExpression;
      var ContinueStatement = (function () {
        function ContinueStatement(label) {
          this.type = syntax_1.Syntax.ContinueStatement;
          this.label = label;
        }
        return ContinueStatement;
      }());
      exports.ContinueStatement = ContinueStatement;
      var DebuggerStatement = (function () {
        function DebuggerStatement() {
          this.type = syntax_1.Syntax.DebuggerStatement;
        }
        return DebuggerStatement;
      }());
      exports.DebuggerStatement = DebuggerStatement;
      var Directive = (function () {
        function Directive(expression, directive) {
          this.type = syntax_1.Syntax.ExpressionStatement;
          this.expression = expression;
          this.directive = directive;
        }
        return Directive;
      }());
      exports.Directive = Directive;
      var DoWhileStatement = (function () {
        function DoWhileStatement(body, test) {
          this.type = syntax_1.Syntax.DoWhileStatement;
          this.body = body;
          this.test = test;
        }
        return DoWhileStatement;
      }());
      exports.DoWhileStatement = DoWhileStatement;
      var EmptyStatement = (function () {
        function EmptyStatement() {
          this.type = syntax_1.Syntax.EmptyStatement;
        }
        return EmptyStatement;
      }());
      exports.EmptyStatement = EmptyStatement;
      var ExportAllDeclaration = (function () {
        function ExportAllDeclaration(source) {
          this.type = syntax_1.Syntax.ExportAllDeclaration;
          this.source = source;
        }
        return ExportAllDeclaration;
      }());
      exports.ExportAllDeclaration = ExportAllDeclaration;
      var ExportDefaultDeclaration = (function () {
        function ExportDefaultDeclaration(declaration) {
          this.type = syntax_1.Syntax.ExportDefaultDeclaration;
          this.declaration = declaration;
        }
        return ExportDefaultDeclaration;
      }());
      exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
      var ExportNamedDeclaration = (function () {
        function ExportNamedDeclaration(declaration, specifiers, source) {
          this.type = syntax_1.Syntax.ExportNamedDeclaration;
          this.declaration = declaration;
          this.specifiers = specifiers;
          this.source = source;
        }
        return ExportNamedDeclaration;
      }());
      exports.ExportNamedDeclaration = ExportNamedDeclaration;
      var ExportSpecifier = (function () {
        function ExportSpecifier(local, exported) {
          this.type = syntax_1.Syntax.ExportSpecifier;
          this.exported = exported;
          this.local = local;
        }
        return ExportSpecifier;
      }());
      exports.ExportSpecifier = ExportSpecifier;
      var ExpressionStatement = (function () {
        function ExpressionStatement(expression) {
          this.type = syntax_1.Syntax.ExpressionStatement;
          this.expression = expression;
        }
        return ExpressionStatement;
      }());
      exports.ExpressionStatement = ExpressionStatement;
      var ForInStatement = (function () {
        function ForInStatement(left, right, body) {
          this.type = syntax_1.Syntax.ForInStatement;
          this.left = left;
          this.right = right;
          this.body = body;
          this.each = false;
        }
        return ForInStatement;
      }());
      exports.ForInStatement = ForInStatement;
      var ForOfStatement = (function () {
        function ForOfStatement(left, right, body) {
          this.type = syntax_1.Syntax.ForOfStatement;
          this.left = left;
          this.right = right;
          this.body = body;
        }
        return ForOfStatement;
      }());
      exports.ForOfStatement = ForOfStatement;
      var ForStatement = (function () {
        function ForStatement(init, test, update, body) {
          this.type = syntax_1.Syntax.ForStatement;
          this.init = init;
          this.test = test;
          this.update = update;
          this.body = body;
        }
        return ForStatement;
      }());
      exports.ForStatement = ForStatement;
      var FunctionDeclaration = (function () {
        function FunctionDeclaration(id, params, body, generator) {
          this.type = syntax_1.Syntax.FunctionDeclaration;
          this.id = id;
          this.params = params;
          this.body = body;
          this.generator = generator;
          this.expression = false;
        }
        return FunctionDeclaration;
      }());
      exports.FunctionDeclaration = FunctionDeclaration;
      var FunctionExpression = (function () {
        function FunctionExpression(id, params, body, generator) {
          this.type = syntax_1.Syntax.FunctionExpression;
          this.id = id;
          this.params = params;
          this.body = body;
          this.generator = generator;
          this.expression = false;
        }
        return FunctionExpression;
      }());
      exports.FunctionExpression = FunctionExpression;
      var Identifier = (function () {
        function Identifier(name) {
          this.type = syntax_1.Syntax.Identifier;
          this.name = name;
        }
        return Identifier;
      }());
      exports.Identifier = Identifier;
      var IfStatement = (function () {
        function IfStatement(test, consequent, alternate) {
          this.type = syntax_1.Syntax.IfStatement;
          this.test = test;
          this.consequent = consequent;
          this.alternate = alternate;
        }
        return IfStatement;
      }());
      exports.IfStatement = IfStatement;
      var ImportDeclaration = (function () {
        function ImportDeclaration(specifiers, source) {
          this.type = syntax_1.Syntax.ImportDeclaration;
          this.specifiers = specifiers;
          this.source = source;
        }
        return ImportDeclaration;
      }());
      exports.ImportDeclaration = ImportDeclaration;
      var ImportDefaultSpecifier = (function () {
        function ImportDefaultSpecifier(local) {
          this.type = syntax_1.Syntax.ImportDefaultSpecifier;
          this.local = local;
        }
        return ImportDefaultSpecifier;
      }());
      exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
      var ImportNamespaceSpecifier = (function () {
        function ImportNamespaceSpecifier(local) {
          this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
          this.local = local;
        }
        return ImportNamespaceSpecifier;
      }());
      exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
      var ImportSpecifier = (function () {
        function ImportSpecifier(local, imported) {
          this.type = syntax_1.Syntax.ImportSpecifier;
          this.local = local;
          this.imported = imported;
        }
        return ImportSpecifier;
      }());
      exports.ImportSpecifier = ImportSpecifier;
      var LabeledStatement = (function () {
        function LabeledStatement(label, body) {
          this.type = syntax_1.Syntax.LabeledStatement;
          this.label = label;
          this.body = body;
        }
        return LabeledStatement;
      }());
      exports.LabeledStatement = LabeledStatement;
      var Literal = (function () {
        function Literal(value, raw) {
          this.type = syntax_1.Syntax.Literal;
          this.value = value;
          this.raw = raw;
        }
        return Literal;
      }());
      exports.Literal = Literal;
      var MetaProperty = (function () {
        function MetaProperty(meta, property) {
          this.type = syntax_1.Syntax.MetaProperty;
          this.meta = meta;
          this.property = property;
        }
        return MetaProperty;
      }());
      exports.MetaProperty = MetaProperty;
      var MethodDefinition = (function () {
        function MethodDefinition(key, computed, value, kind, isStatic) {
          this.type = syntax_1.Syntax.MethodDefinition;
          this.key = key;
          this.computed = computed;
          this.value = value;
          this.kind = kind;
          this.static = isStatic;
        }
        return MethodDefinition;
      }());
      exports.MethodDefinition = MethodDefinition;
      var NewExpression = (function () {
        function NewExpression(callee, args) {
          this.type = syntax_1.Syntax.NewExpression;
          this.callee = callee;
          this.arguments = args;
        }
        return NewExpression;
      }());
      exports.NewExpression = NewExpression;
      var ObjectExpression = (function () {
        function ObjectExpression(properties) {
          this.type = syntax_1.Syntax.ObjectExpression;
          this.properties = properties;
        }
        return ObjectExpression;
      }());
      exports.ObjectExpression = ObjectExpression;
      var ObjectPattern = (function () {
        function ObjectPattern(properties) {
          this.type = syntax_1.Syntax.ObjectPattern;
          this.properties = properties;
        }
        return ObjectPattern;
      }());
      exports.ObjectPattern = ObjectPattern;
      var Program = (function () {
        function Program(body, sourceType) {
          this.type = syntax_1.Syntax.Program;
          this.body = body;
          this.sourceType = sourceType;
        }
        return Program;
      }());
      exports.Program = Program;
      var Property = (function () {
        function Property(kind, key, computed, value, method, shorthand) {
          this.type = syntax_1.Syntax.Property;
          this.key = key;
          this.computed = computed;
          this.value = value;
          this.kind = kind;
          this.method = method;
          this.shorthand = shorthand;
        }
        return Property;
      }());
      exports.Property = Property;
      var RegexLiteral = (function () {
        function RegexLiteral(value, raw, regex) {
          this.type = syntax_1.Syntax.Literal;
          this.value = value;
          this.raw = raw;
          this.regex = regex;
        }
        return RegexLiteral;
      }());
      exports.RegexLiteral = RegexLiteral;
      var RestElement = (function () {
        function RestElement(argument) {
          this.type = syntax_1.Syntax.RestElement;
          this.argument = argument;
        }
        return RestElement;
      }());
      exports.RestElement = RestElement;
      var ReturnStatement = (function () {
        function ReturnStatement(argument) {
          this.type = syntax_1.Syntax.ReturnStatement;
          this.argument = argument;
        }
        return ReturnStatement;
      }());
      exports.ReturnStatement = ReturnStatement;
      var SequenceExpression = (function () {
        function SequenceExpression(expressions) {
          this.type = syntax_1.Syntax.SequenceExpression;
          this.expressions = expressions;
        }
        return SequenceExpression;
      }());
      exports.SequenceExpression = SequenceExpression;
      var SpreadElement = (function () {
        function SpreadElement(argument) {
          this.type = syntax_1.Syntax.SpreadElement;
          this.argument = argument;
        }
        return SpreadElement;
      }());
      exports.SpreadElement = SpreadElement;
      var StaticMemberExpression = (function () {
        function StaticMemberExpression(object, property) {
          this.type = syntax_1.Syntax.MemberExpression;
          this.computed = false;
          this.object = object;
          this.property = property;
        }
        return StaticMemberExpression;
      }());
      exports.StaticMemberExpression = StaticMemberExpression;
      var Super = (function () {
        function Super() {
          this.type = syntax_1.Syntax.Super;
        }
        return Super;
      }());
      exports.Super = Super;
      var SwitchCase = (function () {
        function SwitchCase(test, consequent) {
          this.type = syntax_1.Syntax.SwitchCase;
          this.test = test;
          this.consequent = consequent;
        }
        return SwitchCase;
      }());
      exports.SwitchCase = SwitchCase;
      var SwitchStatement = (function () {
        function SwitchStatement(discriminant, cases) {
          this.type = syntax_1.Syntax.SwitchStatement;
          this.discriminant = discriminant;
          this.cases = cases;
        }
        return SwitchStatement;
      }());
      exports.SwitchStatement = SwitchStatement;
      var TaggedTemplateExpression = (function () {
        function TaggedTemplateExpression(tag, quasi) {
          this.type = syntax_1.Syntax.TaggedTemplateExpression;
          this.tag = tag;
          this.quasi = quasi;
        }
        return TaggedTemplateExpression;
      }());
      exports.TaggedTemplateExpression = TaggedTemplateExpression;
      var TemplateElement = (function () {
        function TemplateElement(value, tail) {
          this.type = syntax_1.Syntax.TemplateElement;
          this.value = value;
          this.tail = tail;
        }
        return TemplateElement;
      }());
      exports.TemplateElement = TemplateElement;
      var TemplateLiteral = (function () {
        function TemplateLiteral(quasis, expressions) {
          this.type = syntax_1.Syntax.TemplateLiteral;
          this.quasis = quasis;
          this.expressions = expressions;
        }
        return TemplateLiteral;
      }());
      exports.TemplateLiteral = TemplateLiteral;
      var ThisExpression = (function () {
        function ThisExpression() {
          this.type = syntax_1.Syntax.ThisExpression;
        }
        return ThisExpression;
      }());
      exports.ThisExpression = ThisExpression;
      var ThrowStatement = (function () {
        function ThrowStatement(argument) {
          this.type = syntax_1.Syntax.ThrowStatement;
          this.argument = argument;
        }
        return ThrowStatement;
      }());
      exports.ThrowStatement = ThrowStatement;
      var TryStatement = (function () {
        function TryStatement(block, handler, finalizer) {
          this.type = syntax_1.Syntax.TryStatement;
          this.block = block;
          this.handler = handler;
          this.finalizer = finalizer;
        }
        return TryStatement;
      }());
      exports.TryStatement = TryStatement;
      var UnaryExpression = (function () {
        function UnaryExpression(operator, argument) {
          this.type = syntax_1.Syntax.UnaryExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = true;
        }
        return UnaryExpression;
      }());
      exports.UnaryExpression = UnaryExpression;
      var UpdateExpression = (function () {
        function UpdateExpression(operator, argument, prefix) {
          this.type = syntax_1.Syntax.UpdateExpression;
          this.operator = operator;
          this.argument = argument;
          this.prefix = prefix;
        }
        return UpdateExpression;
      }());
      exports.UpdateExpression = UpdateExpression;
      var VariableDeclaration = (function () {
        function VariableDeclaration(declarations, kind) {
          this.type = syntax_1.Syntax.VariableDeclaration;
          this.declarations = declarations;
          this.kind = kind;
        }
        return VariableDeclaration;
      }());
      exports.VariableDeclaration = VariableDeclaration;
      var VariableDeclarator = (function () {
        function VariableDeclarator(id, init) {
          this.type = syntax_1.Syntax.VariableDeclarator;
          this.id = id;
          this.init = init;
        }
        return VariableDeclarator;
      }());
      exports.VariableDeclarator = VariableDeclarator;
      var WhileStatement = (function () {
        function WhileStatement(test, body) {
          this.type = syntax_1.Syntax.WhileStatement;
          this.test = test;
          this.body = body;
        }
        return WhileStatement;
      }());
      exports.WhileStatement = WhileStatement;
      var WithStatement = (function () {
        function WithStatement(object, body) {
          this.type = syntax_1.Syntax.WithStatement;
          this.object = object;
          this.body = body;
        }
        return WithStatement;
      }());
      exports.WithStatement = WithStatement;
      var YieldExpression = (function () {
        function YieldExpression(argument, delegate) {
          this.type = syntax_1.Syntax.YieldExpression;
          this.argument = argument;
          this.delegate = delegate;
        }
        return YieldExpression;
      }());
      exports.YieldExpression = YieldExpression;


      /***/
},
/* 11 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      /* istanbul ignore next */
      var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      var character_1 = __webpack_require__(9);
      var token_1 = __webpack_require__(7);
      var parser_1 = __webpack_require__(3);
      var xhtml_entities_1 = __webpack_require__(12);
      var jsx_syntax_1 = __webpack_require__(13);
      var Node = __webpack_require__(10);
      var JSXNode = __webpack_require__(14);
      var JSXToken;
      (function (JSXToken) {
        JSXToken[JSXToken["Identifier"] = 100] = "Identifier";
        JSXToken[JSXToken["Text"] = 101] = "Text";
      })(JSXToken || (JSXToken = {}));
      token_1.TokenName[JSXToken.Identifier] = 'JSXIdentifier';
      token_1.TokenName[JSXToken.Text] = 'JSXText';
      // Fully qualified element name, e.g. <svg:path> returns "svg:path"
      function getQualifiedElementName(elementName) {
        var qualifiedName;
        switch (elementName.type) {
          case jsx_syntax_1.JSXSyntax.JSXIdentifier:
            var id = (elementName);
            qualifiedName = id.name;
            break;
          case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
            var ns = (elementName);
            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
              getQualifiedElementName(ns.name);
            break;
          case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
            var expr = (elementName);
            qualifiedName = getQualifiedElementName(expr.object) + '.' +
              getQualifiedElementName(expr.property);
            break;
        }
        return qualifiedName;
      }
      var JSXParser = (function (_super) {
        __extends(JSXParser, _super);
        function JSXParser(code, options, delegate) {
          _super.call(this, code, options, delegate);
        }
        JSXParser.prototype.parsePrimaryExpression = function () {
          return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
        };
        JSXParser.prototype.startJSX = function () {
          // Unwind the scanner before the lookahead token.
          this.scanner.index = this.startMarker.index;
          this.scanner.lineNumber = this.startMarker.lineNumber;
          this.scanner.lineStart = this.startMarker.lineStart;
        };
        JSXParser.prototype.finishJSX = function () {
          // Prime the next lookahead.
          this.nextToken();
        };
        JSXParser.prototype.reenterJSX = function () {
          this.startJSX();
          this.expectJSX('}');
          // Pop the closing '}' added from the lookahead.
          if (this.config.tokens) {
            this.tokens.pop();
          }
        };
        JSXParser.prototype.createJSXNode = function () {
          this.collectComments();
          return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
          };
        };
        JSXParser.prototype.createJSXChildNode = function () {
          return {
            index: this.scanner.index,
            line: this.scanner.lineNumber,
            column: this.scanner.index - this.scanner.lineStart
          };
        };
        JSXParser.prototype.scanXHTMLEntity = function (quote) {
          var result = '&';
          var valid = true;
          var terminated = false;
          var numeric = false;
          var hex = false;
          while (!this.scanner.eof() && valid && !terminated) {
            var ch = this.scanner.source[this.scanner.index];
            if (ch === quote) {
              break;
            }
            terminated = (ch === ';');
            result += ch;
            ++this.scanner.index;
            if (!terminated) {
              switch (result.length) {
                case 2:
                  // e.g. '&#123;'
                  numeric = (ch === '#');
                  break;
                case 3:
                  if (numeric) {
                    // e.g. '&#x41;'
                    hex = (ch === 'x');
                    valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                    numeric = numeric && !hex;
                  }
                  break;
                default:
                  valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                  valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                  break;
              }
            }
          }
          if (valid && terminated && result.length > 2) {
            // e.g. '&#x41;' becomes just '#x41'
            var str = result.substr(1, result.length - 2);
            if (numeric && str.length > 1) {
              result = String.fromCharCode(parseInt(str.substr(1), 10));
            }
            else if (hex && str.length > 2) {
              result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
            }
            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
              result = xhtml_entities_1.XHTMLEntities[str];
            }
          }
          return result;
        };
        // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
        JSXParser.prototype.lexJSX = function () {
          var cp = this.scanner.source.charCodeAt(this.scanner.index);
          // < > / : = { }
          if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
            var value = this.scanner.source[this.scanner.index++];
            return {
              type: token_1.Token.Punctuator,
              value: value,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: this.scanner.index - 1,
              end: this.scanner.index
            };
          }
          // " '
          if (cp === 34 || cp === 39) {
            var start = this.scanner.index;
            var quote = this.scanner.source[this.scanner.index++];
            var str = '';
            while (!this.scanner.eof()) {
              var ch = this.scanner.source[this.scanner.index++];
              if (ch === quote) {
                break;
              }
              else if (ch === '&') {
                str += this.scanXHTMLEntity(quote);
              }
              else {
                str += ch;
              }
            }
            return {
              type: token_1.Token.StringLiteral,
              value: str,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: start,
              end: this.scanner.index
            };
          }
          // ... or .
          if (cp === 46) {
            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
            var start = this.scanner.index;
            this.scanner.index += value.length;
            return {
              type: token_1.Token.Punctuator,
              value: value,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: start,
              end: this.scanner.index
            };
          }
          // `
          if (cp === 96) {
            // Only placeholder, since it will be rescanned as a real assignment expression.
            return {
              type: token_1.Token.Template,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: this.scanner.index,
              end: this.scanner.index
            };
          }
          // Identifer can not contain backslash (char code 92).
          if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
            var start = this.scanner.index;
            ++this.scanner.index;
            while (!this.scanner.eof()) {
              var ch = this.scanner.source.charCodeAt(this.scanner.index);
              if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
                ++this.scanner.index;
              }
              else if (ch === 45) {
                // Hyphen (char code 45) can be part of an identifier.
                ++this.scanner.index;
              }
              else {
                break;
              }
            }
            var id = this.scanner.source.slice(start, this.scanner.index);
            return {
              type: JSXToken.Identifier,
              value: id,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start: start,
              end: this.scanner.index
            };
          }
          this.scanner.throwUnexpectedToken();
        };
        JSXParser.prototype.nextJSXToken = function () {
          this.collectComments();
          this.startMarker.index = this.scanner.index;
          this.startMarker.lineNumber = this.scanner.lineNumber;
          this.startMarker.lineStart = this.scanner.lineStart;
          var token = this.lexJSX();
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.lineNumber = this.scanner.lineNumber;
          this.lastMarker.lineStart = this.scanner.lineStart;
          if (this.config.tokens) {
            this.tokens.push(this.convertToken(token));
          }
          return token;
        };
        JSXParser.prototype.nextJSXText = function () {
          this.startMarker.index = this.scanner.index;
          this.startMarker.lineNumber = this.scanner.lineNumber;
          this.startMarker.lineStart = this.scanner.lineStart;
          var start = this.scanner.index;
          var text = '';
          while (!this.scanner.eof()) {
            var ch = this.scanner.source[this.scanner.index];
            if (ch === '{' || ch === '<') {
              break;
            }
            ++this.scanner.index;
            text += ch;
            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
              ++this.scanner.lineNumber;
              if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
                ++this.scanner.index;
              }
              this.scanner.lineStart = this.scanner.index;
            }
          }
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.lineNumber = this.scanner.lineNumber;
          this.lastMarker.lineStart = this.scanner.lineStart;
          var token = {
            type: JSXToken.Text,
            value: text,
            lineNumber: this.scanner.lineNumber,
            lineStart: this.scanner.lineStart,
            start: start,
            end: this.scanner.index
          };
          if ((text.length > 0) && this.config.tokens) {
            this.tokens.push(this.convertToken(token));
          }
          return token;
        };
        JSXParser.prototype.peekJSXToken = function () {
          var previousIndex = this.scanner.index;
          var previousLineNumber = this.scanner.lineNumber;
          var previousLineStart = this.scanner.lineStart;
          this.scanner.scanComments();
          var next = this.lexJSX();
          this.scanner.index = previousIndex;
          this.scanner.lineNumber = previousLineNumber;
          this.scanner.lineStart = previousLineStart;
          return next;
        };
        // Expect the next JSX token to match the specified punctuator.
        // If not, an exception will be thrown.
        JSXParser.prototype.expectJSX = function (value) {
          var token = this.nextJSXToken();
          if (token.type !== token_1.Token.Punctuator || token.value !== value) {
            this.throwUnexpectedToken(token);
          }
        };
        // Return true if the next JSX token matches the specified punctuator.
        JSXParser.prototype.matchJSX = function (value) {
          var next = this.peekJSXToken();
          return next.type === token_1.Token.Punctuator && next.value === value;
        };
        JSXParser.prototype.parseJSXIdentifier = function () {
          var node = this.createJSXNode();
          var token = this.nextJSXToken();
          if (token.type !== JSXToken.Identifier) {
            this.throwUnexpectedToken(token);
          }
          return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
        };
        JSXParser.prototype.parseJSXElementName = function () {
          var node = this.createJSXNode();
          var elementName = this.parseJSXIdentifier();
          if (this.matchJSX(':')) {
            var namespace = elementName;
            this.expectJSX(':');
            var name_1 = this.parseJSXIdentifier();
            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
          }
          else if (this.matchJSX('.')) {
            while (this.matchJSX('.')) {
              var object = elementName;
              this.expectJSX('.');
              var property = this.parseJSXIdentifier();
              elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
            }
          }
          return elementName;
        };
        JSXParser.prototype.parseJSXAttributeName = function () {
          var node = this.createJSXNode();
          var attributeName;
          var identifier = this.parseJSXIdentifier();
          if (this.matchJSX(':')) {
            var namespace = identifier;
            this.expectJSX(':');
            var name_2 = this.parseJSXIdentifier();
            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
          }
          else {
            attributeName = identifier;
          }
          return attributeName;
        };
        JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
          var node = this.createJSXNode();
          var token = this.nextJSXToken();
          if (token.type !== token_1.Token.StringLiteral) {
            this.throwUnexpectedToken(token);
          }
          var raw = this.getTokenRaw(token);
          return this.finalize(node, new Node.Literal(token.value, raw));
        };
        JSXParser.prototype.parseJSXExpressionAttribute = function () {
          var node = this.createJSXNode();
          this.expectJSX('{');
          this.finishJSX();
          if (this.match('}')) {
            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
          }
          var expression = this.parseAssignmentExpression();
          this.reenterJSX();
          return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
        };
        JSXParser.prototype.parseJSXAttributeValue = function () {
          return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
        };
        JSXParser.prototype.parseJSXNameValueAttribute = function () {
          var node = this.createJSXNode();
          var name = this.parseJSXAttributeName();
          var value = null;
          if (this.matchJSX('=')) {
            this.expectJSX('=');
            value = this.parseJSXAttributeValue();
          }
          return this.finalize(node, new JSXNode.JSXAttribute(name, value));
        };
        JSXParser.prototype.parseJSXSpreadAttribute = function () {
          var node = this.createJSXNode();
          this.expectJSX('{');
          this.expectJSX('...');
          this.finishJSX();
          var argument = this.parseAssignmentExpression();
          this.reenterJSX();
          return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
        };
        JSXParser.prototype.parseJSXAttributes = function () {
          var attributes = [];
          while (!this.matchJSX('/') && !this.matchJSX('>')) {
            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
              this.parseJSXNameValueAttribute();
            attributes.push(attribute);
          }
          return attributes;
        };
        JSXParser.prototype.parseJSXOpeningElement = function () {
          var node = this.createJSXNode();
          this.expectJSX('<');
          var name = this.parseJSXElementName();
          var attributes = this.parseJSXAttributes();
          var selfClosing = this.matchJSX('/');
          if (selfClosing) {
            this.expectJSX('/');
          }
          this.expectJSX('>');
          return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
        };
        JSXParser.prototype.parseJSXBoundaryElement = function () {
          var node = this.createJSXNode();
          this.expectJSX('<');
          if (this.matchJSX('/')) {
            this.expectJSX('/');
            var name_3 = this.parseJSXElementName();
            this.expectJSX('>');
            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
          }
          var name = this.parseJSXElementName();
          var attributes = this.parseJSXAttributes();
          var selfClosing = this.matchJSX('/');
          if (selfClosing) {
            this.expectJSX('/');
          }
          this.expectJSX('>');
          return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
        };
        JSXParser.prototype.parseJSXEmptyExpression = function () {
          var node = this.createJSXChildNode();
          this.collectComments();
          this.lastMarker.index = this.scanner.index;
          this.lastMarker.lineNumber = this.scanner.lineNumber;
          this.lastMarker.lineStart = this.scanner.lineStart;
          return this.finalize(node, new JSXNode.JSXEmptyExpression());
        };
        JSXParser.prototype.parseJSXExpressionContainer = function () {
          var node = this.createJSXNode();
          this.expectJSX('{');
          var expression;
          if (this.matchJSX('}')) {
            expression = this.parseJSXEmptyExpression();
            this.expectJSX('}');
          }
          else {
            this.finishJSX();
            expression = this.parseAssignmentExpression();
            this.reenterJSX();
          }
          return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
        };
        JSXParser.prototype.parseJSXChildren = function () {
          var children = [];
          while (!this.scanner.eof()) {
            var node = this.createJSXChildNode();
            var token = this.nextJSXText();
            if (token.start < token.end) {
              var raw = this.getTokenRaw(token);
              var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
              children.push(child);
            }
            if (this.scanner.source[this.scanner.index] === '{') {
              var container = this.parseJSXExpressionContainer();
              children.push(container);
            }
            else {
              break;
            }
          }
          return children;
        };
        JSXParser.prototype.parseComplexJSXElement = function (el) {
          var stack = [];
          while (!this.scanner.eof()) {
            el.children = el.children.concat(this.parseJSXChildren());
            var node = this.createJSXChildNode();
            var element = this.parseJSXBoundaryElement();
            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
              var opening = (element);
              if (opening.selfClosing) {
                var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                el.children.push(child);
              }
              else {
                stack.push(el);
                el = { node: node, opening: opening, closing: null, children: [] };
              }
            }
            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
              el.closing = (element);
              var open_1 = getQualifiedElementName(el.opening.name);
              var close_1 = getQualifiedElementName(el.closing.name);
              if (open_1 !== close_1) {
                this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
              }
              if (stack.length > 0) {
                var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                el = stack.pop();
                el.children.push(child);
              }
              else {
                break;
              }
            }
          }
          return el;
        };
        JSXParser.prototype.parseJSXElement = function () {
          var node = this.createJSXNode();
          var opening = this.parseJSXOpeningElement();
          var children = [];
          var closing = null;
          if (!opening.selfClosing) {
            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
            children = el.children;
            closing = el.closing;
          }
          return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
        };
        JSXParser.prototype.parseJSXRoot = function () {
          // Pop the opening '<' added from the lookahead.
          if (this.config.tokens) {
            this.tokens.pop();
          }
          this.startJSX();
          var element = this.parseJSXElement();
          this.finishJSX();
          return element;
        };
        return JSXParser;
      }(parser_1.Parser));
      exports.JSXParser = JSXParser;


      /***/
},
/* 12 */
/***/ function (module, exports) {

      // Generated by generate-xhtml-entities.js. DO NOT MODIFY!
      "use strict";
      exports.XHTMLEntities = {
        quot: '\u0022',
        amp: '\u0026',
        apos: '\u0027',
        gt: '\u003E',
        nbsp: '\u00A0',
        iexcl: '\u00A1',
        cent: '\u00A2',
        pound: '\u00A3',
        curren: '\u00A4',
        yen: '\u00A5',
        brvbar: '\u00A6',
        sect: '\u00A7',
        uml: '\u00A8',
        copy: '\u00A9',
        ordf: '\u00AA',
        laquo: '\u00AB',
        not: '\u00AC',
        shy: '\u00AD',
        reg: '\u00AE',
        macr: '\u00AF',
        deg: '\u00B0',
        plusmn: '\u00B1',
        sup2: '\u00B2',
        sup3: '\u00B3',
        acute: '\u00B4',
        micro: '\u00B5',
        para: '\u00B6',
        middot: '\u00B7',
        cedil: '\u00B8',
        sup1: '\u00B9',
        ordm: '\u00BA',
        raquo: '\u00BB',
        frac14: '\u00BC',
        frac12: '\u00BD',
        frac34: '\u00BE',
        iquest: '\u00BF',
        Agrave: '\u00C0',
        Aacute: '\u00C1',
        Acirc: '\u00C2',
        Atilde: '\u00C3',
        Auml: '\u00C4',
        Aring: '\u00C5',
        AElig: '\u00C6',
        Ccedil: '\u00C7',
        Egrave: '\u00C8',
        Eacute: '\u00C9',
        Ecirc: '\u00CA',
        Euml: '\u00CB',
        Igrave: '\u00CC',
        Iacute: '\u00CD',
        Icirc: '\u00CE',
        Iuml: '\u00CF',
        ETH: '\u00D0',
        Ntilde: '\u00D1',
        Ograve: '\u00D2',
        Oacute: '\u00D3',
        Ocirc: '\u00D4',
        Otilde: '\u00D5',
        Ouml: '\u00D6',
        times: '\u00D7',
        Oslash: '\u00D8',
        Ugrave: '\u00D9',
        Uacute: '\u00DA',
        Ucirc: '\u00DB',
        Uuml: '\u00DC',
        Yacute: '\u00DD',
        THORN: '\u00DE',
        szlig: '\u00DF',
        agrave: '\u00E0',
        aacute: '\u00E1',
        acirc: '\u00E2',
        atilde: '\u00E3',
        auml: '\u00E4',
        aring: '\u00E5',
        aelig: '\u00E6',
        ccedil: '\u00E7',
        egrave: '\u00E8',
        eacute: '\u00E9',
        ecirc: '\u00EA',
        euml: '\u00EB',
        igrave: '\u00EC',
        iacute: '\u00ED',
        icirc: '\u00EE',
        iuml: '\u00EF',
        eth: '\u00F0',
        ntilde: '\u00F1',
        ograve: '\u00F2',
        oacute: '\u00F3',
        ocirc: '\u00F4',
        otilde: '\u00F5',
        ouml: '\u00F6',
        divide: '\u00F7',
        oslash: '\u00F8',
        ugrave: '\u00F9',
        uacute: '\u00FA',
        ucirc: '\u00FB',
        uuml: '\u00FC',
        yacute: '\u00FD',
        thorn: '\u00FE',
        yuml: '\u00FF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        int: '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666',
        lang: '\u27E8',
        rang: '\u27E9'
      };


      /***/
},
/* 13 */
/***/ function (module, exports) {

      "use strict";
      exports.JSXSyntax = {
        JSXAttribute: 'JSXAttribute',
        JSXClosingElement: 'JSXClosingElement',
        JSXElement: 'JSXElement',
        JSXEmptyExpression: 'JSXEmptyExpression',
        JSXExpressionContainer: 'JSXExpressionContainer',
        JSXIdentifier: 'JSXIdentifier',
        JSXMemberExpression: 'JSXMemberExpression',
        JSXNamespacedName: 'JSXNamespacedName',
        JSXOpeningElement: 'JSXOpeningElement',
        JSXSpreadAttribute: 'JSXSpreadAttribute',
        JSXText: 'JSXText'
      };


      /***/
},
/* 14 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var jsx_syntax_1 = __webpack_require__(13);
      var JSXClosingElement = (function () {
        function JSXClosingElement(name) {
          this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
          this.name = name;
        }
        return JSXClosingElement;
      }());
      exports.JSXClosingElement = JSXClosingElement;
      var JSXElement = (function () {
        function JSXElement(openingElement, children, closingElement) {
          this.type = jsx_syntax_1.JSXSyntax.JSXElement;
          this.openingElement = openingElement;
          this.children = children;
          this.closingElement = closingElement;
        }
        return JSXElement;
      }());
      exports.JSXElement = JSXElement;
      var JSXEmptyExpression = (function () {
        function JSXEmptyExpression() {
          this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
        }
        return JSXEmptyExpression;
      }());
      exports.JSXEmptyExpression = JSXEmptyExpression;
      var JSXExpressionContainer = (function () {
        function JSXExpressionContainer(expression) {
          this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
          this.expression = expression;
        }
        return JSXExpressionContainer;
      }());
      exports.JSXExpressionContainer = JSXExpressionContainer;
      var JSXIdentifier = (function () {
        function JSXIdentifier(name) {
          this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
          this.name = name;
        }
        return JSXIdentifier;
      }());
      exports.JSXIdentifier = JSXIdentifier;
      var JSXMemberExpression = (function () {
        function JSXMemberExpression(object, property) {
          this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
          this.object = object;
          this.property = property;
        }
        return JSXMemberExpression;
      }());
      exports.JSXMemberExpression = JSXMemberExpression;
      var JSXAttribute = (function () {
        function JSXAttribute(name, value) {
          this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
          this.name = name;
          this.value = value;
        }
        return JSXAttribute;
      }());
      exports.JSXAttribute = JSXAttribute;
      var JSXNamespacedName = (function () {
        function JSXNamespacedName(namespace, name) {
          this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
          this.namespace = namespace;
          this.name = name;
        }
        return JSXNamespacedName;
      }());
      exports.JSXNamespacedName = JSXNamespacedName;
      var JSXOpeningElement = (function () {
        function JSXOpeningElement(name, selfClosing, attributes) {
          this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
          this.name = name;
          this.selfClosing = selfClosing;
          this.attributes = attributes;
        }
        return JSXOpeningElement;
      }());
      exports.JSXOpeningElement = JSXOpeningElement;
      var JSXSpreadAttribute = (function () {
        function JSXSpreadAttribute(argument) {
          this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
          this.argument = argument;
        }
        return JSXSpreadAttribute;
      }());
      exports.JSXSpreadAttribute = JSXSpreadAttribute;
      var JSXText = (function () {
        function JSXText(value, raw) {
          this.type = jsx_syntax_1.JSXSyntax.JSXText;
          this.value = value;
          this.raw = raw;
        }
        return JSXText;
      }());
      exports.JSXText = JSXText;


      /***/
},
/* 15 */
/***/ function (module, exports, __webpack_require__) {

      "use strict";
      var scanner_1 = __webpack_require__(8);
      var error_handler_1 = __webpack_require__(6);
      var token_1 = __webpack_require__(7);
      var Reader = (function () {
        function Reader() {
          this.values = [];
          this.curly = this.paren = -1;
        }
        ;
        // A function following one of those tokens is an expression.
        Reader.prototype.beforeFunctionExpression = function (t) {
          return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
            'return', 'case', 'delete', 'throw', 'void',
            // assignment operators
            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
            '&=', '|=', '^=', ',',
            // binary/unary operators
            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
        };
        ;
        // Determine if forward slash (/) is an operator or part of a regular expression
        // https://github.com/mozilla/sweet.js/wiki/design
        Reader.prototype.isRegexStart = function () {
          var previous = this.values[this.values.length - 1];
          var regex = (previous !== null);
          switch (previous) {
            case 'this':
            case ']':
              regex = false;
              break;
            case ')':
              var check = this.values[this.paren - 1];
              regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
              break;
            case '}':
              // Dividing a function by anything makes little sense,
              // but we have to check for that.
              regex = false;
              if (this.values[this.curly - 3] === 'function') {
                // Anonymous function, e.g. function(){} /42
                var check_1 = this.values[this.curly - 4];
                regex = check_1 ? !this.beforeFunctionExpression(check_1) : false;
              }
              else if (this.values[this.curly - 4] === 'function') {
                // Named function, e.g. function f(){} /42/
                var check_2 = this.values[this.curly - 5];
                regex = check_2 ? !this.beforeFunctionExpression(check_2) : true;
              }
          }
          return regex;
        };
        ;
        Reader.prototype.push = function (token) {
          if (token.type === token_1.Token.Punctuator || token.type === token_1.Token.Keyword) {
            if (token.value === '{') {
              this.curly = this.values.length;
            }
            else if (token.value === '(') {
              this.paren = this.values.length;
            }
            this.values.push(token.value);
          }
          else {
            this.values.push(null);
          }
        };
        ;
        return Reader;
      }());
      var Tokenizer = (function () {
        function Tokenizer(code, config) {
          this.errorHandler = new error_handler_1.ErrorHandler();
          this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
          this.scanner = new scanner_1.Scanner(code, this.errorHandler);
          this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
          this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
          this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
          this.buffer = [];
          this.reader = new Reader();
        }
        ;
        Tokenizer.prototype.errors = function () {
          return this.errorHandler.errors;
        };
        ;
        Tokenizer.prototype.getNextToken = function () {
          if (this.buffer.length === 0) {
            var comments = this.scanner.scanComments();
            if (this.scanner.trackComment) {
              for (var i = 0; i < comments.length; ++i) {
                var e = comments[i];
                var comment = void 0;
                var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                comment = {
                  type: e.multiLine ? 'BlockComment' : 'LineComment',
                  value: value
                };
                if (this.trackRange) {
                  comment.range = e.range;
                }
                if (this.trackLoc) {
                  comment.loc = e.loc;
                }
                this.buffer.push(comment);
              }
            }
            if (!this.scanner.eof()) {
              var loc = void 0;
              if (this.trackLoc) {
                loc = {
                  start: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  },
                  end: {}
                };
              }
              var token = void 0;
              if (this.scanner.source[this.scanner.index] === '/') {
                token = this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.scanPunctuator();
              }
              else {
                token = this.scanner.lex();
              }
              this.reader.push(token);
              var entry = void 0;
              entry = {
                type: token_1.TokenName[token.type],
                value: this.scanner.source.slice(token.start, token.end)
              };
              if (this.trackRange) {
                entry.range = [token.start, token.end];
              }
              if (this.trackLoc) {
                loc.end = {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
                entry.loc = loc;
              }
              if (token.regex) {
                entry.regex = token.regex;
              }
              this.buffer.push(entry);
            }
          }
          return this.buffer.shift();
        };
        ;
        return Tokenizer;
      }());
      exports.Tokenizer = Tokenizer;


      /***/
}
/******/])
});


// Full source:
//
//		https://github.com/zaach/jsonlint
//
// Copyright (C) 2012 Zachary Carter
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEAL-
// INGS IN THE SOFTWARE.

/* Jison generated parser */
var jsonlint = (function () {
  var parser = {
    trace: function trace() { },
    yy: {},
    symbols_: { "error": 2, "JSONString": 3, "STRING": 4, "JSONNumber": 5, "NUMBER": 6, "JSONNullLiteral": 7, "NULL": 8, "JSONBooleanLiteral": 9, "TRUE": 10, "FALSE": 11, "JSONText": 12, "JSONValue": 13, "EOF": 14, "JSONObject": 15, "JSONArray": 16, "{": 17, "}": 18, "JSONMemberList": 19, "JSONMember": 20, ":": 21, ",": 22, "[": 23, "]": 24, "JSONElementList": 25, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "STRING", 6: "NUMBER", 8: "NULL", 10: "TRUE", 11: "FALSE", 14: "EOF", 17: "{", 18: "}", 21: ":", 22: ",", 23: "[", 24: "]" },
    productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1: // replace escaped characters with actual character
          this.$ = yytext.replace(/\\(\\|")/g, "$" + "1")
            .replace(/\\n/g, '\n')
            .replace(/\\r/g, '\r')
            .replace(/\\t/g, '\t')
            .replace(/\\v/g, '\v')
            .replace(/\\f/g, '\f')
            .replace(/\\b/g, '\b');

          break;
        case 2: this.$ = Number(yytext);
          break;
        case 3: this.$ = null;
          break;
        case 4: this.$ = true;
          break;
        case 5: this.$ = false;
          break;
        case 6: return this.$ = $$[$0 - 1];
          break;
        case 13: this.$ = {};
          break;
        case 14: this.$ = $$[$0 - 1];
          break;
        case 15: this.$ = [$$[$0 - 2], $$[$0]];
          break;
        case 16: this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
          break;
        case 17: this.$ = $$[$0 - 2]; $$[$0 - 2][$$[$0][0]] = $$[$0][1];
          break;
        case 18: this.$ = [];
          break;
        case 19: this.$ = $$[$0 - 1];
          break;
        case 20: this.$ = [$$[$0]];
          break;
        case 21: this.$ = $$[$0 - 2]; $$[$0 - 2].push($$[$0]);
          break;
      }
    },
    table: [{ 3: 5, 4: [1, 12], 5: 6, 6: [1, 13], 7: 3, 8: [1, 9], 9: 4, 10: [1, 10], 11: [1, 11], 12: 1, 13: 2, 15: 7, 16: 8, 17: [1, 14], 23: [1, 15] }, { 1: [3] }, { 14: [1, 16] }, { 14: [2, 7], 18: [2, 7], 22: [2, 7], 24: [2, 7] }, { 14: [2, 8], 18: [2, 8], 22: [2, 8], 24: [2, 8] }, { 14: [2, 9], 18: [2, 9], 22: [2, 9], 24: [2, 9] }, { 14: [2, 10], 18: [2, 10], 22: [2, 10], 24: [2, 10] }, { 14: [2, 11], 18: [2, 11], 22: [2, 11], 24: [2, 11] }, { 14: [2, 12], 18: [2, 12], 22: [2, 12], 24: [2, 12] }, { 14: [2, 3], 18: [2, 3], 22: [2, 3], 24: [2, 3] }, { 14: [2, 4], 18: [2, 4], 22: [2, 4], 24: [2, 4] }, { 14: [2, 5], 18: [2, 5], 22: [2, 5], 24: [2, 5] }, { 14: [2, 1], 18: [2, 1], 21: [2, 1], 22: [2, 1], 24: [2, 1] }, { 14: [2, 2], 18: [2, 2], 22: [2, 2], 24: [2, 2] }, { 3: 20, 4: [1, 12], 18: [1, 17], 19: 18, 20: 19 }, { 3: 5, 4: [1, 12], 5: 6, 6: [1, 13], 7: 3, 8: [1, 9], 9: 4, 10: [1, 10], 11: [1, 11], 13: 23, 15: 7, 16: 8, 17: [1, 14], 23: [1, 15], 24: [1, 21], 25: 22 }, { 1: [2, 6] }, { 14: [2, 13], 18: [2, 13], 22: [2, 13], 24: [2, 13] }, { 18: [1, 24], 22: [1, 25] }, { 18: [2, 16], 22: [2, 16] }, { 21: [1, 26] }, { 14: [2, 18], 18: [2, 18], 22: [2, 18], 24: [2, 18] }, { 22: [1, 28], 24: [1, 27] }, { 22: [2, 20], 24: [2, 20] }, { 14: [2, 14], 18: [2, 14], 22: [2, 14], 24: [2, 14] }, { 3: 20, 4: [1, 12], 20: 29 }, { 3: 5, 4: [1, 12], 5: 6, 6: [1, 13], 7: 3, 8: [1, 9], 9: 4, 10: [1, 10], 11: [1, 11], 13: 30, 15: 7, 16: 8, 17: [1, 14], 23: [1, 15] }, { 14: [2, 19], 18: [2, 19], 22: [2, 19], 24: [2, 19] }, { 3: 5, 4: [1, 12], 5: 6, 6: [1, 13], 7: 3, 8: [1, 9], 9: 4, 10: [1, 10], 11: [1, 11], 13: 31, 15: 7, 16: 8, 17: [1, 14], 23: [1, 15] }, { 18: [2, 17], 22: [2, 17] }, { 18: [2, 15], 22: [2, 15] }, { 22: [2, 21], 24: [2, 21] }],
    defaultActions: { 16: [2, 6] },
    parseError: function parseError(str, hash) {
      throw new Error(str);
    },
    parse: function parse(input) {
      var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

      //this.reductionCount = this.shiftCount = 0;

      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      if (typeof this.lexer.yylloc == 'undefined')
        this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);

      if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }

      function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
          token = self.symbols_[token] || token;
        }
        return token;
      }

      var symbol, preErrorSymbol, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol == null)
            symbol = lex();
          // read action for current state and first input
          action = table[state] && table[state][symbol];
        }

        // handle parse error
        _handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {

          if (!recovering) {
            // Report error
            expected = [];
            for (p in table[state]) if (this.terminals_[p] && p > 2) {
              expected.push("'" + this.terminals_[p] + "'");
            }
            var errStr = '';
            if (this.lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + this.terminals_[symbol] + "'";
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " +
                (symbol == 1 /*EOF*/ ? "end of input" :
                  ("'" + (this.terminals_[symbol] || symbol) + "'"));
            }
            this.parseError(errStr,
              { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
          }

          // just recovered from another error
          if (recovering == 3) {
            if (symbol == EOF) {
              throw new Error(errStr || 'Parsing halted.');
            }

            // discard current lookahead and grab another
            yyleng = this.lexer.yyleng;
            yytext = this.lexer.yytext;
            yylineno = this.lexer.yylineno;
            yyloc = this.lexer.yylloc;
            symbol = lex();
          }

          // try to recover from error
          while (1) {
            // check for error recovery rule in this state
            if ((TERROR.toString()) in table[state]) {
              break;
            }
            if (state == 0) {
              throw new Error(errStr || 'Parsing halted.');
            }
            popStack(1);
            state = stack[stack.length - 1];
          }

          preErrorSymbol = symbol; // save the lookahead token
          symbol = TERROR;         // insert generic error symbol as new lookahead
          state = stack[stack.length - 1];
          action = table[state] && table[state][TERROR];
          recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }

        switch (action[0]) {

          case 1: // shift
            //this.shiftCount++;

            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]); // push state
            symbol = null;
            if (!preErrorSymbol) { // normal execution/no error
              yyleng = this.lexer.yyleng;
              yytext = this.lexer.yytext;
              yylineno = this.lexer.yylineno;
              yyloc = this.lexer.yylloc;
              if (recovering > 0)
                recovering--;
            } else { // error just occurred, resume old lookahead f/ before error
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;

          case 2: // reduce
            //this.reductionCount++;

            len = this.productions_[action[1]][1];

            // perform semantic action
            yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
            // default location, uses first token for firsts, last for lasts
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

            if (typeof r !== 'undefined') {
              return r;
            }

            // pop off stack
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }

            stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            // goto new state = table[STATE][NONTERMINAL]
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;

          case 3: // accept
            return true;
        }

      }

    }
  };
  /* Jison generated lexer */
  var lexer = (function () {
    var lexer = ({
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parseError) {
          this.yy.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
        return this;
      },
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/\n/);
        if (lines) this.yylineno++;
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function (ch) {
        this._input = ch + this._input;
        return this;
      },
      more: function () {
        this._more = true;
        return this;
      },
      less: function (n) {
        this._input = this.match.slice(n) + this._input;
      },
      pastInput: function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
          match,
          tempMatch,
          index,
          lines;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (!this.options.flex) break;
          }
        }
        if (match) {
          lines = match[0].match(/\n.*/g);
          if (lines) this.yylineno += lines.length;
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.yyleng = this.yytext.length;
          this._more = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) this.done = false;
          if (token) return token;
          else return;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(),
            { text: "", token: null, line: this.yylineno });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        return this.conditionStack.pop();
      },
      _currentRules: function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
      },
      topState: function () {
        return this.conditionStack[this.conditionStack.length - 2];
      },
      pushState: function begin(condition) {
        this.begin(condition);
      }
    });
    lexer.options = {};
    lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions) {

      switch ($avoiding_name_collisions) {
        case 0:/* skip whitespace */
          break;
        case 1: return 6
          break;
        case 2: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2); return 4
          break;
        case 3: return 17
          break;
        case 4: return 18
          break;
        case 5: return 23
          break;
        case 6: return 24
          break;
        case 7: return 22
          break;
        case 8: return 21
          break;
        case 9: return 10
          break;
        case 10: return 11
          break;
        case 11: return 8
          break;
        case 12: return 14
          break;
        case 13: return 'INVALID'
          break;
      }
    };
    lexer.rules = [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/];
    lexer.conditions = { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "inclusive": true } };


    ;
    return lexer;
  })()
  parser.lexer = lexer;
  return parser;
})();
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = jsonlint;
  exports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }
  exports.main = function commonjsMain(args) {
    if (!args[1])
      throw new Error('Usage: ' + args[0] + ' FILE');
    if (typeof process !== 'undefined') {
      var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), "utf8");
    } else {
      var cwd = require("file").path(require("file").cwd());
      var source = cwd.join(args[1]).read({ charset: "utf-8" });
    }
    return exports.parser.parse(source);
  }
  if (typeof module !== 'undefined' && require.main === module) {
    exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
  }
}



!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.FFmpeg = t() : e.FFmpeg = t() }(self, (function () { return e = { 497: (e, t, r) => { r(72); var n = r(306).devDependencies; e.exports = { corePath: "https://unpkg.com/@ffmpeg/core@".concat(n["@ffmpeg/core"].substring(1), "/dist/ffmpeg-core.js") } }, 663: (e, t, r) => { function n(e, t, r, n, o, i, a) { try { var c = e[i](a), s = c.value } catch (e) { return void r(e) } c.done ? t(s) : Promise.resolve(s).then(n, o) } var o = r(72), i = function (e) { return new Promise((function (t, r) { var n = new FileReader; n.onload = function () { t(n.result) }, n.onerror = function (e) { var t = e.target.error.code; r(Error("File could not be read! Code=".concat(t))) }, n.readAsArrayBuffer(e) })) }; e.exports = function () { var e, t = (e = regeneratorRuntime.mark((function e(t) { var r, n; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (r = t, void 0 !== t) { e.next = 3; break } return e.abrupt("return", new Uint8Array); case 3: if ("string" != typeof t) { e.next = 16; break } if (!/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(t)) { e.next = 8; break } r = atob(t.split(",")[1]).split("").map((function (e) { return e.charCodeAt(0) })), e.next = 14; break; case 8: return e.next = 10, fetch(o(t)); case 10: return n = e.sent, e.next = 13, n.arrayBuffer(); case 13: r = e.sent; case 14: e.next = 20; break; case 16: if (!(t instanceof File || t instanceof Blob)) { e.next = 20; break } return e.next = 19, i(t); case 19: r = e.sent; case 20: return e.abrupt("return", new Uint8Array(r)); case 21: case "end": return e.stop() } }), e) })), function () { var t = this, r = arguments; return new Promise((function (o, i) { var a = e.apply(t, r); function c(e) { n(a, o, i, c, s, "next", e) } function s(e) { n(a, o, i, c, s, "throw", e) } c(void 0) })) }); return function (e) { return t.apply(this, arguments) } }() }, 452: (e, t, r) => { function n(e, t, r, n, o, i, a) { try { var c = e[i](a), s = c.value } catch (e) { return void r(e) } c.done ? t(s) : Promise.resolve(s).then(n, o) } function o(e) { return function () { var t = this, r = arguments; return new Promise((function (o, i) { var a = e.apply(t, r); function c(e) { n(a, o, i, c, s, "next", e) } function s(e) { n(a, o, i, c, s, "throw", e) } c(void 0) })) } } var i = r(72), a = r(185).log, c = function () { var e = o(regeneratorRuntime.mark((function e(t, r) { var n, o, i; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: return a("info", "fetch ".concat(t)), e.next = 3, fetch(t); case 3: return e.next = 5, e.sent.arrayBuffer(); case 5: return n = e.sent, a("info", "".concat(t, " file size = ").concat(n.byteLength, " bytes")), o = new Blob([n], { type: r }), i = URL.createObjectURL(o), a("info", "".concat(t, " blob URL = ").concat(i)), e.abrupt("return", i); case 11: case "end": return e.stop() } }), e) }))); return function (t, r) { return e.apply(this, arguments) } }(); e.exports = function () { var e = o(regeneratorRuntime.mark((function e(t) { var r, n, o, s, u; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: if ("string" == typeof (r = t.corePath)) { e.next = 3; break } throw Error("corePath should be a string!"); case 3: return n = i(r), e.next = 6, c(n, "application/javascript"); case 6: return o = e.sent, e.next = 9, c(n.replace("ffmpeg-core.js", "ffmpeg-core.wasm"), "application/wasm"); case 9: return s = e.sent, e.next = 12, c(n.replace("ffmpeg-core.js", "ffmpeg-core.worker.js"), "application/javascript"); case 12: if (u = e.sent, "undefined" != typeof createFFmpegCore) { e.next = 15; break } return e.abrupt("return", new Promise((function (e) { var t = document.createElement("script"); t.src = o, t.type = "text/javascript", t.addEventListener("load", (function r() { t.removeEventListener("load", r), a("info", "ffmpeg-core.js script loaded"), e({ createFFmpegCore, corePath: o, wasmPath: s, workerPath: u }) })), document.getElementsByTagName("head")[0].appendChild(t) }))); case 15: return a("info", "ffmpeg-core.js script is loaded already"), e.abrupt("return", Promise.resolve({ createFFmpegCore, corePath: o, wasmPath: s, workerPath: u })); case 17: case "end": return e.stop() } }), e) }))); return function (t) { return e.apply(this, arguments) } }() }, 698: (e, t, r) => { var n = r(497), o = r(452), i = r(663); e.exports = { defaultOptions: n, getCreateFFmpegCore: o, fetchFile: i } }, 500: e => { e.exports = { defaultArgs: ["./ffmpeg", "-nostdin", "-y"], baseOptions: { log: !1, logger: function () { }, progress: function () { }, corePath: "" } } }, 906: (e, t, r) => { function n(e) { return function (e) { if (Array.isArray(e)) return o(e) }(e) || function (e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) }(e) || function (e, t) { if (e) { if ("string" == typeof e) return o(e, t); var r = Object.prototype.toString.call(e).slice(8, -1); return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? o(e, t) : void 0 } }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function o(e, t) { (null == t || t > e.length) && (t = e.length); for (var r = 0, n = new Array(t); r < t; r++)n[r] = e[r]; return n } function i(e, t, r, n, o, i, a) { try { var c = e[i](a), s = c.value } catch (e) { return void r(e) } c.done ? t(s) : Promise.resolve(s).then(n, o) } function a(e) { return function () { var t = this, r = arguments; return new Promise((function (n, o) { var a = e.apply(t, r); function c(e) { i(a, n, o, c, s, "next", e) } function s(e) { i(a, n, o, c, s, "throw", e) } c(void 0) })) } } function c(e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r } function s(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}; t % 2 ? c(Object(r), !0).forEach((function (t) { u(e, t, r[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : c(Object(r)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) })) } return e } function u(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e } function f(e, t) { if (null == e) return {}; var r, n, o = function (e, t) { if (null == e) return {}; var r, n, o = {}, i = Object.keys(e); for (n = 0; n < i.length; n++)r = i[n], t.indexOf(r) >= 0 || (o[r] = e[r]); return o }(e, t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); for (n = 0; n < i.length; n++)r = i[n], t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (o[r] = e[r]) } return o } var l = r(500), p = l.defaultArgs, h = l.baseOptions, m = r(185), g = m.setLogging, d = m.setCustomLogger, y = m.log, v = r(583), b = r(319), w = r(698), x = w.defaultOptions, j = w.getCreateFFmpegCore, E = r(306).version, O = Error("ffmpeg.wasm is not ready, make sure you have completed load()."); e.exports = function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = s(s(s({}, h), x), e), r = t.log, o = t.logger, i = t.progress, c = f(t, ["log", "logger", "progress"]), u = null, l = null, m = null, w = !1, F = i, L = function (e) { "FFMPEG_END" === e && null !== m && (m(), m = null, w = !1) }, P = function (e) { var t = e.type, r = e.message; y(t, r), v(r, F), L(r) }, k = function () { var e = a(regeneratorRuntime.mark((function e() { var t, r, n, o, i; return regeneratorRuntime.wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (y("info", "load ffmpeg-core"), null !== u) { e.next = 17; break } return y("info", "loading ffmpeg-core"), e.next = 5, j(c); case 5: return t = e.sent, r = t.createFFmpegCore, n = t.corePath, o = t.workerPath, i = t.wasmPath, e.next = 12, r({ mainScriptUrlOrBlob: n, printErr: function (e) { return P({ type: "fferr", message: e }) }, print: function (e) { return P({ type: "ffout", message: e }) }, locateFile: function (e, t) { if ("undefined" != typeof window) { if (void 0 !== i && e.endsWith("ffmpeg-core.wasm")) return i; if (void 0 !== o && e.endsWith("ffmpeg-core.worker.js")) return o } return t + e } }); case 12: u = e.sent, l = u.cwrap("proxy_main", "number", ["number", "number"]), y("info", "ffmpeg-core loaded"), e.next = 18; break; case 17: throw Error("ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time."); case 18: case "end": return e.stop() } }), e) }))); return function () { return e.apply(this, arguments) } }(), S = function () { return null !== u }, A = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; if (y("info", "run ffmpeg command: ".concat(t.join(" "))), null === u) throw O; if (w) throw Error("ffmpeg.wasm can only run one command at a time"); return w = !0, new Promise((function (e) { var r = [].concat(n(p), t).filter((function (e) { return 0 !== e.length })); m = e, l.apply(void 0, n(b(u, r))) })) }, _ = function (e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)r[n - 1] = arguments[n]; if (y("info", "run FS.".concat(e, " ").concat(r.map((function (e) { return "string" == typeof e ? e : "<".concat(e.length, " bytes binary file>") })).join(" "))), null === u) throw O; var o = null; try { var i; o = (i = u.FS)[e].apply(i, r) } catch (t) { throw "readdir" === e ? Error("ffmpeg.FS('readdir', '".concat(r[0], "') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')")) : "readFile" === e ? Error("ffmpeg.FS('readFile', '".concat(r[0], "') error. Check if the path exists")) : Error("Oops, something went wrong in FS operation.") } return o }, C = function () { if (null === u) throw O; w = !1, u.exit(1), u = null, l = null, m = null }, R = function (e) { F = e }, T = function (e) { d(e) }; return g(r), d(o), y("info", "use ffmpeg.wasm v".concat(E)), { setProgress: R, setLogger: T, setLogging: g, load: k, isLoaded: S, run: A, exit: C, FS: _ } } }, 352: (e, t, r) => { r(666); var n = r(906), o = r(698).fetchFile; e.exports = { createFFmpeg: n, fetchFile: o } }, 185: e => { var t = !1, r = function () { }; e.exports = { logging: t, setLogging: function (e) { t = e }, setCustomLogger: function (e) { r = e }, log: function (e, n) { r({ type: e, message: n }), t && console.log("[".concat(e, "] ").concat(n)) } } }, 319: e => { e.exports = function (e, t) { var r = e._malloc(t.length * Uint32Array.BYTES_PER_ELEMENT); return t.forEach((function (t, n) { var o = e._malloc(t.length + 1); e.writeAsciiToMemory(t, o), e.setValue(r + Uint32Array.BYTES_PER_ELEMENT * n, o, "i32") })), [t.length, r] } }, 583: e => { function t(e, t) { (null == t || t > e.length) && (t = e.length); for (var r = 0, n = new Array(t); r < t; r++)n[r] = e[r]; return n } var r = 0, n = 0, o = function (e) { var r, n, o = (r = e.split(":"), n = 3, function (e) { if (Array.isArray(e)) return e }(r) || function (e, t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) { var r = [], n = !0, o = !1, i = void 0; try { for (var a, c = e[Symbol.iterator](); !(n = (a = c.next()).done) && (r.push(a.value), !t || r.length !== t); n = !0); } catch (e) { o = !0, i = e } finally { try { n || null == c.return || c.return() } finally { if (o) throw i } } return r } }(r, n) || function (e, r) { if (e) { if ("string" == typeof e) return t(e, r); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? t(e, r) : void 0 } }(r, n) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }()), i = o[0], a = o[1], c = o[2]; return 60 * parseFloat(i) * 60 + 60 * parseFloat(a) + parseFloat(c) }; e.exports = function (e, t) { if ("string" == typeof e) if (e.startsWith("  Duration")) { var i = e.split(", ")[0].split(": ")[1], a = o(i); t({ duration: a, ratio: n }), (0 === r || r > a) && (r = a) } else if (e.startsWith("frame") || e.startsWith("size")) { var c = e.split("time=")[1].split(" ")[0], s = o(c); t({ ratio: n = s / r, time: s }) } else e.startsWith("video:") && (t({ ratio: 1 }), r = 0) } }, 666: e => { var t = function (e) { "use strict"; var t, r = Object.prototype, n = r.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", c = o.toStringTag || "@@toStringTag"; function s(e, t, r) { return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }), e[t] } try { s({}, "") } catch (e) { s = function (e, t, r) { return e[t] = r } } function u(e, t, r, n) { var o = t && t.prototype instanceof d ? t : d, i = Object.create(o.prototype), a = new k(n || []); return i._invoke = function (e, t, r) { var n = l; return function (o, i) { if (n === h) throw new Error("Generator is already running"); if (n === m) { if ("throw" === o) throw i; return A() } for (r.method = o, r.arg = i; ;) { var a = r.delegate; if (a) { var c = F(a, r); if (c) { if (c === g) continue; return c } } if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) { if (n === l) throw n = m, r.arg; r.dispatchException(r.arg) } else "return" === r.method && r.abrupt("return", r.arg); n = h; var s = f(e, t, r); if ("normal" === s.type) { if (n = r.done ? m : p, s.arg === g) continue; return { value: s.arg, done: r.done } } "throw" === s.type && (n = m, r.method = "throw", r.arg = s.arg) } } }(e, r, a), i } function f(e, t, r) { try { return { type: "normal", arg: e.call(t, r) } } catch (e) { return { type: "throw", arg: e } } } e.wrap = u; var l = "suspendedStart", p = "suspendedYield", h = "executing", m = "completed", g = {}; function d() { } function y() { } function v() { } var b = {}; b[i] = function () { return this }; var w = Object.getPrototypeOf, x = w && w(w(S([]))); x && x !== r && n.call(x, i) && (b = x); var j = v.prototype = d.prototype = Object.create(b); function E(e) { ["next", "throw", "return"].forEach((function (t) { s(e, t, (function (e) { return this._invoke(t, e) })) })) } function O(e, t) { function r(o, i, a, c) { var s = f(e[o], e, i); if ("throw" !== s.type) { var u = s.arg, l = u.value; return l && "object" == typeof l && n.call(l, "__await") ? t.resolve(l.__await).then((function (e) { r("next", e, a, c) }), (function (e) { r("throw", e, a, c) })) : t.resolve(l).then((function (e) { u.value = e, a(u) }), (function (e) { return r("throw", e, a, c) })) } c(s.arg) } var o; this._invoke = function (e, n) { function i() { return new t((function (t, o) { r(e, n, t, o) })) } return o = o ? o.then(i, i) : i() } } function F(e, r) { var n = e.iterator[r.method]; if (n === t) { if (r.delegate = null, "throw" === r.method) { if (e.iterator.return && (r.method = "return", r.arg = t, F(e, r), "throw" === r.method)) return g; r.method = "throw", r.arg = new TypeError("The iterator does not provide a 'throw' method") } return g } var o = f(n, e.iterator, r.arg); if ("throw" === o.type) return r.method = "throw", r.arg = o.arg, r.delegate = null, g; var i = o.arg; return i ? i.done ? (r[e.resultName] = i.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, g) : i : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, g) } function L(e) { var t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t) } function P(e) { var t = e.completion || {}; t.type = "normal", delete t.arg, e.completion = t } function k(e) { this.tryEntries = [{ tryLoc: "root" }], e.forEach(L, this), this.reset(!0) } function S(e) { if (e) { var r = e[i]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, a = function r() { for (; ++o < e.length;)if (n.call(e, o)) return r.value = e[o], r.done = !1, r; return r.value = t, r.done = !0, r }; return a.next = a } } return { next: A } } function A() { return { value: t, done: !0 } } return y.prototype = j.constructor = v, v.constructor = y, y.displayName = s(v, c, "GeneratorFunction"), e.isGeneratorFunction = function (e) { var t = "function" == typeof e && e.constructor; return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name)) }, e.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, v) : (e.__proto__ = v, s(e, c, "GeneratorFunction")), e.prototype = Object.create(j), e }, e.awrap = function (e) { return { __await: e } }, E(O.prototype), O.prototype[a] = function () { return this }, e.AsyncIterator = O, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new O(u(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then((function (e) { return e.done ? e.value : a.next() })) }, E(j), s(j, c, "Generator"), j[i] = function () { return this }, j.toString = function () { return "[object Generator]" }, e.keys = function (e) { var t = []; for (var r in e) t.push(r); return t.reverse(), function r() { for (; t.length;) { var n = t.pop(); if (n in e) return r.value = n, r.done = !1, r } return r.done = !0, r } }, e.values = S, k.prototype = { constructor: k, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(P), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t) }, stop: function () { this.done = !0; var e = this.tryEntries[0].completion; if ("throw" === e.type) throw e.arg; return this.rval }, dispatchException: function (e) { if (this.done) throw e; var r = this; function o(n, o) { return c.type = "throw", c.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var a = this.tryEntries[i], c = a.completion; if ("root" === a.tryLoc) return o("end"); if (a.tryLoc <= this.prev) { var s = n.call(a, "catchLoc"), u = n.call(a, "finallyLoc"); if (s && u) { if (this.prev < a.catchLoc) return o(a.catchLoc, !0); if (this.prev < a.finallyLoc) return o(a.finallyLoc) } else if (s) { if (this.prev < a.catchLoc) return o(a.catchLoc, !0) } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < a.finallyLoc) return o(a.finallyLoc) } } } }, abrupt: function (e, t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break } } i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = e, a.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, g) : this.complete(a) }, complete: function (e, t) { if ("throw" === e.type) throw e.arg; return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g }, finish: function (e) { for (var t = this.tryEntries.length - 1; t >= 0; --t) { var r = this.tryEntries[t]; if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), P(r), g } }, catch: function (e) { for (var t = this.tryEntries.length - 1; t >= 0; --t) { var r = this.tryEntries[t]; if (r.tryLoc === e) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; P(r) } return o } } throw new Error("illegal catch attempt") }, delegateYield: function (e, r, n) { return this.delegate = { iterator: S(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), g } }, e }(e.exports); try { regeneratorRuntime = t } catch (e) { Function("r", "regeneratorRuntime = r")(t) } }, 72: function (e, t, r) { var n, o; void 0 === (o = "function" == typeof (n = function () { return function () { var e = arguments.length; if (0 === e) throw new Error("resolveUrl requires at least one argument; got none."); var t = document.createElement("base"); if (t.href = arguments[0], 1 === e) return t.href; var r = document.getElementsByTagName("head")[0]; r.insertBefore(t, r.firstChild); for (var n, o = document.createElement("a"), i = 1; i < e; i++)o.href = arguments[i], n = o.href, t.href = n; return r.removeChild(t), n } }) ? n.call(t, r, t, e) : n) || (e.exports = o) }, 306: e => { "use strict"; e.exports = JSON.parse('{"name":"@ffmpeg/ffmpeg","version":"0.10.1","description":"FFmpeg WebAssembly version","main":"src/index.js","types":"src/index.d.ts","directories":{"example":"examples"},"scripts":{"start":"node scripts/server.js","build":"rimraf dist && webpack --config scripts/webpack.config.prod.js","prepublishOnly":"npm run build","lint":"eslint src","wait":"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js","test":"npm-run-all -p -r start test:all","test:all":"npm-run-all wait test:browser:ffmpeg test:node:all","test:node":"node --experimental-wasm-threads --experimental-wasm-bulk-memory node_modules/.bin/_mocha --exit --bail --require ./scripts/test-helper.js","test:node:all":"npm run test:node -- ./tests/*.test.js","test:browser":"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000","test:browser:ffmpeg":"npm run test:browser -- -f ./tests/ffmpeg.test.html"},"browser":{"./src/node/index.js":"./src/browser/index.js"},"repository":{"type":"git","url":"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git"},"keywords":["ffmpeg","WebAssembly","video"],"author":"Jerome Wu <jeromewus@gmail.com>","license":"MIT","bugs":{"url":"https://github.com/ffmpegwasm/ffmpeg.wasm/issues"},"engines":{"node":">=12.16.1"},"homepage":"https://github.com/ffmpegwasm/ffmpeg.wasm#readme","dependencies":{"is-url":"^1.2.4","node-fetch":"^2.6.1","regenerator-runtime":"^0.13.7","resolve-url":"^0.2.1"},"devDependencies":{"@babel/core":"^7.12.3","@babel/preset-env":"^7.12.1","@ffmpeg/core":"^0.10.0","@types/emscripten":"^1.39.4","babel-loader":"^8.1.0","chai":"^4.2.0","cors":"^2.8.5","eslint":"^7.12.1","eslint-config-airbnb-base":"^14.1.0","eslint-plugin-import":"^2.22.1","express":"^4.17.1","mocha":"^8.2.1","mocha-headless-chrome":"^2.0.3","npm-run-all":"^4.1.5","wait-on":"^5.3.0","webpack":"^5.3.2","webpack-cli":"^4.1.0","webpack-dev-middleware":"^4.0.0"}}') } }, t = {}, function r(n) { if (t[n]) return t[n].exports; var o = t[n] = { exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.exports }(352); var e, t }));
//# sourceMappingURL=ffmpeg.min.js.map


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom)
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    else
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    CodeMirror.addClass(wrap, 'dialog-opened');
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function (template, callback, options) {
    if (!options) options = {};

    closeNotification(this, null);

    var dialog = dialogDiv(this, template, options.bottom);
    var closed = false, me = this;
    function close(newVal) {
      if (typeof newVal == 'string') {
        inp.value = newVal;
      } else {
        if (closed) return;
        closed = true;
        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
        dialog.parentNode.removeChild(dialog);
        me.focus();

        if (options.onClose) options.onClose(dialog);
      }
    }

    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      inp.focus();

      if (options.value) {
        inp.value = options.value;
        if (options.selectValueOnOpen !== false) {
          inp.select();
        }
      }

      if (options.onInput)
        CodeMirror.on(inp, "input", function (e) { options.onInput(e, inp.value, close); });
      if (options.onKeyUp)
        CodeMirror.on(inp, "keyup", function (e) { options.onKeyUp(e, inp.value, close); });

      CodeMirror.on(inp, "keydown", function (e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
        }
        if (e.keyCode == 13) callback(inp.value, e);
      });

      if (options.closeOnBlur !== false) CodeMirror.on(dialog, "focusout", function (evt) {
        if (evt.relatedTarget !== null) close();
      });
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function () {
        close();
        me.focus();
      });

      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

      button.focus();
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function (template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function (callback) {
        CodeMirror.on(b, "click", function (e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function () {
        --blurring;
        setTimeout(function () { if (blurring <= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function () { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function (template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, doneTimer;
    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function (e) {
      CodeMirror.e_preventDefault(e);
      close();
    });

    if (duration)
      doneTimer = setTimeout(close, duration);

    return close;
  });
});


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// declare global: DOMRect

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = { hint: getHints };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function (options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  CodeMirror.defineExtension("closeHint", function () {
    if (this.state.completionActive) this.state.completionActive.close()
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    if (this.options.updateOnCursorActivity) {
      var self = this;
      cm.on("cursorActivity", this.activityFunc = function () { self.cursorActivity(); });
    }
  }

  var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
    return setTimeout(fn, 1000 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function () {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      if (this.options.updateOnCursorActivity) {
        this.cm.off("cursorActivity", this.activityFunc);
      }

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function () {
      return this.cm.state.completionActive == this;
    },

    pick: function (data, i) {
      var completion = data.list[i], self = this;
      this.cm.operation(function () {
        if (completion.hint)
          completion.hint(self.cm, data, completion);
        else
          self.cm.replaceRange(getText(completion), completion.from || data.from,
            completion.to || data.to, "complete");
        CodeMirror.signal(data, "pick", completion);
        self.cm.scrollIntoView();
      });
      if (this.options.closeOnPick) {
        this.close();
      }
    },

    cursorActivity: function () {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var identStart = this.startPos;
      if (this.data) {
        identStart = this.data.from;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
        pos.ch < identStart.ch || this.cm.somethingSelected() ||
        (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function () { self.update(); });
        if (this.widget) this.widget.disable();
      }
    },

    update: function (first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function (data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function (data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function () { handle.moveFocus(-1); },
      Down: function () { handle.moveFocus(1); },
      PageUp: function () { handle.moveFocus(-handle.menuSize() + 1, true); },
      PageDown: function () { handle.moveFocus(handle.menuSize() - 1, true); },
      Home: function () { handle.setFocus(0); },
      End: function () { handle.setFocus(handle.length - 1); },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    var mac = /Mac/.test(navigator.platform);

    if (mac) {
      baseMap["Ctrl-P"] = function () { handle.moveFocus(-1); };
      baseMap["Ctrl-N"] = function () { handle.moveFocus(1); };
    }

    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function (cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.id = "cm-complete-" + Math.floor(Math.random(1e6))
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

    var hints = this.hints = ownerDocument.createElement("ul");
    hints.setAttribute("role", "listbox")
    hints.setAttribute("aria-expanded", "true")
    hints.id = this.id
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (i == this.selectedHint) elt.setAttribute("aria-selected", "true")
      elt.id = this.id + "-" + i
      elt.setAttribute("role", "option")
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.
      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);
      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);
    }
    hints.style.left = (left - offsetLeft) + "px";
    hints.style.top = (top - offsetTop) + "px";

    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    cm.getInputField().setAttribute("aria-autocomplete", "list")
    cm.getInputField().setAttribute("aria-owns", this.id)
    cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint)

    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;

    // Compute in the timeout to avoid reflow on init
    var startScroll;
    setTimeout(function () { startScroll = cm.getScrollInfo(); });

    var overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height - offsetTop) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left - offsetLeft) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (scrolls) overlapX += cm.display.nativeBarWidth;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function (n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function (n) { widget.changeActive(n); },
      menuSize: function () { return widget.screenAmount(); },
      length: completions.length,
      close: function () { completion.close(); },
      pick: function () { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function () { closingOnBlur = setTimeout(function () { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function () { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function () {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      if (!startScroll) startScroll = cm.getScrollInfo();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) { widget.changeActive(t.hintId); widget.pick(); }
    });

    CodeMirror.on(hints, "click", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function () {
      setTimeout(function () { cm.focus(); }, 20);
    });

    // The first hint doesn't need to be scrolled to on init
    var selectedHintRange = this.getSelectedHintRange();
    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
      this.scrollToActive();
    }

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var input = this.completion.cm.getInputField()
      input.removeAttribute("aria-activedescendant")
      input.removeAttribute("aria-owns")

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function () {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function () { widget.picked = true; } };
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function (i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) {
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node.removeAttribute("aria-selected")
      }
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      node.setAttribute("aria-selected", "true")
      this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id)
      this.scrollToActive()
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    scrollToActive: function () {
      var selectedHintRange = this.getSelectedHintRange();
      var node1 = this.hints.childNodes[selectedHintRange.from];
      var node2 = this.hints.childNodes[selectedHintRange.to];
      var firstNode = this.hints.firstChild;
      if (node1.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
    },

    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },

    getSelectedHintRange: function () {
      var margin = this.completion.options.scrollMargin || 0;
      return {
        from: Math.max(0, this.selectedHint - margin),
        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),
      };
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function (cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function (result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function (cm) { return CodeMirror.hint.fromList(cm, { words: words }) }
    } else if (CodeMirror.hint.anyword) {
      return function (cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function () { }
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur)
    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start)
    } else {
      term = ""
      from = cur
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return { list: found, from: from, to: to };
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnPick: true,
    closeOnUnfocus: true,
    updateOnCursorActivity: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null,
    paddingForScrollbar: true,
    moveOnOverlap: true,
  };

  CodeMirror.defineOption("hintOptions", null);
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Glue code between CodeMirror and Tern.
//
// Create a CodeMirror.TernServer to wrap an actual Tern server,
// register open documents (CodeMirror.Doc instances) with it, and
// call its methods to activate the assisting functions that Tern
// provides.
//
// Options supported (all optional):
// * defs: An array of JSON definition data structures.
// * plugins: An object mapping plugin names to configuration
//   options.
// * getFile: A function(name, c) that can be used to access files in
//   the project that haven't been loaded yet. Simply do c(null) to
//   indicate that a file is not available.
// * fileFilter: A function(value, docName, doc) that will be applied
//   to documents before passing them on to Tern.
// * switchToDoc: A function(name, doc) that should, when providing a
//   multi-file view, switch the view or focus to the named file.
// * showError: A function(editor, message) that can be used to
//   override the way errors are displayed.
// * completionTip: Customize the content in tooltips for completions.
//   Is passed a single argument—the completion's data as returned by
//   Tern—and may return a string, DOM node, or null to indicate that
//   no tip should be shown. By default the docstring is shown.
// * typeTip: Like completionTip, but for the tooltips shown for type
//   queries.
// * responseFilter: A function(doc, query, request, error, data) that
//   will be applied to the Tern responses before treating them
//
//
// It is possible to run the Tern server in a web worker by specifying
// these additional options:
// * useWorker: Set to true to enable web worker mode. You'll probably
//   want to feature detect the actual value you use here, for example
//   !!window.Worker.
// * workerScript: The main script of the worker. Point this to
//   wherever you are hosting worker.js from this directory.
// * workerDeps: An array of paths pointing (relative to workerScript)
//   to the Acorn and Tern libraries and any Tern plugins you want to
//   load. Or, if you minified those into a single script and included
//   them in the workerScript, simply leave this undefined.

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";
  // declare global: tern

  CodeMirror.TernServer = function (options) {
    var self = this;
    this.options = options || {};
    var plugins = this.options.plugins || (this.options.plugins = {});
    if (!plugins.doc_comment) plugins.doc_comment = true;
    this.docs = Object.create(null);
    if (this.options.useWorker) {
      this.server = new WorkerServer(this);
    } else {
      this.server = new tern.Server({
        getFile: function (name, c) { return getFile(self, name, c); },
        async: true,
        defs: this.options.defs || [],
        plugins: plugins
      });
    }
    this.trackChange = function (doc, change) { trackChange(self, doc, change); };

    this.cachedArgHints = null;
    this.activeArgHints = null;
    this.jumpStack = [];

    this.getHint = function (cm, c) { return hint(self, cm, c); };
    this.getHint.async = true;
  };

  CodeMirror.TernServer.prototype = {
    addDoc: function (name, doc) {
      var data = { doc: doc, name: name, changed: null };
      this.server.addFile(name, docValue(this, data));
      CodeMirror.on(doc, "change", this.trackChange);
      return this.docs[name] = data;
    },

    delDoc: function (id) {
      var found = resolveDoc(this, id);
      if (!found) return;
      CodeMirror.off(found.doc, "change", this.trackChange);
      delete this.docs[found.name];
      this.server.delFile(found.name);
    },

    hideDoc: function (id) {
      closeArgHints(this);
      var found = resolveDoc(this, id);
      if (found && found.changed) sendDoc(this, found);
    },

    complete: function (cm) {
      cm.showHint({ hint: this.getHint });
    },

    showType: function (cm, pos, c) { showContextInfo(this, cm, pos, "type", c); },

    showDocs: function (cm, pos, c) { showContextInfo(this, cm, pos, "documentation", c); },

    updateArgHints: function (cm) { updateArgHints(this, cm); },

    jumpToDef: function (cm) { jumpToDef(this, cm); },

    jumpBack: function (cm) { jumpBack(this, cm); },

    rename: function (cm) { rename(this, cm); },

    selectName: function (cm) { selectName(this, cm); },

    request: function (cm, query, c, pos) {
      var self = this;
      var doc = findDoc(this, cm.getDoc());
      var request = buildRequest(this, doc, query, pos);
      var extraOptions = request.query && this.options.queryOptions && this.options.queryOptions[request.query.type]
      if (extraOptions) for (var prop in extraOptions) request.query[prop] = extraOptions[prop];

      this.server.request(request, function (error, data) {
        if (!error && self.options.responseFilter)
          data = self.options.responseFilter(doc, query, request, error, data);
        c(error, data);
      });
    },

    destroy: function () {
      closeArgHints(this)
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
      }
    }
  };

  var Pos = CodeMirror.Pos;
  var cls = "CodeMirror-Tern-";
  var bigDoc = 250;

  function getFile(ts, name, c) {
    var buf = ts.docs[name];
    if (buf)
      c(docValue(ts, buf));
    else if (ts.options.getFile)
      ts.options.getFile(name, c);
    else
      c(null);
  }

  function findDoc(ts, doc, name) {
    for (var n in ts.docs) {
      var cur = ts.docs[n];
      if (cur.doc == doc) return cur;
    }
    if (!name) for (var i = 0; ; ++i) {
      n = "[doc" + (i || "") + "]";
      if (!ts.docs[n]) { name = n; break; }
    }
    return ts.addDoc(name, doc);
  }

  function resolveDoc(ts, id) {
    if (typeof id == "string") return ts.docs[id];
    if (id instanceof CodeMirror) id = id.getDoc();
    if (id instanceof CodeMirror.Doc) return findDoc(ts, id);
  }

  function trackChange(ts, doc, change) {
    var data = findDoc(ts, doc);

    var argHints = ts.cachedArgHints;
    if (argHints && argHints.doc == doc && cmpPos(argHints.start, change.to) >= 0)
      ts.cachedArgHints = null;

    var changed = data.changed;
    if (changed == null)
      data.changed = changed = { from: change.from.line, to: change.from.line };
    var end = change.from.line + (change.text.length - 1);
    if (change.from.line < changed.to) changed.to = changed.to - (change.to.line - end);
    if (end >= changed.to) changed.to = end + 1;
    if (changed.from > change.from.line) changed.from = change.from.line;

    if (doc.lineCount() > bigDoc && change.to - changed.from > 100) setTimeout(function () {
      if (data.changed && data.changed.to - data.changed.from > 100) sendDoc(ts, data);
    }, 200);
  }

  function sendDoc(ts, doc) {
    ts.server.request({ files: [{ type: "full", name: doc.name, text: docValue(ts, doc) }] }, function (error) {
      if (error) window.console.error(error);
      else doc.changed = null;
    });
  }

  // Completion

  function hint(ts, cm, c) {
    ts.request(cm, { type: "completions", types: true, docs: true, urls: true }, function (error, data) {
      if (error) return showError(ts, cm, error);
      var completions = [], after = "";
      var from = data.start, to = data.end;
      if (cm.getRange(Pos(from.line, from.ch - 2), from) == "[\"" &&
        cm.getRange(to, Pos(to.line, to.ch + 2)) != "\"]")
        after = "\"]";

      for (var i = 0; i < data.completions.length; ++i) {
        var completion = data.completions[i], className = typeToIcon(completion.type);
        if (data.guess) className += " " + cls + "guess";
        completions.push({
          text: completion.name + after,
          displayText: completion.displayName || completion.name,
          className: className,
          data: completion
        });
      }

      var obj = { from: from, to: to, list: completions };
      var tooltip = null;
      CodeMirror.on(obj, "close", function () { remove(tooltip); });
      CodeMirror.on(obj, "update", function () { remove(tooltip); });
      CodeMirror.on(obj, "select", function (cur, node) {
        remove(tooltip);
        var content = ts.options.completionTip ? ts.options.completionTip(cur.data) : cur.data.doc;
        if (content) {
          tooltip = makeTooltip(node.parentNode.getBoundingClientRect().right + window.pageXOffset,
            node.getBoundingClientRect().top + window.pageYOffset, content, cm, cls + "hint-doc");
        }
      });
      c(obj);
    });
  }

  function typeToIcon(type) {
    var suffix;
    if (type == "?") suffix = "unknown";
    else if (type == "number" || type == "string" || type == "bool") suffix = type;
    else if (/^fn\(/.test(type)) suffix = "fn";
    else if (/^\[/.test(type)) suffix = "array";
    else suffix = "object";
    return cls + "completion " + cls + "completion-" + suffix;
  }

  // Type queries

  function showContextInfo(ts, cm, pos, queryName, c) {
    ts.request(cm, queryName, function (error, data) {
      if (error) return showError(ts, cm, error);
      if (ts.options.typeTip) {
        var tip = ts.options.typeTip(data);
      } else {
        var tip = elt("span", null, elt("strong", null, data.type || "not found"));
        if (data.doc)
          tip.appendChild(document.createTextNode(" — " + data.doc));
        if (data.url) {
          tip.appendChild(document.createTextNode(" "));
          var child = tip.appendChild(elt("a", null, "[docs]"));
          child.href = data.url;
          child.target = "_blank";
        }
      }
      tempTooltip(cm, tip, ts);
      if (c) c();
    }, pos);
  }

  // Maintaining argument hints

  function updateArgHints(ts, cm) {
    closeArgHints(ts);

    if (cm.somethingSelected()) return;
    var state = cm.getTokenAt(cm.getCursor()).state;
    var inner = CodeMirror.innerMode(cm.getMode(), state);
    if (inner.mode.name != "javascript") return;
    var lex = inner.state.lexical;
    if (lex.info != "call") return;

    var ch, argPos = lex.pos || 0, tabSize = cm.getOption("tabSize");
    for (var line = cm.getCursor().line, e = Math.max(0, line - 9), found = false; line >= e; --line) {
      var str = cm.getLine(line), extra = 0;
      for (var pos = 0; ;) {
        var tab = str.indexOf("\t", pos);
        if (tab == -1) break;
        extra += tabSize - (tab + extra) % tabSize - 1;
        pos = tab + 1;
      }
      ch = lex.column - extra;
      if (str.charAt(ch) == "(") { found = true; break; }
    }
    if (!found) return;

    var start = Pos(line, ch);
    var cache = ts.cachedArgHints;
    if (cache && cache.doc == cm.getDoc() && cmpPos(start, cache.start) == 0)
      return showArgHints(ts, cm, argPos);

    ts.request(cm, { type: "type", preferFunction: true, end: start }, function (error, data) {
      if (error || !data.type || !(/^fn\(/).test(data.type)) return;
      ts.cachedArgHints = {
        start: start,
        type: parseFnType(data.type),
        name: data.exprName || data.name || "fn",
        guess: data.guess,
        doc: cm.getDoc()
      };
      showArgHints(ts, cm, argPos);
    });
  }

  function showArgHints(ts, cm, pos) {
    closeArgHints(ts);

    var cache = ts.cachedArgHints, tp = cache.type;
    var tip = elt("span", cache.guess ? cls + "fhint-guess" : null,
      elt("span", cls + "fname", cache.name), "(");
    for (var i = 0; i < tp.args.length; ++i) {
      if (i) tip.appendChild(document.createTextNode(", "));
      var arg = tp.args[i];
      tip.appendChild(elt("span", cls + "farg" + (i == pos ? " " + cls + "farg-current" : ""), arg.name || "?"));
      if (arg.type != "?") {
        tip.appendChild(document.createTextNode(":\u00a0"));
        tip.appendChild(elt("span", cls + "type", arg.type));
      }
    }
    tip.appendChild(document.createTextNode(tp.rettype ? ") ->\u00a0" : ")"));
    if (tp.rettype) tip.appendChild(elt("span", cls + "type", tp.rettype));
    var place = cm.cursorCoords(null, "page");
    var tooltip = ts.activeArgHints = makeTooltip(place.right + 1, place.bottom, tip, cm)
    setTimeout(function () {
      tooltip.clear = onEditorActivity(cm, function () {
        if (ts.activeArgHints == tooltip) closeArgHints(ts)
      })
    }, 20)
  }

  function parseFnType(text) {
    var args = [], pos = 3;

    function skipMatching(upto) {
      var depth = 0, start = pos;
      for (; ;) {
        var next = text.charAt(pos);
        if (upto.test(next) && !depth) return text.slice(start, pos);
        if (/[{\[\(]/.test(next)) ++depth;
        else if (/[}\]\)]/.test(next)) --depth;
        ++pos;
      }
    }

    // Parse arguments
    if (text.charAt(pos) != ")") for (; ;) {
      var name = text.slice(pos).match(/^([^, \(\[\{]+): /);
      if (name) {
        pos += name[0].length;
        name = name[1];
      }
      args.push({ name: name, type: skipMatching(/[\),]/) });
      if (text.charAt(pos) == ")") break;
      pos += 2;
    }

    var rettype = text.slice(pos).match(/^\) -> (.*)$/);

    return { args: args, rettype: rettype && rettype[1] };
  }

  // Moving to the definition of something

  function jumpToDef(ts, cm) {
    function inner(varName) {
      var req = { type: "definition", variable: varName || null };
      var doc = findDoc(ts, cm.getDoc());
      ts.server.request(buildRequest(ts, doc, req), function (error, data) {
        if (error) return showError(ts, cm, error);
        if (!data.file && data.url) { window.open(data.url); return; }

        if (data.file) {
          var localDoc = ts.docs[data.file], found;
          if (localDoc && (found = findContext(localDoc.doc, data))) {
            ts.jumpStack.push({
              file: doc.name,
              start: cm.getCursor("from"),
              end: cm.getCursor("to")
            });
            moveTo(ts, doc, localDoc, found.start, found.end);
            return;
          }
        }
        showError(ts, cm, "Could not find a definition.");
      });
    }

    if (!atInterestingExpression(cm))
      dialog(cm, "Jump to variable", function (name) { if (name) inner(name); });
    else
      inner();
  }

  function jumpBack(ts, cm) {
    var pos = ts.jumpStack.pop(), doc = pos && ts.docs[pos.file];
    if (!doc) return;
    moveTo(ts, findDoc(ts, cm.getDoc()), doc, pos.start, pos.end);
  }

  function moveTo(ts, curDoc, doc, start, end) {
    doc.doc.setSelection(start, end);
    if (curDoc != doc && ts.options.switchToDoc) {
      closeArgHints(ts);
      ts.options.switchToDoc(doc.name, doc.doc);
    }
  }

  // The {line,ch} representation of positions makes this rather awkward.
  function findContext(doc, data) {
    var before = data.context.slice(0, data.contextOffset).split("\n");
    var startLine = data.start.line - (before.length - 1);
    var start = Pos(startLine, (before.length == 1 ? data.start.ch : doc.getLine(startLine).length) - before[0].length);

    var text = doc.getLine(startLine).slice(start.ch);
    for (var cur = startLine + 1; cur < doc.lineCount() && text.length < data.context.length; ++cur)
      text += "\n" + doc.getLine(cur);
    if (text.slice(0, data.context.length) == data.context) return data;

    var cursor = doc.getSearchCursor(data.context, 0, false);
    var nearest, nearestDist = Infinity;
    while (cursor.findNext()) {
      var from = cursor.from(), dist = Math.abs(from.line - start.line) * 10000;
      if (!dist) dist = Math.abs(from.ch - start.ch);
      if (dist < nearestDist) { nearest = from; nearestDist = dist; }
    }
    if (!nearest) return null;

    if (before.length == 1)
      nearest.ch += before[0].length;
    else
      nearest = Pos(nearest.line + (before.length - 1), before[before.length - 1].length);
    if (data.start.line == data.end.line)
      var end = Pos(nearest.line, nearest.ch + (data.end.ch - data.start.ch));
    else
      var end = Pos(nearest.line + (data.end.line - data.start.line), data.end.ch);
    return { start: nearest, end: end };
  }

  function atInterestingExpression(cm) {
    var pos = cm.getCursor("end"), tok = cm.getTokenAt(pos);
    if (tok.start < pos.ch && tok.type == "comment") return false;
    return /[\w)\]]/.test(cm.getLine(pos.line).slice(Math.max(pos.ch - 1, 0), pos.ch + 1));
  }

  // Variable renaming

  function rename(ts, cm) {
    var token = cm.getTokenAt(cm.getCursor());
    if (!/\w/.test(token.string)) return showError(ts, cm, "Not at a variable");
    dialog(cm, "New name for " + token.string, function (newName) {
      ts.request(cm, { type: "rename", newName: newName, fullDocs: true }, function (error, data) {
        if (error) return showError(ts, cm, error);
        applyChanges(ts, data.changes);
      });
    });
  }

  function selectName(ts, cm) {
    var name = findDoc(ts, cm.doc).name;
    ts.request(cm, { type: "refs" }, function (error, data) {
      if (error) return showError(ts, cm, error);
      var ranges = [], cur = 0;
      var curPos = cm.getCursor();
      for (var i = 0; i < data.refs.length; i++) {
        var ref = data.refs[i];
        if (ref.file == name) {
          ranges.push({ anchor: ref.start, head: ref.end });
          if (cmpPos(curPos, ref.start) >= 0 && cmpPos(curPos, ref.end) <= 0)
            cur = ranges.length - 1;
        }
      }
      cm.setSelections(ranges, cur);
    });
  }

  var nextChangeOrig = 0;
  function applyChanges(ts, changes) {
    var perFile = Object.create(null);
    for (var i = 0; i < changes.length; ++i) {
      var ch = changes[i];
      (perFile[ch.file] || (perFile[ch.file] = [])).push(ch);
    }
    for (var file in perFile) {
      var known = ts.docs[file], chs = perFile[file];;
      if (!known) continue;
      chs.sort(function (a, b) { return cmpPos(b.start, a.start); });
      var origin = "*rename" + (++nextChangeOrig);
      for (var i = 0; i < chs.length; ++i) {
        var ch = chs[i];
        known.doc.replaceRange(ch.text, ch.start, ch.end, origin);
      }
    }
  }

  // Generic request-building helper

  function buildRequest(ts, doc, query, pos) {
    var files = [], offsetLines = 0, allowFragments = !query.fullDocs;
    if (!allowFragments) delete query.fullDocs;
    if (typeof query == "string") query = { type: query };
    query.lineCharPositions = true;
    if (query.end == null) {
      query.end = pos || doc.doc.getCursor("end");
      if (doc.doc.somethingSelected())
        query.start = doc.doc.getCursor("start");
    }
    var startPos = query.start || query.end;

    if (doc.changed) {
      if (doc.doc.lineCount() > bigDoc && allowFragments !== false &&
        doc.changed.to - doc.changed.from < 100 &&
        doc.changed.from <= startPos.line && doc.changed.to > query.end.line) {
        files.push(getFragmentAround(doc, startPos, query.end));
        query.file = "#0";
        var offsetLines = files[0].offsetLines;
        if (query.start != null) query.start = Pos(query.start.line - -offsetLines, query.start.ch);
        query.end = Pos(query.end.line - offsetLines, query.end.ch);
      } else {
        files.push({
          type: "full",
          name: doc.name,
          text: docValue(ts, doc)
        });
        query.file = doc.name;
        doc.changed = null;
      }
    } else {
      query.file = doc.name;
    }
    for (var name in ts.docs) {
      var cur = ts.docs[name];
      if (cur.changed && cur != doc) {
        files.push({ type: "full", name: cur.name, text: docValue(ts, cur) });
        cur.changed = null;
      }
    }

    return { query: query, files: files };
  }

  function getFragmentAround(data, start, end) {
    var doc = data.doc;
    var minIndent = null, minLine = null, endLine, tabSize = 4;
    for (var p = start.line - 1, min = Math.max(0, p - 50); p >= min; --p) {
      var line = doc.getLine(p), fn = line.search(/\bfunction\b/);
      if (fn < 0) continue;
      var indent = CodeMirror.countColumn(line, null, tabSize);
      if (minIndent != null && minIndent <= indent) continue;
      minIndent = indent;
      minLine = p;
    }
    if (minLine == null) minLine = min;
    var max = Math.min(doc.lastLine(), end.line + 20);
    if (minIndent == null || minIndent == CodeMirror.countColumn(doc.getLine(start.line), null, tabSize))
      endLine = max;
    else for (endLine = end.line + 1; endLine < max; ++endLine) {
      var indent = CodeMirror.countColumn(doc.getLine(endLine), null, tabSize);
      if (indent <= minIndent) break;
    }
    var from = Pos(minLine, 0);

    return {
      type: "part",
      name: data.name,
      offsetLines: from.line,
      text: doc.getRange(from, Pos(endLine, end.line == endLine ? null : 0))
    };
  }

  // Generic utilities

  var cmpPos = CodeMirror.cmpPos;

  function elt(tagname, cls /*, ... elts*/) {
    var e = document.createElement(tagname);
    if (cls) e.className = cls;
    for (var i = 2; i < arguments.length; ++i) {
      var elt = arguments[i];
      if (typeof elt == "string") elt = document.createTextNode(elt);
      e.appendChild(elt);
    }
    return e;
  }

  function dialog(cm, text, f) {
    if (cm.openDialog)
      cm.openDialog(text + ": <input type=text>", f);
    else
      f(prompt(text, ""));
  }

  // Tooltips

  function tempTooltip(cm, content, ts) {
    if (cm.state.ternTooltip) remove(cm.state.ternTooltip);
    var where = cm.cursorCoords();
    var tip = cm.state.ternTooltip = makeTooltip(where.right + 1, where.bottom, content, cm);
    function maybeClear() {
      old = true;
      if (!mouseOnTip) clear();
    }
    function clear() {
      cm.state.ternTooltip = null;
      if (tip.parentNode) fadeOut(tip)
      clearActivity()
    }
    var mouseOnTip = false, old = false;
    CodeMirror.on(tip, "mousemove", function () { mouseOnTip = true; });
    CodeMirror.on(tip, "mouseout", function (e) {
      var related = e.relatedTarget || e.toElement
      if (!related || !CodeMirror.contains(tip, related)) {
        if (old) clear();
        else mouseOnTip = false;
      }
    });
    setTimeout(maybeClear, ts.options.hintDelay ? ts.options.hintDelay : 1700);
    var clearActivity = onEditorActivity(cm, clear)
  }

  function onEditorActivity(cm, f) {
    cm.on("cursorActivity", f)
    cm.on("blur", f)
    cm.on("scroll", f)
    cm.on("setDoc", f)
    return function () {
      cm.off("cursorActivity", f)
      cm.off("blur", f)
      cm.off("scroll", f)
      cm.off("setDoc", f)
    }
  }

  function makeTooltip(x, y, content, cm, className) {
    var node = elt("div", cls + "tooltip" + " " + (className || ""), content);
    node.style.left = x + "px";
    node.style.top = y + "px";
    var container = ((cm.options || {}).hintOptions || {}).container || document.body;
    container.appendChild(node);

    var pos = cm.cursorCoords();
    var winW = window.innerWidth;
    var winH = window.innerHeight;
    var box = node.getBoundingClientRect();
    var hints = document.querySelector(".CodeMirror-hints");
    var overlapY = box.bottom - winH;
    var overlapX = box.right - winW;

    if (hints && overlapX > 0) {
      node.style.left = 0;
      var box = node.getBoundingClientRect();
      node.style.left = (x = x - hints.offsetWidth - box.width) + "px";
      overlapX = box.right - winW;
    }
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        node.style.top = (pos.top - height) + "px";
      } else if (height > winH) {
        node.style.height = (winH - 5) + "px";
        node.style.top = (pos.bottom - box.top) + "px";
      }
    }
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        node.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      node.style.left = (x - overlapX) + "px";
    }

    return node;
  }

  function remove(node) {
    var p = node && node.parentNode;
    if (p) p.removeChild(node);
  }

  function fadeOut(tooltip) {
    tooltip.style.opacity = "0";
    setTimeout(function () { remove(tooltip); }, 1100);
  }

  function showError(ts, cm, msg) {
    if (ts.options.showError)
      ts.options.showError(cm, msg);
    else
      tempTooltip(cm, String(msg), ts);
  }

  function closeArgHints(ts) {
    if (ts.activeArgHints) {
      if (ts.activeArgHints.clear) ts.activeArgHints.clear()
      remove(ts.activeArgHints)
      ts.activeArgHints = null
    }
  }

  function docValue(ts, doc) {
    var val = doc.doc.getValue();
    if (ts.options.fileFilter) val = ts.options.fileFilter(val, doc.name, doc.doc);
    return val;
  }

  // Worker wrapper

  function WorkerServer(ts) {
    var worker = ts.worker = new Worker(ts.options.workerScript);
    worker.postMessage({
      type: "init",
      defs: ts.options.defs,
      plugins: ts.options.plugins,
      scripts: ts.options.workerDeps
    });
    var msgId = 0, pending = {};

    function send(data, c) {
      if (c) {
        data.id = ++msgId;
        pending[msgId] = c;
      }
      worker.postMessage(data);
    }
    worker.onmessage = function (e) {
      var data = e.data;
      if (data.type == "getFile") {
        getFile(ts, data.name, function (err, text) {
          send({ type: "getFile", err: String(err), text: text, id: data.id });
        });
      } else if (data.type == "debug") {
        window.console.log(data.message);
      } else if (data.id && pending[data.id]) {
        pending[data.id](data.err, data.body);
        delete pending[data.id];
      }
    };
    worker.onerror = function (e) {
      for (var id in pending) pending[id](e);
      pending = {};
    };

    this.addFile = function (name, text) { send({ type: "add", name: name, text: text }); };
    this.delFile = function (name) { send({ type: "del", name: name }); };
    this.request = function (body, c) { send({ type: "req", body: body }, c); };
  }
});


(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.acorn = f() } })(function () {
  var define, module, exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
    1: [function (require, module, exports) {


      // The main exported interface (under `self.acorn` when in the
      // browser) is a `parse` function that takes a code string and
      // returns an abstract syntax tree as specified by [Mozilla parser
      // API][api].
      //
      // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

      "use strict";

      exports.parse = parse;

      // This function tries to parse a single expression at a given
      // offset in a string. Useful for parsing mixed-language formats
      // that embed JavaScript expressions.

      exports.parseExpressionAt = parseExpressionAt;

      // Acorn is organized as a tokenizer and a recursive-descent parser.
      // The `tokenize` export provides an interface to the tokenizer.

      exports.tokenizer = tokenizer;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // Acorn is a tiny, fast JavaScript parser written in JavaScript.
      //
      // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
      // various contributors and released under an MIT license.
      //
      // Git repositories for Acorn are available at
      //
      //     http://marijnhaverbeke.nl/git/acorn
      //     https://github.com/marijnh/acorn.git
      //
      // Please use the [github bug tracker][ghbt] to report issues.
      //
      // [ghbt]: https://github.com/marijnh/acorn/issues
      //
      // This file defines the main parser interface. The library also comes
      // with a [error-tolerant parser][dammit] and an
      // [abstract syntax tree walker][walk], defined in other files.
      //
      // [dammit]: acorn_loose.js
      // [walk]: util/walk.js

      var _state = require("./state");

      var Parser = _state.Parser;

      var _options = require("./options");

      var getOptions = _options.getOptions;

      require("./parseutil");

      require("./statement");

      require("./lval");

      require("./expression");

      exports.Parser = _state.Parser;
      exports.plugins = _state.plugins;
      exports.defaultOptions = _options.defaultOptions;

      var _location = require("./location");

      exports.SourceLocation = _location.SourceLocation;
      exports.getLineInfo = _location.getLineInfo;
      exports.Node = require("./node").Node;

      var _tokentype = require("./tokentype");

      exports.TokenType = _tokentype.TokenType;
      exports.tokTypes = _tokentype.types;

      var _tokencontext = require("./tokencontext");

      exports.TokContext = _tokencontext.TokContext;
      exports.tokContexts = _tokencontext.types;

      var _identifier = require("./identifier");

      exports.isIdentifierChar = _identifier.isIdentifierChar;
      exports.isIdentifierStart = _identifier.isIdentifierStart;
      exports.Token = require("./tokenize").Token;

      var _whitespace = require("./whitespace");

      exports.isNewLine = _whitespace.isNewLine;
      exports.lineBreak = _whitespace.lineBreak;
      exports.lineBreakG = _whitespace.lineBreakG;
      var version = "1.0.1"; exports.version = version;

      function parse(input, options) {
        var p = parser(options, input);
        var startPos = p.options.locations ? [p.pos, p.curPosition()] : p.pos;
        p.nextToken();
        return p.parseTopLevel(p.options.program || p.startNodeAt(startPos));
      }

      function parseExpressionAt(input, pos, options) {
        var p = parser(options, input, pos);
        p.nextToken();
        return p.parseExpression();
      }

      function tokenizer(input, options) {
        return parser(options, input);
      }

      function parser(options, input) {
        return new Parser(getOptions(options), String(input));
      }

    }, { "./expression": 2, "./identifier": 3, "./location": 4, "./lval": 5, "./node": 6, "./options": 7, "./parseutil": 8, "./state": 9, "./statement": 10, "./tokencontext": 11, "./tokenize": 12, "./tokentype": 13, "./whitespace": 15 }], 2: [function (require, module, exports) {
      // A recursive descent parser operates by defining functions for all
      // syntactic elements, and recursively calling those, each function
      // advancing the input stream and returning an AST node. Precedence
      // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
      // instead of `(!x)[1]` is handled by the fact that the parser
      // function that parses unary prefix operators is called first, and
      // in turn calls the function that parses `[]` subscripts — that
      // way, it'll receive the node for `x[1]` already parsed, and wraps
      // *that* in the unary operator node.
      //
      // Acorn uses an [operator precedence parser][opp] to handle binary
      // operator precedence, because it is much more compact than using
      // the technique outlined above, which uses different, nesting
      // functions to specify precedence, for all of the ten binary
      // precedence levels that JavaScript defines.
      //
      // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

      "use strict";

      var tt = require("./tokentype").types;

      var Parser = require("./state").Parser;

      var reservedWords = require("./identifier").reservedWords;

      var has = require("./util").has;

      var pp = Parser.prototype;

      // Check if property name clashes with already added.
      // Object/class getters and setters are not allowed to clash —
      // either with each other or with an init property — and in
      // strict mode, init properties are also not allowed to be repeated.

      pp.checkPropClash = function (prop, propHash) {
        if (this.options.ecmaVersion >= 6) return;
        var key = prop.key,
          name = undefined;
        switch (key.type) {
          case "Identifier":
            name = key.name; break;
          case "Literal":
            name = String(key.value); break;
          default:
            return;
        }
        var kind = prop.kind || "init",
          other = undefined;
        if (has(propHash, name)) {
          other = propHash[name];
          var isGetSet = kind !== "init";
          if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };

      // ### Expression parsing

      // These nest, from the most general expression type at the top to
      // 'atomic', nondivisible expression types at the bottom. Most of
      // the functions will simply let the function(s) below them parse,
      // and, *if* the syntactic construct they handle is present, wrap
      // the AST node that the inner parser gave them in another node.

      // Parse a full expression. The optional arguments are used to
      // forbid the `in` operator (in for loops initalization expressions)
      // and provide reference for storing '=' operator inside shorthand
      // property assignment in contexts where both object expression
      // and object pattern might appear (so it's possible to raise
      // delayed syntax error at correct position).

      pp.parseExpression = function (noIn, refShorthandDefaultPos) {
        var start = this.markPosition();
        var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
        if (this.type === tt.comma) {
          var node = this.startNodeAt(start);
          node.expressions = [expr];
          while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };

      // Parse an assignment expression. This includes applications of
      // operators like `+=`.

      pp.parseMaybeAssign = function (noIn, refShorthandDefaultPos) {
        if (this.type == tt._yield && this.inGenerator) return this.parseYield();

        var failOnShorthandAssign = undefined;
        if (!refShorthandDefaultPos) {
          refShorthandDefaultPos = { start: 0 };
          failOnShorthandAssign = true;
        } else {
          failOnShorthandAssign = false;
        }
        var start = this.markPosition();
        var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);
        if (this.type.isAssign) {
          var node = this.startNodeAt(start);
          node.operator = this.value;
          node.left = this.type === tt.eq ? this.toAssignable(left) : left;
          refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
          this.checkLVal(left);
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression");
        } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
          this.unexpected(refShorthandDefaultPos.start);
        }
        return left;
      };

      // Parse a ternary conditional (`?:`) operator.

      pp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {
        var start = this.markPosition();
        var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
        if (this.eat(tt.question)) {
          var node = this.startNodeAt(start);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tt.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };

      // Start the precedence parser.

      pp.parseExprOps = function (noIn, refShorthandDefaultPos) {
        var start = this.markPosition();
        var expr = this.parseMaybeUnary(refShorthandDefaultPos);
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
        return this.parseExprOp(expr, start, -1, noIn);
      };

      // Parse binary operators with the operator precedence parsing
      // algorithm. `left` is the left-hand side of the operator.
      // `minPrec` provides context that allows the function to stop and
      // defer further parser to one of its callers when it encounters an
      // operator that has a lower precedence than the set it is parsing.

      pp.parseExprOp = function (left, leftStart, minPrec, noIn) {
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== tt._in)) {
          if (prec > minPrec) {
            var node = this.startNodeAt(leftStart);
            node.left = left;
            node.operator = this.value;
            var op = this.type;
            this.next();
            var start = this.markPosition();
            node.right = this.parseExprOp(this.parseMaybeUnary(), start, prec, noIn);
            this.finishNode(node, op === tt.logicalOR || op === tt.logicalAND ? "LogicalExpression" : "BinaryExpression");
            return this.parseExprOp(node, leftStart, minPrec, noIn);
          }
        }
        return left;
      };

      // Parse unary operators, both prefix and postfix.

      pp.parseMaybeUnary = function (refShorthandDefaultPos) {
        if (this.type.prefix) {
          var node = this.startNode(),
            update = this.type === tt.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary();
          if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
          if (update) this.checkLVal(node.argument); else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
          return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        }
        var start = this.markPosition();
        var expr = this.parseExprSubscripts(refShorthandDefaultPos);
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(start);
          node.operator = this.value;
          node.prefix = false;
          node.argument = expr;
          this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node, "UpdateExpression");
        }
        return expr;
      };

      // Parse call, dot, and `[]`-subscript expressions.

      pp.parseExprSubscripts = function (refShorthandDefaultPos) {
        var start = this.markPosition();
        var expr = this.parseExprAtom(refShorthandDefaultPos);
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
        return this.parseSubscripts(expr, start);
      };

      pp.parseSubscripts = function (base, start, noCalls) {
        if (this.eat(tt.dot)) {
          var node = this.startNodeAt(start);
          node.object = base;
          node.property = this.parseIdent(true);
          node.computed = false;
          return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
        } else if (this.eat(tt.bracketL)) {
          var node = this.startNodeAt(start);
          node.object = base;
          node.property = this.parseExpression();
          node.computed = true;
          this.expect(tt.bracketR);
          return this.parseSubscripts(this.finishNode(node, "MemberExpression"), start, noCalls);
        } else if (!noCalls && this.eat(tt.parenL)) {
          var node = this.startNodeAt(start);
          node.callee = base;
          node.arguments = this.parseExprList(tt.parenR, false);
          return this.parseSubscripts(this.finishNode(node, "CallExpression"), start, noCalls);
        } else if (this.type === tt.backQuote) {
          var node = this.startNodeAt(start);
          node.tag = base;
          node.quasi = this.parseTemplate();
          return this.parseSubscripts(this.finishNode(node, "TaggedTemplateExpression"), start, noCalls);
        } return base;
      };

      // Parse an atomic expression — either a single token that is an
      // expression, an expression started by a keyword like `function` or
      // `new`, or an expression wrapped in punctuation like `()`, `[]`,
      // or `{}`.

      pp.parseExprAtom = function (refShorthandDefaultPos) {
        var node = undefined;
        switch (this.type) {
          case tt._this:
          case tt._super:
            var type = this.type === tt._this ? "ThisExpression" : "Super";
            node = this.startNode();
            this.next();
            return this.finishNode(node, type);

          case tt._yield:
            if (this.inGenerator) unexpected();

          case tt.name:
            var start = this.markPosition();
            var id = this.parseIdent(this.type !== tt.name);
            if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(start), [id]);
            }
            return id;

          case tt.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;

          case tt.num: case tt.string:
            return this.parseLiteral(this.value);

          case tt._null: case tt._true: case tt._false:
            node = this.startNode();
            node.value = this.type === tt._null ? null : this.type === tt._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");

          case tt.parenL:
            return this.parseParenAndDistinguishExpression();

          case tt.bracketL:
            node = this.startNode();
            this.next();
            // check whether this is array comprehension or regular array
            if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
              return this.parseComprehension(node, false);
            }
            node.elements = this.parseExprList(tt.bracketR, true, true, refShorthandDefaultPos);
            return this.finishNode(node, "ArrayExpression");

          case tt.braceL:
            return this.parseObj(false, refShorthandDefaultPos);

          case tt._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, false);

          case tt._class:
            return this.parseClass(this.startNode(), false);

          case tt._new:
            return this.parseNew();

          case tt.backQuote:
            return this.parseTemplate();

          default:
            this.unexpected();
        }
      };

      pp.parseLiteral = function (value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        this.next();
        return this.finishNode(node, "Literal");
      };

      pp.parseParenExpression = function () {
        this.expect(tt.parenL);
        var val = this.parseExpression();
        this.expect(tt.parenR);
        return val;
      };

      pp.parseParenAndDistinguishExpression = function () {
        var start = this.markPosition(),
          val = undefined;
        if (this.options.ecmaVersion >= 6) {
          this.next();

          if (this.options.ecmaVersion >= 7 && this.type === tt._for) {
            return this.parseComprehension(this.startNodeAt(start), true);
          }

          var innerStart = this.markPosition(),
            exprList = [],
            first = true;
          var refShorthandDefaultPos = { start: 0 },
            spreadStart = undefined,
            innerParenStart = undefined;
          while (this.type !== tt.parenR) {
            first ? first = false : this.expect(tt.comma);
            if (this.type === tt.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseRest());
              break;
            } else {
              if (this.type === tt.parenL && !innerParenStart) {
                innerParenStart = this.start;
              }
              exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
            }
          }
          var innerEnd = this.markPosition();
          this.expect(tt.parenR);

          if (!this.canInsertSemicolon() && this.eat(tt.arrow)) {
            if (innerParenStart) this.unexpected(innerParenStart);
            return this.parseArrowExpression(this.startNodeAt(start), exprList);
          }

          if (!exprList.length) this.unexpected(this.lastTokStart);
          if (spreadStart) this.unexpected(spreadStart);
          if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);

          if (exprList.length > 1) {
            val = this.startNodeAt(innerStart);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEnd);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }

        if (this.options.preserveParens) {
          var par = this.startNodeAt(start);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };

      // New's precedence is slightly tricky. It must allow its argument
      // to be a `[]` or dot subscript expression, but not a call — at
      // least, not without wrapping it in parentheses. Thus, it uses the

      var empty = [];

      pp.parseNew = function () {
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
          node.meta = meta;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
          return this.finishNode(node, "MetaProperty");
        }
        var start = this.markPosition();
        node.callee = this.parseSubscripts(this.parseExprAtom(), start, true);
        if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false); else node.arguments = empty;
        return this.finishNode(node, "NewExpression");
      };

      // Parse template expression.

      pp.parseTemplateElement = function () {
        var elem = this.startNode();
        elem.value = {
          raw: this.input.slice(this.start, this.end),
          cooked: this.value
        };
        this.next();
        elem.tail = this.type === tt.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };

      pp.parseTemplate = function () {
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement();
        node.quasis = [curElt];
        while (!curElt.tail) {
          this.expect(tt.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(tt.braceR);
          node.quasis.push(curElt = this.parseTemplateElement());
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };

      // Parse an object literal or binding pattern.

      pp.parseObj = function (isPattern, refShorthandDefaultPos) {
        var node = this.startNode(),
          first = true,
          propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(tt.braceR)) {
          if (!first) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first = false;

          var prop = this.startNode(),
            isGenerator = undefined,
            start = undefined;
          if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refShorthandDefaultPos) start = this.markPosition();
            if (!isPattern) isGenerator = this.eat(tt.star);
          }
          this.parsePropertyName(prop);
          if (this.eat(tt.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault() : this.parseMaybeAssign(false, refShorthandDefaultPos);
            prop.kind = "init";
          } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
            if (isPattern) this.unexpected();
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator);
          } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != tt.comma && this.type != tt.braceR)) {
            if (isGenerator || isPattern) this.unexpected();
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            prop.kind = "init";
            if (isPattern) {
              if (this.isKeyword(prop.key.name) || this.strict && (reservedWords.strictBind(prop.key.name) || reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
              prop.value = this.parseMaybeDefault(start, prop.key);
            } else if (this.type === tt.eq && refShorthandDefaultPos) {
              if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;
              prop.value = this.parseMaybeDefault(start, prop.key);
            } else {
              prop.value = prop.key;
            }
            prop.shorthand = true;
          } else this.unexpected();

          this.checkPropClash(prop, propHash);
          node.properties.push(this.finishNode(prop, "Property"));
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };

      pp.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(tt.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(tt.bracketR);
            return;
          } else {
            prop.computed = false;
          }
        }
        prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
      };

      // Initialize empty function node.

      pp.initFunction = function (node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = false;
          node.expression = false;
        }
      };

      // Parse object or class method.

      pp.parseMethod = function (isGenerator) {
        var node = this.startNode();
        this.initFunction(node);
        this.expect(tt.parenL);
        node.params = this.parseBindingList(tt.parenR, false, false);
        var allowExpressionBody = undefined;
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
          allowExpressionBody = true;
        } else {
          allowExpressionBody = false;
        }
        this.parseFunctionBody(node, allowExpressionBody);
        return this.finishNode(node, "FunctionExpression");
      };

      // Parse arrow function expression with given parameters.

      pp.parseArrowExpression = function (node, params) {
        this.initFunction(node);
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true);
        return this.finishNode(node, "ArrowFunctionExpression");
      };

      // Parse function body and check parameters.

      pp.parseFunctionBody = function (node, allowExpression) {
        var isExpression = allowExpression && this.type !== tt.braceL;

        if (isExpression) {
          node.body = this.parseMaybeAssign();
          node.expression = true;
        } else {
          // Start a new scope with regard to labels and the `inFunction`
          // flag (restore them to their old value afterwards).
          var oldInFunc = this.inFunction,
            oldInGen = this.inGenerator,
            oldLabels = this.labels;
          this.inFunction = true; this.inGenerator = node.generator; this.labels = [];
          node.body = this.parseBlock(true);
          node.expression = false;
          this.inFunction = oldInFunc; this.inGenerator = oldInGen; this.labels = oldLabels;
        }

        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
          var nameHash = {},
            oldStrict = this.strict;
          this.strict = true;
          if (node.id) this.checkLVal(node.id, true);
          for (var i = 0; i < node.params.length; i++) {
            this.checkLVal(node.params[i], true, nameHash);
          } this.strict = oldStrict;
        }
      };

      // Parses a comma-separated list of expressions, and returns them as
      // an array. `close` is the token type that ends the list, and
      // `allowEmpty` can be turned on to allow subsequent commas with
      // nothing in between them to be parsed as `null` (which is needed
      // for array literals).

      pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
        var elts = [],
          first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) break;
          } else first = false;

          if (allowEmpty && this.type === tt.comma) {
            elts.push(null);
          } else {
            if (this.type === tt.ellipsis) elts.push(this.parseSpread(refShorthandDefaultPos)); else elts.push(this.parseMaybeAssign(false, refShorthandDefaultPos));
          }
        }
        return elts;
      };

      // Parse the next token as an identifier. If `liberal` is true (used
      // when parsing properties), it will also convert keywords into
      // identifiers.

      pp.parseIdent = function (liberal) {
        var node = this.startNode();
        if (liberal && this.options.allowReserved == "never") liberal = false;
        if (this.type === tt.name) {
          if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1))) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
          node.name = this.value;
        } else if (liberal && this.type.keyword) {
          node.name = this.type.keyword;
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "Identifier");
      };

      // Parses yield expression inside generator.

      pp.parseYield = function () {
        var node = this.startNode();
        this.next();
        if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(tt.star);
          node.argument = this.parseMaybeAssign();
        }
        return this.finishNode(node, "YieldExpression");
      };

      // Parses array and generator comprehensions.

      pp.parseComprehension = function (node, isGenerator) {
        node.blocks = [];
        while (this.type === tt._for) {
          var block = this.startNode();
          this.next();
          this.expect(tt.parenL);
          block.left = this.parseBindingAtom();
          this.checkLVal(block.left, true);
          this.expectContextual("of");
          block.right = this.parseExpression();
          this.expect(tt.parenR);
          node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
        }
        node.filter = this.eat(tt._if) ? this.parseParenExpression() : null;
        node.body = this.parseExpression();
        this.expect(isGenerator ? tt.parenR : tt.bracketR);
        node.generator = isGenerator;
        return this.finishNode(node, "ComprehensionExpression");
      };

    }, { "./identifier": 3, "./state": 9, "./tokentype": 13, "./util": 14 }], 3: [function (require, module, exports) {


      // Test whether a given character code starts an identifier.

      "use strict";

      exports.isIdentifierStart = isIdentifierStart;

      // Test whether a given character is part of an identifier.

      exports.isIdentifierChar = isIdentifierChar;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // This is a trick taken from Esprima. It turns out that, on
      // non-Chrome browsers, to check whether a string is in a set, a
      // predicate containing a big ugly `switch` statement is faster than
      // a regular expression, and on Chrome the two are about on par.
      // This function uses `eval` (non-lexical) to produce such a
      // predicate from a space-separated string of words.
      //
      // It starts by sorting the words by length.

      function makePredicate(words) {
        words = words.split(" ");
        var f = "",
          cats = [];
        out: for (var i = 0; i < words.length; ++i) {
          for (var j = 0; j < cats.length; ++j) {
            if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }
          } cats.push([words[i]]);
        }
        function compareTo(arr) {
          if (arr.length == 1) {
            return f += "return str === " + JSON.stringify(arr[0]) + ";";
          } f += "switch(str){";
          for (var i = 0; i < arr.length; ++i) {
            f += "case " + JSON.stringify(arr[i]) + ":";
          } f += "return true}return false;";
        }

        // When there are more than three length categories, an outer
        // switch first dispatches on the lengths, to save on comparisons.

        if (cats.length > 3) {
          cats.sort(function (a, b) {
            return b.length - a.length;
          });
          f += "switch(str.length){";
          for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
          }
          f += "}"

            // Otherwise, simply generate a flat `switch` statement.

            ;
        } else {
          compareTo(words);
        }
        return new Function("str", f);
      }

      // Reserved word lists for various dialects of the language

      var reservedWords = {
        3: makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
        5: makePredicate("class enum extends super const export import"),
        6: makePredicate("enum await"),
        strict: makePredicate("implements interface let package private protected public static yield"),
        strictBind: makePredicate("eval arguments")
      };

      exports.reservedWords = reservedWords;
      // And the keywords

      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

      var keywords = {
        5: makePredicate(ecma5AndLessKeywords),
        6: makePredicate(ecma5AndLessKeywords + " let const class extends export import yield super")
      };

      exports.keywords = keywords;
      // ## Character categories

      // Big ugly regular expressions that match characters in the
      // whitespace, identifier, and identifier-start categories. These
      // are only applied when a character is found to actually have a
      // code point above 128.
      // Generated by `tools/generate-identifier-regex.js`.

      var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";

      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

      // These are a run-length and offset encoded representation of the
      // >0xffff code points that are a valid part of identifiers. The
      // offset starts at 0x10000, and each pair of numbers represents an
      // offset to the next range, and then a size of the range. They were
      // generated by tools/generate-identifier-regex.js
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

      // This has a complexity linear to the value of the code. The
      // assumption is that looking up astral identifier characters is
      // rare.
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) {
            return false;
          } pos += set[i + 1];
          if (pos >= code) {
            return true;
          }
        }
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        } if (code < 91) {
          return true;
        } if (code < 97) {
          return code === 95;
        } if (code < 123) {
          return true;
        } if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        } if (astral === false) {
          return false;
        } return isInAstralSet(code, astralIdentifierStartCodes);
      }

      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        } if (code < 58) {
          return true;
        } if (code < 65) {
          return false;
        } if (code < 91) {
          return true;
        } if (code < 97) {
          return code === 95;
        } if (code < 123) {
          return true;
        } if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        } if (astral === false) {
          return false;
        } return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }

    }, {}], 4: [function (require, module, exports) {
      "use strict";

      var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      // The `getLineInfo` function is mostly useful when the
      // `locations` option is off (for performance reasons) and you
      // want to find the line/column position for a given character
      // offset. `input` should be the code string that the offset refers
      // into.

      exports.getLineInfo = getLineInfo;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var Parser = require("./state").Parser;

      var lineBreakG = require("./whitespace").lineBreakG;

      // These are used when `options.locations` is on, for the
      // `startLoc` and `endLoc` properties.

      var Position = exports.Position = (function () {
        function Position(line, col) {
          _classCallCheck(this, Position);

          this.line = line;
          this.column = col;
        }

        _createClass(Position, {
          offset: {
            value: function offset(n) {
              return new Position(this.line, this.column + n);
            }
          }
        });

        return Position;
      })();

      var SourceLocation = exports.SourceLocation = function SourceLocation(p, start, end) {
        _classCallCheck(this, SourceLocation);

        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) this.source = p.sourceFile;
      };

      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ;) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur);
          }
        }
      }

      var pp = Parser.prototype;

      // This function is used to raise exceptions on parse errors. It
      // takes an offset integer (into the current `input`) to indicate
      // the location of the error, attaches the position to the end
      // of the error message, and then raises a `SyntaxError` with that
      // message.

      pp.raise = function (pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
        throw err;
      };

      pp.curPosition = function () {
        return new Position(this.curLine, this.pos - this.lineStart);
      };

      pp.markPosition = function () {
        return this.options.locations ? [this.start, this.startLoc] : this.start;
      };

    }, { "./state": 9, "./whitespace": 15 }], 5: [function (require, module, exports) {
      "use strict";

      var tt = require("./tokentype").types;

      var Parser = require("./state").Parser;

      var reservedWords = require("./identifier").reservedWords;

      var has = require("./util").has;

      var pp = Parser.prototype;

      // Convert existing expression atom to assignable pattern
      // if possible.

      pp.toAssignable = function (node, isBinding) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
              break;

            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (var i = 0; i < node.properties.length; i++) {
                var prop = node.properties[i];
                if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                this.toAssignable(prop.value, isBinding);
              }
              break;

            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, isBinding);
              break;

            case "AssignmentExpression":
              if (node.operator === "=") {
                node.type = "AssignmentPattern";
              } else {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              break;

            case "MemberExpression":
              if (!isBinding) break;

            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        }
        return node;
      };

      // Convert list of expression atoms to binding list.

      pp.toAssignableList = function (exprList, isBinding) {
        var end = exprList.length;
        if (end) {
          var last = exprList[end - 1];
          if (last && last.type == "RestElement") {
            --end;
          } else if (last && last.type == "SpreadElement") {
            last.type = "RestElement";
            var arg = last.argument;
            this.toAssignable(arg, isBinding);
            if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
            --end;
          }
        }
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) this.toAssignable(elt, isBinding);
        }
        return exprList;
      };

      // Parses spread element.

      pp.parseSpread = function (refShorthandDefaultPos) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(refShorthandDefaultPos);
        return this.finishNode(node, "SpreadElement");
      };

      pp.parseRest = function () {
        var node = this.startNode();
        this.next();
        node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();
        return this.finishNode(node, "RestElement");
      };

      // Parses lvalue (assignable) atom.

      pp.parseBindingAtom = function () {
        if (this.options.ecmaVersion < 6) return this.parseIdent();
        switch (this.type) {
          case tt.name:
            return this.parseIdent();

          case tt.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(tt.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");

          case tt.braceL:
            return this.parseObj(true);

          default:
            this.unexpected();
        }
      };

      pp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
        var elts = [],
          first = true;
        while (!this.eat(close)) {
          if (first) first = false; else this.expect(tt.comma);
          if (allowEmpty && this.type === tt.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === tt.ellipsis) {
            elts.push(this.parseRest());
            this.expect(close);
            break;
          } else {
            elts.push(this.parseMaybeDefault());
          }
        }
        return elts;
      };

      // Parses assignment pattern around given atom if possible.

      pp.parseMaybeDefault = function (startPos, left) {
        startPos = startPos || this.markPosition();
        left = left || this.parseBindingAtom();
        if (!this.eat(tt.eq)) return left;
        var node = this.startNodeAt(startPos);
        node.operator = "=";
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };

      // Verify that a node is an lval — something that can be assigned
      // to.

      pp.checkLVal = function (expr, isBinding, checkClashes) {
        switch (expr.type) {
          case "Identifier":
            if (this.strict && (reservedWords.strictBind(expr.name) || reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            if (checkClashes) {
              if (has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash in strict mode");
              checkClashes[expr.name] = true;
            }
            break;

          case "MemberExpression":
            if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
            break;

          case "ObjectPattern":
            for (var i = 0; i < expr.properties.length; i++) {
              this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
            } break;

          case "ArrayPattern":
            for (var i = 0; i < expr.elements.length; i++) {
              var elem = expr.elements[i];
              if (elem) this.checkLVal(elem, isBinding, checkClashes);
            }
            break;

          case "AssignmentPattern":
            this.checkLVal(expr.left, isBinding, checkClashes);
            break;

          case "RestElement":
            this.checkLVal(expr.argument, isBinding, checkClashes);
            break;

          default:
            this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
        }
      };

    }, { "./identifier": 3, "./state": 9, "./tokentype": 13, "./util": 14 }], 6: [function (require, module, exports) {
      "use strict";

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var Parser = require("./state").Parser;

      var SourceLocation = require("./location").SourceLocation;

      // Start an AST node, attaching a start offset.

      var pp = Parser.prototype;

      var Node = exports.Node = function Node() {
        _classCallCheck(this, Node);
      };

      pp.startNode = function () {
        var node = new Node();
        node.start = this.start;
        if (this.options.locations) node.loc = new SourceLocation(this, this.startLoc);
        if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
        if (this.options.ranges) node.range = [this.start, 0];
        return node;
      };

      pp.startNodeAt = function (pos) {
        var node = new Node(),
          start = pos;
        if (this.options.locations) {
          node.loc = new SourceLocation(this, start[1]);
          start = pos[0];
        }
        node.start = start;
        if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
        if (this.options.ranges) node.range = [start, 0];
        return node;
      };

      // Finish an AST node, adding `type` and `end` properties.

      pp.finishNode = function (node, type) {
        node.type = type;
        node.end = this.lastTokEnd;
        if (this.options.locations) node.loc.end = this.lastTokEndLoc;
        if (this.options.ranges) node.range[1] = this.lastTokEnd;
        return node;
      };

      // Finish node at given position

      pp.finishNodeAt = function (node, type, pos) {
        if (this.options.locations) {
          node.loc.end = pos[1]; pos = pos[0];
        }
        node.type = type;
        node.end = pos;
        if (this.options.ranges) node.range[1] = pos;
        return node;
      };

    }, { "./location": 4, "./state": 9 }], 7: [function (require, module, exports) {


      // Interpret and default an options object

      "use strict";

      exports.getOptions = getOptions;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _util = require("./util");

      var has = _util.has;
      var isArray = _util.isArray;

      var SourceLocation = require("./location").SourceLocation;

      // A second optional argument can be given to further configure
      // the parser process. These options are recognized:

      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must
        // be either 3, or 5, or 6. This influences support for strict
        // mode, the set of reserved words, support for getters and
        // setters and other features.
        ecmaVersion: 5,
        // Source type ("script" or "module") for different semantics
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // th position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are not enforced. Disable
        // `allowReserved` to enforce them. When this option has the
        // value "never", reserved words and keywords can also not be
        // used as property names.
        allowReserved: true,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program.
        allowImportExportEverywhere: false,
        // When enabled, hashbang directive in the beginning of file
        // is allowed and treated as a line comment.
        allowHashBang: false,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokenize() returns. Note that you are not
        // allowed to call the parser from the callback—that will
        // corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false,
        plugins: {}
      }; exports.defaultOptions = defaultOptions;

      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
        } if (isArray(options.onToken)) {
          (function () {
            var tokens = options.onToken;
            options.onToken = function (token) {
              return tokens.push(token);
            };
          })();
        }
        if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

        return options;
      }

      function pushComment(options, array) {
        return function (block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
          if (options.ranges) comment.range = [start, end];
          array.push(comment);
        };
      }

    }, { "./location": 4, "./util": 14 }], 8: [function (require, module, exports) {
      "use strict";

      var tt = require("./tokentype").types;

      var Parser = require("./state").Parser;

      var lineBreak = require("./whitespace").lineBreak;

      var pp = Parser.prototype;

      // ## Parser utilities

      // Test whether a statement node is the string literal `"use strict"`.

      pp.isUseStrict = function (stmt) {
        return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
      };

      // Predicate that tests whether the next token is of the given
      // type, and if yes, consumes it as a side effect.

      pp.eat = function (type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };

      // Tests whether parsed token is a contextual keyword.

      pp.isContextual = function (name) {
        return this.type === tt.name && this.value === name;
      };

      // Consumes contextual keyword if possible.

      pp.eatContextual = function (name) {
        return this.value === name && this.eat(tt.name);
      };

      // Asserts that following token is given contextual keyword.

      pp.expectContextual = function (name) {
        if (!this.eatContextual(name)) this.unexpected();
      };

      // Test whether a semicolon can be inserted at the current position.

      pp.canInsertSemicolon = function () {
        return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };

      pp.insertSemicolon = function () {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          return true;
        }
      };

      // Consume a semicolon, or, failing that, see if we are allowed to
      // pretend that there is a semicolon at this position.

      pp.semicolon = function () {
        if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
      };

      pp.afterTrailingComma = function (tokType) {
        if (this.type == tokType) {
          if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          this.next();
          return true;
        }
      };

      // Expect a token of a given type. If found, consume it, otherwise,
      // raise an unexpected token error.

      pp.expect = function (type) {
        this.eat(type) || this.unexpected();
      };

      // Raise an unexpected token error.

      pp.unexpected = function (pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };

    }, { "./state": 9, "./tokentype": 13, "./whitespace": 15 }], 9: [function (require, module, exports) {
      "use strict";

      exports.Parser = Parser;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _identifier = require("./identifier");

      var reservedWords = _identifier.reservedWords;
      var keywords = _identifier.keywords;

      var _tokentype = require("./tokentype");

      var tt = _tokentype.types;
      var lineBreak = _tokentype.lineBreak;

      function Parser(options, input, startPos) {
        this.options = options;
        this.loadPlugins(this.options.plugins);
        this.sourceFile = this.options.sourceFile || null;
        this.isKeyword = keywords[this.options.ecmaVersion >= 6 ? 6 : 5];
        this.isReservedWord = reservedWords[this.options.ecmaVersion];
        this.input = input;

        // Set up token state

        // The current position of the tokenizer in the input.
        if (startPos) {
          this.pos = startPos;
          this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }

        // Properties of the current token:
        // Its type
        this.type = tt.eof;
        // For tokens that include more information than their type, the value
        this.value = null;
        // Its start and end offset
        this.start = this.end = this.pos;
        // And, if locations are used, the {line, column} object
        // corresponding to those offsets
        this.startLoc = this.endLoc = null;

        // Position information for the previous token
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;

        // The context stack is used to superficially track syntactic
        // context to predict whether a regular expression is allowed in a
        // given position.
        this.context = this.initialContext();
        this.exprAllowed = true;

        // Figure out if it's a module code.
        this.strict = this.inModule = this.options.sourceType === "module";

        // Flags to track whether we are in a function, a generator.
        this.inFunction = this.inGenerator = false;
        // Labels in scope.
        this.labels = [];

        // If enabled, skip leading hashbang line.
        if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
      }

      Parser.prototype.extend = function (name, f) {
        this[name] = f(this[name]);
      };

      // Registered plugins

      var plugins = {};

      exports.plugins = plugins;
      Parser.prototype.loadPlugins = function (plugins) {
        for (var _name in plugins) {
          var plugin = exports.plugins[_name];
          if (!plugin) throw new Error("Plugin '" + _name + "' not found");
          plugin(this, plugins[_name]);
        }
      };

    }, { "./identifier": 3, "./tokentype": 13 }], 10: [function (require, module, exports) {
      "use strict";

      var tt = require("./tokentype").types;

      var Parser = require("./state").Parser;

      var lineBreak = require("./whitespace").lineBreak;

      var pp = Parser.prototype;

      // ### Statement parsing

      // Parse a program. Initializes the parser, reads any number of
      // statements, and wraps them in a Program node.  Optionally takes a
      // `program` argument.  If present, the statements will be appended
      // to its body instead of creating a new node.

      pp.parseTopLevel = function (node) {
        var first = true;
        if (!node.body) node.body = [];
        while (this.type !== tt.eof) {
          var stmt = this.parseStatement(true, true);
          node.body.push(stmt);
          if (first && this.isUseStrict(stmt)) this.setStrict(true);
          first = false;
        }
        this.next();
        if (this.options.ecmaVersion >= 6) {
          node.sourceType = this.options.sourceType;
        }
        return this.finishNode(node, "Program");
      };

      var loopLabel = { kind: "loop" },
        switchLabel = { kind: "switch" };

      // Parse a single statement.
      //
      // If expecting a statement and finding a slash operator, parse a
      // regular expression literal. This is to handle cases like
      // `if (foo) /blah/.exec(foo)`, where looking at the previous token
      // does not help.

      pp.parseStatement = function (declaration, topLevel) {
        var starttype = this.type,
          node = this.startNode();

        // Most types of statements are recognized by the keyword they
        // start with. Many are trivial to parse, some require a bit of
        // complexity.

        switch (starttype) {
          case tt._break: case tt._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case tt._debugger:
            return this.parseDebuggerStatement(node);
          case tt._do:
            return this.parseDoStatement(node);
          case tt._for:
            return this.parseForStatement(node);
          case tt._function:
            if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
            return this.parseFunctionStatement(node);
          case tt._class:
            if (!declaration) this.unexpected();
            return this.parseClass(node, true);
          case tt._if:
            return this.parseIfStatement(node);
          case tt._return:
            return this.parseReturnStatement(node);
          case tt._switch:
            return this.parseSwitchStatement(node);
          case tt._throw:
            return this.parseThrowStatement(node);
          case tt._try:
            return this.parseTryStatement(node);
          case tt._let: case tt._const:
            if (!declaration) this.unexpected(); // NOTE: falls through to _var
          case tt._var:
            return this.parseVarStatement(node, starttype);
          case tt._while:
            return this.parseWhileStatement(node);
          case tt._with:
            return this.parseWithStatement(node);
          case tt.braceL:
            return this.parseBlock();
          case tt.semi:
            return this.parseEmptyStatement(node);
          case tt._export:
          case tt._import:
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
              if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
            return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);

          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            var maybeName = this.value,
              expr = this.parseExpression();
            if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr); else return this.parseExpressionStatement(node, expr);
        }
      };

      pp.parseBreakContinueStatement = function (node, keyword) {
        var isBreak = keyword == "break";
        this.next();
        if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null; else if (this.type !== tt.name) this.unexpected(); else {
          node.label = this.parseIdent();
          this.semicolon();
        }

        // Verify that there is an actual destination to break or
        // continue to.
        for (var i = 0; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
            if (node.label && isBreak) break;
          }
        }
        if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };

      pp.parseDebuggerStatement = function (node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };

      pp.parseDoStatement = function (node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement(false);
        this.labels.pop();
        this.expect(tt._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) this.eat(tt.semi); else this.semicolon();
        return this.finishNode(node, "DoWhileStatement");
      };

      // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
      // loop is non-trivial. Basically, we have to parse the init `var`
      // statement or expression, disallowing the `in` operator (see
      // the second parameter to `parseExpression`), and then check
      // whether the next token is `in` or `of`. When there is no init
      // part (semicolon immediately after the opening parenthesis), it
      // is a regular `for` loop.

      pp.parseForStatement = function (node) {
        this.next();
        this.labels.push(loopLabel);
        this.expect(tt.parenL);
        if (this.type === tt.semi) return this.parseFor(node, null);
        if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {
          var _init = this.startNode(),
            varKind = this.type;
          this.next();
          this.parseVar(_init, true, varKind);
          this.finishNode(_init, "VariableDeclaration");
          if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== tt._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
          return this.parseFor(node, _init);
        }
        var refShorthandDefaultPos = { start: 0 };
        var init = this.parseExpression(true, refShorthandDefaultPos);
        if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
          this.toAssignable(init);
          this.checkLVal(init);
          return this.parseForIn(node, init);
        } else if (refShorthandDefaultPos.start) {
          this.unexpected(refShorthandDefaultPos.start);
        }
        return this.parseFor(node, init);
      };

      pp.parseFunctionStatement = function (node) {
        this.next();
        return this.parseFunction(node, true);
      };

      pp.parseIfStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement(false);
        node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
        return this.finishNode(node, "IfStatement");
      };

      pp.parseReturnStatement = function (node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
        this.next();

        // In `return` (and `break`/`continue`), the keywords with
        // optional arguments, we eagerly look for a semicolon or the
        // possibility to insert one.

        if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null; else {
          node.argument = this.parseExpression(); this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };

      pp.parseSwitchStatement = function (node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(tt.braceL);
        this.labels.push(switchLabel);

        // Statements under must be grouped (by label) in SwitchCase
        // nodes. `cur` is used to keep the node that we are currently
        // adding statements to.

        for (var cur, sawDefault; this.type != tt.braceR;) {
          if (this.type === tt._case || this.type === tt._default) {
            var isCase = this.type === tt._case;
            if (cur) this.finishNode(cur, "SwitchCase");
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
              sawDefault = true;
              cur.test = null;
            }
            this.expect(tt.colon);
          } else {
            if (!cur) this.unexpected();
            cur.consequent.push(this.parseStatement(true));
          }
        }
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next(); // Closing brace
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };

      pp.parseThrowStatement = function (node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };

      // Reused empty array added for node fields that are always empty.

      var empty = [];

      pp.parseTryStatement = function (node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === tt._catch) {
          var clause = this.startNode();
          this.next();
          this.expect(tt.parenL);
          clause.param = this.parseBindingAtom();
          this.checkLVal(clause.param, true);
          this.expect(tt.parenR);
          clause.guard = null;
          clause.body = this.parseBlock();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.guardedHandlers = empty;
        node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
        return this.finishNode(node, "TryStatement");
      };

      pp.parseVarStatement = function (node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };

      pp.parseWhileStatement = function (node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement(false);
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };

      pp.parseWithStatement = function (node) {
        if (this.strict) this.raise(this.start, "'with' in strict mode");
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement(false);
        return this.finishNode(node, "WithStatement");
      };

      pp.parseEmptyStatement = function (node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };

      pp.parseLabeledStatement = function (node, maybeName, expr) {
        for (var i = 0; i < this.labels.length; ++i) {
          if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        } var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
        this.labels.push({ name: maybeName, kind: kind });
        node.body = this.parseStatement(true);
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };

      pp.parseExpressionStatement = function (node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };

      // Parse a semicolon-enclosed block of statements, handling `"use
      // strict"` declarations when `allowStrict` is true (used for
      // function bodies).

      pp.parseBlock = function (allowStrict) {
        var node = this.startNode(),
          first = true,
          oldStrict = undefined;
        node.body = [];
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          var stmt = this.parseStatement(true);
          node.body.push(stmt);
          if (first && allowStrict && this.isUseStrict(stmt)) {
            oldStrict = this.strict;
            this.setStrict(this.strict = true);
          }
          first = false;
        }
        if (oldStrict === false) this.setStrict(false);
        return this.finishNode(node, "BlockStatement");
      };

      // Parse a regular `for` loop. The disambiguation code in
      // `parseStatement` will already have parsed the init statement or
      // expression.

      pp.parseFor = function (node, init) {
        node.init = init;
        this.expect(tt.semi);
        node.test = this.type === tt.semi ? null : this.parseExpression();
        this.expect(tt.semi);
        node.update = this.type === tt.parenR ? null : this.parseExpression();
        this.expect(tt.parenR);
        node.body = this.parseStatement(false);
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };

      // Parse a `for`/`in` and `for`/`of` loop, which are almost
      // same from parser's perspective.

      pp.parseForIn = function (node, init) {
        var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
        this.next();
        node.left = init;
        node.right = this.parseExpression();
        this.expect(tt.parenR);
        node.body = this.parseStatement(false);
        this.labels.pop();
        return this.finishNode(node, type);
      };

      // Parse a list of variable declarations.

      pp.parseVar = function (node, isFor, kind) {
        node.declarations = [];
        node.kind = kind.keyword;
        for (; ;) {
          var decl = this.startNode();
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, true);
          if (this.eat(tt.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === tt._const && !(this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type != "Identifier" && !(isFor && (this.type === tt._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(tt.comma)) break;
        }
        return node;
      };

      // Parse a function declaration or literal (depending on the
      // `isStatement` parameter).

      pp.parseFunction = function (node, isStatement, allowExpressionBody) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);
        if (isStatement || this.type === tt.name) node.id = this.parseIdent();
        this.expect(tt.parenL);
        node.params = this.parseBindingList(tt.parenR, false, false);
        this.parseFunctionBody(node, allowExpressionBody);
        return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      };

      // Parse a class declaration or literal (depending on the
      // `isStatement` parameter).

      pp.parseClass = function (node, isStatement) {
        this.next();
        node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
        node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
        var classBody = this.startNode();
        classBody.body = [];
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (this.eat(tt.semi)) continue;
          var method = this.startNode();
          var isGenerator = this.eat(tt.star);
          this.parsePropertyName(method);
          if (this.type !== tt.parenL && !method.computed && method.key.type === "Identifier" && method.key.name === "static") {
            if (isGenerator) this.unexpected();
            method["static"] = true;
            isGenerator = this.eat(tt.star);
            this.parsePropertyName(method);
          } else {
            method["static"] = false;
          }
          method.kind = "method";
          if (!method.computed && !isGenerator) {
            if (method.key.type === "Identifier") {
              if (this.type !== tt.parenL && (method.key.name === "get" || method.key.name === "set")) {
                method.kind = method.key.name;
                this.parsePropertyName(method);
              } else if (!method["static"] && method.key.name === "constructor") {
                method.kind = "constructor";
              }
            } else if (!method["static"] && method.key.type === "Literal" && method.key.value === "constructor") {
              method.kind = "constructor";
            }
          }
          method.value = this.parseMethod(isGenerator);
          classBody.body.push(this.finishNode(method, "MethodDefinition"));
        }
        node.body = this.finishNode(classBody, "ClassBody");
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };

      // Parses module export declaration.

      pp.parseExport = function (node) {
        this.next();
        // export * from '...'
        if (this.eat(tt.star)) {
          this.expectContextual("from");
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(tt._default)) {
          // export default ...
          var expr = this.parseMaybeAssign();
          var needsSemi = true;
          if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
            needsSemi = false;
            if (expr.id) {
              expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
            }
          }
          node.declaration = expr;
          if (needsSemi) this.semicolon();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        // export var|const|let|function|class ...
        if (this.type.keyword) {
          node.declaration = this.parseStatement(true);
          node.specifiers = [];
          node.source = null;
        } else {
          // export { x, y as z } [from '...']
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers();
          if (this.eatContextual("from")) {
            node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
          } else {
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };

      // Parses a comma-separated list of module exports.

      pp.parseExportSpecifiers = function () {
        var nodes = [],
          first = true;
        // export { x, y as z } [from '...']
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (!first) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first = false;

          var node = this.startNode();
          node.local = this.parseIdent(this.type === tt._default);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      };

      // Parses import declaration.

      pp.parseImport = function (node) {
        this.next();
        // import '...'
        if (this.type === tt.string) {
          node.specifiers = empty;
          node.source = this.parseExprAtom();
          node.kind = "";
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      // Parses a comma-separated list of module imports.

      pp.parseImportSpecifiers = function () {
        var nodes = [],
          first = true;
        if (this.type === tt.name) {
          // import defaultObj, { x, y as z } from '...'
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLVal(node.local, true);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(tt.comma)) return nodes;
        }
        if (this.type === tt.star) {
          var node = this.startNode();
          this.next();
          this.expectContextual("as");
          node.local = this.parseIdent();
          this.checkLVal(node.local, true);
          nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (!first) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first = false;

          var node = this.startNode();
          node.imported = this.parseIdent(true);
          node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
          this.checkLVal(node.local, true);
          nodes.push(this.finishNode(node, "ImportSpecifier"));
        }
        return nodes;
      };

    }, { "./state": 9, "./tokentype": 13, "./whitespace": 15 }], 11: [function (require, module, exports) {
      "use strict";

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // The algorithm used to determine whether a regexp can appear at a
      // given point in the program is loosely based on sweet.js' approach.
      // See https://github.com/mozilla/sweet.js/wiki/design

      var Parser = require("./state").Parser;

      var tt = require("./tokentype").types;

      var lineBreak = require("./whitespace").lineBreak;

      var TokContext = exports.TokContext = function TokContext(token, isExpr, preserveSpace, override) {
        _classCallCheck(this, TokContext);

        this.token = token;
        this.isExpr = isExpr;
        this.preserveSpace = preserveSpace;
        this.override = override;
      };

      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", true),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function (p) {
          return p.readTmplToken();
        }),
        f_expr: new TokContext("function", true)
      };

      exports.types = types;
      var pp = Parser.prototype;

      pp.initialContext = function () {
        return [types.b_stat];
      };

      pp.braceIsBlock = function (prevType) {
        var parent = undefined;
        if (prevType === tt.colon && (parent = this.curContext()).token == "{") return !parent.isExpr;
        if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof) return true;
        if (prevType == tt.braceL) return this.curContext() === types.b_stat;
        return !this.exprAllowed;
      };

      pp.updateContext = function (prevType) {
        var update = undefined,
          type = this.type;
        if (type.keyword && prevType == tt.dot) this.exprAllowed = false; else if (update = type.updateContext) update.call(this, prevType); else this.exprAllowed = type.beforeExpr;
      };

      // Token-specific context update code

      tt.parenR.updateContext = tt.braceR.updateContext = function () {
        if (this.context.length == 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext() === types.f_expr) {
          this.context.pop();
          this.exprAllowed = false;
        } else if (out === types.b_tmpl) {
          this.exprAllowed = true;
        } else {
          this.exprAllowed = !out.isExpr;
        }
      };

      tt.braceL.updateContext = function (prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };

      tt.dollarBraceL.updateContext = function () {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };

      tt.parenL.updateContext = function (prevType) {
        var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };

      tt.incDec.updateContext = function () { };

      tt._function.updateContext = function () {
        if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
        this.exprAllowed = false;
      };

      tt.backQuote.updateContext = function () {
        if (this.curContext() === types.q_tmpl) this.context.pop(); else this.context.push(types.q_tmpl);
        this.exprAllowed = false;
      };

      // tokExprAllowed stays unchanged

    }, { "./state": 9, "./tokentype": 13, "./whitespace": 15 }], 12: [function (require, module, exports) {
      "use strict";

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _identifier = require("./identifier");

      var isIdentifierStart = _identifier.isIdentifierStart;
      var isIdentifierChar = _identifier.isIdentifierChar;

      var _tokentype = require("./tokentype");

      var tt = _tokentype.types;
      var keywordTypes = _tokentype.keywords;

      var Parser = require("./state").Parser;

      var SourceLocation = require("./location").SourceLocation;

      var _whitespace = require("./whitespace");

      var lineBreak = _whitespace.lineBreak;
      var lineBreakG = _whitespace.lineBreakG;
      var isNewLine = _whitespace.isNewLine;
      var nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;

      // Object type used to represent tokens. Note that normally, tokens
      // simply exist as properties on the parser object. This is only
      // used for the onToken callback and the external tokenizer.

      var Token = exports.Token = function Token(p) {
        _classCallCheck(this, Token);

        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        if (p.options.ranges) this.range = [p.start, p.end];
      };

      // ## Tokenizer

      var pp = Parser.prototype;

      // Move to the next token

      pp.next = function () {
        if (this.options.onToken) this.options.onToken(new Token(this));

        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };

      pp.getToken = function () {
        this.next();
        return new Token(this);
      };

      // If we're in an ES6 environment, make parsers iterable
      if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
        var self = this;
        return {
          next: function next() {
            var token = self.getToken();
            return {
              done: token.type === tt.eof,
              value: token
            };
          }
        };
      };

      // Toggle strict mode. Re-reads the next number or string to please
      // pedantic tests (`"use strict"; 010;` should fail).

      pp.setStrict = function (strict) {
        this.strict = strict;
        if (this.type !== tt.num && this.type !== tt.string) return;
        this.pos = this.start;
        if (this.options.locations) {
          while (this.pos < this.lineStart) {
            this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
            --this.curLine;
          }
        }
        this.nextToken();
      };

      pp.curContext = function () {
        return this.context[this.context.length - 1];
      };

      // Read a single token, updating the parser object's token-related
      // properties.

      pp.nextToken = function () {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) this.skipSpace();

        this.start = this.pos;
        if (this.options.locations) this.startLoc = this.curPosition();
        if (this.pos >= this.input.length) return this.finishToken(tt.eof);

        if (curContext.override) return curContext.override(this); else this.readToken(this.fullCharCodeAtPos());
      };

      pp.readToken = function (code) {
        // Identifier or keyword. '\uXXXX' sequences are allowed in
        // identifiers, so '\' also dispatches to that.
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

        return this.getTokenFromCode(code);
      };

      pp.fullCharCodeAtPos = function () {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 57344) return code;
        var next = this.input.charCodeAt(this.pos + 1);
        return (code << 10) + next - 56613888;
      };

      pp.skipBlockComment = function () {
        var startLoc = this.options.onComment && this.options.locations && this.curPosition();
        var start = this.pos,
          end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match = undefined;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.options.locations && this.curPosition());
      };

      pp.skipLineComment = function (startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.options.locations && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
          ++this.pos;
          ch = this.input.charCodeAt(this.pos);
        }
        if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.options.locations && this.curPosition());
      };

      // Called at the start of the parse and after every token. Skips
      // whitespace and comments, and.

      pp.skipSpace = function () {
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 32) {
            // ' '
            ++this.pos;
          } else if (ch === 13) {
            ++this.pos;
            var next = this.input.charCodeAt(this.pos);
            if (next === 10) {
              ++this.pos;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
          } else if (ch === 10 || ch === 8232 || ch === 8233) {
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
          } else if (ch > 8 && ch < 14) {
            ++this.pos;
          } else if (ch === 47) {
            // '/'
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 42) {
              // '*'
              this.skipBlockComment();
            } else if (next === 47) {
              // '/'
              this.skipLineComment(2);
            } else break;
          } else if (ch === 160) {
            // '\xa0'
            ++this.pos;
          } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break;
          }
        }
      };

      // Called at the end of every token. Sets `end`, `val`, and
      // maintains `context` and `exprAllowed`, and skips the space after
      // the token, so that the next one's `start` will point at the
      // right position.

      pp.finishToken = function (type, val) {
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        var prevType = this.type;
        this.type = type;
        this.value = val;

        this.updateContext(prevType);
      };

      // ### Token reading

      // This is the function that is called to fetch the next token. It
      // is somewhat obscure, because it works in character codes rather
      // than characters, and because operator parsing has been inlined
      // into it.
      //
      // All in the name of speed.
      //
      pp.readToken_dot = function () {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) return this.readNumber(true);
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          // 46 = dot '.'
          this.pos += 3;
          return this.finishToken(tt.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(tt.dot);
        }
      };

      pp.readToken_slash = function () {
        // '/'
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos; return this.readRegexp();
        }
        if (next === 61) return this.finishOp(tt.assign, 2);
        return this.finishOp(tt.slash, 1);
      };

      pp.readToken_mult_modulo = function (code) {
        // '%*'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(tt.assign, 2);
        return this.finishOp(code === 42 ? tt.star : tt.modulo, 1);
      };

      pp.readToken_pipe_amp = function (code) {
        // '|&'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);
        if (next === 61) return this.finishOp(tt.assign, 2);
        return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);
      };

      pp.readToken_caret = function () {
        // '^'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(tt.assign, 2);
        return this.finishOp(tt.bitwiseXOR, 1);
      };

      pp.readToken_plus_min = function (code) {
        // '+-'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
            // A `-->` line comment
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(tt.incDec, 2);
        }
        if (next === 61) return this.finishOp(tt.assign, 2);
        return this.finishOp(tt.plusMin, 1);
      };

      pp.readToken_lt_gt = function (code) {
        // '<>'
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);
          return this.finishOp(tt.bitShift, size);
        }
        if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
          if (this.inModule) unexpected();
          // `<!--`, an XML-style comment that should be interpreted as a line comment
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
        return this.finishOp(tt.relational, size);
      };

      pp.readToken_eq_excl = function (code) {
        // '=!'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          // '=>'
          this.pos += 2;
          return this.finishToken(tt.arrow);
        }
        return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);
      };

      pp.getTokenFromCode = function (code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            // '.'
            return this.readToken_dot();

          // Punctuation tokens.
          case 40:
            ++this.pos; return this.finishToken(tt.parenL);
          case 41:
            ++this.pos; return this.finishToken(tt.parenR);
          case 59:
            ++this.pos; return this.finishToken(tt.semi);
          case 44:
            ++this.pos; return this.finishToken(tt.comma);
          case 91:
            ++this.pos; return this.finishToken(tt.bracketL);
          case 93:
            ++this.pos; return this.finishToken(tt.bracketR);
          case 123:
            ++this.pos; return this.finishToken(tt.braceL);
          case 125:
            ++this.pos; return this.finishToken(tt.braceR);
          case 58:
            ++this.pos; return this.finishToken(tt.colon);
          case 63:
            ++this.pos; return this.finishToken(tt.question);

          case 96:
            // '`'
            if (this.options.ecmaVersion < 6) break;
            ++this.pos;
            return this.finishToken(tt.backQuote);

          case 48:
            // '0'
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
              if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
            // 1-9
            return this.readNumber(false);

          // Quotes produce strings.
          case 34: case 39:
            // '"', "'"
            return this.readString(code);

          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.

          case 47:
            // '/'
            return this.readToken_slash();

          case 37: case 42:
            // '%*'
            return this.readToken_mult_modulo(code);

          case 124: case 38:
            // '|&'
            return this.readToken_pipe_amp(code);

          case 94:
            // '^'
            return this.readToken_caret();

          case 43: case 45:
            // '+-'
            return this.readToken_plus_min(code);

          case 60: case 62:
            // '<>'
            return this.readToken_lt_gt(code);

          case 61: case 33:
            // '=!'
            return this.readToken_eq_excl(code);

          case 126:
            // '~'
            return this.finishOp(tt.prefix, 1);
        }

        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };

      pp.finishOp = function (type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };

      var regexpUnicodeSupport = false;
      try {
        new RegExp("￿", "u"); regexpUnicodeSupport = true;
      } catch (e) { }

      // Parse a regular expression. Some context-awareness is necessary,
      // since a '/' inside a '[]' set does not end the expression.

      pp.readRegexp = function () {
        var escaped = undefined,
          inClass = undefined,
          start = this.pos;
        for (; ;) {
          if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
          if (!escaped) {
            if (ch === "[") inClass = true; else if (ch === "]" && inClass) inClass = false; else if (ch === "/" && !inClass) break;
            escaped = ch === "\\";
          } else escaped = false;
          ++this.pos;
        }
        var content = this.input.slice(start, this.pos);
        ++this.pos;
        // Need to use `readWord1` because '\uXXXX' sequences are allowed
        // here (don't ask).
        var mods = this.readWord1();
        var tmp = content;
        if (mods) {
          var validFlags = /^[gmsiy]*$/;
          if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
          if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
          if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
            // Replace each astral symbol and every Unicode escape sequence that
            // possibly represents an astral symbol or a paired surrogate with a
            // single ASCII symbol to avoid throwing on regular expressions that
            // are only valid in combination with the `/u` flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it would
            // be replaced by `[x-b]` which throws an error.
            tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|\\u\{([0-9a-fA-F]+)\}|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
          }
        }
        // Detect invalid regular expressions.
        try {
          new RegExp(tmp);
        } catch (e) {
          if (e instanceof SyntaxError) this.raise(start, "Error parsing regular expression: " + e.message);
          this.raise(e);
        }
        // Get a regular expression object for this pattern-flag pair, or `null` in
        // case the current environment doesn't support the flags it uses.
        var value = undefined;
        try {
          value = new RegExp(content, mods);
        } catch (err) {
          value = null;
        }
        return this.finishToken(tt.regexp, { pattern: content, flags: mods, value: value });
      };

      // Read an integer in the given radix. Return null if zero digits
      // were read, the integer value otherwise. When `len` is given, this
      // will return `null` unless the integer has exactly `len` digits.

      pp.readInt = function (radix, len) {
        var start = this.pos,
          total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = this.input.charCodeAt(this.pos),
            val = undefined;
          if (code >= 97) val = code - 97 + 10; // a
          else if (code >= 65) val = code - 65 + 10; // A
          else if (code >= 48 && code <= 57) val = code - 48; // 0-9
          else val = Infinity;
          if (val >= radix) break;
          ++this.pos;
          total = total * radix + val;
        }
        if (this.pos === start || len != null && this.pos - start !== len) return null;

        return total;
      };

      pp.readRadixNumber = function (radix) {
        this.pos += 2; // 0x
        var val = this.readInt(radix);
        if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(tt.num, val);
      };

      // Read an integer, octal integer, or floating-point number.

      pp.readNumber = function (startsWithDot) {
        var start = this.pos,
          isFloat = false,
          octal = this.input.charCodeAt(this.pos) === 48;
        if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
        if (this.input.charCodeAt(this.pos) === 46) {
          ++this.pos;
          this.readInt(10);
          isFloat = true;
        }
        var next = this.input.charCodeAt(this.pos);
        if (next === 69 || next === 101) {
          // 'eE'
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) ++this.pos; // '+-'
          if (this.readInt(10) === null) this.raise(start, "Invalid number");
          isFloat = true;
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

        var str = this.input.slice(start, this.pos),
          val = undefined;
        if (isFloat) val = parseFloat(str); else if (!octal || str.length === 1) val = parseInt(str, 10); else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number"); else val = parseInt(str, 8);
        return this.finishToken(tt.num, val);
      };

      // Read a string value, interpreting backslash-escapes.

      pp.readCodePoint = function () {
        var ch = this.input.charCodeAt(this.pos),
          code = undefined;

        if (ch === 123) {
          if (this.options.ecmaVersion < 6) this.unexpected();
          ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) this.unexpected();
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };

      function codePointToString(code) {
        // UTF-16 Decoding
        if (code <= 65535) {
          return String.fromCharCode(code);
        } return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
      }

      pp.readString = function (quote) {
        var out = "",
          chunkStart = ++this.pos;
        for (; ;) {
          if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) break;
          if (ch === 92) {
            // '\'
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar();
            chunkStart = this.pos;
          } else {
            if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(tt.string, out);
      };

      // Reads template string tokens.

      pp.readTmplToken = function () {
        var out = "",
          chunkStart = this.pos;
        for (; ;) {
          if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            // '`', '${'
            if (this.pos === this.start && this.type === tt.template) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(tt.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(tt.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tt.template, out);
          }
          if (ch === 92) {
            // '\'
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar();
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
              out += "\n";
            } else {
              out += String.fromCharCode(ch);
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };

      // Used to read escaped characters

      pp.readEscapedChar = function () {
        var ch = this.input.charCodeAt(++this.pos);
        var octal = /^[0-7]+/.exec(this.input.slice(this.pos, this.pos + 3));
        if (octal) octal = octal[0];
        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
        if (octal === "0") octal = null;
        ++this.pos;
        if (octal) {
          if (this.strict) this.raise(this.pos - 2, "Octal literal in strict mode");
          this.pos += octal.length - 1;
          return String.fromCharCode(parseInt(octal, 8));
        } else {
          switch (ch) {
            case 110:
              return "\n"; // 'n' -> '\n'
            case 114:
              return "\r"; // 'r' -> '\r'
            case 120:
              return String.fromCharCode(this.readHexChar(2)); // 'x'
            case 117:
              return codePointToString(this.readCodePoint()); // 'u'
            case 116:
              return "\t"; // 't' -> '\t'
            case 98:
              return "\b"; // 'b' -> '\b'
            case 118:
              return "\u000b"; // 'v' -> '\u000b'
            case 102:
              return "\f"; // 'f' -> '\f'
            case 48:
              return "\u0000"; // 0 -> '\0'
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
            case 10:
              // ' \n'
              if (this.options.locations) {
                this.lineStart = this.pos; ++this.curLine;
              }
              return "";
            default:
              return String.fromCharCode(ch);
          }
        }
      };

      // Used to read character escape sequences ('\x', '\u', '\U').

      pp.readHexChar = function (len) {
        var n = this.readInt(16, len);
        if (n === null) this.raise(this.start, "Bad character escape sequence");
        return n;
      };

      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.

      var containsEsc;

      // Read an identifier, and return it as a string. Sets `containsEsc`
      // to whether the word contained a '\u' escape.
      //
      // Incrementally adds only escaped chars, adding other chunks as-is
      // as a micro-optimization.

      pp.readWord1 = function () {
        containsEsc = false;
        var word = "",
          first = true,
          chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            // "\"
            containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) != 117) // "u"
              this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };

      // Read an identifier or keyword token. Will check for reserved
      // words when necessary.

      pp.readWord = function () {
        var word = this.readWord1();
        var type = tt.name;
        if ((this.options.ecmaVersion >= 6 || !containsEsc) && this.isKeyword(word)) type = keywordTypes[word];
        return this.finishToken(type, word);
      };

    }, { "./identifier": 3, "./location": 4, "./state": 9, "./tokentype": 13, "./whitespace": 15 }], 13: [function (require, module, exports) {
      "use strict";

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // ## Token types

      // The assignment of fine-grained, information-carrying type objects
      // allows the tokenizer to store the information it has about a
      // token in a way that is very cheap for the parser to look up.

      // All token type variables start with an underscore, to make them
      // easy to recognize.

      // The `beforeExpr` property is used to disambiguate between regular
      // expressions and divisions. It is set on all token types that can
      // be followed by an expression (thus, a slash after them would be a
      // regular expression).
      //
      // `isLoop` marks a keyword as starting a loop, which is important
      // to know when parsing a label, in order to allow or disallow
      // continue jumps to that label.

      var TokenType = exports.TokenType = function TokenType(label) {
        var conf = arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, TokenType);

        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };

      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true },
        startsExpr = { startsExpr: true };

      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        eof: new TokenType("eof"),

        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.

        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=", 6),
        relational: binop("</>", 7),
        bitShift: binop("<</>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10)
      };

      exports.types = types;
      // Map keyword names to token types.

      var keywords = {};

      exports.keywords = keywords;
      // Succinct definitions of keyword token types
      function kw(name) {
        var options = arguments[1] === undefined ? {} : arguments[1];

        options.keyword = name;
        keywords[name] = types["_" + name] = new TokenType(name, options);
      }

      kw("break");
      kw("case", beforeExpr);
      kw("catch");
      kw("continue");
      kw("debugger");
      kw("default");
      kw("do", { isLoop: true });
      kw("else", beforeExpr);
      kw("finally");
      kw("for", { isLoop: true });
      kw("function");
      kw("if");
      kw("return", beforeExpr);
      kw("switch");
      kw("throw", beforeExpr);
      kw("try");
      kw("var");
      kw("let");
      kw("const");
      kw("while", { isLoop: true });
      kw("with");
      kw("new", { beforeExpr: true, startsExpr: true });
      kw("this", startsExpr);
      kw("super", startsExpr);
      kw("class");
      kw("extends", beforeExpr);
      kw("export");
      kw("import");
      kw("yield", { beforeExpr: true, startsExpr: true });
      kw("null", startsExpr);
      kw("true", startsExpr);
      kw("false", startsExpr);
      kw("in", { beforeExpr: true, binop: 7 });
      kw("instanceof", { beforeExpr: true, binop: 7 });
      kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
      kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
      kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

    }, {}], 14: [function (require, module, exports) {
      "use strict";

      exports.isArray = isArray;

      // Checks if an object has a property.

      exports.has = has;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      }

      function has(obj, propName) {
        return Object.prototype.hasOwnProperty.call(obj, propName);
      }

    }, {}], 15: [function (require, module, exports) {
      "use strict";

      exports.isNewLine = isNewLine;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // Matches a whole line break (where CRLF is considered a single
      // line break). Used to count lines.

      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      exports.lineBreak = lineBreak;
      var lineBreakG = new RegExp(lineBreak.source, "g");

      exports.lineBreakG = lineBreakG;

      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code == 8233;
      }

      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      exports.nonASCIIwhitespace = nonASCIIwhitespace;

    }, {}]
  }, {}, [1])(1)
});

(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } (g.acorn || (g.acorn = {})).loose = f() } })(function () {
  var define, module, exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
    1: [function (require, module, exports) {
      "use strict";

      var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

      exports.parse_dammit = parse_dammit;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      // Acorn: Loose parser
      //
      // This module provides an alternative parser (`parse_dammit`) that
      // exposes that same interface as `parse`, but will try to parse
      // anything as JavaScript, repairing syntax error the best it can.
      // There are circumstances in which it will raise an error and give
      // up, but they are very rare. The resulting AST will be a mostly
      // valid JavaScript AST (as per the [Mozilla parser API][api], except
      // that:
      //
      // - Return outside functions is allowed
      //
      // - Label consistency (no conflicts, break only to existing labels)
      //   is not enforced.
      //
      // - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
      //   the parser got too confused to return anything meaningful.
      //
      // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
      //
      // The expected use for this is to *first* try `acorn.parse`, and only
      // if that fails switch to `parse_dammit`. The loose parser might
      // parse badly indented code incorrectly, so **don't** use it as
      // your default parser.
      //
      // Quite a lot of acorn.js is duplicated here. The alternative was to
      // add a *lot* of extra cruft to that file, making it less readable
      // and slower. Copying and editing the code allowed me to make
      // invasive changes and simplifications without creating a complicated
      // tangle.

      var acorn = _interopRequireWildcard(require(".."));

      var _state = require("./state");

      var LooseParser = _state.LooseParser;

      require("./tokenize");

      require("./parseutil");

      require("./statement");

      require("./expression");

      exports.LooseParser = _state.LooseParser;

      acorn.defaultOptions.tabSize = 4;

      function parse_dammit(input, options) {
        var p = new LooseParser(input, options);
        p.next();
        return p.parseTopLevel();
      }

      acorn.parse_dammit = parse_dammit;
      acorn.LooseParser = LooseParser;

    }, { "..": 2, "./expression": 3, "./parseutil": 4, "./state": 5, "./statement": 6, "./tokenize": 7 }], 2: [function (require, module, exports) {
      "use strict";

      module.exports = typeof window != "undefined" ? window.acorn : require(("suppress", "acorn"));

    }, {}], 3: [function (require, module, exports) {
      "use strict";

      var LooseParser = require("./state").LooseParser;

      var isDummy = require("./parseutil").isDummy;

      var tt = require("..").tokTypes;

      var lp = LooseParser.prototype;

      lp.checkLVal = function (expr) {
        if (!expr) return expr;
        switch (expr.type) {
          case "Identifier":
          case "MemberExpression":
          case "ObjectPattern":
          case "ArrayPattern":
          case "RestElement":
          case "AssignmentPattern":
            return expr;

          default:
            return this.dummyIdent();
        }
      };

      lp.parseExpression = function (noIn) {
        var start = this.storeCurrentPos();
        var expr = this.parseMaybeAssign(noIn);
        if (this.tok.type === tt.comma) {
          var node = this.startNodeAt(start);
          node.expressions = [expr];
          while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };

      lp.parseParenExpression = function () {
        this.pushCx();
        this.expect(tt.parenL);
        var val = this.parseExpression();
        this.popCx();
        this.expect(tt.parenR);
        return val;
      };

      lp.parseMaybeAssign = function (noIn) {
        var start = this.storeCurrentPos();
        var left = this.parseMaybeConditional(noIn);
        if (this.tok.type.isAssign) {
          var node = this.startNodeAt(start);
          node.operator = this.tok.value;
          node.left = this.tok.type === tt.eq ? this.toAssignable(left) : this.checkLVal(left);
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression");
        }
        return left;
      };

      lp.parseMaybeConditional = function (noIn) {
        var start = this.storeCurrentPos();
        var expr = this.parseExprOps(noIn);
        if (this.eat(tt.question)) {
          var node = this.startNodeAt(start);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          node.alternate = this.expect(tt.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };

      lp.parseExprOps = function (noIn) {
        var start = this.storeCurrentPos();
        var indent = this.curIndent,
          line = this.curLineStart;
        return this.parseExprOp(this.parseMaybeUnary(noIn), start, -1, noIn, indent, line);
      };

      lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
        if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
        var prec = this.tok.type.binop;
        if (prec != null && (!noIn || this.tok.type !== tt._in)) {
          if (prec > minPrec) {
            var node = this.startNodeAt(start);
            node.left = left;
            node.operator = this.tok.value;
            this.next();
            if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
              node.right = this.dummyIdent();
            } else {
              var rightStart = this.storeCurrentPos();
              node.right = this.parseExprOp(this.parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
            }
            this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
            return this.parseExprOp(node, start, minPrec, noIn, indent, line);
          }
        }
        return left;
      };

      lp.parseMaybeUnary = function (noIn) {
        if (this.tok.type.prefix) {
          var node = this.startNode(),
            update = this.tok.type === tt.incDec;
          node.operator = this.tok.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(noIn);
          if (update) node.argument = this.checkLVal(node.argument);
          return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (this.tok.type === tt.ellipsis) {
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeUnary(noIn);
          return this.finishNode(node, "SpreadElement");
        }
        var start = this.storeCurrentPos();
        var expr = this.parseExprSubscripts();
        while (this.tok.type.postfix && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(start);
          node.operator = this.tok.value;
          node.prefix = false;
          node.argument = this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node, "UpdateExpression");
        }
        return expr;
      };

      lp.parseExprSubscripts = function () {
        var start = this.storeCurrentPos();
        return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
      };

      lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
        for (; ;) {
          if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
            if (this.tok.type == tt.dot && this.curIndent == startIndent) --startIndent; else return base;
          }

          if (this.eat(tt.dot)) {
            var node = this.startNodeAt(start);
            node.object = base;
            if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent(); else node.property = this.parsePropertyAccessor() || this.dummyIdent();
            node.computed = false;
            base = this.finishNode(node, "MemberExpression");
          } else if (this.tok.type == tt.bracketL) {
            this.pushCx();
            this.next();
            var node = this.startNodeAt(start);
            node.object = base;
            node.property = this.parseExpression();
            node.computed = true;
            this.popCx();
            this.expect(tt.bracketR);
            base = this.finishNode(node, "MemberExpression");
          } else if (!noCalls && this.tok.type == tt.parenL) {
            this.pushCx();
            var node = this.startNodeAt(start);
            node.callee = base;
            node.arguments = this.parseExprList(tt.parenR);
            base = this.finishNode(node, "CallExpression");
          } else if (this.tok.type == tt.backQuote) {
            var node = this.startNodeAt(start);
            node.tag = base;
            node.quasi = this.parseTemplate();
            base = this.finishNode(node, "TaggedTemplateExpression");
          } else {
            return base;
          }
        }
      };

      lp.parseExprAtom = function () {
        var node = undefined;
        switch (this.tok.type) {
          case tt._this:
          case tt._super:
            var type = this.tok.type === tt._this ? "ThisExpression" : "Super";
            node = this.startNode();
            this.next();
            return this.finishNode(node, type);

          case tt.name:
            var start = this.storeCurrentPos();
            var id = this.parseIdent();
            return this.eat(tt.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

          case tt.regexp:
            node = this.startNode();
            var val = this.tok.value;
            node.regex = { pattern: val.pattern, flags: val.flags };
            node.value = val.value;
            node.raw = this.input.slice(this.tok.start, this.tok.end);
            this.next();
            return this.finishNode(node, "Literal");

          case tt.num: case tt.string:
            node = this.startNode();
            node.value = this.tok.value;
            node.raw = this.input.slice(this.tok.start, this.tok.end);
            this.next();
            return this.finishNode(node, "Literal");

          case tt._null: case tt._true: case tt._false:
            node = this.startNode();
            node.value = this.tok.type === tt._null ? null : this.tok.type === tt._true;
            node.raw = this.tok.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");

          case tt.parenL:
            var parenStart = this.storeCurrentPos();
            this.next();
            var inner = this.parseExpression();
            this.expect(tt.parenR);
            if (this.eat(tt.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (isDummy(inner) ? [] : [inner]));
            }
            if (this.options.preserveParens) {
              var par = this.startNodeAt(parenStart);
              par.expression = inner;
              inner = this.finishNode(par, "ParenthesizedExpression");
            }
            return inner;

          case tt.bracketL:
            node = this.startNode();
            this.pushCx();
            node.elements = this.parseExprList(tt.bracketR, true);
            return this.finishNode(node, "ArrayExpression");

          case tt.braceL:
            return this.parseObj();

          case tt._class:
            return this.parseClass();

          case tt._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, false);

          case tt._new:
            return this.parseNew();

          case tt._yield:
            node = this.startNode();
            this.next();
            if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != tt.star && !this.tok.type.startsExpr) {
              node.delegate = false;
              node.argument = null;
            } else {
              node.delegate = this.eat(tt.star);
              node.argument = this.parseMaybeAssign();
            }
            return this.finishNode(node, "YieldExpression");

          case tt.backQuote:
            return this.parseTemplate();

          default:
            return this.dummyIdent();
        }
      };

      lp.parseNew = function () {
        var node = this.startNode(),
          startIndent = this.curIndent,
          line = this.curLineStart;
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
          node.meta = meta;
          node.property = this.parseIdent(true);
          return this.finishNode(node, "MetaProperty");
        }
        var start = this.storeCurrentPos();
        node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
        if (this.tok.type == tt.parenL) {
          this.pushCx();
          node.arguments = this.parseExprList(tt.parenR);
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      };

      lp.parseTemplateElement = function () {
        var elem = this.startNode();
        elem.value = {
          raw: this.input.slice(this.tok.start, this.tok.end),
          cooked: this.tok.value
        };
        this.next();
        elem.tail = this.tok.type === tt.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };

      lp.parseTemplate = function () {
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement();
        node.quasis = [curElt];
        while (!curElt.tail) {
          this.next();
          node.expressions.push(this.parseExpression());
          if (this.expect(tt.braceR)) {
            curElt = this.parseTemplateElement();
          } else {
            curElt = this.startNode();
            curElt.value = { cooked: "", raw: "" };
            curElt.tail = true;
          }
          node.quasis.push(curElt);
        }
        this.expect(tt.backQuote);
        return this.finishNode(node, "TemplateLiteral");
      };

      lp.parseObj = function () {
        var node = this.startNode();
        node.properties = [];
        this.pushCx();
        var indent = this.curIndent + 1,
          line = this.curLineStart;
        this.eat(tt.braceL);
        if (this.curIndent + 1 < indent) {
          indent = this.curIndent; line = this.curLineStart;
        }
        while (!this.closes(tt.braceR, indent, line)) {
          var prop = this.startNode(),
            isGenerator = undefined,
            start = undefined;
          if (this.options.ecmaVersion >= 6) {
            start = this.storeCurrentPos();
            prop.method = false;
            prop.shorthand = false;
            isGenerator = this.eat(tt.star);
          }
          this.parsePropertyName(prop);
          if (isDummy(prop.key)) {
            if (isDummy(this.parseMaybeAssign())) this.next(); this.eat(tt.comma); continue;
          }
          if (this.eat(tt.colon)) {
            prop.kind = "init";
            prop.value = this.parseMaybeAssign();
          } else if (this.options.ecmaVersion >= 6 && (this.tok.type === tt.parenL || this.tok.type === tt.braceL)) {
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator);
          } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != tt.comma && this.tok.type != tt.braceR)) {
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
          } else {
            prop.kind = "init";
            if (this.options.ecmaVersion >= 6) {
              if (this.eat(tt.eq)) {
                var assign = this.startNodeAt(start);
                assign.operator = "=";
                assign.left = prop.key;
                assign.right = this.parseMaybeAssign();
                prop.value = this.finishNode(assign, "AssignmentExpression");
              } else {
                prop.value = prop.key;
              }
            } else {
              prop.value = this.dummyIdent();
            }
            prop.shorthand = true;
          }
          node.properties.push(this.finishNode(prop, "Property"));
          this.eat(tt.comma);
        }
        this.popCx();
        if (!this.eat(tt.braceR)) {
          // If there is no closing brace, make the node span to the start
          // of the next token (this is useful for Tern)
          this.last.end = this.tok.start;
          if (this.options.locations) this.last.loc.end = this.tok.loc.start;
        }
        return this.finishNode(node, "ObjectExpression");
      };

      lp.parsePropertyName = function (prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(tt.bracketL)) {
            prop.computed = true;
            prop.key = this.parseExpression();
            this.expect(tt.bracketR);
            return;
          } else {
            prop.computed = false;
          }
        }
        var key = this.tok.type === tt.num || this.tok.type === tt.string ? this.parseExprAtom() : this.parseIdent();
        prop.key = key || this.dummyIdent();
      };

      lp.parsePropertyAccessor = function () {
        if (this.tok.type === tt.name || this.tok.type.keyword) return this.parseIdent();
      };

      lp.parseIdent = function () {
        var name = this.tok.type === tt.name ? this.tok.value : this.tok.type.keyword;
        if (!name) return this.dummyIdent();
        var node = this.startNode();
        this.next();
        node.name = name;
        return this.finishNode(node, "Identifier");
      };

      lp.initFunction = function (node) {
        node.id = null;
        node.params = [];
        if (this.options.ecmaVersion >= 6) {
          node.generator = false;
          node.expression = false;
        }
      };

      // Convert existing expression atom to assignable pattern
      // if possible.

      lp.toAssignable = function (node) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "ObjectExpression":
              node.type = "ObjectPattern";
              var props = node.properties;
              for (var i = 0; i < props.length; i++) {
                this.toAssignable(props[i].value);
              } break;

            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements);
              break;

            case "SpreadElement":
              node.type = "RestElement";
              node.argument = this.toAssignable(node.argument);
              break;

            case "AssignmentExpression":
              node.type = "AssignmentPattern";
              break;
          }
        }
        return this.checkLVal(node);
      };

      lp.toAssignableList = function (exprList) {
        for (var i = 0; i < exprList.length; i++) {
          this.toAssignable(exprList[i]);
        } return exprList;
      };

      lp.parseFunctionParams = function (params) {
        this.pushCx();
        params = this.parseExprList(tt.parenR);
        return this.toAssignableList(params);
      };

      lp.parseMethod = function (isGenerator) {
        var node = this.startNode();
        this.initFunction(node);
        node.params = this.parseFunctionParams();
        node.generator = isGenerator || false;
        node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== tt.braceL;
        node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
        return this.finishNode(node, "FunctionExpression");
      };

      lp.parseArrowExpression = function (node, params) {
        this.initFunction(node);
        node.params = this.toAssignableList(params);
        node.expression = this.tok.type !== tt.braceL;
        node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
        return this.finishNode(node, "ArrowFunctionExpression");
      };

      lp.parseExprList = function (close, allowEmpty) {
        var indent = this.curIndent,
          line = this.curLineStart,
          elts = [];
        this.next(); // Opening bracket
        while (!this.closes(close, indent + 1, line)) {
          if (this.eat(tt.comma)) {
            elts.push(allowEmpty ? null : this.dummyIdent());
            continue;
          }
          var elt = this.parseMaybeAssign();
          if (isDummy(elt)) {
            if (this.closes(close, indent, line)) break;
            this.next();
          } else {
            elts.push(elt);
          }
          this.eat(tt.comma);
        }
        this.popCx();
        if (!this.eat(close)) {
          // If there is no closing brace, make the node span to the start
          // of the next token (this is useful for Tern)
          this.last.end = this.tok.start;
          if (this.options.locations) this.last.loc.end = this.tok.loc.start;
        }
        return elts;
      };

    }, { "..": 2, "./parseutil": 4, "./state": 5 }], 4: [function (require, module, exports) {
      "use strict";

      exports.isDummy = isDummy;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var LooseParser = require("./state").LooseParser;

      var _ = require("..");

      var Node = _.Node;
      var SourceLocation = _.SourceLocation;
      var lineBreak = _.lineBreak;
      var isNewLine = _.isNewLine;
      var tt = _.tokTypes;

      var lp = LooseParser.prototype;

      lp.startNode = function () {
        var node = new Node();
        node.start = this.tok.start;
        if (this.options.locations) node.loc = new SourceLocation(this.toks, this.tok.loc.start);
        if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
        if (this.options.ranges) node.range = [this.tok.start, 0];
        return node;
      };

      lp.storeCurrentPos = function () {
        return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
      };

      lp.startNodeAt = function (pos) {
        var node = new Node();
        if (this.options.locations) {
          node.start = pos[0];
          node.loc = new SourceLocation(this.toks, pos[1]);
          pos = pos[0];
        } else {
          node.start = pos;
        }
        if (this.options.directSourceFile) node.sourceFile = this.options.directSourceFile;
        if (this.options.ranges) node.range = [pos, 0];
        return node;
      };

      lp.finishNode = function (node, type) {
        node.type = type;
        node.end = this.last.end;
        if (this.options.locations) node.loc.end = this.last.loc.end;
        if (this.options.ranges) node.range[1] = this.last.end;
        return node;
      };

      lp.dummyIdent = function () {
        var dummy = this.startNode();
        dummy.name = "✖";
        return this.finishNode(dummy, "Identifier");
      };

      function isDummy(node) {
        return node.name == "✖";
      }

      lp.eat = function (type) {
        if (this.tok.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };

      lp.isContextual = function (name) {
        return this.tok.type === tt.name && this.tok.value === name;
      };

      lp.eatContextual = function (name) {
        return this.tok.value === name && this.eat(tt.name);
      };

      lp.canInsertSemicolon = function () {
        return this.tok.type === tt.eof || this.tok.type === tt.braceR || lineBreak.test(this.input.slice(this.last.end, this.tok.start));
      };

      lp.semicolon = function () {
        return this.eat(tt.semi);
      };

      lp.expect = function (type) {
        if (this.eat(type)) return true;
        for (var i = 1; i <= 2; i++) {
          if (this.lookAhead(i).type == type) {
            for (var j = 0; j < i; j++) {
              this.next();
            } return true;
          }
        }
      };

      lp.pushCx = function () {
        this.context.push(this.curIndent);
      };
      lp.popCx = function () {
        this.curIndent = this.context.pop();
      };

      lp.lineEnd = function (pos) {
        while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) ++pos;
        return pos;
      };

      lp.indentationAfter = function (pos) {
        for (var count = 0; ; ++pos) {
          var ch = this.input.charCodeAt(pos);
          if (ch === 32) ++count; else if (ch === 9) count += this.options.tabSize; else return count;
        }
      };

      lp.closes = function (closeTok, indent, line, blockHeuristic) {
        if (this.tok.type === closeTok || this.tok.type === tt.eof) return true;
        return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
      };

      lp.tokenStartsLine = function () {
        for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
          var ch = this.input.charCodeAt(p);
          if (ch !== 9 && ch !== 32) return false;
        }
        return true;
      };

    }, { "..": 2, "./state": 5 }], 5: [function (require, module, exports) {
      "use strict";

      exports.LooseParser = LooseParser;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _ = require("..");

      var tokenizer = _.tokenizer;
      var SourceLocation = _.SourceLocation;
      var tt = _.tokTypes;

      function LooseParser(input, options) {
        this.toks = tokenizer(input, options);
        this.options = this.toks.options;
        this.input = this.toks.input;
        this.tok = this.last = { type: tt.eof, start: 0, end: 0 };
        if (this.options.locations) {
          var here = this.toks.curPosition();
          this.tok.loc = new SourceLocation(this.toks, here, here);
        }
        this.ahead = []; // Tokens ahead
        this.context = []; // Indentation contexted
        this.curIndent = 0;
        this.curLineStart = 0;
        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
      }

    }, { "..": 2 }], 6: [function (require, module, exports) {
      "use strict";

      var LooseParser = require("./state").LooseParser;

      var isDummy = require("./parseutil").isDummy;

      var _ = require("..");

      var getLineInfo = _.getLineInfo;
      var tt = _.tokTypes;

      var lp = LooseParser.prototype;

      lp.parseTopLevel = function () {
        var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);
        node.body = [];
        while (this.tok.type !== tt.eof) node.body.push(this.parseStatement());
        this.last = this.tok;
        if (this.options.ecmaVersion >= 6) {
          node.sourceType = this.options.sourceType;
        }
        return this.finishNode(node, "Program");
      };

      lp.parseStatement = function () {
        var starttype = this.tok.type,
          node = this.startNode();

        switch (starttype) {
          case tt._break: case tt._continue:
            this.next();
            var isBreak = starttype === tt._break;
            if (this.semicolon() || this.canInsertSemicolon()) {
              node.label = null;
            } else {
              node.label = this.tok.type === tt.name ? this.parseIdent() : null;
              this.semicolon();
            }
            return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

          case tt._debugger:
            this.next();
            this.semicolon();
            return this.finishNode(node, "DebuggerStatement");

          case tt._do:
            this.next();
            node.body = this.parseStatement();
            node.test = this.eat(tt._while) ? this.parseParenExpression() : this.dummyIdent();
            this.semicolon();
            return this.finishNode(node, "DoWhileStatement");

          case tt._for:
            this.next();
            this.pushCx();
            this.expect(tt.parenL);
            if (this.tok.type === tt.semi) return this.parseFor(node, null);
            if (this.tok.type === tt._var || this.tok.type === tt._let || this.tok.type === tt._const) {
              var _init = this.parseVar(true);
              if (_init.declarations.length === 1 && (this.tok.type === tt._in || this.isContextual("of"))) {
                return this.parseForIn(node, _init);
              }
              return this.parseFor(node, _init);
            }
            var init = this.parseExpression(true);
            if (this.tok.type === tt._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
            return this.parseFor(node, init);

          case tt._function:
            this.next();
            return this.parseFunction(node, true);

          case tt._if:
            this.next();
            node.test = this.parseParenExpression();
            node.consequent = this.parseStatement();
            node.alternate = this.eat(tt._else) ? this.parseStatement() : null;
            return this.finishNode(node, "IfStatement");

          case tt._return:
            this.next();
            if (this.eat(tt.semi) || this.canInsertSemicolon()) node.argument = null; else {
              node.argument = this.parseExpression(); this.semicolon();
            }
            return this.finishNode(node, "ReturnStatement");

          case tt._switch:
            var blockIndent = this.curIndent,
              line = this.curLineStart;
            this.next();
            node.discriminant = this.parseParenExpression();
            node.cases = [];
            this.pushCx();
            this.expect(tt.braceL);

            var cur = undefined;
            while (!this.closes(tt.braceR, blockIndent, line, true)) {
              if (this.tok.type === tt._case || this.tok.type === tt._default) {
                var isCase = this.tok.type === tt._case;
                if (cur) this.finishNode(cur, "SwitchCase");
                node.cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) cur.test = this.parseExpression(); else cur.test = null;
                this.expect(tt.colon);
              } else {
                if (!cur) {
                  node.cases.push(cur = this.startNode());
                  cur.consequent = [];
                  cur.test = null;
                }
                cur.consequent.push(this.parseStatement());
              }
            }
            if (cur) this.finishNode(cur, "SwitchCase");
            this.popCx();
            this.eat(tt.braceR);
            return this.finishNode(node, "SwitchStatement");

          case tt._throw:
            this.next();
            node.argument = this.parseExpression();
            this.semicolon();
            return this.finishNode(node, "ThrowStatement");

          case tt._try:
            this.next();
            node.block = this.parseBlock();
            node.handler = null;
            if (this.tok.type === tt._catch) {
              var clause = this.startNode();
              this.next();
              this.expect(tt.parenL);
              clause.param = this.toAssignable(this.parseExprAtom());
              this.expect(tt.parenR);
              clause.guard = null;
              clause.body = this.parseBlock();
              node.handler = this.finishNode(clause, "CatchClause");
            }
            node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
            if (!node.handler && !node.finalizer) return node.block;
            return this.finishNode(node, "TryStatement");

          case tt._var:
          case tt._let:
          case tt._const:
            return this.parseVar();

          case tt._while:
            this.next();
            node.test = this.parseParenExpression();
            node.body = this.parseStatement();
            return this.finishNode(node, "WhileStatement");

          case tt._with:
            this.next();
            node.object = this.parseParenExpression();
            node.body = this.parseStatement();
            return this.finishNode(node, "WithStatement");

          case tt.braceL:
            return this.parseBlock();

          case tt.semi:
            this.next();
            return this.finishNode(node, "EmptyStatement");

          case tt._class:
            return this.parseClass(true);

          case tt._import:
            return this.parseImport();

          case tt._export:
            return this.parseExport();

          default:
            var expr = this.parseExpression();
            if (isDummy(expr)) {
              this.next();
              if (this.tok.type === tt.eof) return this.finishNode(node, "EmptyStatement");
              return this.parseStatement();
            } else if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) {
              node.body = this.parseStatement();
              node.label = expr;
              return this.finishNode(node, "LabeledStatement");
            } else {
              node.expression = expr;
              this.semicolon();
              return this.finishNode(node, "ExpressionStatement");
            }
        }
      };

      lp.parseBlock = function () {
        var node = this.startNode();
        this.pushCx();
        this.expect(tt.braceL);
        var blockIndent = this.curIndent,
          line = this.curLineStart;
        node.body = [];
        while (!this.closes(tt.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
        this.popCx();
        this.eat(tt.braceR);
        return this.finishNode(node, "BlockStatement");
      };

      lp.parseFor = function (node, init) {
        node.init = init;
        node.test = node.update = null;
        if (this.eat(tt.semi) && this.tok.type !== tt.semi) node.test = this.parseExpression();
        if (this.eat(tt.semi) && this.tok.type !== tt.parenR) node.update = this.parseExpression();
        this.popCx();
        this.expect(tt.parenR);
        node.body = this.parseStatement();
        return this.finishNode(node, "ForStatement");
      };

      lp.parseForIn = function (node, init) {
        var type = this.tok.type === tt._in ? "ForInStatement" : "ForOfStatement";
        this.next();
        node.left = init;
        node.right = this.parseExpression();
        this.popCx();
        this.expect(tt.parenR);
        node.body = this.parseStatement();
        return this.finishNode(node, type);
      };

      lp.parseVar = function (noIn) {
        var node = this.startNode();
        node.kind = this.tok.type.keyword;
        this.next();
        node.declarations = [];
        do {
          var decl = this.startNode();
          decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom()) : this.parseIdent();
          decl.init = this.eat(tt.eq) ? this.parseMaybeAssign(noIn) : null;
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        } while (this.eat(tt.comma));
        if (!node.declarations.length) {
          var decl = this.startNode();
          decl.id = this.dummyIdent();
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        }
        if (!noIn) this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };

      lp.parseClass = function (isStatement) {
        var node = this.startNode();
        this.next();
        if (this.tok.type === tt.name) node.id = this.parseIdent(); else if (isStatement) node.id = this.dummyIdent(); else node.id = null;
        node.superClass = this.eat(tt._extends) ? this.parseExpression() : null;
        node.body = this.startNode();
        node.body.body = [];
        this.pushCx();
        var indent = this.curIndent + 1,
          line = this.curLineStart;
        this.eat(tt.braceL);
        if (this.curIndent + 1 < indent) {
          indent = this.curIndent; line = this.curLineStart;
        }
        while (!this.closes(tt.braceR, indent, line)) {
          if (this.semicolon()) continue;
          var method = this.startNode(),
            isGenerator = undefined,
            start = undefined;
          if (this.options.ecmaVersion >= 6) {
            method["static"] = false;
            isGenerator = this.eat(tt.star);
          }
          this.parsePropertyName(method);
          if (isDummy(method.key)) {
            if (isDummy(this.parseMaybeAssign())) this.next(); this.eat(tt.comma); continue;
          }
          if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != tt.parenL && this.tok.type != tt.braceL)) {
            method["static"] = true;
            isGenerator = this.eat(tt.star);
            this.parsePropertyName(method);
          } else {
            method["static"] = false;
          }
          if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== tt.parenL && this.tok.type !== tt.braceL) {
            method.kind = method.key.name;
            this.parsePropertyName(method);
            method.value = this.parseMethod(false);
          } else {
            if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
              method.kind = "constructor";
            } else {
              method.kind = "method";
            }
            method.value = this.parseMethod(isGenerator);
          }
          node.body.body.push(this.finishNode(method, "MethodDefinition"));
        }
        this.popCx();
        if (!this.eat(tt.braceR)) {
          // If there is no closing brace, make the node span to the start
          // of the next token (this is useful for Tern)
          this.last.end = this.tok.start;
          if (this.options.locations) this.last.loc.end = this.tok.loc.start;
        }
        this.semicolon();
        this.finishNode(node.body, "ClassBody");
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };

      lp.parseFunction = function (node, isStatement) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = this.eat(tt.star);
        }
        if (this.tok.type === tt.name) node.id = this.parseIdent(); else if (isStatement) node.id = this.dummyIdent();
        node.params = this.parseFunctionParams();
        node.body = this.parseBlock();
        return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      };

      lp.parseExport = function () {
        var node = this.startNode();
        this.next();
        if (this.eat(tt.star)) {
          node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(tt._default)) {
          var expr = this.parseMaybeAssign();
          if (expr.id) {
            switch (expr.type) {
              case "FunctionExpression":
                expr.type = "FunctionDeclaration"; break;
              case "ClassExpression":
                expr.type = "ClassDeclaration"; break;
            }
          }
          node.declaration = expr;
          this.semicolon();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.tok.type.keyword) {
          node.declaration = this.parseStatement();
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifierList();
          node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };

      lp.parseImport = function () {
        var node = this.startNode();
        this.next();
        if (this.tok.type === tt.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
          node.kind = "";
        } else {
          var elt = undefined;
          if (this.tok.type === tt.name && this.tok.value !== "from") {
            elt = this.startNode();
            elt.local = this.parseIdent();
            this.finishNode(elt, "ImportDefaultSpecifier");
            this.eat(tt.comma);
          }
          node.specifiers = this.parseImportSpecifierList();
          node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
          if (elt) node.specifiers.unshift(elt);
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      lp.parseImportSpecifierList = function () {
        var elts = [];
        if (this.tok.type === tt.star) {
          var elt = this.startNode();
          this.next();
          if (this.eatContextual("as")) elt.local = this.parseIdent();
          elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
        } else {
          var indent = this.curIndent,
            line = this.curLineStart,
            continuedLine = this.nextLineStart;
          this.pushCx();
          this.eat(tt.braceL);
          if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
          while (!this.closes(tt.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
            var elt = this.startNode();
            if (this.eat(tt.star)) {
              if (this.eatContextual("as")) elt.local = this.parseIdent();
              this.finishNode(elt, "ImportNamespaceSpecifier");
            } else {
              if (this.isContextual("from")) break;
              elt.imported = this.parseIdent();
              elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
              this.finishNode(elt, "ImportSpecifier");
            }
            elts.push(elt);
            this.eat(tt.comma);
          }
          this.eat(tt.braceR);
          this.popCx();
        }
        return elts;
      };

      lp.parseExportSpecifierList = function () {
        var elts = [];
        var indent = this.curIndent,
          line = this.curLineStart,
          continuedLine = this.nextLineStart;
        this.pushCx();
        this.eat(tt.braceL);
        if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
        while (!this.closes(tt.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
          if (this.isContextual("from")) break;
          var elt = this.startNode();
          elt.local = this.parseIdent();
          elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
          this.finishNode(elt, "ExportSpecifier");
          elts.push(elt);
          this.eat(tt.comma);
        }
        this.eat(tt.braceR);
        this.popCx();
        return elts;
      };

    }, { "..": 2, "./parseutil": 4, "./state": 5 }], 7: [function (require, module, exports) {
      "use strict";

      var _ = require("..");

      var tt = _.tokTypes;
      var Token = _.Token;
      var isNewLine = _.isNewLine;
      var SourceLocation = _.SourceLocation;
      var getLineInfo = _.getLineInfo;
      var lineBreakG = _.lineBreakG;

      var LooseParser = require("./state").LooseParser;

      var lp = LooseParser.prototype;

      function isSpace(ch) {
        return ch < 14 && ch > 8 || ch === 32 || ch === 160 || isNewLine(ch);
      }

      lp.next = function () {
        this.last = this.tok;
        if (this.ahead.length) this.tok = this.ahead.shift(); else this.tok = this.readToken();

        if (this.tok.start >= this.nextLineStart) {
          while (this.tok.start >= this.nextLineStart) {
            this.curLineStart = this.nextLineStart;
            this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
          }
          this.curIndent = this.indentationAfter(this.curLineStart);
        }
      };

      lp.readToken = function () {
        for (; ;) {
          try {
            this.toks.next();
            if (this.toks.type === tt.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
              this.toks.end++;
              this.toks.type = tt.ellipsis;
            }
            return new Token(this.toks);
          } catch (e) {
            if (!(e instanceof SyntaxError)) throw e;

            // Try to skip some text, based on the error message, and then continue
            var msg = e.message,
              pos = e.raisedAt,
              replace = true;
            if (/unterminated/i.test(msg)) {
              pos = this.lineEnd(e.pos + 1);
              if (/string/.test(msg)) {
                replace = { start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos) };
              } else if (/regular expr/i.test(msg)) {
                var re = this.input.slice(e.pos, pos);
                try {
                  re = new RegExp(re);
                } catch (e) { }
                replace = { start: e.pos, end: pos, type: tt.regexp, value: re };
              } else if (/template/.test(msg)) {
                replace = {
                  start: e.pos, end: pos,
                  type: tt.template,
                  value: this.input.slice(e.pos, pos)
                };
              } else {
                replace = false;
              }
            } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number/i.test(msg)) {
              while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
            } else if (/character escape|expected hexadecimal/i.test(msg)) {
              while (pos < this.input.length) {
                var ch = this.input.charCodeAt(pos++);
                if (ch === 34 || ch === 39 || isNewLine(ch)) break;
              }
            } else if (/unexpected character/i.test(msg)) {
              pos++;
              replace = false;
            } else if (/regular expression/i.test(msg)) {
              replace = true;
            } else {
              throw e;
            }
            this.resetTo(pos);
            if (replace === true) replace = { start: pos, end: pos, type: tt.name, value: "✖" };
            if (replace) {
              if (this.options.locations) replace.loc = new SourceLocation(this.toks, getLineInfo(this.input, replace.start), getLineInfo(this.input, replace.end));
              return replace;
            }
          }
        }
      };

      lp.resetTo = function (pos) {
        this.toks.pos = pos;
        var ch = this.input.charAt(pos - 1);
        this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

        if (this.options.locations) {
          this.toks.curLine = 1;
          this.toks.lineStart = lineBreakG.lastIndex = 0;
          var match = undefined;
          while ((match = lineBreakG.exec(this.input)) && match.index < pos) {
            ++this.toks.curLine;
            this.toks.lineStart = match.index + match[0].length;
          }
        }
      };

      lp.lookAhead = function (n) {
        while (n > this.ahead.length) this.ahead.push(this.readToken());
        return this.ahead[n - 1];
      };

    }, { "..": 2, "./state": 5 }]
  }, {}, [1])(1)
});

(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } (g.acorn || (g.acorn = {})).walk = f() } })(function () {
  var define, module, exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
    1: [function (require, module, exports) {
      "use strict";

      var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

      // AST walker module for Mozilla Parser API compatible trees

      // A simple walk is one where you simply specify callbacks to be
      // called on specific nodes. The last two arguments are optional. A
      // simple use would be
      //
      //     walk.simple(myTree, {
      //         Expression: function(node) { ... }
      //     });
      //
      // to do something with all expressions. All Parser API node types
      // can be used to identify node types, as well as Expression,
      // Statement, and ScopeBody, which denote categories of nodes.
      //
      // The base argument can be used to pass a custom (recursive)
      // walker, and state can be used to give this walked an initial
      // state.

      exports.simple = simple;

      // An ancestor walk builds up an array of ancestor nodes (including
      // the current node) and passes them to the callback as the state parameter.
      exports.ancestor = ancestor;

      // A recursive walk is one where your functions override the default
      // walkers. They can modify and replace the state parameter that's
      // threaded through the walk, and can opt how and whether to walk
      // their child nodes (by calling their third argument on these
      // nodes).
      exports.recursive = recursive;

      // Find a node with a given start, end, and type (all are optional,
      // null can be used as wildcard). Returns a {node, state} object, or
      // undefined when it doesn't find a matching node.
      exports.findNodeAt = findNodeAt;

      // Find the innermost node of a given type that contains the given
      // position. Interface similar to findNodeAt.
      exports.findNodeAround = findNodeAround;

      // Find the outermost matching node after a given position.
      exports.findNodeAfter = findNodeAfter;

      // Find the outermost matching node before a given position.
      exports.findNodeBefore = findNodeBefore;

      // Used to create a custom walker. Will fill in all missing node
      // type properties with the defaults.
      exports.make = make;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      function simple(node, visitors, base, state) {
        if (!base) base = exports.base; (function c(node, st, override) {
          var type = override || node.type,
            found = visitors[type];
          base[type](node, st, c);
          if (found) found(node, st);
        })(node, state);
      }

      function ancestor(node, visitors, base, state) {
        if (!base) base = exports.base;
        if (!state) state = []; (function c(node, st, override) {
          var type = override || node.type,
            found = visitors[type];
          if (node != st[st.length - 1]) {
            st = st.slice();
            st.push(node);
          }
          base[type](node, st, c);
          if (found) found(node, st);
        })(node, state);
      }

      function recursive(node, state, funcs, base) {
        var visitor = funcs ? exports.make(funcs, base) : base; (function c(node, st, override) {
          visitor[override || node.type](node, st, c);
        })(node, state);
      }

      function makeTest(test) {
        if (typeof test == "string") {
          return function (type) {
            return type == test;
          };
        } else if (!test) {
          return function () {
            return true;
          };
        } else {
          return test;
        }
      }

      var Found = function Found(node, state) {
        _classCallCheck(this, Found);

        this.node = node; this.state = state;
      };

      function findNodeAt(node, start, end, test, base, state) {
        test = makeTest(test);
        if (!base) base = exports.base;
        try {
          ; (function c(node, st, override) {
            var type = override || node.type;
            if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
            if (test(type, node) && (start == null || node.start == start) && (end == null || node.end == end)) throw new Found(node, st);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          } throw e;
        }
      }

      function findNodeAround(node, pos, test, base, state) {
        test = makeTest(test);
        if (!base) base = exports.base;
        try {
          ; (function c(node, st, override) {
            var type = override || node.type;
            if (node.start > pos || node.end < pos) {
              return;
            } base[type](node, st, c);
            if (test(type, node)) throw new Found(node, st);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          } throw e;
        }
      }

      function findNodeAfter(node, pos, test, base, state) {
        test = makeTest(test);
        if (!base) base = exports.base;
        try {
          ; (function c(node, st, override) {
            if (node.end < pos) {
              return;
            } var type = override || node.type;
            if (node.start >= pos && test(type, node)) throw new Found(node, st);
            base[type](node, st, c);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          } throw e;
        }
      }

      function findNodeBefore(node, pos, test, base, state) {
        test = makeTest(test);
        if (!base) base = exports.base;
        var max = undefined; (function c(node, st, override) {
          if (node.start > pos) {
            return;
          } var type = override || node.type;
          if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
          base[type](node, st, c);
        })(node, state);
        return max;
      }

      function make(funcs, base) {
        if (!base) base = exports.base;
        var visitor = {};
        for (var type in base) visitor[type] = base[type];
        for (var type in funcs) visitor[type] = funcs[type];
        return visitor;
      }

      function skipThrough(node, st, c) {
        c(node, st);
      }
      function ignore(_node, _st, _c) { }

      // Node walkers.

      var base = {};

      exports.base = base;
      base.Program = base.BlockStatement = function (node, st, c) {
        for (var i = 0; i < node.body.length; ++i) {
          c(node.body[i], st, "Statement");
        }
      };
      base.Statement = skipThrough;
      base.EmptyStatement = ignore;
      base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
        return c(node.expression, st, "Expression");
      };
      base.IfStatement = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) c(node.alternate, st, "Statement");
      };
      base.LabeledStatement = function (node, st, c) {
        return c(node.body, st, "Statement");
      };
      base.BreakStatement = base.ContinueStatement = ignore;
      base.WithStatement = function (node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.SwitchStatement = function (node, st, c) {
        c(node.discriminant, st, "Expression");
        for (var i = 0; i < node.cases.length; ++i) {
          var cs = node.cases[i];
          if (cs.test) c(cs.test, st, "Expression");
          for (var j = 0; j < cs.consequent.length; ++j) {
            c(cs.consequent[j], st, "Statement");
          }
        }
      };
      base.ReturnStatement = base.YieldExpression = function (node, st, c) {
        if (node.argument) c(node.argument, st, "Expression");
      };
      base.ThrowStatement = base.SpreadElement = base.RestElement = function (node, st, c) {
        return c(node.argument, st, "Expression");
      };
      base.TryStatement = function (node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) c(node.handler.body, st, "ScopeBody");
        if (node.finalizer) c(node.finalizer, st, "Statement");
      };
      base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForStatement = function (node, st, c) {
        if (node.init) c(node.init, st, "ForInit");
        if (node.test) c(node.test, st, "Expression");
        if (node.update) c(node.update, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInStatement = base.ForOfStatement = function (node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInit = function (node, st, c) {
        if (node.type == "VariableDeclaration") c(node, st); else c(node, st, "Expression");
      };
      base.DebuggerStatement = ignore;

      base.FunctionDeclaration = function (node, st, c) {
        return c(node, st, "Function");
      };
      base.VariableDeclaration = function (node, st, c) {
        for (var i = 0; i < node.declarations.length; ++i) {
          var decl = node.declarations[i];
          if (decl.init) c(decl.init, st, "Expression");
        }
      };

      base.Function = function (node, st, c) {
        return c(node.body, st, "ScopeBody");
      };
      base.ScopeBody = function (node, st, c) {
        return c(node, st, "Statement");
      };

      base.Expression = skipThrough;
      base.ThisExpression = base.Super = base.MetaProperty = ignore;
      base.ArrayExpression = base.ArrayPattern = function (node, st, c) {
        for (var i = 0; i < node.elements.length; ++i) {
          var elt = node.elements[i];
          if (elt) c(elt, st, "Expression");
        }
      };
      base.ObjectExpression = base.ObjectPattern = function (node, st, c) {
        for (var i = 0; i < node.properties.length; ++i) {
          c(node.properties[i], st);
        }
      };
      base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
      base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
        for (var i = 0; i < node.expressions.length; ++i) {
          c(node.expressions[i], st, "Expression");
        }
      };
      base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
        c(node.argument, st, "Expression");
      };
      base.BinaryExpression = base.AssignmentExpression = base.AssignmentPattern = base.LogicalExpression = function (node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
      };
      base.ConditionalExpression = function (node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
      };
      base.NewExpression = base.CallExpression = function (node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
          c(node.arguments[i], st, "Expression");
        }
      };
      base.MemberExpression = function (node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) c(node.property, st, "Expression");
      };
      base.ExportDeclaration = function (node, st, c) {
        return c(node.declaration, st);
      };
      base.ImportDeclaration = function (node, st, c) {
        for (var i = 0; i < node.specifiers.length; i++) {
          c(node.specifiers[i], st);
        }
      };
      base.ImportSpecifier = base.ImportBatchSpecifier = base.Identifier = base.Literal = ignore;

      base.TaggedTemplateExpression = function (node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st);
      };
      base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
        if (node.superClass) c(node.superClass, st, "Expression");
        for (var i = 0; i < node.body.body.length; i++) {
          c(node.body.body[i], st);
        }
      };
      base.MethodDefinition = base.Property = function (node, st, c) {
        if (node.computed) c(node.key, st, "Expression");
        c(node.value, st, "Expression");
      };
      base.ComprehensionExpression = function (node, st, c) {
        for (var i = 0; i < node.blocks.length; i++) {
          c(node.blocks[i].right, st, "Expression");
        } c(node.body, st, "Expression");
      };

    }, {}]
  }, {}, [1])(1)
});

// Shims to fill in enough of ECMAScript 5 to make Tern run. Does not
// supply standard-compliant methods, in that some functionality is
// left out (such as second argument to Object.create, self args in
// array methods, etc). WILL clash with other ECMA5 polyfills in a
// probably disruptive way.

(function () {
  Object.create = Object.create || (function () {
    if (!({ __proto__: null } instanceof Object))
      return function (base) { return { __proto__: base }; };
    function ctor() { }
    var frame = document.body.appendChild(document.createElement("iframe"));
    frame.src = "javascript:";
    var empty = frame.contentWindow.Object.prototype;
    delete empty.hasOwnProperty;
    delete empty.isPrototypeOf;
    delete empty.propertyIsEnumerable;
    delete empty.valueOf;
    delete empty.toString;
    delete empty.toLocaleString;
    delete empty.constructor;
    return function (base) { ctor.prototype = base || empty; return new ctor(); };
  })();

  // Array methods

  var AP = Array.prototype;

  AP.some = AP.some || function (pred) {
    for (var i = 0; i < this.length; ++i) if (pred(this[i], i)) return true;
  };

  AP.forEach = AP.forEach || function (f) {
    for (var i = 0; i < this.length; ++i) f(this[i], i);
  };

  AP.indexOf = AP.indexOf || function (x, start) {
    for (var i = start || 0; i < this.length; ++i) if (this[i] === x) return i;
    return -1;
  };

  AP.lastIndexOf = AP.lastIndexOf || function (x, start) {
    for (var i = start == null ? this.length - 1 : start; i >= 0; ++i) if (this[i] === x) return i;
    return -1;
  };

  AP.map = AP.map || function (f) {
    for (var r = [], i = 0; i < this.length; ++i) r.push(f(this[i], i));
    return r;
  };

  Array.isArray = Array.isArray || function (v) {
    return Object.prototype.toString.call(v) == "[object Array]";
  };

  String.prototype.trim = String.prototype.trim || function () {
    var from = 0, to = this.length;
    while (/\s/.test(this.charAt(from))) ++from;
    while (/\s/.test(this.charAt(to - 1))) --to;
    return this.slice(from, to);
  };

  /*! JSON v3.2.4 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */
  if (!window.JSON) (function () {
    var e = void 0, i = !0, k = null, l = {}.toString, m, n, p = "function" === typeof define && define.c, q = !p && "object" == typeof exports && exports; q || p ? "object" == typeof JSON && JSON ? p ? q = JSON : (q.stringify = JSON.stringify, q.parse = JSON.parse) : p && (q = this.JSON = {}) : q = this.JSON || (this.JSON = {}); var r, t, u, x, z, B, C, D, E, F, G, H, I, J = new Date(-3509827334573292), K, O, P; try { J = -109252 == J.getUTCFullYear() && 0 === J.getUTCMonth() && 1 == J.getUTCDate() && 10 == J.getUTCHours() && 37 == J.getUTCMinutes() && 6 == J.getUTCSeconds() && 708 == J.getUTCMilliseconds() } catch (Q) { }
    function R(b) {
      var c, a, d, j = b == "json"; if (j || b == "json-stringify" || b == "json-parse") {
        if (b == "json-stringify" || j) {
          if (c = typeof q.stringify == "function" && J) {
            (d = function () { return 1 }).toJSON = d; try {
              c = q.stringify(0) === "0" && q.stringify(new Number) === "0" && q.stringify(new String) == '""' && q.stringify(l) === e && q.stringify(e) === e && q.stringify() === e && q.stringify(d) === "1" && q.stringify([d]) == "[1]" && q.stringify([e]) == "[null]" && q.stringify(k) == "null" && q.stringify([e, l, k]) == "[null,null,null]" && q.stringify({ A: [d, i, false, k, "\x00\u0008\n\u000c\r\t"] }) ==
              '{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}' && q.stringify(k, d) === "1" && q.stringify([1, 2], k, 1) == "[\n 1,\n 2\n]" && q.stringify(new Date(-864E13)) == '"-271821-04-20T00:00:00.000Z"' && q.stringify(new Date(864E13)) == '"+275760-09-13T00:00:00.000Z"' && q.stringify(new Date(-621987552E5)) == '"-000001-01-01T00:00:00.000Z"' && q.stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"'
            } catch (f) { c = false }
          } if (!j) return c
        } if (b == "json-parse" || j) {
          if (typeof q.parse == "function") try {
            if (q.parse("0") === 0 && !q.parse(false)) {
              d =
              q.parse('{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}'); if (a = d.a.length == 5 && d.a[0] == 1) { try { a = !q.parse('"\t"') } catch (o) { } if (a) try { a = q.parse("01") != 1 } catch (g) { } }
            }
          } catch (h) { a = false } if (!j) return a
        } return c && a
      }
    }
    if (!R("json")) {
      J || (K = Math.floor, O = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], P = function (b, c) { return O[c] + 365 * (b - 1970) + K((b - 1969 + (c = +(c > 1))) / 4) - K((b - 1901 + c) / 100) + K((b - 1601 + c) / 400) }); if (!(m = {}.hasOwnProperty)) m = function (b) {
        var c = {}, a; if ((c.__proto__ = k, c.__proto__ = { toString: 1 }, c).toString != l) m = function (a) { var b = this.__proto__, a = a in (this.__proto__ = k, this); this.__proto__ = b; return a }; else { a = c.constructor; m = function (b) { var c = (this.constructor || a).prototype; return b in this && !(b in c && this[b] === c[b]) } } c =
          k; return m.call(this, b)
      }; n = function (b, c) {
        var a = 0, d, j, f; (d = function () { this.valueOf = 0 }).prototype.valueOf = 0; j = new d; for (f in j) m.call(j, f) && a++; d = j = k; if (a) a = a == 2 ? function (a, b) { var c = {}, d = l.call(a) == "[object Function]", f; for (f in a) !(d && f == "prototype") && !m.call(c, f) && (c[f] = 1) && m.call(a, f) && b(f) } : function (a, b) { var c = l.call(a) == "[object Function]", d, f; for (d in a) !(c && d == "prototype") && m.call(a, d) && !(f = d === "constructor") && b(d); (f || m.call(a, d = "constructor")) && b(d) }; else {
          j = ["valueOf", "toString", "toLocaleString",
            "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"]; a = function (a, b) { var c = l.call(a) == "[object Function]", d; for (d in a) !(c && d == "prototype") && m.call(a, d) && b(d); for (c = j.length; d = j[--c]; m.call(a, d) && b(d)); }
        } a(b, c)
      }; R("json-stringify") || (r = { "\\": "\\\\", '"': '\\"', "\u0008": "\\b", "\u000c": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t" }, t = function (b, c) { return ("000000" + (c || 0)).slice(-b) }, u = function (b) {
        for (var c = '"', a = 0, d; d = b.charAt(a); a++)c = c + ('\\"\u0008\u000c\n\r\t'.indexOf(d) > -1 ? r[d] : r[d] = d < " " ?
          "\\u00" + t(2, d.charCodeAt(0).toString(16)) : d); return c + '"'
      }, x = function (b, c, a, d, j, f, o) {
        var g = c[b], h, s, v, w, L, M, N, y, A; if (typeof g == "object" && g) {
          h = l.call(g); if (h == "[object Date]" && !m.call(g, "toJSON")) if (g > -1 / 0 && g < 1 / 0) {
            if (P) { v = K(g / 864E5); for (h = K(v / 365.2425) + 1970 - 1; P(h + 1, 0) <= v; h++); for (s = K((v - P(h, 0)) / 30.42); P(h, s + 1) <= v; s++); v = 1 + v - P(h, s); w = (g % 864E5 + 864E5) % 864E5; L = K(w / 36E5) % 24; M = K(w / 6E4) % 60; N = K(w / 1E3) % 60; w = w % 1E3 } else {
              h = g.getUTCFullYear(); s = g.getUTCMonth(); v = g.getUTCDate(); L = g.getUTCHours(); M = g.getUTCMinutes();
              N = g.getUTCSeconds(); w = g.getUTCMilliseconds()
            } g = (h <= 0 || h >= 1E4 ? (h < 0 ? "-" : "+") + t(6, h < 0 ? -h : h) : t(4, h)) + "-" + t(2, s + 1) + "-" + t(2, v) + "T" + t(2, L) + ":" + t(2, M) + ":" + t(2, N) + "." + t(3, w) + "Z"
          } else g = k; else if (typeof g.toJSON == "function" && (h != "[object Number]" && h != "[object String]" && h != "[object Array]" || m.call(g, "toJSON"))) g = g.toJSON(b)
        } a && (g = a.call(c, b, g)); if (g === k) return "null"; h = l.call(g); if (h == "[object Boolean]") return "" + g; if (h == "[object Number]") return g > -1 / 0 && g < 1 / 0 ? "" + g : "null"; if (h == "[object String]") return u(g); if (typeof g ==
          "object") { for (b = o.length; b--;)if (o[b] === g) throw TypeError(); o.push(g); y = []; c = f; f = f + j; if (h == "[object Array]") { s = 0; for (b = g.length; s < b; A || (A = i), s++) { h = x(s, g, a, d, j, f, o); y.push(h === e ? "null" : h) } b = A ? j ? "[\n" + f + y.join(",\n" + f) + "\n" + c + "]" : "[" + y.join(",") + "]" : "[]" } else { n(d || g, function (b) { var c = x(b, g, a, d, j, f, o); c !== e && y.push(u(b) + ":" + (j ? " " : "") + c); A || (A = i) }); b = A ? j ? "{\n" + f + y.join(",\n" + f) + "\n" + c + "}" : "{" + y.join(",") + "}" : "{}" } o.pop(); return b }
      }, q.stringify = function (b, c, a) {
        var d, j, f, o, g, h; if (typeof c == "function" ||
          typeof c == "object" && c) if (l.call(c) == "[object Function]") j = c; else if (l.call(c) == "[object Array]") { f = {}; o = 0; for (g = c.length; o < g; h = c[o++], (l.call(h) == "[object String]" || l.call(h) == "[object Number]") && (f[h] = 1)); } if (a) if (l.call(a) == "[object Number]") { if ((a = a - a % 1) > 0) { d = ""; for (a > 10 && (a = 10); d.length < a; d = d + " "); } } else l.call(a) == "[object String]" && (d = a.length <= 10 ? a : a.slice(0, 10)); return x("", (h = {}, h[""] = b, h), j, f, d, "", [])
      }); R("json-parse") || (z = String.fromCharCode, B = {
        "\\": "\\", '"': '"', "/": "/", b: "\u0008", t: "\t",
        n: "\n", f: "\u000c", r: "\r"
      }, C = function () { H = I = k; throw SyntaxError(); }, D = function () {
        for (var b = I, c = b.length, a, d, j, f, o; H < c;) {
          a = b.charAt(H); if ("\t\r\n ".indexOf(a) > -1) H++; else {
            if ("{}[]:,".indexOf(a) > -1) { H++; return a } if (a == '"') {
              d = "@"; for (H++; H < c;) {
                a = b.charAt(H); if (a < " ") C(); else if (a == "\\") { a = b.charAt(++H); if ('\\"/btnfr'.indexOf(a) > -1) { d = d + B[a]; H++ } else if (a == "u") { j = ++H; for (f = H + 4; H < f; H++) { a = b.charAt(H); a >= "0" && a <= "9" || a >= "a" && a <= "f" || a >= "A" && a <= "F" || C() } d = d + z("0x" + b.slice(j, H)) } else C() } else {
                  if (a == '"') break;
                  d = d + a; H++
                }
              } if (b.charAt(H) == '"') { H++; return d }
            } else {
              j = H; if (a == "-") { o = i; a = b.charAt(++H) } if (a >= "0" && a <= "9") { for (a == "0" && (a = b.charAt(H + 1), a >= "0" && a <= "9") && C(); H < c && (a = b.charAt(H), a >= "0" && a <= "9"); H++); if (b.charAt(H) == ".") { for (f = ++H; f < c && (a = b.charAt(f), a >= "0" && a <= "9"); f++); f == H && C(); H = f } a = b.charAt(H); if (a == "e" || a == "E") { a = b.charAt(++H); (a == "+" || a == "-") && H++; for (f = H; f < c && (a = b.charAt(f), a >= "0" && a <= "9"); f++); f == H && C(); H = f } return +b.slice(j, H) } o && C(); if (b.slice(H, H + 4) == "true") { H = H + 4; return i } if (b.slice(H, H + 5) ==
                "false") { H = H + 5; return false } if (b.slice(H, H + 4) == "null") { H = H + 4; return k }
            } C()
          }
        } return "$"
      }, E = function (b) { var c, a; b == "$" && C(); if (typeof b == "string") { if (b.charAt(0) == "@") return b.slice(1); if (b == "[") { for (c = []; ; a || (a = i)) { b = D(); if (b == "]") break; if (a) if (b == ",") { b = D(); b == "]" && C() } else C(); b == "," && C(); c.push(E(b)) } return c } if (b == "{") { for (c = {}; ; a || (a = i)) { b = D(); if (b == "}") break; if (a) if (b == ",") { b = D(); b == "}" && C() } else C(); (b == "," || typeof b != "string" || b.charAt(0) != "@" || D() != ":") && C(); c[b.slice(1)] = E(D()) } return c } C() } return b },
        G = function (b, c, a) { a = F(b, c, a); a === e ? delete b[c] : b[c] = a }, F = function (b, c, a) { var d = b[c], j; if (typeof d == "object" && d) if (l.call(d) == "[object Array]") for (j = d.length; j--;)G(d, j, a); else n(d, function (b) { G(d, b, a) }); return a.call(b, c, d) }, q.parse = function (b, c) { var a, d; H = 0; I = b; a = E(D()); D() != "$" && C(); H = I = k; return c && l.call(c) == "[object Function]" ? F((d = {}, d[""] = a, d), "", c) : a })
    } p && define(function () { return q });
  }());
})();


(function (root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
})(this, function (exports) {
  function on(type, f) {
    var handlers = this._handlers || (this._handlers = Object.create(null));
    (handlers[type] || (handlers[type] = [])).push(f);
  }
  function off(type, f) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i)
      if (arr[i] == f) { arr.splice(i, 1); break; }
  }
  function signal(type, a1, a2, a3, a4) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4);
  }

  exports.mixin = function (obj) {
    obj.on = on; obj.off = off; obj.signal = signal;
    return obj;
  };
});

// The Tern server object

// A server is a stateful object that manages the analysis for a
// project, and defines an interface for querying the code in the
// project.

(function (root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("./infer"), require("./signal"),
      require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "./infer", "./signal", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
})(this, function (exports, infer, signal, acorn, walk) {
  "use strict";

  var plugins = Object.create(null);
  exports.registerPlugin = function (name, init) { plugins[name] = init; };

  var defaultOptions = exports.defaultOptions = {
    debug: false,
    async: false,
    getFile: function (_f, c) { if (this.async) c(null, null); },
    defs: [],
    plugins: {},
    fetchTimeout: 1000,
    dependencyBudget: 20000,
    reuseInstances: true,
    stripCRs: false
  };

  var queryTypes = {
    completions: {
      takesFile: true,
      run: findCompletions
    },
    properties: {
      run: findProperties
    },
    type: {
      takesFile: true,
      run: findTypeAt
    },
    documentation: {
      takesFile: true,
      run: findDocs
    },
    definition: {
      takesFile: true,
      run: findDef
    },
    refs: {
      takesFile: true,
      fullFile: true,
      run: findRefs
    },
    rename: {
      takesFile: true,
      fullFile: true,
      run: buildRename
    },
    files: {
      run: listFiles
    }
  };

  exports.defineQueryType = function (name, desc) { queryTypes[name] = desc; };

  function File(name, parent) {
    this.name = name;
    this.parent = parent;
    this.scope = this.text = this.ast = this.lineOffsets = null;
  }
  File.prototype.asLineChar = function (pos) { return asLineChar(this, pos); };

  function updateText(file, text, srv) {
    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
    infer.withContext(srv.cx, function () {
      file.ast = infer.parse(file.text, srv.passes, { directSourceFile: file, allowReturnOutsideFunction: true });
    });
    file.lineOffsets = null;
  }

  var Server = exports.Server = function (options) {
    this.cx = null;
    this.options = options || {};
    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
      options[o] = defaultOptions[o];

    this.handlers = Object.create(null);
    this.files = [];
    this.fileMap = Object.create(null);
    this.needsPurge = [];
    this.budgets = Object.create(null);
    this.uses = 0;
    this.pending = 0;
    this.asyncError = null;
    this.passes = Object.create(null);

    this.defs = options.defs.slice(0);
    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin) && plugin in plugins) {
      var init = plugins[plugin](this, options.plugins[plugin]);
      if (init && init.defs) {
        if (init.loadFirst) this.defs.unshift(init.defs);
        else this.defs.push(init.defs);
      }
      if (init && init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
        (this.passes[type] || (this.passes[type] = [])).push(init.passes[type]);
    }

    this.reset();
  };
  Server.prototype = signal.mixin({
    addFile: function (name, /*optional*/ text, parent) {
      // Don't crash when sloppy plugins pass non-existent parent ids
      if (parent && !(parent in this.fileMap)) parent = null;
      ensureFile(this, name, parent, text);
    },
    delFile: function (name) {
      var file = this.findFile(name);
      if (file) {
        this.needsPurge.push(file.name);
        this.files.splice(this.files.indexOf(file), 1);
        delete this.fileMap[name];
      }
    },
    reset: function () {
      this.signal("reset");
      this.cx = new infer.Context(this.defs, this);
      this.uses = 0;
      this.budgets = Object.create(null);
      for (var i = 0; i < this.files.length; ++i) {
        var file = this.files[i];
        file.scope = null;
      }
    },

    request: function (doc, c) {
      var inv = invalidDoc(doc);
      if (inv) return c(inv);

      var self = this;
      doRequest(this, doc, function (err, data) {
        c(err, data);
        if (self.uses > 40) {
          self.reset();
          analyzeAll(self, null, function () { });
        }
      });
    },

    findFile: function (name) {
      return this.fileMap[name];
    },

    flush: function (c) {
      var cx = this.cx;
      analyzeAll(this, null, function (err) {
        if (err) return c(err);
        infer.withContext(cx, c);
      });
    },

    startAsyncAction: function () {
      ++this.pending;
    },
    finishAsyncAction: function (err) {
      if (err) this.asyncError = err;
      if (--this.pending === 0) this.signal("everythingFetched");
    }
  });

  function doRequest(srv, doc, c) {
    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
      return c("No query type '" + doc.query.type + "' defined");

    var query = doc.query;
    // Respond as soon as possible when this just uploads files
    if (!query) c(null, {});

    var files = doc.files || [];
    if (files.length) ++srv.uses;
    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      if (file.type == "delete")
        srv.delFile(file.name);
      else
        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
    }

    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
    if (!query) {
      analyzeAll(srv, timeBudget, function () { });
      return;
    }

    var queryType = queryTypes[query.type];
    if (queryType.takesFile) {
      if (typeof query.file != "string") return c(".query.file must be a string");
      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
    }

    analyzeAll(srv, timeBudget, function (err) {
      if (err) return c(err);
      var file = queryType.takesFile && resolveFile(srv, files, query.file);
      if (queryType.fullFile && file.type == "part")
        return c("Can't run a " + query.type + " query on a file fragment");

      function run() {
        var result;
        try {
          result = queryType.run(srv, query, file);
        } catch (e) {
          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
          return c(e);
        }
        c(null, result);
      }
      infer.withContext(srv.cx, timeBudget ? function () { infer.withTimeout(timeBudget[0], run); } : run);
    });
  }

  function analyzeFile(srv, file) {
    infer.withContext(srv.cx, function () {
      file.scope = srv.cx.topScope;
      srv.signal("beforeLoad", file);
      infer.analyze(file.ast, file.name, file.scope, srv.passes);
      srv.signal("afterLoad", file);
    });
    return file;
  }

  function ensureFile(srv, name, parent, text) {
    var known = srv.findFile(name);
    if (known) {
      if (text != null) {
        if (known.scope) {
          srv.needsPurge.push(name);
          known.scope = null;
        }
        updateText(known, text, srv);
      }
      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
        known.parent = parent;
        if (known.excluded) known.excluded = null;
      }
      return;
    }

    var file = new File(name, parent);
    srv.files.push(file);
    srv.fileMap[name] = file;
    if (text != null) {
      updateText(file, text, srv);
    } else if (srv.options.async) {
      srv.startAsyncAction();
      srv.options.getFile(name, function (err, text) {
        updateText(file, text || "", srv);
        srv.finishAsyncAction(err);
      });
    } else {
      updateText(file, srv.options.getFile(name) || "", srv);
    }
  }

  function fetchAll(srv, c) {
    var done = true, returned = false;
    srv.files.forEach(function (file) {
      if (file.text != null) return;
      if (srv.options.async) {
        done = false;
        srv.options.getFile(file.name, function (err, text) {
          if (err && !returned) { returned = true; return c(err); }
          updateText(file, text || "", srv);
          fetchAll(srv, c);
        });
      } else {
        try {
          updateText(file, srv.options.getFile(file.name) || "", srv);
        } catch (e) { return c(e); }
      }
    });
    if (done) c();
  }

  function waitOnFetch(srv, timeBudget, c) {
    var done = function () {
      srv.off("everythingFetched", done);
      clearTimeout(timeout);
      analyzeAll(srv, timeBudget, c);
    };
    srv.on("everythingFetched", done);
    var timeout = setTimeout(done, srv.options.fetchTimeout);
  }

  function analyzeAll(srv, timeBudget, c) {
    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

    var e = srv.fetchError;
    if (e) { srv.fetchError = null; return c(e); }

    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function () {
      infer.purge(srv.needsPurge);
      srv.needsPurge.length = 0;
    });

    var done = true;
    // The second inner loop might add new files. The outer loop keeps
    // repeating both inner loops until all files have been looked at.
    for (var i = 0; i < srv.files.length;) {
      var toAnalyze = [];
      for (; i < srv.files.length; ++i) {
        var file = srv.files[i];
        if (file.text == null) done = false;
        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
      }
      toAnalyze.sort(function (a, b) {
        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
      });
      for (var j = 0; j < toAnalyze.length; j++) {
        var file = toAnalyze[j];
        if (file.parent && !chargeOnBudget(srv, file)) {
          file.excluded = true;
        } else if (timeBudget) {
          var startTime = +new Date;
          infer.withTimeout(timeBudget[0], function () { analyzeFile(srv, file); });
          timeBudget[0] -= +new Date - startTime;
        } else {
          analyzeFile(srv, file);
        }
      }
    }
    if (done) c();
    else waitOnFetch(srv, timeBudget, c);
  }

  function firstLine(str) {
    var end = str.indexOf("\n");
    if (end < 0) return str;
    return str.slice(0, end);
  }

  function findMatchingPosition(line, file, near) {
    var pos = Math.max(0, near - 500), closest = null;
    if (!/^\s*$/.test(line)) for (; ;) {
      var found = file.indexOf(line, pos);
      if (found < 0 || found > near + 500) break;
      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
        closest = found;
      pos = found + line.length;
    }
    return closest;
  }

  function scopeDepth(s) {
    for (var i = 0; s; ++i, s = s.prev) { }
    return i;
  }

  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }

  function resolveFile(srv, localFiles, name) {
    var isRef = name.match(/^#(\d+)$/);
    if (!isRef) return srv.findFile(name);

    var file = localFiles[isRef[1]];
    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
    if (file.type == "full") return srv.findFile(file.name);

    // This is a partial file

    var realFile = file.backing = srv.findFile(file.name);
    var offset;
    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : { line: file.offsetLines, ch: 0 }, true);
    var line = firstLine(file.text);
    var foundPos = findMatchingPosition(line, realFile.text, offset);
    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
    var inObject, atFunction;

    infer.withContext(srv.cx, function () {
      infer.purge(file.name, pos, pos + file.text.length);

      var text = file.text, m;
      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
        if (objNode && objNode.node.objType)
          inObject = { type: objNode.node.objType, prop: m[2] || m[1] };
      }
      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
        var cut = m[1].length, white = "";
        for (var i = 0; i < cut; ++i) white += " ";
        text = white + text.slice(cut);
        atFunction = true;
      }

      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
      file.ast = infer.parse(text, srv.passes, { directSourceFile: file, allowReturnOutsideFunction: true });
      infer.analyze(file.ast, file.name, scope, srv.passes);

      // This is a kludge to tie together the function types (if any)
      // outside and inside of the fragment, so that arguments and
      // return values have some information known about them.
      tieTogether: if (inObject || atFunction) {
        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
        if (!newInner.fnType) break tieTogether;
        if (inObject) {
          var prop = inObject.type.getProp(inObject.prop);
          prop.addType(newInner.fnType);
        } else if (atFunction) {
          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
          if (inner == scopeStart || !inner.fnType) break tieTogether;
          var fOld = inner.fnType, fNew = newInner.fnType;
          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
            fOld.args[i].propagate(fNew.args[i]);
          fOld.self.propagate(fNew.self);
          fNew.retval.propagate(fOld.retval);
        }
      }
    });
    return file;
  }

  // Budget management

  function astSize(node) {
    var size = 0;
    walk.simple(node, { Expression: function () { ++size; } });
    return size;
  }

  function parentDepth(srv, parent) {
    var depth = 0;
    while (parent) {
      parent = srv.findFile(parent).parent;
      ++depth;
    }
    return depth;
  }

  function budgetName(srv, file) {
    for (; ;) {
      var parent = srv.findFile(file.parent);
      if (!parent.parent) break;
      file = parent;
    }
    return file.name;
  }

  function chargeOnBudget(srv, file) {
    var bName = budgetName(srv, file);
    var size = astSize(file.ast);
    var known = srv.budgets[bName];
    if (known == null)
      known = srv.budgets[bName] = srv.options.dependencyBudget;
    if (known < size) return false;
    srv.budgets[bName] = known - size;
    return true;
  }

  // Query helpers

  function isPosition(val) {
    return typeof val == "number" || typeof val == "object" &&
      typeof val.line == "number" && typeof val.ch == "number";
  }

  // Baseline query document validation
  function invalidDoc(doc) {
    if (doc.query) {
      if (typeof doc.query.type != "string") return ".query.type must be a string";
      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
    }
    if (doc.files) {
      if (!Array.isArray(doc.files)) return "Files property must be an array";
      for (var i = 0; i < doc.files.length; ++i) {
        var file = doc.files[i];
        if (typeof file != "object") return ".files[n] must be objects";
        else if (typeof file.name != "string") return ".files[n].name must be a string";
        else if (file.type == "delete") continue;
        else if (typeof file.text != "string") return ".files[n].text must be a string";
        else if (file.type == "part") {
          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
            return ".files[n].offset must be a position";
        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
      }
    }
  }

  var offsetSkipLines = 25;

  function findLineStart(file, line) {
    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var pos = 0, curLine = 0;
    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

    while (curLine < line) {
      ++curLine;
      pos = text.indexOf("\n", pos) + 1;
      if (pos === 0) return null;
      if (curLine % offsetSkipLines === 0) offsets.push(pos);
    }
    return pos;
  }

  var resolvePos = exports.resolvePos = function (file, pos, tolerant) {
    if (typeof pos != "number") {
      var lineStart = findLineStart(file, pos.line);
      if (lineStart == null) {
        if (tolerant) pos = file.text.length;
        else throw ternError("File doesn't contain a line " + pos.line);
      } else {
        pos = lineStart + pos.ch;
      }
    }
    if (pos > file.text.length) {
      if (tolerant) pos = file.text.length;
      else throw ternError("Position " + pos + " is outside of file.");
    }
    return pos;
  };

  function asLineChar(file, pos) {
    if (!file) return { line: 0, ch: 0 };
    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var text = file.text, line, lineStart;
    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
      line = i * offsetSkipLines;
      lineStart = offsets[i];
    }
    for (; ;) {
      var eol = text.indexOf("\n", lineStart);
      if (eol >= pos || eol < 0) break;
      lineStart = eol + 1;
      ++line;
    }
    return { line: line, ch: pos - lineStart };
  }

  var outputPos = exports.outputPos = function (query, file, pos) {
    if (query.lineCharPositions) {
      var out = asLineChar(file, pos);
      if (file.type == "part")
        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
      return out;
    } else {
      return pos + (file.type == "part" ? file.offset : 0);
    }
  };

  // Delete empty fields from result objects
  function clean(obj) {
    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
    return obj;
  }
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }

  // Built-in query types

  function compareCompletions(a, b) {
    if (typeof a != "string") { a = a.name; b = b.name; }
    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
    else return aUp ? 1 : -1;
  }

  function isStringAround(node, start, end) {
    return node.type == "Literal" && typeof node.value == "string" &&
      node.start == start - 1 && node.end <= end + 1;
  }

  function pointInProp(objNode, point) {
    for (var i = 0; i < objNode.properties.length; i++) {
      var curProp = objNode.properties[i];
      if (curProp.key.start <= point && curProp.key.end >= point)
        return curProp;
    }
  }

  var jsKeywords = ("break do instanceof typeof case else new var " +
    "catch finally return void continue for switch while debugger " +
    "function this with default if throw delete in try").split(" ");

  function findCompletions(srv, query, file) {
    if (query.end == null) throw ternError("missing .query.end field");
    if (srv.passes.completion) for (var i = 0; i < srv.passes.completion.length; i++) {
      var result = srv.passes.completion[i](file, query);
      if (result) return result;
    }

    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
    if (query.expandWordForward !== false)
      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
    if (query.caseInsensitive) word = word.toLowerCase();
    var wrapAsObjs = query.types || query.depths || query.docs || query.urls || query.origins;

    function gather(prop, obj, depth, addInfo) {
      // 'hasOwnProperty' and such are usually just noise, leave them
      // out when no prefix is provided.
      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
        (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
      if (ignoreObj && ignoreObj.props[prop]) return;
      for (var i = 0; i < completions.length; ++i) {
        var c = completions[i];
        if ((wrapAsObjs ? c.name : c) == prop) return;
      }
      var rec = wrapAsObjs ? { name: prop } : prop;
      completions.push(rec);

      if (obj && (query.types || query.docs || query.urls || query.origins)) {
        var val = obj.props[prop];
        infer.resetGuessing();
        var type = val.getType();
        rec.guess = infer.didGuess();
        if (query.types)
          rec.type = infer.toString(val);
        if (query.docs)
          maybeSet(rec, "doc", val.doc || type && type.doc);
        if (query.urls)
          maybeSet(rec, "url", val.url || type && type.url);
        if (query.origins)
          maybeSet(rec, "origin", val.origin || type && type.origin);
      }
      if (query.depths) rec.depth = depth;
      if (wrapAsObjs && addInfo) addInfo(rec);
    }

    var hookname, prop, objType, isKey;

    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
    var memberExpr, objLit;
    // Decide whether this is an object property, either in a member
    // expression or an object literal.
    if (exprAt) {
      if (exprAt.node.type == "MemberExpression" && exprAt.node.object.end < wordStart) {
        memberExpr = exprAt;
      } else if (isStringAround(exprAt.node, wordStart, wordEnd)) {
        var parent = infer.parentNode(exprAt.node, file.ast);
        if (parent.type == "MemberExpression" && parent.property == exprAt.node)
          memberExpr = { node: parent, state: exprAt.state };
      } else if (exprAt.node.type == "ObjectExpression") {
        var objProp = pointInProp(exprAt.node, wordEnd);
        if (objProp) {
          objLit = exprAt;
          prop = isKey = objProp.key.name;
        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
          objLit = exprAt;
          prop = isKey = true;
        }
      }
    }

    if (objLit) {
      // Since we can't use the type of the literal itself to complete
      // its properties (it doesn't contain the information we need),
      // we have to try asking the surrounding expression for type info.
      objType = infer.typeFromContext(file.ast, objLit);
      ignoreObj = objLit.node.objType;
    } else if (memberExpr) {
      prop = memberExpr.node.property;
      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
      memberExpr.node = memberExpr.node.object;
      objType = infer.expressionType(memberExpr);
    } else if (text.charAt(wordStart - 1) == ".") {
      var pathStart = wordStart - 1;
      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
      var path = text.slice(pathStart, wordStart - 1);
      if (path) {
        objType = infer.def.parsePath(path, file.scope).getObjType();
        prop = word;
      }
    }

    if (prop != null) {
      srv.cx.completingProperty = prop;

      if (objType) infer.forAllPropertiesOf(objType, gather);

      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
        objType.guessProperties(function (p, o, d) { if (p != prop && p != "✖") gather(p, o, d); });
      if (!completions.length && word.length >= 2 && query.guess !== false)
        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
      hookname = "memberCompletion";
    } else {
      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
      if (query.includeKeywords) jsKeywords.forEach(function (kw) {
        gather(kw, null, 0, function (rec) { rec.isKeyword = true; });
      });
      hookname = "variableCompletion";
    }
    if (srv.passes[hookname])
      srv.passes[hookname].forEach(function (hook) { hook(file, wordStart, wordEnd, gather); });

    if (query.sort !== false) completions.sort(compareCompletions);
    srv.cx.completingProperty = null;

    return {
      start: outputPos(query, file, wordStart),
      end: outputPos(query, file, wordEnd),
      isProperty: !!prop,
      isObjectKey: !!isKey,
      completions: completions
    };
  }

  function findProperties(srv, query) {
    var prefix = query.prefix, found = [];
    for (var prop in srv.cx.props)
      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
    if (query.sort !== false) found.sort(compareCompletions);
    return { completions: found };
  }

  var findExpr = exports.findQueryExpr = function (file, query, wide) {
    if (query.end == null) throw ternError("missing .query.end field");

    if (query.variable) {
      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
      return {
        node: { type: "Identifier", name: query.variable, start: query.end, end: query.end + 1 },
        state: scope
      };
    } else {
      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
      if (expr) return expr;
      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (expr && (expr.node.type == "ObjectExpression" || wide ||
        (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
        return expr;
      return null;
    }
  };

  function findExprOrThrow(file, query, wide) {
    var expr = findExpr(file, query, wide);
    if (expr) return expr;
    throw ternError("No expression at the given position.");
  }

  function ensureObj(tp) {
    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
    return tp;
  }

  function findExprType(srv, query, file, expr) {
    var type;
    if (expr) {
      infer.resetGuessing();
      type = infer.expressionType(expr);
    }
    if (srv.passes["typeAt"]) {
      var pos = resolvePos(file, query.end);
      srv.passes["typeAt"].forEach(function (hook) {
        type = hook(file, pos, expr, type);
      });
    }
    if (!type) throw ternError("No type found at the given position.");

    var objProp;
    if (expr.node.type == "ObjectExpression" && query.end != null &&
      (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
      var name = objProp.key.name;
      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
      if (fromCx && fromCx.hasProp(name)) {
        type = fromCx.hasProp(name);
      } else {
        var fromLocal = ensureObj(type);
        if (fromLocal && fromLocal.hasProp(name))
          type = fromLocal.hasProp(name);
      }
    }
    return type;
  };

  function findTypeAt(srv, query, file) {
    var expr = findExpr(file, query), exprName;
    var type = findExprType(srv, query, file, expr), exprType = type;
    if (query.preferFunction)
      type = type.getFunctionType() || type.getType();
    else
      type = type.getType();

    if (expr) {
      if (expr.node.type == "Identifier")
        exprName = expr.node.name;
      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
        exprName = expr.node.property.name;
    }

    if (query.depth != null && typeof query.depth != "number")
      throw ternError(".query.depth must be a number");

    var result = {
      guess: infer.didGuess(),
      type: infer.toString(exprType, query.depth),
      name: type && type.name,
      exprName: exprName
    };
    if (type) storeTypeDocs(type, result);
    if (!result.doc && exprType.doc) result.doc = exprType.doc;

    return clean(result);
  }

  function findDocs(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    var result = { url: type.url, doc: type.doc, type: infer.toString(type) };
    var inner = type.getType();
    if (inner) storeTypeDocs(inner, result);
    return clean(result);
  }

  function storeTypeDocs(type, out) {
    if (!out.url) out.url = type.url;
    if (!out.doc) out.doc = type.doc;
    if (!out.origin) out.origin = type.origin;
    var ctor, boring = infer.cx().protos;
    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
      type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
      out.url = ctor.url;
      out.doc = ctor.doc;
    }
  }

  var getSpan = exports.getSpan = function (obj) {
    if (!obj.origin) return;
    if (obj.originNode) {
      var node = obj.originNode;
      if (/^Function/.test(node.type) && node.id) node = node.id;
      return { origin: obj.origin, node: node };
    }
    if (obj.span) return { origin: obj.origin, span: obj.span };
  };

  var storeSpan = exports.storeSpan = function (srv, query, span, target) {
    target.origin = span.origin;
    if (span.span) {
      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
      target.start = query.lineCharPositions ? { line: Number(m[2]), ch: Number(m[3]) } : Number(m[1]);
      target.end = query.lineCharPositions ? { line: Number(m[5]), ch: Number(m[6]) } : Number(m[4]);
    } else {
      var file = srv.findFile(span.origin);
      target.start = outputPos(query, file, span.node.start);
      target.end = outputPos(query, file, span.node.end);
    }
  };

  function findDef(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    if (infer.didGuess()) return {};

    var span = getSpan(type);
    var result = { url: type.url, doc: type.doc, origin: type.origin };

    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
      var tp = type.types[i];
      storeTypeDocs(tp, result);
      if (!span) span = getSpan(tp);
    }

    if (span && span.node) { // refers to a loaded file
      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
      result.start = start; result.end = end;
      result.file = span.origin;
      var cxStart = Math.max(0, span.node.start - 50);
      result.contextOffset = span.node.start - cxStart;
      result.context = spanFile.text.slice(cxStart, cxStart + 50);
    } else if (span) { // external
      result.file = span.origin;
      storeSpan(srv, query, span, result);
    }
    return clean(result);
  }

  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
    var name = expr.node.name;

    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) { }
    if (!scope) throw ternError("Could not find a definition for " + name + " " + !!srv.cx.topScope.props.x);

    var type, refs = [];
    function storeRef(file) {
      return function (node, scopeHere) {
        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
          var exists = s.hasProp(checkShadowing);
          if (exists)
            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
              (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
              (asLineChar(file, exists.name.start).line + 1));
        }
        refs.push({
          file: file.name,
          start: outputPos(query, file, node.start),
          end: outputPos(query, file, node.end)
        });
      };
    }

    if (scope.originNode) {
      type = "local";
      if (checkShadowing) {
        for (var prev = scope.prev; prev; prev = prev.prev)
          if (checkShadowing in prev.props) break;
        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function (node) {
          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
            (asLineChar(file, node.start).line + 1));
        });
      }
      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
    } else {
      type = "global";
      for (var i = 0; i < srv.files.length; ++i) {
        var cur = srv.files[i];
        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
      }
    }

    return { refs: refs, type: type, name: name };
  }

  function findRefsToProperty(srv, query, expr, prop) {
    var objType = infer.expressionType(expr).getObjType();
    if (!objType) throw ternError("Couldn't determine type of base object.");

    var refs = [];
    function storeRef(file) {
      return function (node) {
        refs.push({
          file: file.name,
          start: outputPos(query, file, node.start),
          end: outputPos(query, file, node.end)
        });
      };
    }
    for (var i = 0; i < srv.files.length; ++i) {
      var cur = srv.files[i];
      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
    }

    return { refs: refs, name: prop.name };
  }

  function findRefs(srv, query, file) {
    var expr = findExprOrThrow(file, query, true);
    if (expr.node.type == "Identifier") {
      return findRefsToVariable(srv, query, file, expr);
    } else if (expr.node.type == "MemberExpression" && !expr.node.computed) {
      var p = expr.node.property;
      expr.node = expr.node.object;
      return findRefsToProperty(srv, query, expr, p);
    } else if (expr.node.type == "ObjectExpression") {
      var pos = resolvePos(file, query.end);
      for (var i = 0; i < expr.node.properties.length; ++i) {
        var k = expr.node.properties[i].key;
        if (k.start <= pos && k.end >= pos)
          return findRefsToProperty(srv, query, expr, k);
      }
    }
    throw ternError("Not at a variable or property name.");
  }

  function buildRename(srv, query, file) {
    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
    var expr = findExprOrThrow(file, query);
    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
    delete data.refs;
    data.files = srv.files.map(function (f) { return f.name; });

    var changes = data.changes = [];
    for (var i = 0; i < refs.length; ++i) {
      var use = refs[i];
      use.text = query.newName;
      changes.push(use);
    }

    return data;
  }

  function listFiles(srv) {
    return { files: srv.files.map(function (f) { return f.name; }) };
  }

  exports.version = "0.11.1";
});

// Type description parser
//
// Type description JSON files (such as ecma5.json and browser.json)
// are used to
//
// A) describe types that come from native code
//
// B) to cheaply load the types for big libraries, or libraries that
//    can't be inferred well

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return exports.init = mod;
  if (typeof define == "function" && define.amd) // AMD
    return define({ init: mod });
  tern.def = { init: mod };
})(function (exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function (spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(args, retType) {
    return function (self, cArgs) {
      var realArgs = [];
      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs));
    };
  }
  function computedUnion(types) {
    return function (self, args) {
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
      return union;
    };
  }
  function computedArray(inner) {
    return function (self, args) {
      return new infer.Arr(inner(self, args));
    };
  }

  TypeParser.prototype = {
    eat: function (str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function (re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function () {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function (comp, name, top) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -> ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call) {
          if (top) {
            computeRet = retType;
            retType = infer.ANull;
            computeRetStart = retStart;
          } else {
            computed = true;
          }
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(args, retType);

      if (top && (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function (comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (; ;) {
        var next = this.parseTypeMaybeProp(comp, name, top);
        types.push(next);
        if (next.call) computed = true;
        if (!this.eat("|")) break;
      }
      if (computed) return computedUnion(types);
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) types[i].propagate(union);
      return union;
    },
    parseTypeMaybeProp: function (comp, name, top) {
      var result = this.parseTypeInner(comp, name, top);
      while (comp && this.eat(".")) result = this.extendWithProp(result);
      return result;
    },
    extendWithProp: function (base) {
      var propName = this.word(/[\w<>$!]/) || this.error();
      if (base.apply) return function (self, args) {
        return extractProp(base(self, args), propName);
      };
      return extractProp(base, propName);
    },
    parseTypeInner: function (comp, name, top) {
      if (this.eat("fn(")) {
        return this.parseFnType(comp, name, top);
      } else if (this.eat("[")) {
        var inner = this.parseType(comp);
        this.eat("]") || this.error();
        if (inner.call) return computedArray(inner);
        if (top && this.base) {
          infer.Arr.call(this.base, inner);
          return this.base;
        }
        return new infer.Arr(inner);
      } else if (this.eat("+")) {
        var path = this.word(/[\w$<>\.!]/);
        var base = parsePath(path + ".prototype");
        if (!(base instanceof infer.Obj)) base = parsePath(path);
        if (!(base instanceof infer.Obj)) return base;
        if (comp && this.eat("[")) return this.parsePoly(base);
        if (top && this.forceNew) return new infer.Obj(base);
        return infer.getInstance(base);
      } else if (comp && this.eat("!")) {
        var arg = this.word(/\d/);
        if (arg) {
          arg = Number(arg);
          return function (_self, args) { return args[arg] || infer.ANull; };
        } else if (this.eat("this")) {
          return function (self) { return self; };
        } else if (this.eat("custom:")) {
          var fname = this.word(/[\w$]/);
          return customFunctions[fname] || function () { return infer.ANull; };
        } else {
          return this.fromWord("!" + this.word(/[\w$<>\.!]/));
        }
      } else if (this.eat("?")) {
        return infer.ANull;
      } else {
        return this.fromWord(this.word(/[\w$<>\.!`]/));
      }
    },
    fromWord: function (spec) {
      var cx = infer.cx();
      switch (spec) {
        case "number": return cx.num;
        case "string": return cx.str;
        case "bool": return cx.bool;
        case "<top>": return cx.topScope;
      }
      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
      return parsePath(spec);
    },
    parsePoly: function (base) {
      var propName = "<i>", match;
      if (match = this.spec.slice(this.pos).match(/^\s*(\w+)\s*=\s*/)) {
        propName = match[1];
        this.pos += match[0].length;
      }
      var value = this.parseType(true);
      if (!this.eat("]")) this.error();
      if (value.call) return function (self, args) {
        var instance = infer.getInstance(base);
        value(self, args).propagate(instance.defProp(propName));
        return instance;
      };
      var instance = infer.getInstance(base);
      value.propagate(instance.defProp(propName));
      return instance;
    }
  };

  function parseType(spec, name, base, forceNew) {
    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function (i) {
      var arg = type.args[i];
      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function (_self, fArgs) {
        var fArg = fArgs[i];
        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
      });
    })(i);
    return type;
  }

  function addEffect(fn, handler, replaceRet) {
    var oldCmp = fn.computeRet, rv = fn.retval;
    fn.computeRet = function (self, args, argNodes) {
      var handled = handler(self, args, argNodes);
      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
      return replaceRet ? handled : old;
    };
  }

  var parseEffect = exports.parseEffect = function (effect, fn) {
    var m;
    if (effect.indexOf("propagate ") == 0) {
      var p = new TypeParser(effect, 10);
      var origin = p.parseType(true);
      if (!p.eat(" ")) p.error();
      var target = p.parseType(true);
      addEffect(fn, function (self, args) {
        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
      });
    } else if (effect.indexOf("call ") == 0) {
      var andRet = effect.indexOf("and return ", 5) == 5;
      var p = new TypeParser(effect, andRet ? 16 : 5);
      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
      if (p.eat(" this=")) getSelf = p.parseType(true);
      while (p.eat(" ")) getArgs.push(p.parseType(true));
      addEffect(fn, function (self, args) {
        var callee = unwrapType(getCallee, self, args);
        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
        var result = andRet ? new infer.AVal : infer.ANull;
        callee.propagate(new infer.IsCallee(slf, as, null, result));
        return result;
      }, andRet);
    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
      var customFunc = customFunctions[m[1]];
      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
    } else if (effect.indexOf("copy ") == 0) {
      var p = new TypeParser(effect, 5);
      var getFrom = p.parseType(true);
      p.eat(" ");
      var getTo = p.parseType(true);
      addEffect(fn, function (self, args) {
        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
        from.forAllProps(function (prop, val, local) {
          if (local && prop != "<i>")
            to.propagate(new infer.PropHasSubset(prop, val));
        });
      });
    } else {
      throw new Error("Unknown effect type: " + effect);
    }
  };

  var currentTopScope;

  var parsePath = exports.parsePath = function (path, scope) {
    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
    if (cached != null) return cached;
    cx.paths[path] = infer.ANull;

    var base = scope || currentTopScope || cx.topScope;

    if (cx.localDefs) for (var name in cx.localDefs) {
      if (path.indexOf(name) == 0) {
        if (path == name) return cx.paths[path] = cx.localDefs[path];
        if (path.charAt(name.length) == ".") {
          base = cx.localDefs[name];
          path = path.slice(name.length + 1);
          break;
        }
      }
    }

    var parts = path.split(".");
    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
      var prop = parts[i];
      if (prop.charAt(0) == "!") {
        if (prop == "!proto") {
          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
        } else {
          var fn = base.getFunctionType();
          if (!fn) {
            base = infer.ANull;
          } else if (prop == "!ret") {
            base = fn.retval && fn.retval.getType(false) || infer.ANull;
          } else {
            var arg = fn.args && fn.args[Number(prop.slice(1))];
            base = (arg && arg.getType(false)) || infer.ANull;
          }
        }
      } else if (base instanceof infer.Obj) {
        var propVal = (prop == "prototype" && base instanceof infer.Fn) ? base.getProp(prop) : base.props[prop];
        if (!propVal || propVal.isEmpty())
          base = infer.ANull;
        else
          base = propVal.types[0];
      }
    }
    // Uncomment this to get feedback on your poorly written .json files
    // if (base == infer.ANull) console.error("bad path: " + origPath + " (" + cx.curOrigin + ")");
    cx.paths[origPath] = base == infer.ANull ? null : base;
    return base;
  };

  function emptyObj(ctor) {
    var empty = Object.create(ctor.prototype);
    empty.props = Object.create(null);
    empty.isShell = true;
    return empty;
  }

  function isSimpleAnnotation(spec) {
    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
    for (var prop in spec)
      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
        return false;
    return true;
  }

  function passOne(base, spec, path) {
    if (!base) {
      var tp = spec["!type"];
      if (tp) {
        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
        else throw new Error("Invalid !type spec: " + tp);
      } else if (spec["!stdProto"]) {
        base = infer.cx().protos[spec["!stdProto"]];
      } else {
        base = emptyObj(infer.Obj);
      }
      base.name = path;
    }

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name];
      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
      var prop = base.defProp(name);
      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
    }
    return base;
  }

  function passTwo(base, spec, path) {
    if (base.isShell) {
      delete base.isShell;
      var tp = spec["!type"];
      if (tp) {
        parseType(tp, path, base);
      } else {
        var proto = spec["!proto"] && parseType(spec["!proto"]);
        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
      }
    }

    var effects = spec["!effects"];
    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
      parseEffect(effects[i], base);
    copyInfo(spec, base);

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
      if (typeof inner == "string") {
        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
      } else {
        if (!isSimpleAnnotation(inner))
          passTwo(known.getObjType(), inner, innerPath);
        else if (known.isEmpty())
          parseType(inner["!type"], innerPath, null, true).propagate(known);
        else
          continue;
        if (inner["!doc"]) known.doc = inner["!doc"];
        if (inner["!url"]) known.url = inner["!url"];
        if (inner["!span"]) known.span = inner["!span"];
      }
    }
    return base;
  }

  function copyInfo(spec, type) {
    if (spec["!doc"]) type.doc = spec["!doc"];
    if (spec["!url"]) type.url = spec["!url"];
    if (spec["!span"]) type.span = spec["!span"];
    if (spec["!data"]) type.metaData = spec["!data"];
  }

  function runPasses(type, arg) {
    var parent = infer.cx().parent, pass = parent && parent.passes && parent.passes[type];
    if (pass) for (var i = 0; i < pass.length; i++) pass[i](arg);
  }

  function doLoadEnvironment(data, scope) {
    var cx = infer.cx();

    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

    runPasses("preLoadDef", data);

    passOne(scope, data);

    var def = data["!define"];
    if (def) {
      for (var name in def) {
        var spec = def[name];
        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
      }
      for (var name in def) {
        var spec = def[name];
        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
      }
    }

    passTwo(scope, data);

    runPasses("postLoadDef", data);

    cx.curOrigin = cx.localDefs = null;
  }

  exports.load = function (data, scope) {
    if (!scope) scope = infer.cx().topScope;
    var oldScope = currentTopScope;
    currentTopScope = scope;
    try {
      doLoadEnvironment(data, scope);
    } finally {
      currentTopScope = oldScope;
    }
  };

  exports.parse = function (data, origin, path) {
    var cx = infer.cx();
    if (origin) {
      cx.origin = origin;
      cx.localDefs = cx.definitions[origin];
    }

    try {
      if (typeof data == "string")
        return parseType(data, path);
      else
        return passTwo(passOne(null, data, path), data, path);
    } finally {
      if (origin) cx.origin = cx.localDefs = null;
    }
  };

  // Used to register custom logic for more involved effect or type
  // computation.
  var customFunctions = Object.create(null);
  infer.registerFunction = function (name, f) { customFunctions[name] = f; };

  var IsCreated = infer.constraint("created, target, spec", {
    addType: function (tp) {
      if (tp instanceof infer.Obj && this.created++ < 5) {
        var derived = new infer.Obj(tp), spec = this.spec;
        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
        if (spec instanceof infer.Obj) for (var prop in spec.props) {
          var cur = spec.props[prop].types[0];
          var p = derived.defProp(prop);
          if (cur && cur instanceof infer.Obj && cur.props.value) {
            var vtp = cur.props.value.getType(false);
            if (vtp) p.addType(vtp);
          }
        }
        this.target.addType(derived);
      }
    }
  });

  infer.registerFunction("Object_create", function (_self, args, argNodes) {
    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
      return new infer.Obj();

    var result = new infer.AVal;
    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
    return result;
  });

  var PropSpec = infer.constraint("target", {
    addType: function (tp) {
      if (!(tp instanceof infer.Obj)) return;
      if (tp.hasProp("value"))
        tp.getProp("value").propagate(this.target);
      else if (tp.hasProp("get"))
        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
    }
  });

  infer.registerFunction("Object_defineProperty", function (_self, args, argNodes) {
    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
      typeof argNodes[1].value == "string") {
      var obj = args[0], connect = new infer.AVal;
      obj.propagate(new infer.PropHasSubset(argNodes[1].value, connect, argNodes[1]));
      args[2].propagate(new PropSpec(connect));
    }
    return infer.ANull;
  });

  infer.registerFunction("Object_defineProperties", function (_self, args, argNodes) {
    if (args.length >= 2) {
      var obj = args[0];
      args[1].forAllProps(function (prop, val, local) {
        if (!local) return;
        var connect = new infer.AVal;
        obj.propagate(new infer.PropHasSubset(prop, connect, argNodes && argNodes[1]));
        val.propagate(new PropSpec(connect));
      });
    }
    return infer.ANull;
  });

  var IsBound = infer.constraint("self, args, target", {
    addType: function (tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
        tp.argNames.slice(this.args.length), tp.retval));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("Function_bind", function (self, args) {
    if (!args.length) return infer.ANull;
    var result = new infer.AVal;
    self.propagate(new IsBound(args[0], args.slice(1), result));
    return result;
  });

  infer.registerFunction("Array_ctor", function (_self, args) {
    var arr = new infer.Arr;
    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
      var content = arr.getProp("<i>");
      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
    }
    return arr;
  });

  infer.registerFunction("Promise_ctor", function (_self, args, argNodes) {
    if (args.length < 1) return infer.ANull;
    var self = new infer.Obj(infer.cx().definitions.ecma6["Promise.prototype"]);
    var valProp = self.defProp("value", argNodes && argNodes[0]);
    var valArg = new infer.AVal;
    valArg.propagate(valProp);
    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
    var reject = infer.cx().definitions.ecma6.promiseReject;
    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
    return self;
  });

  return exports;
});

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod(tern.comment || (tern.comment = {}));
})(function (exports) {
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;
  }

  function onOwnLine(text, pos) {
    for (; pos > 0; --pos) {
      var ch = text.charCodeAt(pos - 1);
      if (ch == 10) break;
      if (!isSpace(ch)) return false;
    }
    return true;
  }

  // Gather comments directly before a function
  exports.commentsBefore = function (text, pos) {
    var found = null, emptyLines = 0, topIsLineComment;
    out: while (pos > 0) {
      var prev = text.charCodeAt(pos - 1);
      if (prev == 10) {
        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {
          prev = text.charCodeAt(scan - 1);
          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            var content = text.slice(scan, pos);
            if (!emptyLines && topIsLineComment) found[0] = content + "\n" + found[0];
            else (found || (found = [])).unshift(content);
            topIsLineComment = true;
            emptyLines = 0;
            pos = scan - 2;
            break;
          } else if (prev == 10) {
            if (!sawNonWS && ++emptyLines > 1) break out;
            break;
          } else if (!sawNonWS && !isSpace(prev)) {
            sawNonWS = true;
          }
        }
      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {
        for (var scan = pos - 2; scan > 1; --scan) {
          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            (found || (found = [])).unshift(text.slice(scan, pos - 2));
            topIsLineComment = false;
            emptyLines = 0;
            break;
          }
        }
        pos = scan - 2;
      } else if (isSpace(prev)) {
        --pos;
      } else {
        break;
      }
    }
    return found;
  };

  exports.commentAfter = function (text, pos) {
    while (pos < text.length) {
      var next = text.charCodeAt(pos);
      if (next == 47) {
        var after = text.charCodeAt(pos + 1), end;
        if (after == 47) // line comment
          end = text.indexOf("\n", pos + 2);
        else if (after == 42) // block comment
          end = text.indexOf("*/", pos + 2);
        else
          return;
        return text.slice(pos + 2, end < 0 ? text.length : end);
      } else if (isSpace(next)) {
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function (text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.commentsBefore(text, node.start);
  };
});

// Main type inference engine

// Walks an AST, building up a graph of abstract values and constraints
// that cause types to flow from one node to another. Also defines a
// number of utilities for accessing ASTs and scopes.

// Analysis is done in a context, which is tracked by the dynamically
// bound cx variable. Use withContext to set the current context.

// For memory-saving reasons, individual types export an interface
// similar to abstract values (which can hold multiple types), and can
// thus be used in place abstract values that only ever contain a
// single type.

(function (root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("acorn"), require("acorn/dist/acorn_loose"), require("acorn/dist/walk"),
      require("./def"), require("./signal"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "acorn/dist/acorn", "acorn/dist/acorn_loose", "acorn/dist/walk", "./def", "./signal"], mod);
  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
})(this, function (exports, acorn, acorn_loose, walk, def, signal) {
  "use strict";

  var toString = exports.toString = function (type, maxDepth, parent) {
    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
    return type.toString(maxDepth, parent);
  };

  // A variant of AVal used for unknown, dead-end values. Also serves
  // as prototype for AVals, Types, and Constraints because it
  // implements 'empty' versions of all the methods that the code
  // expects.
  var ANull = exports.ANull = signal.mixin({
    addType: function () { },
    propagate: function () { },
    getProp: function () { return ANull; },
    forAllProps: function () { },
    hasType: function () { return false; },
    isEmpty: function () { return true; },
    getFunctionType: function () { },
    getObjType: function () { },
    getType: function () { },
    gatherProperties: function () { },
    propagatesTo: function () { },
    typeHint: function () { },
    propHint: function () { },
    toString: function () { return "?"; }
  });

  function extend(proto, props) {
    var obj = Object.create(proto);
    if (props) for (var prop in props) obj[prop] = props[prop];
    return obj;
  }

  // ABSTRACT VALUES

  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10, WG_MULTI_MEMBER = 5,
    WG_CATCH_ERROR = 5, WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2;

  var AVal = exports.AVal = function () {
    this.types = [];
    this.forward = null;
    this.maxWeight = 0;
  };
  AVal.prototype = extend(ANull, {
    addType: function (type, weight) {
      weight = weight || WG_DEFAULT;
      if (this.maxWeight < weight) {
        this.maxWeight = weight;
        if (this.types.length == 1 && this.types[0] == type) return;
        this.types.length = 0;
      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
        return;
      }

      this.signal("addType", type);
      this.types.push(type);
      var forward = this.forward;
      if (forward) withWorklist(function (add) {
        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
      });
    },

    propagate: function (target, weight) {
      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
      (this.forward || (this.forward = [])).push(target);
      var types = this.types;
      if (types.length) withWorklist(function (add) {
        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
      });
    },

    getProp: function (prop) {
      if (prop == "__proto__" || prop == "✖") return ANull;
      var found = (this.props || (this.props = Object.create(null)))[prop];
      if (!found) {
        found = this.props[prop] = new AVal;
        this.propagate(new PropIsSubset(prop, found));
      }
      return found;
    },

    forAllProps: function (c) {
      this.propagate(new ForAllProps(c));
    },

    hasType: function (type) {
      return this.types.indexOf(type) > -1;
    },
    isEmpty: function () { return this.types.length === 0; },
    getFunctionType: function () {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Fn) return this.types[i];
    },
    getObjType: function () {
      var seen = null;
      for (var i = this.types.length - 1; i >= 0; --i) {
        var type = this.types[i];
        if (!(type instanceof Obj)) continue;
        if (type.name) return type;
        if (!seen) seen = type;
      }
      return seen;
    },

    getType: function (guess) {
      if (this.types.length === 0 && guess !== false) return this.makeupType();
      if (this.types.length === 1) return this.types[0];
      return canonicalType(this.types);
    },

    toString: function (maxDepth, parent) {
      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);
      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
      var simplified = simplifyTypes(this.types);
      if (simplified.length > 2) return "?";
      return simplified.map(function (tp) { return toString(tp, maxDepth, parent); }).join("|");
    },

    computedPropType: function () {
      if (!this.propertyOf) return null;
      if (this.propertyOf.hasProp("<i>")) {
        var computedProp = this.propertyOf.getProp("<i>");
        if (computedProp == this) return null;
        return computedProp.getType();
      } else if (this.propertyOf.maybeProps && this.propertyOf.maybeProps["<i>"] == this) {
        for (var prop in this.propertyOf.props) {
          var val = this.propertyOf.props[prop];
          if (!val.isEmpty()) return val;
        }
        return null;
      }
    },

    makeupType: function () {
      var computed = this.computedPropType();
      if (computed) return computed;

      if (!this.forward) return null;
      for (var i = this.forward.length - 1; i >= 0; --i) {
        var hint = this.forward[i].typeHint();
        if (hint && !hint.isEmpty()) { guessing = true; return hint; }
      }

      var props = Object.create(null), foundProp = null;
      for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
          props[prop] = true;
          foundProp = prop;
        }
      }
      if (!foundProp) return null;

      var objs = objsWithProp(foundProp);
      if (objs) {
        var matches = [];
        search: for (var i = 0; i < objs.length; ++i) {
          var obj = objs[i];
          for (var prop in props) if (!obj.hasProp(prop)) continue search;
          if (obj.hasCtor) obj = getInstance(obj);
          matches.push(obj);
        }
        var canon = canonicalType(matches);
        if (canon) { guessing = true; return canon; }
      }
    },

    typeHint: function () { return this.types.length ? this.getType() : null; },
    propagatesTo: function () { return this; },

    gatherProperties: function (f, depth) {
      for (var i = 0; i < this.types.length; ++i)
        this.types[i].gatherProperties(f, depth);
    },

    guessProperties: function (f) {
      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop) f(prop, null, 0);
      }
      var guessed = this.makeupType();
      if (guessed) guessed.gatherProperties(f);
    }
  });

  function similarAVal(a, b, depth) {
    var typeA = a.getType(false), typeB = b.getType(false);
    if (!typeA || !typeB) return true;
    return similarType(typeA, typeB, depth);
  }

  function similarType(a, b, depth) {
    if (!a || depth >= 5) return b;
    if (a == b) return a;
    if (!b) return a;
    if (a.constructor != b.constructor) return false;
    if (a.constructor == Arr) {
      var innerA = a.getProp("<i>").getType(false);
      if (!innerA) return b;
      var innerB = b.getProp("<i>").getType(false);
      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
    } else if (a.constructor == Obj) {
      var propsA = 0, propsB = 0, same = 0;
      for (var prop in a.props) {
        propsA++;
        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
          same++;
      }
      for (var prop in b.props) propsB++;
      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
      return propsA > propsB ? a : b;
    } else if (a.constructor == Fn) {
      if (a.args.length != b.args.length ||
        !a.args.every(function (tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
        !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
        return false;
      return a;
    } else {
      return false;
    }
  }

  var simplifyTypes = exports.simplifyTypes = function (types) {
    var found = [];
    outer: for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      for (var j = 0; j < found.length; j++) {
        var similar = similarType(tp, found[j], 0);
        if (similar) {
          found[j] = similar;
          continue outer;
        }
      }
      found.push(tp);
    }
    return found;
  };

  function canonicalType(types) {
    var arrays = 0, fns = 0, objs = 0, prim = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      if (tp instanceof Arr) ++arrays;
      else if (tp instanceof Fn) ++fns;
      else if (tp instanceof Obj) ++objs;
      else if (tp instanceof Prim) {
        if (prim && tp.name != prim.name) return null;
        prim = tp;
      }
    }
    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
    if (kinds > 1) return null;
    if (prim) return prim;

    var maxScore = 0, maxTp = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i], score = 0;
      if (arrays) {
        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
      } else if (fns) {
        score = 1;
        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
        if (!tp.retval.isEmpty()) ++score;
      } else if (objs) {
        score = tp.name ? 100 : 2;
      }
      if (score >= maxScore) { maxScore = score; maxTp = tp; }
    }
    return maxTp;
  }

  // PROPAGATION STRATEGIES

  function Constraint() { }
  Constraint.prototype = extend(ANull, {
    init: function () { this.origin = cx.curOrigin; }
  });

  var constraint = exports.constraint = function (props, methods) {
    var body = "this.init();";
    props = props ? props.split(", ") : [];
    for (var i = 0; i < props.length; ++i)
      body += "this." + props[i] + " = " + props[i] + ";";
    var ctor = Function.apply(null, props.concat([body]));
    ctor.prototype = Object.create(Constraint.prototype);
    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
    return ctor;
  };

  var PropIsSubset = constraint("prop, target", {
    addType: function (type, weight) {
      if (type.getProp)
        type.getProp(this.prop).propagate(this.target, weight);
    },
    propHint: function () { return this.prop; },
    propagatesTo: function () {
      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
        return { target: this.target, pathExt: "." + this.prop };
    }
  });

  var PropHasSubset = exports.PropHasSubset = constraint("prop, type, originNode", {
    addType: function (type, weight) {
      if (!(type instanceof Obj)) return;
      var prop = type.defProp(this.prop, this.originNode);
      if (!prop.origin) prop.origin = this.origin;
      this.type.propagate(prop, weight);
    },
    propHint: function () { return this.prop; }
  });

  var ForAllProps = constraint("c", {
    addType: function (type) {
      if (!(type instanceof Obj)) return;
      type.forAllProps(this.c);
    }
  });

  function withDisabledComputing(fn, body) {
    cx.disabledComputing = { fn: fn, prev: cx.disabledComputing };
    try {
      return body();
    } finally {
      cx.disabledComputing = cx.disabledComputing.prev;
    }
  }
  var IsCallee = exports.IsCallee = constraint("self, args, argNodes, retval", {
    init: function () {
      Constraint.prototype.init.call(this);
      this.disabled = cx.disabledComputing;
    },
    addType: function (fn, weight) {
      if (!(fn instanceof Fn)) return;
      for (var i = 0; i < this.args.length; ++i) {
        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
      }
      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
      var compute = fn.computeRet;
      if (compute) for (var d = this.disabled; d; d = d.prev)
        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
      if (compute)
        compute(this.self, this.args, this.argNodes).propagate(this.retval, weight);
      else
        fn.retval.propagate(this.retval, weight);
    },
    typeHint: function () {
      var names = [];
      for (var i = 0; i < this.args.length; ++i) names.push("?");
      return new Fn(null, this.self, this.args, names, ANull);
    },
    propagatesTo: function () {
      return { target: this.retval, pathExt: ".!ret" };
    }
  });

  var HasMethodCall = constraint("propName, args, argNodes, retval", {
    init: function () {
      Constraint.prototype.init.call(this);
      this.disabled = cx.disabledComputing;
    },
    addType: function (obj, weight) {
      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
      callee.disabled = this.disabled;
      obj.getProp(this.propName).propagate(callee, weight);
    },
    propHint: function () { return this.propName; }
  });

  var IsCtor = exports.IsCtor = constraint("target, noReuse", {
    addType: function (f, weight) {
      if (!(f instanceof Fn)) return;
      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
    }
  });

  var getInstance = exports.getInstance = function (obj, ctor) {
    if (ctor === false) return new Obj(obj);

    if (!ctor) ctor = obj.hasCtor;
    if (!obj.instances) obj.instances = [];
    for (var i = 0; i < obj.instances.length; ++i) {
      var cur = obj.instances[i];
      if (cur.ctor == ctor) return cur.instance;
    }
    var instance = new Obj(obj, ctor && ctor.name);
    instance.origin = obj.origin;
    obj.instances.push({ ctor: ctor, instance: instance });
    return instance;
  };

  var IsProto = exports.IsProto = constraint("ctor, target", {
    addType: function (o, _weight) {
      if (!(o instanceof Obj)) return;
      if ((this.count = (this.count || 0) + 1) > 8) return;
      if (o == cx.protos.Array)
        this.target.addType(new Arr);
      else
        this.target.addType(getInstance(o, this.ctor));
    }
  });

  var FnPrototype = constraint("fn", {
    addType: function (o, _weight) {
      if (o instanceof Obj && !o.hasCtor) {
        o.hasCtor = this.fn;
        var adder = new SpeculativeThis(o, this.fn);
        adder.addType(this.fn);
        o.forAllProps(function (_prop, val, local) {
          if (local) val.propagate(adder);
        });
      }
    }
  });

  var IsAdded = constraint("other, target", {
    addType: function (type, weight) {
      if (type == cx.str)
        this.target.addType(cx.str, weight);
      else if (type == cx.num && this.other.hasType(cx.num))
        this.target.addType(cx.num, weight);
    },
    typeHint: function () { return this.other; }
  });

  var IfObj = exports.IfObj = constraint("target", {
    addType: function (t, weight) {
      if (t instanceof Obj) this.target.addType(t, weight);
    },
    propagatesTo: function () { return this.target; }
  });

  var SpeculativeThis = constraint("obj, ctor", {
    addType: function (tp) {
      if (tp instanceof Fn && tp.self && tp.self.isEmpty())
        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_THIS);
    }
  });

  var Muffle = constraint("inner, weight", {
    addType: function (tp, weight) {
      this.inner.addType(tp, Math.min(weight, this.weight));
    },
    propagatesTo: function () { return this.inner.propagatesTo(); },
    typeHint: function () { return this.inner.typeHint(); },
    propHint: function () { return this.inner.propHint(); }
  });

  // TYPE OBJECTS

  var Type = exports.Type = function () { };
  Type.prototype = extend(ANull, {
    constructor: Type,
    propagate: function (c, w) { c.addType(this, w); },
    hasType: function (other) { return other == this; },
    isEmpty: function () { return false; },
    typeHint: function () { return this; },
    getType: function () { return this; }
  });

  var Prim = exports.Prim = function (proto, name) { this.name = name; this.proto = proto; };
  Prim.prototype = extend(Type.prototype, {
    constructor: Prim,
    toString: function () { return this.name; },
    getProp: function (prop) { return this.proto.hasProp(prop) || ANull; },
    gatherProperties: function (f, depth) {
      if (this.proto) this.proto.gatherProperties(f, depth);
    }
  });

  var Obj = exports.Obj = function (proto, name) {
    if (!this.props) this.props = Object.create(null);
    this.proto = proto === true ? cx.protos.Object : proto;
    if (proto && !name && proto.name && !(this instanceof Fn)) {
      var match = /^(.*)\.prototype$/.exec(this.proto.name);
      if (match) name = match[1];
    }
    this.name = name;
    this.maybeProps = null;
    this.origin = cx.curOrigin;
  };
  Obj.prototype = extend(Type.prototype, {
    constructor: Obj,
    toString: function (maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      if (maxDepth <= 0 && this.name) return this.name;
      var props = [], etc = false;
      for (var prop in this.props) if (prop != "<i>") {
        if (props.length > 5) { etc = true; break; }
        if (maxDepth)
          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
        else
          props.push(prop);
      }
      props.sort();
      if (etc) props.push("...");
      return "{" + props.join(", ") + "}";
    },
    hasProp: function (prop, searchProto) {
      var found = this.props[prop];
      if (searchProto !== false)
        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
      return found;
    },
    defProp: function (prop, originNode) {
      var found = this.hasProp(prop, false);
      if (found) {
        if (originNode && !found.originNode) found.originNode = originNode;
        return found;
      }
      if (prop == "__proto__" || prop == "✖") return ANull;

      var av = this.maybeProps && this.maybeProps[prop];
      if (av) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
      } else {
        av = new AVal;
        av.propertyOf = this;
      }

      this.props[prop] = av;
      av.originNode = originNode;
      av.origin = cx.curOrigin;
      this.broadcastProp(prop, av, true);
      return av;
    },
    getProp: function (prop) {
      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
      if (found) return found;
      if (prop == "__proto__" || prop == "✖") return ANull;
      var av = this.ensureMaybeProps()[prop] = new AVal;
      av.propertyOf = this;
      return av;
    },
    broadcastProp: function (prop, val, local) {
      if (local) {
        this.signal("addProp", prop, val);
        // If this is a scope, it shouldn't be registered
        if (!(this instanceof Scope)) registerProp(prop, this);
      }

      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
        var h = this.onNewProp[i];
        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
      }
    },
    onProtoProp: function (prop, val, _local) {
      var maybe = this.maybeProps && this.maybeProps[prop];
      if (maybe) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
        this.proto.getProp(prop).propagate(maybe);
      }
      this.broadcastProp(prop, val, false);
    },
    ensureMaybeProps: function () {
      if (!this.maybeProps) {
        if (this.proto) this.proto.forAllProps(this);
        this.maybeProps = Object.create(null);
      }
      return this.maybeProps;
    },
    removeProp: function (prop) {
      var av = this.props[prop];
      delete this.props[prop];
      this.ensureMaybeProps()[prop] = av;
      av.types.length = 0;
    },
    forAllProps: function (c) {
      if (!this.onNewProp) {
        this.onNewProp = [];
        if (this.proto) this.proto.forAllProps(this);
      }
      this.onNewProp.push(c);
      for (var o = this; o; o = o.proto) for (var prop in o.props) {
        if (c.onProtoProp)
          c.onProtoProp(prop, o.props[prop], o == this);
        else
          c(prop, o.props[prop], o == this);
      }
    },
    maybeUnregProtoPropHandler: function () {
      if (this.maybeProps) {
        for (var _n in this.maybeProps) return;
        this.maybeProps = null;
      }
      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
      this.proto.unregPropHandler(this);
    },
    unregPropHandler: function (handler) {
      for (var i = 0; i < this.onNewProp.length; ++i)
        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
      this.maybeUnregProtoPropHandler();
    },
    gatherProperties: function (f, depth) {
      for (var prop in this.props) if (prop != "<i>")
        f(prop, this, depth);
      if (this.proto) this.proto.gatherProperties(f, depth + 1);
    },
    getObjType: function () { return this; }
  });

  var Fn = exports.Fn = function (name, self, args, argNames, retval) {
    Obj.call(this, cx.protos.Function, name);
    this.self = self;
    this.args = args;
    this.argNames = argNames;
    this.retval = retval;
  };
  Fn.prototype = extend(Obj.prototype, {
    constructor: Fn,
    toString: function (maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      var str = "fn(";
      for (var i = 0; i < this.args.length; ++i) {
        if (i) str += ", ";
        var name = this.argNames[i];
        if (name && name != "?") str += name + ": ";
        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
      }
      str += ")";
      if (!this.retval.isEmpty())
        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
      return str;
    },
    getProp: function (prop) {
      if (prop == "prototype") {
        var known = this.hasProp(prop, false);
        if (!known) {
          known = this.defProp(prop);
          var proto = new Obj(true, this.name && this.name + ".prototype");
          proto.origin = this.origin;
          known.addType(proto, WG_MADEUP_PROTO);
        }
        return known;
      }
      return Obj.prototype.getProp.call(this, prop);
    },
    defProp: function (prop, originNode) {
      if (prop == "prototype") {
        var found = this.hasProp(prop, false);
        if (found) return found;
        found = Obj.prototype.defProp.call(this, prop, originNode);
        found.origin = this.origin;
        found.propagate(new FnPrototype(this));
        return found;
      }
      return Obj.prototype.defProp.call(this, prop, originNode);
    },
    getFunctionType: function () { return this; }
  });

  var Arr = exports.Arr = function (contentType) {
    Obj.call(this, cx.protos.Array);
    var content = this.defProp("<i>");
    if (contentType) contentType.propagate(content);
  };
  Arr.prototype = extend(Obj.prototype, {
    constructor: Arr,
    toString: function (maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      return "[" + (maxDepth > -3 ? toString(this.getProp("<i>"), maxDepth - 1, this) : "?") + "]";
    }
  });

  // THE PROPERTY REGISTRY

  function registerProp(prop, obj) {
    var data = cx.props[prop] || (cx.props[prop] = []);
    data.push(obj);
  }

  function objsWithProp(prop) {
    return cx.props[prop];
  }

  // INFERENCE CONTEXT

  exports.Context = function (defs, parent) {
    this.parent = parent;
    this.props = Object.create(null);
    this.protos = Object.create(null);
    this.origins = [];
    this.curOrigin = "ecma5";
    this.paths = Object.create(null);
    this.definitions = Object.create(null);
    this.purgeGen = 0;
    this.workList = null;
    this.disabledComputing = null;

    exports.withContext(this, function () {
      cx.protos.Object = new Obj(null, "Object.prototype");
      cx.topScope = new Scope();
      cx.topScope.name = "<top>";
      cx.protos.Array = new Obj(true, "Array.prototype");
      cx.protos.Function = new Obj(true, "Function.prototype");
      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
      cx.protos.String = new Obj(true, "String.prototype");
      cx.protos.Number = new Obj(true, "Number.prototype");
      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
      cx.str = new Prim(cx.protos.String, "string");
      cx.bool = new Prim(cx.protos.Boolean, "bool");
      cx.num = new Prim(cx.protos.Number, "number");
      cx.curOrigin = null;

      if (defs) for (var i = 0; i < defs.length; ++i)
        def.load(defs[i]);
    });
  };

  var cx = null;
  exports.cx = function () { return cx; };

  exports.withContext = function (context, f) {
    var old = cx;
    cx = context;
    try { return f(); }
    finally { cx = old; }
  };

  exports.TimedOut = function () {
    this.message = "Timed out";
    this.stack = (new Error()).stack;
  };
  exports.TimedOut.prototype = Object.create(Error.prototype);
  exports.TimedOut.prototype.name = "infer.TimedOut";

  var timeout;
  exports.withTimeout = function (ms, f) {
    var end = +new Date + ms;
    var oldEnd = timeout;
    if (oldEnd && oldEnd < end) return f();
    timeout = end;
    try { return f(); }
    finally { timeout = oldEnd; }
  };

  exports.addOrigin = function (origin) {
    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
  };

  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
  function withWorklist(f) {
    if (cx.workList) return f(cx.workList);

    var list = [], depth = 0;
    var add = cx.workList = function (type, target, weight) {
      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
        list.push(type, target, weight, depth);
    };
    try {
      var ret = f(add);
      for (var i = 0; i < list.length; i += 4) {
        if (timeout && +new Date >= timeout)
          throw new exports.TimedOut();
        depth = list[i + 3] + 1;
        list[i + 1].addType(list[i], list[i + 2]);
      }
      return ret;
    } finally {
      cx.workList = null;
    }
  }

  // SCOPES

  var Scope = exports.Scope = function (prev) {
    Obj.call(this, prev || true);
    this.prev = prev;
  };
  Scope.prototype = extend(Obj.prototype, {
    constructor: Scope,
    defVar: function (name, originNode) {
      for (var s = this; ; s = s.proto) {
        var found = s.props[name];
        if (found) return found;
        if (!s.prev) return s.defProp(name, originNode);
      }
    }
  });

  // RETVAL COMPUTATION HEURISTICS

  function maybeInstantiate(scope, score) {
    if (scope.fnType)
      scope.fnType.instantiateScore = (scope.fnType.instantiateScore || 0) + score;
  }

  var NotSmaller = {};
  function nodeSmallerThan(node, n) {
    try {
      walk.simple(node, { Expression: function () { if (--n <= 0) throw NotSmaller; } });
      return true;
    } catch (e) {
      if (e == NotSmaller) return false;
      throw e;
    }
  }

  function maybeTagAsInstantiated(node, scope) {
    var score = scope.fnType.instantiateScore;
    if (!cx.disabledComputing && score && scope.fnType.args.length && nodeSmallerThan(node, score * 5)) {
      maybeInstantiate(scope.prev, score / 2);
      setFunctionInstantiated(node, scope);
      return true;
    } else {
      scope.fnType.instantiateScore = null;
    }
  }

  function setFunctionInstantiated(node, scope) {
    var fn = scope.fnType;
    // Disconnect the arg avals, so that we can add info to them without side effects
    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
    fn.self = new AVal;
    fn.computeRet = function (self, args) {
      // Prevent recursion
      return withDisabledComputing(fn, function () {
        var oldOrigin = cx.curOrigin;
        cx.curOrigin = fn.origin;
        var scopeCopy = new Scope(scope.prev);
        scopeCopy.originNode = scope.originNode;
        for (var v in scope.props) {
          var local = scopeCopy.defProp(v, scope.props[v].originNode);
          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
            args[i].propagate(local);
        }
        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
        while (argNames.length < args.length) argNames.push("?");
        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull);
        scopeCopy.fnType.originNode = fn.originNode;
        if (fn.arguments) {
          var argset = scopeCopy.fnType.arguments = new AVal;
          scopeCopy.defProp("arguments").addType(new Arr(argset));
          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
        }
        node.body.scope = scopeCopy;
        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
        walk.recursive(node.body, scopeCopy, null, inferWrapper);
        cx.curOrigin = oldOrigin;
        return scopeCopy.fnType.retval;
      });
    };
  }

  function maybeTagAsGeneric(scope) {
    var fn = scope.fnType, target = fn.retval;
    if (target == ANull) return;
    var targetInner, asArray;
    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
      target = asArray = targetInner.getProp("<i>");

    function explore(aval, path, depth) {
      if (depth > 3 || !aval.forward) return;
      for (var i = 0; i < aval.forward.length; ++i) {
        var prop = aval.forward[i].propagatesTo();
        if (!prop) continue;
        var newPath = path, dest;
        if (prop instanceof AVal) {
          dest = prop;
        } else if (prop.target instanceof AVal) {
          newPath += prop.pathExt;
          dest = prop.target;
        } else continue;
        if (dest == target) return newPath;
        var found = explore(dest, newPath, depth + 1);
        if (found) return found;
      }
    }

    var foundPath = explore(fn.self, "!this", 0);
    for (var i = 0; !foundPath && i < fn.args.length; ++i)
      foundPath = explore(fn.args[i], "!" + i, 0);

    if (foundPath) {
      if (asArray) foundPath = "[" + foundPath + "]";
      var p = new def.TypeParser(foundPath);
      var parsed = p.parseType(true);
      fn.computeRet = parsed.apply ? parsed : function () { return parsed; };
      fn.computeRetSource = foundPath;
      return true;
    }
  }

  // SCOPE GATHERING PASS

  function addVar(scope, nameNode) {
    return scope.defProp(nameNode.name, nameNode);
  }

  var scopeGatherer = walk.make({
    Function: function (node, scope, c) {
      var inner = node.body.scope = new Scope(scope);
      inner.originNode = node;
      var argVals = [], argNames = [];
      for (var i = 0; i < node.params.length; ++i) {
        var param = node.params[i];
        argNames.push(param.name);
        argVals.push(addVar(inner, param));
      }
      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull);
      inner.fnType.originNode = node;
      if (node.id) {
        var decl = node.type == "FunctionDeclaration";
        addVar(decl ? scope : inner, node.id);
      }
      c(node.body, inner, "ScopeBody");
    },
    TryStatement: function (node, scope, c) {
      c(node.block, scope, "Statement");
      if (node.handler) {
        var v = addVar(scope, node.handler.param);
        c(node.handler.body, scope, "ScopeBody");
        var e5 = cx.definitions.ecma5;
        if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
      }
      if (node.finalizer) c(node.finalizer, scope, "Statement");
    },
    VariableDeclaration: function (node, scope, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        addVar(scope, decl.id);
        if (decl.init) c(decl.init, scope, "Expression");
      }
    }
  });

  // CONSTRAINT GATHERING PASS

  function propName(node, scope, c) {
    var prop = node.property;
    if (!node.computed) return prop.name;
    if (prop.type == "Literal" && typeof prop.value == "string") return prop.value;
    if (c) infer(prop, scope, c, ANull);
    return "<i>";
  }

  function unopResultType(op) {
    switch (op) {
      case "+": case "-": case "~": return cx.num;
      case "!": return cx.bool;
      case "typeof": return cx.str;
      case "void": case "delete": return ANull;
    }
  }
  function binopIsBoolean(op) {
    switch (op) {
      case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
      case "in": case "instanceof": return true;
    }
  }
  function literalType(node) {
    if (node.regex) return getInstance(cx.protos.RegExp);
    switch (typeof node.value) {
      case "boolean": return cx.bool;
      case "number": return cx.num;
      case "string": return cx.str;
      case "object":
      case "function":
        if (!node.value) return ANull;
        return getInstance(cx.protos.RegExp);
    }
  }

  function ret(f) {
    return function (node, scope, c, out, name) {
      var r = f(node, scope, c, name);
      if (out) r.propagate(out);
      return r;
    };
  }
  function fill(f) {
    return function (node, scope, c, out, name) {
      if (!out) out = new AVal;
      f(node, scope, c, out, name);
      return out;
    };
  }

  var inferExprVisitor = {
    ArrayExpression: ret(function (node, scope, c) {
      var eltval = new AVal;
      for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt) infer(elt, scope, c, eltval);
      }
      return new Arr(eltval);
    }),
    ObjectExpression: ret(function (node, scope, c, name) {
      var obj = node.objType = new Obj(true, name);
      obj.originNode = node;

      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i], key = prop.key, name;
        if (prop.value.name == "✖") continue;

        if (key.type == "Identifier") {
          name = key.name;
        } else if (typeof key.value == "string") {
          name = key.value;
        }
        if (!name || prop.kind == "set") {
          infer(prop.value, scope, c, ANull);
          continue;
        }

        var val = obj.defProp(name, key), out = val;
        val.initializer = true;
        if (prop.kind == "get")
          out = new IsCallee(obj, [], null, val);
        infer(prop.value, scope, c, out, name);
      }
      return obj;
    }),
    FunctionExpression: ret(function (node, scope, c, name) {
      var inner = node.body.scope, fn = inner.fnType;
      if (name && !fn.name) fn.name = name;
      c(node.body, scope, "ScopeBody");
      maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
      if (node.id) inner.getProp(node.id.name).addType(fn);
      return fn;
    }),
    SequenceExpression: ret(function (node, scope, c) {
      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
        infer(node.expressions[i], scope, c, ANull);
      return infer(node.expressions[l], scope, c);
    }),
    UnaryExpression: ret(function (node, scope, c) {
      infer(node.argument, scope, c, ANull);
      return unopResultType(node.operator);
    }),
    UpdateExpression: ret(function (node, scope, c) {
      infer(node.argument, scope, c, ANull);
      return cx.num;
    }),
    BinaryExpression: ret(function (node, scope, c) {
      if (node.operator == "+") {
        var lhs = infer(node.left, scope, c);
        var rhs = infer(node.right, scope, c);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
        var result = new AVal;
        lhs.propagate(new IsAdded(rhs, result));
        rhs.propagate(new IsAdded(lhs, result));
        return result;
      } else {
        infer(node.left, scope, c, ANull);
        infer(node.right, scope, c, ANull);
        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
      }
    }),
    AssignmentExpression: ret(function (node, scope, c) {
      var rhs, name, pName;
      if (node.left.type == "MemberExpression") {
        pName = propName(node.left, scope, c);
        if (node.left.object.type == "Identifier")
          name = node.left.object.name + "." + pName;
      } else {
        name = node.left.name;
      }

      if (node.operator != "=" && node.operator != "+=") {
        infer(node.right, scope, c, ANull);
        rhs = cx.num;
      } else {
        rhs = infer(node.right, scope, c, null, name);
      }

      if (node.left.type == "MemberExpression") {
        var obj = infer(node.left.object, scope, c);
        if (pName == "prototype") maybeInstantiate(scope, 20);
        if (pName == "<i>") {
          // This is a hack to recognize for/in loops that copy
          // properties, and do the copying ourselves, insofar as we
          // manage, because such loops tend to be relevant for type
          // information.
          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
          if (over) {
            maybeInstantiate(scope, 20);
            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
            over.forAllProps(function (prop, val, local) {
              if (local && prop != "prototype" && prop != "<i>")
                obj.propagate(new PropHasSubset(prop, fromRight ? val : ANull));
            });
            return rhs;
          }
        }
        obj.propagate(new PropHasSubset(pName, rhs, node.left.property));
      } else { // Identifier
        rhs.propagate(scope.defVar(node.left.name, node.left));
      }
      return rhs;
    }),
    LogicalExpression: fill(function (node, scope, c, out) {
      infer(node.left, scope, c, out);
      infer(node.right, scope, c, out);
    }),
    ConditionalExpression: fill(function (node, scope, c, out) {
      infer(node.test, scope, c, ANull);
      infer(node.consequent, scope, c, out);
      infer(node.alternate, scope, c, out);
    }),
    NewExpression: fill(function (node, scope, c, out, name) {
      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
        maybeInstantiate(scope, 20);

      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope, c));
      var callee = infer(node.callee, scope, c);
      var self = new AVal;
      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
      self.propagate(out, WG_NEW_INSTANCE);
      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
    }),
    CallExpression: fill(function (node, scope, c, out) {
      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope, c));
      if (node.callee.type == "MemberExpression") {
        var self = infer(node.callee.object, scope, c);
        var pName = propName(node.callee, scope, c);
        if ((pName == "call" || pName == "apply") &&
          scope.fnType && scope.fnType.args.indexOf(self) > -1)
          maybeInstantiate(scope, 30);
        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
      } else {
        var callee = infer(node.callee, scope, c);
        if (scope.fnType && scope.fnType.args.indexOf(callee) > -1)
          maybeInstantiate(scope, 30);
        var knownFn = callee.getFunctionType();
        if (knownFn && knownFn.instantiateScore && scope.fnType)
          maybeInstantiate(scope, knownFn.instantiateScore / 5);
        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
      }
    }),
    MemberExpression: fill(function (node, scope, c, out) {
      var name = propName(node, scope);
      var obj = infer(node.object, scope, c);
      var prop = obj.getProp(name);
      if (name == "<i>") {
        var propType = infer(node.property, scope, c);
        if (!propType.hasType(cx.num))
          return prop.propagate(out, WG_MULTI_MEMBER);
      }
      prop.propagate(out);
    }),
    Identifier: ret(function (node, scope) {
      if (node.name == "arguments" && scope.fnType && !(node.name in scope.props))
        scope.defProp(node.name, scope.fnType.originNode)
          .addType(new Arr(scope.fnType.arguments = new AVal));
      return scope.getProp(node.name);
    }),
    ThisExpression: ret(function (_node, scope) {
      return scope.fnType ? scope.fnType.self : cx.topScope;
    }),
    Literal: ret(function (node) {
      return literalType(node);
    })
  };

  function infer(node, scope, c, out, name) {
    return inferExprVisitor[node.type](node, scope, c, out, name);
  }

  var inferWrapper = walk.make({
    Expression: function (node, scope, c) {
      infer(node, scope, c, ANull);
    },

    FunctionDeclaration: function (node, scope, c) {
      var inner = node.body.scope, fn = inner.fnType;
      c(node.body, scope, "ScopeBody");
      maybeTagAsInstantiated(node, inner) || maybeTagAsGeneric(inner);
      var prop = scope.getProp(node.id.name);
      prop.addType(fn);
    },

    VariableDeclaration: function (node, scope, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i], prop = scope.getProp(decl.id.name);
        if (decl.init)
          infer(decl.init, scope, c, prop, decl.id.name);
      }
    },

    ReturnStatement: function (node, scope, c) {
      if (!node.argument) return;
      var output = ANull;
      if (scope.fnType) {
        if (scope.fnType.retval == ANull) scope.fnType.retval = new AVal;
        output = scope.fnType.retval;
      }
      infer(node.argument, scope, c, output);
    },

    ForInStatement: function (node, scope, c) {
      var source = infer(node.right, scope, c);
      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
        (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
        maybeInstantiate(scope, 5);
        var varName;
        if (node.left.type == "Identifier") {
          varName = node.left.name;
        } else if (node.left.type == "VariableDeclaration") {
          varName = node.left.declarations[0].id.name;
        }
        if (varName && varName in scope.props)
          scope.getProp(varName).iteratesOver = source;
      }
      c(node.body, scope, "Statement");
    },

    ScopeBody: function (node, scope, c) { c(node, node.scope || scope); }
  });

  // PARSING

  function runPasses(passes, pass) {
    var arr = passes && passes[pass];
    var args = Array.prototype.slice.call(arguments, 2);
    if (arr) for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var parse = exports.parse = function (text, passes, options) {
    var ast;
    try { ast = acorn.parse(text, options); }
    catch (e) { ast = acorn_loose.parse_dammit(text, options); }
    runPasses(passes, "postParse", ast, text);
    return ast;
  };

  // ANALYSIS INTERFACE

  exports.analyze = function (ast, name, scope, passes) {
    if (typeof ast == "string") ast = parse(ast);

    if (!name) name = "file#" + cx.origins.length;
    exports.addOrigin(cx.curOrigin = name);

    if (!scope) scope = cx.topScope;
    walk.recursive(ast, scope, null, scopeGatherer);
    runPasses(passes, "preInfer", ast, scope);
    walk.recursive(ast, scope, null, inferWrapper);
    runPasses(passes, "postInfer", ast, scope);

    cx.curOrigin = null;
  };

  // PURGING

  exports.purge = function (origins, start, end) {
    var test = makePredicate(origins, start, end);
    ++cx.purgeGen;
    cx.topScope.purge(test);
    for (var prop in cx.props) {
      var list = cx.props[prop];
      for (var i = 0; i < list.length; ++i) {
        var obj = list[i], av = obj.props[prop];
        if (!av || test(av, av.originNode)) list.splice(i--, 1);
      }
      if (!list.length) delete cx.props[prop];
    }
  };

  function makePredicate(origins, start, end) {
    var arr = Array.isArray(origins);
    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
    if (arr) {
      if (end == null) return function (n) { return origins.indexOf(n.origin) > -1; };
      return function (n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
    } else {
      if (end == null) return function (n) { return n.origin == origins; };
      return function (n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
    }
  }

  AVal.prototype.purge = function (test) {
    if (this.purgeGen == cx.purgeGen) return;
    this.purgeGen = cx.purgeGen;
    for (var i = 0; i < this.types.length; ++i) {
      var type = this.types[i];
      if (test(type, type.originNode))
        this.types.splice(i--, 1);
      else
        type.purge(test);
    }
    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
      var f = this.forward[i];
      if (test(f)) {
        this.forward.splice(i--, 1);
        if (this.props) this.props = null;
      } else if (f.purge) {
        f.purge(test);
      }
    }
  };
  ANull.purge = function () { };
  Obj.prototype.purge = function (test) {
    if (this.purgeGen == cx.purgeGen) return true;
    this.purgeGen = cx.purgeGen;
    for (var p in this.props) {
      var av = this.props[p];
      if (test(av, av.originNode))
        this.removeProp(p);
      av.purge(test);
    }
  };
  Fn.prototype.purge = function (test) {
    if (Obj.prototype.purge.call(this, test)) return;
    this.self.purge(test);
    this.retval.purge(test);
    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
  };

  // EXPRESSION TYPE DETERMINATION

  function findByPropertyName(name) {
    guessing = true;
    var found = objsWithProp(name);
    if (found) for (var i = 0; i < found.length; ++i) {
      var val = found[i].getProp(name);
      if (!val.isEmpty()) return val;
    }
    return ANull;
  }

  var typeFinder = {
    ArrayExpression: function (node, scope) {
      var eltval = new AVal;
      for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt) findType(elt, scope).propagate(eltval);
      }
      return new Arr(eltval);
    },
    ObjectExpression: function (node) {
      return node.objType;
    },
    FunctionExpression: function (node) {
      return node.body.scope.fnType;
    },
    SequenceExpression: function (node, scope) {
      return findType(node.expressions[node.expressions.length - 1], scope);
    },
    UnaryExpression: function (node) {
      return unopResultType(node.operator);
    },
    UpdateExpression: function () {
      return cx.num;
    },
    BinaryExpression: function (node, scope) {
      if (binopIsBoolean(node.operator)) return cx.bool;
      if (node.operator == "+") {
        var lhs = findType(node.left, scope);
        var rhs = findType(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
      }
      return cx.num;
    },
    AssignmentExpression: function (node, scope) {
      return findType(node.right, scope);
    },
    LogicalExpression: function (node, scope) {
      var lhs = findType(node.left, scope);
      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
    },
    ConditionalExpression: function (node, scope) {
      var lhs = findType(node.consequent, scope);
      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
    },
    NewExpression: function (node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      var proto = f && f.getProp("prototype").getObjType();
      if (!proto) return ANull;
      return getInstance(proto, f);
    },
    CallExpression: function (node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      if (!f) return ANull;
      if (f.computeRet) {
        for (var i = 0, args = []; i < node.arguments.length; ++i)
          args.push(findType(node.arguments[i], scope));
        var self = ANull;
        if (node.callee.type == "MemberExpression")
          self = findType(node.callee.object, scope);
        return f.computeRet(self, args, node.arguments);
      } else {
        return f.retval;
      }
    },
    MemberExpression: function (node, scope) {
      var propN = propName(node, scope), obj = findType(node.object, scope).getType();
      if (obj) return obj.getProp(propN);
      if (propN == "<i>") return ANull;
      return findByPropertyName(propN);
    },
    Identifier: function (node, scope) {
      return scope.hasProp(node.name) || ANull;
    },
    ThisExpression: function (_node, scope) {
      return scope.fnType ? scope.fnType.self : cx.topScope;
    },
    Literal: function (node) {
      return literalType(node);
    }
  };

  function findType(node, scope) {
    return typeFinder[node.type](node, scope);
  }

  var searchVisitor = exports.searchVisitor = walk.make({
    Function: function (node, _st, c) {
      var scope = node.body.scope;
      if (node.id) c(node.id, scope);
      for (var i = 0; i < node.params.length; ++i)
        c(node.params[i], scope);
      c(node.body, scope, "ScopeBody");
    },
    TryStatement: function (node, st, c) {
      if (node.handler)
        c(node.handler.param, st);
      walk.base.TryStatement(node, st, c);
    },
    VariableDeclaration: function (node, st, c) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        c(decl.id, st);
        if (decl.init) c(decl.init, st, "Expression");
      }
    }
  });
  exports.fullVisitor = walk.make({
    MemberExpression: function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, node.computed ? "Expression" : null);
    },
    ObjectExpression: function (node, st, c) {
      for (var i = 0; i < node.properties.length; ++i) {
        c(node.properties[i].value, st, "Expression");
        c(node.properties[i].key, st);
      }
    }
  }, searchVisitor);

  exports.findExpressionAt = function (ast, start, end, defaultScope, filter) {
    var test = filter || function (_t, node) {
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.findExpressionAround = function (ast, start, end, defaultScope, filter) {
    var test = filter || function (_t, node) {
      if (start != null && node.start > start) return false;
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.expressionType = function (found) {
    return findType(found.node, found.state);
  };

  // Finding the expected type of something, from context

  exports.parentNode = function (child, ast) {
    var stack = [];
    function c(node, st, override) {
      if (node.start <= child.start && node.end >= child.end) {
        var top = stack[stack.length - 1];
        if (node == child) throw { found: top };
        if (top != node) stack.push(node);
        walk.base[override || node.type](node, st, c);
        if (top != node) stack.pop();
      }
    }
    try {
      c(ast, null);
    } catch (e) {
      if (e.found) return e.found;
      throw e;
    }
  };

  var findTypeFromContext = {
    ArrayExpression: function (parent, _, get) { return get(parent, true).getProp("<i>"); },
    ObjectExpression: function (parent, node, get) {
      for (var i = 0; i < parent.properties.length; ++i) {
        var prop = node.properties[i];
        if (prop.value == node)
          return get(parent, true).getProp(prop.key.name);
      }
    },
    UnaryExpression: function (parent) { return unopResultType(parent.operator); },
    UpdateExpression: function () { return cx.num; },
    BinaryExpression: function (parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
    AssignmentExpression: function (parent, _, get) { return get(parent.left); },
    LogicalExpression: function (parent, _, get) { return get(parent, true); },
    ConditionalExpression: function (parent, node, get) {
      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
    },
    NewExpression: function (parent, node, get) {
      return this.CallExpression(parent, node, get);
    },
    CallExpression: function (parent, node, get) {
      for (var i = 0; i < parent.arguments.length; i++) {
        var arg = parent.arguments[i];
        if (arg == node) {
          var calleeType = get(parent.callee).getFunctionType();
          if (calleeType instanceof Fn)
            return calleeType.args[i];
          break;
        }
      }
    },
    ReturnStatement: function (_parent, node, get) {
      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
      if (fnNode) {
        var fnType = fnNode.node.type == "FunctionExpression"
          ? get(fnNode.node, true).getFunctionType()
          : fnNode.node.body.scope.fnType;
        if (fnType) return fnType.retval.getType();
      }
    },
    VariableDeclaration: function (parent, node, get) {
      for (var i = 0; i < parent.declarations.length; i++) {
        var decl = parent.declarations[i];
        if (decl.init == node) return get(decl.id);
      }
    }
  };

  exports.typeFromContext = function (ast, found) {
    var parent = exports.parentNode(found.node, ast);
    var type = null;
    if (findTypeFromContext.hasOwnProperty(parent.type)) {
      type = findTypeFromContext[parent.type](parent, found.node, function (node, fromContext) {
        var obj = { node: node, state: found.state };
        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
        return tp || ANull;
      });
    }
    return type || exports.expressionType(found);
  };

  // Flag used to indicate that some wild guessing was used to produce
  // a type or set of completions.
  var guessing = false;

  exports.resetGuessing = function (val) { guessing = val; };
  exports.didGuess = function () { return guessing; };

  exports.forAllPropertiesOf = function (type, f) {
    type.gatherProperties(f, 0);
  };

  var refFindWalker = walk.make({}, searchVisitor);

  exports.findRefs = function (ast, baseScope, name, refScope, f) {
    refFindWalker.Identifier = function (node, scope) {
      if (node.name != name) return;
      for (var s = scope; s; s = s.prev) {
        if (s == refScope) f(node, scope);
        if (name in s.props) return;
      }
    };
    walk.recursive(ast, baseScope, null, refFindWalker);
  };

  var simpleWalker = walk.make({
    Function: function (node, _st, c) { c(node.body, node.body.scope, "ScopeBody"); }
  });

  exports.findPropRefs = function (ast, scope, objType, propName, f) {
    walk.simple(ast, {
      MemberExpression: function (node, scope) {
        if (node.computed || node.property.name != propName) return;
        if (findType(node.object, scope).getType() == objType) f(node.property);
      },
      ObjectExpression: function (node, scope) {
        if (findType(node, scope).getType() != objType) return;
        for (var i = 0; i < node.properties.length; ++i)
          if (node.properties[i].key.name == propName) f(node.properties[i].key);
      }
    }, simpleWalker, scope);
  };

  // LOCAL-VARIABLE QUERIES

  var scopeAt = exports.scopeAt = function (ast, pos, defaultScope) {
    var found = walk.findNodeAround(ast, pos, function (tp, node) {
      return tp == "ScopeBody" && node.scope;
    });
    if (found) return found.node.scope;
    else return defaultScope || cx.topScope;
  };

  exports.forAllLocalsAt = function (ast, pos, defaultScope, f) {
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };

  // INIT DEF MODULE

  // Delayed initialization because of cyclic dependencies.
  def = exports.def = def.init({}, exports);
});


// Parses comments above variable declarations, function declarations,
// and object properties as docstrings and JSDoc-style type
// annotations.

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
      require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(tern, tern, tern.comment, acorn, acorn.walk);
})(function (infer, tern, comment, acorn, walk) {
  "use strict";

  var WG_MADEUP = 1, WG_STRONG = 101;

  tern.registerPlugin("doc_comment", function (server, options) {
    server.jsdocTypedefs = Object.create(null);
    server.on("reset", function () {
      server.jsdocTypedefs = Object.create(null);
    });
    server._docComment = {
      weight: options && options.strong ? WG_STRONG : undefined,
      fullDocs: options && options.fullDocs
    };

    return {
      passes: {
        postParse: postParse,
        postInfer: postInfer,
        postLoadDef: postLoadDef
      }
    };
  });

  function postParse(ast, text) {
    function attachComments(node) { comment.ensureCommentsBefore(text, node); }

    walk.simple(ast, {
      VariableDeclaration: attachComments,
      FunctionDeclaration: attachComments,
      AssignmentExpression: function (node) {
        if (node.operator == "=") attachComments(node);
      },
      ObjectExpression: function (node) {
        for (var i = 0; i < node.properties.length; ++i)
          attachComments(node.properties[i]);
      },
      CallExpression: function (node) {
        if (isDefinePropertyCall(node)) attachComments(node);
      }
    });
  }

  function isDefinePropertyCall(node) {
    return node.callee.type == "MemberExpression" &&
      node.callee.object.name == "Object" &&
      node.callee.property.name == "defineProperty" &&
      node.arguments.length >= 3 &&
      typeof node.arguments[1].value == "string";
  }

  function postInfer(ast, scope) {
    jsdocParseTypedefs(ast.sourceFile.text, scope);

    walk.simple(ast, {
      VariableDeclaration: function (node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
            scope.getProp(node.declarations[0].id.name));
      },
      FunctionDeclaration: function (node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
            scope.getProp(node.id.name),
            node.body.scope.fnType);
      },
      AssignmentExpression: function (node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
            infer.expressionType({ node: node.left, state: scope }));
      },
      ObjectExpression: function (node, scope) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i];
          if (prop.commentsBefore)
            interpretComments(prop, prop.commentsBefore, scope,
              node.objType.getProp(prop.key.name));
        }
      },
      CallExpression: function (node, scope) {
        if (node.commentsBefore && isDefinePropertyCall(node)) {
          var type = infer.expressionType({ node: node.arguments[0], state: scope }).getObjType();
          if (type && type instanceof infer.Obj) {
            var prop = type.props[node.arguments[1].value];
            if (prop) interpretComments(node, node.commentsBefore, scope, prop);
          }
        }
      }
    }, infer.searchVisitor, scope);
  }

  function postLoadDef(data) {
    var defs = data["!typedef"];
    var cx = infer.cx(), orig = data["!name"];
    if (defs) for (var name in defs)
      cx.parent.jsdocTypedefs[name] =
        maybeInstance(infer.def.parse(defs[name], orig, name), name);
  }

  // COMMENT INTERPRETATION

  function interpretComments(node, comments, scope, aval, type) {
    jsdocInterpretComments(node, scope, aval, comments);
    var cx = infer.cx();

    if (!type && aval instanceof infer.AVal && aval.types.length) {
      type = aval.types[aval.types.length - 1];
      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)
        type = null;
    }

    var result = comments[comments.length - 1];
    if (cx.parent._docComment.fullDocs) {
      result = result.trim().replace(/\n[ \t]*\* ?/g, "\n");
    } else {
      var dot = result.search(/\.\s/);
      if (dot > 5) result = result.slice(0, dot + 1);
      result = result.trim().replace(/\s*\n\s*\*\s*|\s{1,}/g, " ");
    }
    result = result.replace(/^\s*\*+\s*/, "");

    if (aval instanceof infer.AVal) aval.doc = result;
    if (type) type.doc = result;
  }

  // Parses a subset of JSDoc-style comments in order to include the
  // explicitly defined types in the analysis.

  function skipSpace(str, pos) {
    while (/\s/.test(str.charAt(pos))) ++pos;
    return pos;
  }

  function isIdentifier(string) {
    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;
    for (var i = 1; i < string.length; i++)
      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;
    return true;
  }

  function parseLabelList(scope, str, pos, close) {
    var labels = [], types = [], madeUp = false;
    for (var first = true; ; first = false) {
      pos = skipSpace(str, pos);
      if (first && str.charAt(pos) == close) break;
      var colon = str.indexOf(":", pos);
      if (colon < 0) return null;
      var label = str.slice(pos, colon);
      if (!isIdentifier(label)) return null;
      labels.push(label);
      pos = colon + 1;
      var type = parseType(scope, str, pos);
      if (!type) return null;
      pos = type.end;
      madeUp = madeUp || type.madeUp;
      types.push(type.type);
      pos = skipSpace(str, pos);
      var next = str.charAt(pos);
      ++pos;
      if (next == close) break;
      if (next != ",") return null;
    }
    return { labels: labels, types: types, end: pos, madeUp: madeUp };
  }

  function parseType(scope, str, pos) {
    var type, union = false, madeUp = false;
    for (; ;) {
      var inner = parseTypeInner(scope, str, pos);
      if (!inner) return null;
      madeUp = madeUp || inner.madeUp;
      if (union) inner.type.propagate(union);
      else type = inner.type;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != "|") break;
      pos++;
      if (!union) {
        union = new infer.AVal;
        type.propagate(union);
        type = union;
      }
    }
    var isOptional = false;
    if (str.charAt(pos) == "=") {
      ++pos;
      isOptional = true;
    }
    return { type: type, end: pos, isOptional: isOptional, madeUp: madeUp };
  }

  function parseTypeInner(scope, str, pos) {
    pos = skipSpace(str, pos);
    var type, madeUp = false;

    if (str.indexOf("function(", pos) == pos) {
      var args = parseLabelList(scope, str, pos + 9, ")"), ret = infer.ANull;
      if (!args) return null;
      pos = skipSpace(str, args.end);
      if (str.charAt(pos) == ":") {
        ++pos;
        var retType = parseType(scope, str, pos + 1);
        if (!retType) return null;
        pos = retType.end;
        ret = retType.type;
        madeUp = retType.madeUp;
      }
      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);
    } else if (str.charAt(pos) == "[") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      madeUp = inner.madeUp;
      if (str.charAt(pos) != "]") return null;
      ++pos;
      type = new infer.Arr(inner.type);
    } else if (str.charAt(pos) == "{") {
      var fields = parseLabelList(scope, str, pos + 1, "}");
      if (!fields) return null;
      type = new infer.Obj(true);
      for (var i = 0; i < fields.types.length; ++i) {
        var field = type.defProp(fields.labels[i]);
        field.initializer = true;
        fields.types[i].propagate(field);
      }
      pos = fields.end;
      madeUp = fields.madeUp;
    } else if (str.charAt(pos) == "(") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != ")") return null;
      ++pos;
      type = inner.type;
    } else {
      var start = pos;
      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;
      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
      if (start == pos) return null;
      var word = str.slice(start, pos);
      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;
      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;
      else if (/^string$/i.test(word)) type = infer.cx().str;
      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;
      else if (/^array$/i.test(word)) {
        var inner = null;
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var inAngles = parseType(scope, str, pos + 2);
          if (!inAngles) return null;
          pos = skipSpace(str, inAngles.end);
          madeUp = inAngles.madeUp;
          if (str.charAt(pos++) != ">") return null;
          inner = inAngles.type;
        }
        type = new infer.Arr(inner);
      } else if (/^object$/i.test(word)) {
        type = new infer.Obj(true);
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var key = parseType(scope, str, pos + 2);
          if (!key) return null;
          pos = skipSpace(str, key.end);
          if (str.charAt(pos++) != ",") return null;
          var val = parseType(scope, str, pos);
          if (!val) return null;
          pos = skipSpace(str, val.end);
          madeUp = key.madeUp || val.madeUp;
          if (str.charAt(pos++) != ">") return null;
          val.type.propagate(type.defProp("<i>"));
        }
      } else {
        while (str.charCodeAt(pos) == 46 ||
          acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
        var path = str.slice(start, pos);
        var cx = infer.cx(), defs = cx.parent && cx.parent.jsdocTypedefs, found;
        if (defs && (path in defs)) {
          type = defs[path];
        } else if (found = infer.def.parsePath(path, scope).getObjType()) {
          type = maybeInstance(found, path);
        } else {
          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);
          if (!(path in cx.jsdocPlaceholders))
            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);
          else
            type = cx.jsdocPlaceholders[path];
          madeUp = true;
        }
      }
    }

    return { type: type, end: pos, madeUp: madeUp };
  }

  function maybeInstance(type, path) {
    if (type instanceof infer.Fn && /^[A-Z]/.test(path)) {
      var proto = type.getProp("prototype").getObjType();
      if (proto instanceof infer.Obj) return infer.getInstance(proto);
    }
    return type;
  }

  function parseTypeOuter(scope, str, pos) {
    pos = skipSpace(str, pos || 0);
    if (str.charAt(pos) != "{") return null;
    var result = parseType(scope, str, pos + 1);
    if (!result) return null;
    var end = skipSpace(str, result.end);
    if (str.charAt(end) != "}") return null;
    result.end = end + 1;
    return result;
  }

  function jsdocInterpretComments(node, scope, aval, comments) {
    var type, args, ret, foundOne, self, parsed;

    for (var i = 0; i < comments.length; ++i) {
      var comment = comments[i];
      var decl = /(?:\n|\$|\*)\s*@(type|param|arg(?:ument)?|returns?|this)\s+(.*)/g, m;
      while (m = decl.exec(comment)) {
        if (m[1] == "this" && (parsed = parseType(scope, m[2], 0))) {
          self = parsed;
          foundOne = true;
          continue;
        }

        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;
        foundOne = true;

        switch (m[1]) {
          case "returns": case "return":
            ret = parsed; break;
          case "type":
            type = parsed; break;
          case "param": case "arg": case "argument":
            var name = m[2].slice(parsed.end).match(/^\s*(\[?)\s*([^\]\s=]+)\s*(?:=[^\]]+\s*)?(\]?).*/);
            if (!name) continue;
            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[3] === ']') ? "?" : "");
            (args || (args = Object.create(null)))[argname] = parsed;
            break;
        }
      }
    }

    if (foundOne) applyType(type, self, args, ret, node, aval);
  };

  function jsdocParseTypedefs(text, scope) {
    var cx = infer.cx();

    var re = /\s@typedef\s+(.*)/g, m;
    while (m = re.exec(text)) {
      var parsed = parseTypeOuter(scope, m[1]);
      var name = parsed && m[1].slice(parsed.end).match(/^\s*(\S+)/);
      if (name)
        cx.parent.jsdocTypedefs[name[1]] = parsed.type;
    }
  }

  function propagateWithWeight(type, target) {
    var weight = infer.cx().parent._docComment.weight;
    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));
  }

  function applyType(type, self, args, ret, node, aval) {
    var fn;
    if (node.type == "VariableDeclaration") {
      var decl = node.declarations[0];
      if (decl.init && decl.init.type == "FunctionExpression") fn = decl.init.body.scope.fnType;
    } else if (node.type == "FunctionDeclaration") {
      fn = node.body.scope.fnType;
    } else if (node.type == "AssignmentExpression") {
      if (node.right.type == "FunctionExpression")
        fn = node.right.body.scope.fnType;
    } else if (node.type == "CallExpression") {
    } else { // An object property
      if (node.value.type == "FunctionExpression") fn = node.value.body.scope.fnType;
    }

    if (fn && (args || ret || self)) {
      if (args) for (var i = 0; i < fn.argNames.length; ++i) {
        var name = fn.argNames[i], known = args[name];
        if (!known && (known = args[name + "?"]))
          fn.argNames[i] += "?";
        if (known) propagateWithWeight(known, fn.args[i]);
      }
      if (ret) propagateWithWeight(ret, fn.retval);
      if (self) propagateWithWeight(self, fn.self);
    } else if (type) {
      propagateWithWeight(type, aval);
    }
  };
});

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("tern/lib/infer"), require("tern/lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["tern/lib/infer", "tern/lib/tern"], mod);
  mod(tern, tern);
})(function (infer, tern) {
  "use strict";

  tern.registerPlugin("threejs", function (server, options) {
    return {
      defs: {
        "!name": "threejs",
        "THREE": {
          "Original": {
            "!url": "http://threejs.org/docs/#Reference/Original",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "todo"
          },
          "Camera": {
            "!url": "http://threejs.org/docs/#Reference/cameras/Camera",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "matrixWorldInverse": {
                "!type": "+THREE.Matrix4",
                "!doc": "This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera."
              },
              "projectionMatrix": {
                "!type": "+THREE.Matrix4",
                "!doc": "This is the matrix which contains the projection."
              },
              "lookAt": {
                "!type": "fn(vector: +THREE.Vector3)",
                "!doc": "vector — point to look at<br>\n\t\t<br>\n\t\tThis makes the camera look at the vector position in the global space as long as the parent of this camera is the scene or at position (0,0,0)."
              }
            },
            "!doc": "Abstract base class for cameras. This class should always be inherited when you build a new camera.",
            "!type": "fn()"
          },
          "CubeCamera": {
            "!url": "http://threejs.org/docs/#Reference/cameras/CubeCamera",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "renderTarget": {
                "!type": "+THREE.WebGLRenderTargetCube",
                "!doc": "The cube texture that gets generated."
              },
              "updateCubeMap": {
                "!type": "fn(renderer: todo, scene: todo) -> todo",
                "!doc": "Call this to update the renderTarget."
              }
            },
            "!doc": "Creates 6 cameras that render to a [page:WebGLRenderTargetCube].",
            "!type": "fn(near: number, far: number, cubeResolution: number)"
          },
          "OrthographicCamera": {
            "!url": "http://threejs.org/docs/#Reference/cameras/OrthographicCamera",
            "prototype": {
              "!proto": "THREE.Camera.prototype",
              "left": {
                "!type": "number",
                "!doc": "Camera frustum left plane."
              },
              "right": {
                "!type": "number",
                "!doc": "Camera frustum right plane."
              },
              "top": {
                "!type": "number",
                "!doc": "Camera frustum top plane."
              },
              "bottom": {
                "!type": "number",
                "!doc": "Camera frustum bottom plane."
              },
              "near": {
                "!type": "number",
                "!doc": "Camera frustum near plane."
              },
              "far": {
                "!type": "number",
                "!doc": "Camera frustum far plane."
              },
              "updateProjectionMatrix": {
                "!type": "fn()",
                "!doc": "Updates the camera projection matrix. Must be called after change of parameters."
              }
            },
            "!doc": "Camera with orthographic projection.",
            "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number)"
          },
          "PerspectiveCamera": {
            "!url": "http://threejs.org/docs/#Reference/cameras/PerspectiveCamera",
            "prototype": {
              "!proto": "THREE.Camera.prototype",
              "fov": {
                "!type": "number",
                "!doc": "Camera frustum vertical field of view, from bottom to top of view, in degrees."
              },
              "aspect": {
                "!type": "number",
                "!doc": "Camera frustum aspect ratio, window width divided by window height."
              },
              "near": {
                "!type": "number",
                "!doc": "Camera frustum near plane."
              },
              "far": {
                "!type": "number",
                "!doc": "Camera frustum far plane."
              },
              "setLens": {
                "!type": "fn(focalLength: number, frameSize: number)",
                "!doc": "Uses focal length (in mm) to estimate and set FOV 35mm (fullframe) camera is used if frame size is not specified.<br>\n\t\tFormula based on [link:http://www.bobatkins.com/photography/technical/field_of_view.html]"
              },
              "setViewOffset": {
                "!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
                "!doc": "For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br>\n\n\t\t<pre>+---+---+---+\n| A | B | C |\n+---+---+---+\n| D | E | F |\n+---+---+---+</pre>\n\n\t\tthen for each monitor you would call it like this:<br>\n\n\t\t<code>var w = 1920;\nvar h = 1080;\nvar fullWidth = w * 3;\nvar fullHeight = h * 2;\n\n// A\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n// B\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n// C\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n// D\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n// E\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n// F\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n</code>\n\n\t\tNote there is no reason monitors have to be the same size or in a grid."
              },
              "updateProjectionMatrix": {
                "!type": "fn()",
                "!doc": "Updates the camera projection matrix. Must be called after change of parameters."
              }
            },
            "!doc": "Camera with perspective projection.",
            "!type": "fn(fov: number, aspect: number, near: number, far: number)"
          },
          "CustomBlendingEquations": {
            "!url": "http://threejs.org/docs/#Reference/constants/CustomBlendingEquations",
            "prototype": {}
          },
          "GLState": {
            "!url": "http://threejs.org/docs/#Reference/constants/GLState",
            "prototype": {}
          },
          "Materials": {
            "!url": "http://threejs.org/docs/#Reference/constants/Materials",
            "prototype": {}
          },
          "ShadowingTypes": {
            "!url": "http://threejs.org/docs/#Reference/constants/ShadowingTypes",
            "prototype": {}
          },
          "Textures": {
            "!url": "http://threejs.org/docs/#Reference/constants/Textures",
            "prototype": {}
          },
          "BufferAttribute": {
            "!url": "http://threejs.org/docs/#Reference/core/BufferAttribute",
            "prototype": {
              "array": {
                "!type": "[]",
                "!doc": "Stores the data associated with this attribute; can be an Array or a Typed Array. This element should have <code>itemSize * numVertices</code> elements, where numVertices is the number of vertices in the associated [page:BufferGeometry geometry]."
              },
              "itemSize": {
                "!type": "number",
                "!doc": "Records how many items of the array are associated with a particular vertex. For instance, if this\n\t\tattribute is storing a 3-component vector (such as a position, normal, or color), then itemSize should be 3."
              },
              "length": {
                "!type": "number",
                "!doc": "Gives the total number of elements in the array."
              },
              "needsUpdate": {
                "!type": "bool",
                "!doc": "Flag to indicate that this attribute has changed and should be re-send to the GPU. Set this to true when you modify the value of the array."
              },
              "setX": {
                "!type": "fn(index, x)",
                "!doc": "Sets the value of the array at <code>index * itemSize</code> to x"
              },
              "setY": {
                "!type": "fn(index, y)",
                "!doc": "Sets the value of the array at <code>index * itemSize + 1</code> to y"
              },
              "setZ": {
                "!type": "fn(index, z)",
                "!doc": "Sets the value of the array at <code>index * itemSize + 2</code> to z"
              },
              "setXY": {
                "!type": "fn(index, x, y)",
                "!doc": "Sets the value of the array at <code>index * itemSize</code> to x and \n\t\tsets the value of the array at <code>index * itemSize + 1</code> to y"
              },
              "setXYZ": {
                "!type": "fn(index, x, y, z)",
                "!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, and\n\t\tthe value of the array at <code>index * itemSize + 2</code> to z."
              },
              "setXYZW": {
                "!type": "fn(index, x, y, z, w)",
                "!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, \n\t\tthe value of the array at <code>index * itemSize + 2</code> to z, and\n\t\tthe value of the array at <code>index * itemSize + 3</code> to w."
              },
              "clone": {
                "!type": "fn() -> +THREE.BufferAttribute",
                "!doc": "Copies this attribute."
              }
            },
            "!doc": "This class stores data for an attribute associated with a [page:BufferGeometry]. See that page for details and a usage example. This class is used to store builtin attributes such as vertex position, normals, color, etc., but can also be used in your code to store custom attributes in a [page:BufferGeometry].",
            "!type": "fn(array: [], itemSize: number)"
          },
          "BufferGeometry": {
            "!url": "http://threejs.org/docs/#Reference/core/BufferGeometry",
            "prototype": {
              "id": {
                "!type": "number",
                "!doc": "Unique number for this buffergeometry instance."
              },
              "attributes": {
                "!type": "Hashmap",
                "!doc": "This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.\n\t\tRather than accessing this property directly, use addAttribute and getAttribute to access attributes of this geometry."
              },
              "drawCalls": {
                "!type": "[]",
                "!doc": "For geometries that use indexed triangles, this Array can be used to split the object into multiple WebGL draw calls. Each draw call will draw some subset of the vertices in this geometry using the configured [page:Material shader]. This may be necessary if, for instance, you have more than 65535 vertices in your object. \n\t\tEach element is an object of the form:\n\t\t<code>{ start: Integer, count: Integer, index: Integer }</code>\n\t\twhere start specifies the index of the first vertex in this draw call, count specifies how many vertices are included, and index specifies an optional offset.\n\n\t\tUse addDrawCall to add draw calls, rather than modifying this array directly."
              },
              "boundingBox": {
                "!type": "+THREE.Box3",
                "!doc": "Bounding box.\n\t\t<code>{ min: new THREE.Vector3(), max: new THREE.Vector3() }</code>"
              },
              "boundingSphere": {
                "!type": "+THREE.Sphere",
                "!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
              },
              "morphTargets": {
                "!type": "[]",
                "!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new THREE.Vertex(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
              },
              "addAttribute": {
                "!type": "null",
                "!doc": "Adds an attribute to this geometry. Use this rather than the attributes property, \n\t\tbecause an internal array of attributes is maintained to speed up iterating over\n\t\tattributes."
              },
              "addDrawCall": {
                "!type": "fn(start: number, count: number, indexOffset: number)",
                "!doc": "Adds a draw call to this geometry; see the drawcalls property for details."
              },
              "applyMatrix": {
                "!type": "fn(matrix: +THREE.Matrix4)",
                "!doc": "Bakes matrix transform directly into vertex coordinates."
              },
              "computeVertexNormals": {
                "!type": "fn()",
                "!doc": "Computes vertex normals by averaging face normals.<br>"
              },
              "computeBoundingBox": {
                "!type": "fn()",
                "!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute.<br>\n\t\tBounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
              },
              "computeBoundingSphere": {
                "!type": "fn()",
                "!doc": "Computes bounding sphere of the geometry, updating [page:Geometry Geometry.boundingSphere] attribute.<br>\n\t\tBounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
              },
              "dispose": {
                "!type": "fn()",
                "!doc": "Disposes the object from memory. <br>\n\t\tYou need to call this when you want the bufferGeometry removed while the application is running."
              },
              "fromGeometry": {
                "!type": "fn()",
                "!doc": "Populates this BufferGeometry with data from a [page:Geometry] object."
              },
              "getAttribute": {
                "!type": "fn(name: string) -> +THREE.BufferAttribute",
                "!doc": "Returns the [page:BufferAttribute attribute] with the specified name."
              },
              "normalizeNormals": {
                "!type": "fn()",
                "!doc": "Every normal vector in a geometry will have a magnitude of 1.\n\t\tThis will correct lighting on the geometry surfaces."
              }
            },
            "!doc": "<p>\n\t\tThis class is an efficient alternative to [page:Geometry], because it stores all data, including\n\t\tvertex positions, face indices, normals, colors, UVs, and custom attributes within buffers; this\n\t\treduces the cost of passing all this data to the GPU. \n\t\tThis also makes BufferGeometry harder to work with than [page:Geometry]; rather than accessing \n\t\tposition data as [page:Vector3] objects, color data as [page:Color] objects, and so on, you have to \n\t\taccess the raw data from the appropriate [page:BufferAttribute attribute] buffer. This makes \n\t\tBufferGeometry best-suited for static objects where you don't need to manipulate the geometry much\n\t\tafter instantiating it.\n\t\t</p>\n\n\t\t<h3>Example</h3>\n\t\t<code>\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\t// create a simple square shape. We duplicate the top left and bottom right\n\t\t// vertices because each vertex needs to appear once per triangle. \n\t\tvar vertexPositions = [ \n\t\t\t[-1.0, -1.0,  1.0],\n\t\t\t[ 1.0, -1.0,  1.0],\n\t\t\t[ 1.0,  1.0,  1.0],\n\n\t\t\t[ 1.0,  1.0,  1.0],\n\t\t\t[-1.0,  1.0,  1.0],\n\t\t\t[-1.0, -1.0,  1.0]\n\t\t];\n\t\tvar vertices = new Float32Array( vertexPositions.length * 3 ); // three components per vertex\n\n\t\t// components of the position vector for each vertex are stored\n\t\t// contiguously in the buffer.\n\t\tfor ( var i = 0; i &lt; vertexPositions.length; i++ )\n\t\t{\n\t\t\tvertices[ i*3 + 0 ] = vertexPositions[i][0];\n\t\t\tvertices[ i*3 + 1 ] = vertexPositions[i][1];\n\t\t\tvertices[ i*3 + 2 ] = vertexPositions[i][2];\n\t\t}\n\n\t\t// itemSize = 3 because there are 3 values (components) per vertex\n\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tvar material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t</code>\n\t\t<p>More examples: [example:webgl_buffergeometry Complex mesh with non-indexed faces], [example:webgl_buffergeometry_uint Complex mesh with indexed faces], [example:webgl_buffergeometry_lines Lines], [example:webgl_buffergeometry_lines_indexed Indexed Lines], [example:webgl_buffergeometry_particles Particles], and [example:webgl_buffergeometry_rawshader Raw Shaders].</p>\n\n\t\t\n\t\t<h3>Accessing attributes</h3>\n\t\t<p>\n\t\tWebGL stores data associated with individual vertices of a geometry in <emph>attributes</emph>. \n\t\tExamples include the position of the vertex, the normal vector for the vertex, the vertex color,\n\t\tand so on. When using [page:Geometry], the [page:WebGLRenderer renderer] takes care of wrapping\n\t\tup this information into typed array buffers and sending this data to the shader. With \n\t\tBufferGeometry, all of this data is stored in buffers associated with an individual attributes.\n\t\tThis means that to get the position data associated with a vertex (for instance), you must call\n\t\t[page:.getAttribute] to access the 'position' [page:BufferAttribute attribute], then access the individual \n\t\tx, y, and z coordinates of the position.  \n\t\t</p>\n\t\t<p>\n\t\tThe following attributes are set by various members of this class:\n\t\t</p>\n\t\t<h4>[page:BufferAttribute position] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z coordinates of each vertex in this geometry. Set by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute normal] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the face or vertex normal vector of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute color] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the red, green, and blue channels of vertex color of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute tangent] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the tangent vector of each vertex in this geometry. Set by [page:.computeTangents]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute index] (itemSize: 3)</h4>\n\t\tAllows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles,\" and works much the same as it does in [page:Geometry]: each triangle is associated with the index of three vertices. This attribute therefore stores the index of each vertex for each triangular face.\n\n\t\tIf this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.",
            "!type": "fn()"
          },
          "Clock": {
            "!url": "http://threejs.org/docs/#Reference/core/Clock",
            "prototype": {
              "autoStart": {
                "!type": "bool",
                "!doc": "If set, starts the clock automatically when the first update is called."
              },
              "startTime": {
                "!type": "number",
                "!doc": "When the clock is running, It holds the start time of the clock. <br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
              },
              "oldTime": {
                "!type": "number",
                "!doc": "When the clock is running, It holds the previous time from a update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
              },
              "elapsedTime": {
                "!type": "number",
                "!doc": "When the clock is running, It holds the time elapsed between the start of the clock to the previous update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
              },
              "running": {
                "!type": "bool",
                "!doc": "This property keeps track whether the clock is running or not."
              },
              "start": {
                "!type": "fn()",
                "!doc": "Starts clock."
              },
              "stop": {
                "!type": "fn()",
                "!doc": "Stops clock."
              },
              "getElapsedTime": {
                "!type": "fn() -> number",
                "!doc": "Get the seconds passed since the clock started."
              },
              "getDelta": {
                "!type": "fn() -> number",
                "!doc": "Get the seconds passed since the last call to this method."
              }
            },
            "!doc": "Object for keeping track of time.",
            "!type": "fn(autoStart: bool)"
          },
          "EventDispatcher": {
            "!url": "http://threejs.org/docs/#Reference/core/EventDispatcher",
            "prototype": {
              "addEventListener": {
                "!type": "fn(type: string, listener: function)",
                "!doc": "Adds a listener to an event type."
              },
              "hasEventListener": {
                "!type": "fn(type: string, listener: function) -> bool",
                "!doc": "Checks if listener is added to an event type."
              },
              "removeEventListener": {
                "!type": "fn(type: string, listener: function)",
                "!doc": "Removes a listener from an event type."
              },
              "dispatchEvent": {
                "!type": "fn(type: string)",
                "!doc": "Fire an event type."
              }
            },
            "!doc": "JavaScript events for custom objects.<br>\n\t\t<a href=\"https://github.com/mrdoob/eventdispatcher.js\">https://github.com/mrdoob/eventdispatcher.js</a>",
            "!type": "fn()"
          },
          "Face3": {
            "!url": "http://threejs.org/docs/#Reference/core/Face3",
            "prototype": {
              "a": {
                "!type": "number",
                "!doc": "Vertex A index."
              },
              "b": {
                "!type": "number",
                "!doc": "Vertex B index."
              },
              "c": {
                "!type": "number",
                "!doc": "Vertex C index."
              },
              "normal": {
                "!type": "+THREE.Vector3",
                "!doc": "Face normal."
              },
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Face color."
              },
              "vertexNormals": {
                "!type": "[]",
                "!doc": "Array of 3 vertex normals."
              },
              "vertexColors": {
                "!type": "[]",
                "!doc": "Array of 3 vertex colors."
              },
              "materialIndex": {
                "!type": "number",
                "!doc": "Material index (points to [page:MultiMaterial MultiMaterial.materials])."
              },
              "clone": {
                "!type": "fn() -> +THREE.Face3",
                "!doc": "Creates a new clone of the Face3 object."
              }
            },
            "!doc": "Triangle face.",
            "!type": "fn(a: number, b: number, c: number, normal: +THREE.Vector3, color: +THREE.Color, materialIndex: number)"
          },
          "Geometry": {
            "!url": "http://threejs.org/docs/#Reference/core/Geometry",
            "prototype": {
              "id": {
                "!type": "number",
                "!doc": "Unique number for this geometry instance."
              },
              "name": {
                "!type": "string",
                "!doc": "Name for this geometry. Default is an empty string."
              },
              "vertices": {
                "!type": "[]",
                "!doc": "Array of [page:Vector3 vertices].<br>\n\t\tThe array of vertices holds every position of points in the model.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.verticesNeedUpdate] needs to be set to true."
              },
              "colors": {
                "!type": "[]",
                "!doc": "Array of vertex [page:Color colors], matching number and order of vertices.<br>\n\t\tUsed in [page:PointCloud] and [page:Line].<br>\n\t\t[page:Mesh Meshes] use per-face-use-of-vertex colors embedded directly in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.colorsNeedUpdate] needs to be set to true."
              },
              "faces": {
                "!type": "[]",
                "!doc": "Array of [page:Face3 triangles].<br>\n\t\tThe array of faces describe how each vertex in the model is connected with each other.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.elementsNeedUpdate] needs to be set to true."
              },
              "faceVertexUvs": {
                "!type": "[]",
                "!doc": "Array of face [page:UV] layers.<br>\n\t\tEach UV layer is an array of [page:UV]s matching the order and number of vertices in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.uvsNeedUpdate] needs to be set to true."
              },
              "morphTargets": {
                "!type": "[]",
                "!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new THREE.Vector3(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
              },
              "morphNormals": {
                "!type": "[]",
                "!doc": "Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:\n\t\t<code>morphNormal = { name: \"NormalName\", normals: [ new THREE.Vector3(), ... ] }</code>"
              },
              "skinWeights": {
                "!type": "[]",
                "!doc": "Array of skinning weights, matching number and order of vertices."
              },
              "skinIndices": {
                "!type": "[]",
                "!doc": "Array of skinning indices, matching number and order of vertices."
              },
              "boundingBox": {
                "!type": "object",
                "!doc": "Bounding box.\n\t\t<code>{ min: new THREE.Vector3(), max: new THREE.Vector3() }</code>"
              },
              "boundingSphere": {
                "!type": "object",
                "!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
              },
              "dynamic": {
                "!type": "bool",
                "!doc": "Set to *true* if attribute buffers will need to change in runtime (using \"dirty\" flags).<br>\n\t\tUnless set to true internal typed arrays corresponding to buffers will be deleted once sent to GPU.<br>\n\t\tDefaults to true."
              },
              "verticesNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the vertices array has been updated."
              },
              "elementsNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the faces array has been updated."
              },
              "uvsNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the uvs array has been updated."
              },
              "normalsNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the normals array has been updated."
              },
              "colorsNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the colors array has been updated."
              },
              "lineDistancesNeedUpdate": {
                "!type": "bool",
                "!doc": "Set to *true* if the linedistances array has been updated."
              },
              "lineDistances": {
                "!type": "array",
                "!doc": "An array containing distances between vertices for Line geometries.\n\t\tThis is required for LinePieces/LineDashedMaterial to render correctly.\n\t\tLine distances can also be generated with computeLineDistances."
              },
              "applyMatrix": {
                "!type": "fn(matrix: +THREE.Matrix4)",
                "!doc": "Bakes matrix transform directly into vertex coordinates."
              },
              "computeFaceNormals": {
                "!type": "fn()",
                "!doc": "Computes face normals."
              },
              "computeVertexNormals": {
                "!type": "fn()",
                "!doc": "Computes vertex normals by averaging face normals.<br>\n\t\tFace normals must be existing / computed beforehand."
              },
              "computeMorphNormals": {
                "!type": "fn()",
                "!doc": "Computes morph normals."
              },
              "computeBoundingBox": {
                "!type": "fn()",
                "!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute."
              },
              "computeBoundingSphere": {
                "!type": "fn()",
                "!doc": "Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are *null*."
              },
              "merge": {
                "!type": "fn(geometry: +THREE.Geometry, matrix: +THREE.Matrix4, materialIndexOffset: number)",
                "!doc": "Merge two geometries or geometry and geometry from object (using object's transform)"
              },
              "mergeVertices": {
                "!type": "fn()",
                "!doc": "Checks for duplicate vertices using hashmap.<br>\n\t\tDuplicated vertices are removed and faces' vertices are updated."
              },
              "clone": {
                "!type": "fn() -> +THREE.Geometry",
                "!doc": "Creates a new clone of the Geometry."
              },
              "dispose": {
                "!type": "fn()",
                "!doc": "Removes The object from memory. <br>\n\t\tDon't forget to call this method when you remove a geometry because it can cause memory leaks."
              }
            },
            "!doc": "Base class for geometries.<br>\n\t\tA geometry holds all data necessary to describe a 3D model.",
            "!type": "fn()"
          },
          "Object3D": {
            "!url": "http://threejs.org/docs/#Reference/core/Object3D",
            "prototype": {
              "id": {
                "!type": "number",
                "!doc": "readonly – Unique number for this object instance."
              },
              "uuid": {
                "!type": "string",
                "!doc": "[link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.\n\t\tThis gets automatically assigned, so this shouldn't be edited."
              },
              "name": {
                "!type": "string",
                "!doc": "Optional name of the object (doesn't need to be unique)."
              },
              "parent": {
                "!type": "+THREE.Object3D",
                "!doc": "Object's parent in the scene graph."
              },
              "children": {
                "!type": "+THREE.Object3D",
                "!doc": "Array with object's children."
              },
              "position": {
                "!type": "+THREE.Vector3",
                "!doc": "Object's local position."
              },
              "rotation": {
                "!type": "+THREE.Euler",
                "!doc": "Object's local rotation (<a href=\"https://en.wikipedia.org/wiki/Euler_angles\" target=\"_blank\">Euler angles</a>), in radians."
              },
              "scale": {
                "!type": "+THREE.Vector3",
                "!doc": "Object's local scale."
              },
              "up": {
                "!type": "+THREE.Vector3",
                "!doc": "Up direction."
              },
              "matrix": {
                "!type": "+THREE.Matrix4",
                "!doc": "Local transform."
              },
              "quaternion": {
                "!type": "+THREE.Quaternion",
                "!doc": "Object's local rotation as [page:Quaternion Quaternion]."
              },
              "visible": {
                "!type": "bool",
                "!doc": "default – true"
              },
              "castShadow": {
                "!type": "bool",
                "!doc": "default – false"
              },
              "receiveShadow": {
                "!type": "bool",
                "!doc": "default – false"
              },
              "frustumCulled": {
                "!type": "bool",
                "!doc": "default – true"
              },
              "matrixAutoUpdate": {
                "!type": "bool",
                "!doc": "default – true"
              },
              "matrixWorldNeedsUpdate": {
                "!type": "bool",
                "!doc": "default – false"
              },
              "userData": {
                "!type": "object",
                "!doc": "An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned."
              },
              "matrixWorld": {
                "!type": "+THREE.Matrix4",
                "!doc": "The global transform of the object. If the Object3d has no parent, then it's identical to the local transform."
              },
              "applyMatrix": {
                "!type": "fn(matrix: +THREE.Matrix4)",
                "!doc": "This updates the position, rotation and scale with the matrix."
              },
              "translateX": {
                "!type": "fn(distance: number)",
                "!doc": "Translates object along x axis by distance."
              },
              "translateY": {
                "!type": "fn(distance: number)",
                "!doc": "Translates object along y axis by distance."
              },
              "translateZ": {
                "!type": "fn(distance: number)",
                "!doc": "Translates object along z axis by distance."
              },
              "localToWorld": {
                "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Updates the vector from local space to world space."
              },
              "worldToLocal": {
                "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Updates the vector from world space to local space."
              },
              "lookAt": {
                "!type": "fn(vector: +THREE.Vector3)",
                "!doc": "Rotates object to face point in space."
              },
              "traverse": {
                "!type": "fn(callback: function)",
                "!doc": "Executes the callback on this object and all descendants."
              },
              "traverseVisible": {
                "!type": "fn(callback: function)",
                "!doc": "Like traverse, but the callback will only be executed for visible objects.\n\t\tDescendants of invisible objects are not traversed."
              },
              "traverseAncestors": {
                "!type": "fn(callback: function)",
                "!doc": "Executes the callback on this object and all ancestors."
              },
              "updateMatrix": {
                "!type": "fn()",
                "!doc": "Updates local transform."
              },
              "updateMatrixWorld": {
                "!type": "fn(force: bool)",
                "!doc": "Updates global transform of the object and its children."
              },
              "clone": {
                "!type": "fn() -> +THREE.Object3D",
                "!doc": "Creates a new clone of this object and all descendants."
              },
              "getObjectByName": {
                "!type": "fn(name: string) -> +THREE.Object3D",
                "!doc": "Searches through the object's children and returns the first with a matching name."
              },
              "getObjectById": {
                "!type": "fn(id: number) -> +THREE.Object3D",
                "!doc": "Searches through the object's children and returns the first with a matching id."
              },
              "translateOnAxis": {
                "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
                "!doc": "Translate an object by distance along an axis in object space. The axis is assumed to be normalized."
              },
              "rotateOnAxis": {
                "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
                "!doc": "Rotate an object along an axis in object space. The axis is assumed to be normalized."
              },
              "raycast": {
                "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
                "!doc": "Abstract method to get intersections between a casted ray and this object. Subclasses such as [page:Mesh], [page:Line], and [page:PointCloud] implement this method in order to participate in raycasting."
              }
            },
            "!doc": "Base class for scene graph objects.",
            "!type": "fn()"
          },
          "Raycaster": {
            "!url": "http://threejs.org/docs/#Reference/core/Raycaster",
            "prototype": {
              "ray": {
                "!type": "+THREE.Ray",
                "!doc": "The Ray used for the raycasting."
              },
              "near": {
                "!type": "float",
                "!doc": "The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be smaller than the far property."
              },
              "far": {
                "!type": "float",
                "!doc": "The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be larger than the near property."
              },
              "precision": {
                "!type": "float",
                "!doc": "The precision factor of the raycaster when intersecting [page:Mesh] objects."
              },
              "set": {
                "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)",
                "!doc": "Updates the ray with a new origin and direction."
              },
              "setFromCamera": {
                "!type": "fn(coords: +THREE.Vector2, camera: +THREE.Camera)",
                "!doc": "Updates the ray with a new origin and direction."
              },
              "intersectObject": {
                "!type": "fn(object: +THREE.Object3D, recursive: bool) -> []",
                "!doc": "Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first. An array of intersections is returned...\n        <code>\n            [ { distance, point, face, faceIndex, indices, object }, ... ]\n        </code>\n        <p>\n        [page:Float distance] – distance between the origin of the ray and the intersection<br>\n        [page:Vector3 point] – point of intersection, in world coordinates<br>\n        [page:Face3 face] – intersected face<br>\n        [page:Integer faceIndex] – index of the intersected face<br>\n        [page:Array indices] – indices of vertices comprising the intersected face<br>\n        [page:Object3D object] – the intersected object\n    \t</p>\n        <p>\n        When intersecting a [page:Mesh] with a [page:BufferGeometry], the *faceIndex* will be *undefined*, and *indices* will be set; when intersecting a [page:Mesh] with a [page:Geometry], *indices* will be *undefined*. \n        </p>\n\t\t<p>\n\t\t*Raycaster* delegates to the [page:Object3D.raycast raycast] method of the passed object, when evaluating whether the ray intersects the object or not. This allows [page:Mesh meshes] to respond differently to ray casting than [page:Line lines] and [page:PointCloud pointclouds].\n\t\t</p>\n\t\t<p>\n\t\t*Note* that for meshes, faces must be pointed towards the origin of the [page:.ray ray] in order to be detected; intersections of the ray passing through the back of a face will not be detected. To raycast against both faces of an object, you'll want to set the [page:Mesh.material material]'s [page:Material.side side] property to *THREE.DoubleSide*.  \n\t\t</p>"
              },
              "intersectObjects": {
                "!type": "fn(objects: [], recursive: bool) -> []",
                "!doc": "Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by [page:.intersectObject]."
              }
            },
            "!doc": "This class makes raycasting easier. Raycasting is used for picking and more.",
            "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3, near: number, far: number)"
          },
          "Lut": {
            "!url": "http://threejs.org/docs/#Reference/examples/Lut",
            "prototype": {
              "minV": {
                "!type": "number",
                "!doc": "The minimum value to be represented with the lookup table. Default is 0."
              },
              "maxV": {
                "!type": "number",
                "!doc": "The maximum value to be represented with the lookup table. Default is 1."
              },
              "copy": {
                "!type": "fn(lut: +THREE.Lut)",
                "!doc": "Copies given lut."
              },
              "setminV": {
                "!type": "fn(minV: number) -> +THREE.Lut",
                "!doc": "Sets this Lut with the minimum value to be represented."
              },
              "setmaxV": {
                "!type": "fn(maxV: number) -> +THREE.Lut",
                "!doc": "Sets this Lut with the maximum value to be represented."
              },
              "changeNumberOfColors": {
                "!type": "fn(numberOfColors: number) -> +THREE.Lut",
                "!doc": "Sets this Lut with the number of colors to be used."
              },
              "changeColorMap": {
                "!type": "fn(colorMap: number) -> +THREE.Lut",
                "!doc": "Sets this Lut with the colormap to be used."
              },
              "addColorMap": {
                "!type": "fn(colorMapName, arrayOfColors) -> +THREE.Lut",
                "!doc": "Insert a new color map into the set of available color maps."
              },
              "getColor": {
                "!type": "fn(value) -> +THREE.Lut",
                "!doc": "Returns a Three.Color."
              }
            },
            "!doc": "Represents a lookup table for colormaps. It is used to determine the color values from a range of data values.",
            "!type": "fn(colormap, numberOfColors)"
          },
          "FontUtils": {
            "!url": "http://threejs.org/docs/#Reference/extras/FontUtils",
            "prototype": {
              "divisions": {
                "!type": "number",
                "!doc": "The amount of segments in a curve. Default is 10."
              },
              "style": {
                "!type": "string",
                "!doc": "The style of the used font. Default is \"normal\"."
              },
              "weight": {
                "!type": "string",
                "!doc": "The weight of the used font. Default is \"normal\"."
              },
              "face": {
                "!type": "string",
                "!doc": "The name of the font. Default is \"helvetiker\"."
              },
              "faces": {
                "!type": "object",
                "!doc": "All Fonts which are already loaded in."
              },
              "size": {
                "!type": "number",
                "!doc": "The size of the used Font. Default is 150."
              },
              "drawText": {
                "!type": "fn(text: string) -> object",
                "!doc": "Calculates the path and offset of the text in the used font. It returns an  object like { paths : fontPaths, offset : width }."
              },
              "Triangulate": {
                "!type": "fn(contour: [], indices: bool) -> []",
                "!doc": "Triangulates a contour into an array of faces."
              },
              "extractGlyphPoints": {
                "!type": "fn(c: string, face: string, scale: number, offset: number, path: +THREE.Path) -> object",
                "!doc": "This ectracts the glyphPoints of the character of the face and returns an object containing the path and the new offset."
              },
              "generateShapes": {
                "!type": "fn(text: string, parameters: object) -> []",
                "!doc": "Generates shapes from the text and return them as an Array of [page:Shape]."
              },
              "loadFace": {
                "!type": "fn(data: object) -> object",
                "!doc": "This loads and saves the data of the face and return the data. When you add the font Data as javascriptfile, then this automatically get called. So there is no need to do this yourself."
              },
              "getFace": {
                "!type": "fn() -> object",
                "!doc": "Returns the used font its data based on its style and weight."
              }
            },
            "!doc": "A class for text operations in three.js (See [page:TextGeometry])"
          },
          "GeometryUtils": {
            "!url": "http://threejs.org/docs/#Reference/extras/GeometryUtils",
            "prototype": {},
            "!doc": "Contains handy functions geometry manipulations."
          },
          "Curve": {
            "!url": "http://threejs.org/docs/#Reference/extras/core/Curve",
            "prototype": {
              "getPoint": {
                "!type": "fn(t) -> Vector",
                "!doc": "Returns a vector for point t of the curve where t is between 0 and 1"
              },
              "getPointAt": {
                "!type": "fn(u) -> Vector",
                "!doc": "Returns a vector for point at relative position in curve according to arc length"
              },
              "getPoints": {
                "!type": "fn(divisions) -> []",
                "!doc": "Get sequence of points using getPoint( t )"
              },
              "getSpacedPoints": {
                "!type": "fn(divisions) -> []",
                "!doc": "Get sequence of equi-spaced points using getPointAt( u )"
              },
              "getLength": {
                "!type": "fn() -> number",
                "!doc": "Get total curve arc length"
              },
              "getLengths": {
                "!type": "fn(divisions) -> []",
                "!doc": "Get list of cumulative segment lengths"
              },
              "updateArcLengths": {
                "!type": "fn()",
                "!doc": "Update the cumlative segment distance cache"
              },
              "getUtoTmapping": {
                "!type": "fn(u, distance) -> number",
                "!doc": "Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant"
              },
              "getTangent": {
                "!type": "fn(t) -> Vector",
                "!doc": "Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation"
              },
              "getTangentAt": {
                "!type": "fn(u) -> Vector",
                "!doc": "Returns tangent at equidistant point u on the curve"
              }
            },
            "!doc": "An extensible curve object which contains methods for interpolation.",
            "!type": "fn()"
          },
          "CurvePath": {
            "!url": "http://threejs.org/docs/#Reference/extras/core/CurvePath",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "curves": {
                "!type": "array",
                "!doc": "todo"
              },
              "bends": {
                "!type": "array",
                "!doc": "todo"
              },
              "autoClose": {
                "!type": "boolean",
                "!doc": "todo"
              },
              "add": {
                "!type": "fn(curve: todo) -> todo",
                "!doc": "todo"
              },
              "closePath": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              },
              "getBoundingBox": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              },
              "getCurveLengths": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "todo",
            "!type": "fn()"
          },
          "Gyroscope": {
            "!url": "http://threejs.org/docs/#Reference/extras/core/Gyroscope",
            "prototype": {
              "!proto": "THREE.Object3D.prototype"
            },
            "!doc": "todo",
            "!type": "fn()"
          },
          "Path": {
            "!url": "http://threejs.org/docs/#Reference/extras/core/Path",
            "prototype": {
              "!proto": "THREE.CurvePath.prototype",
              "actions": {
                "!type": "array",
                "!doc": "The possible actions that define the path."
              },
              "setFromPoints": {
                "!type": "fn(vectors) -> todo",
                "!doc": "Adds to the Path from the points. The first vector defines the offset. After that the lines get defined."
              },
              "moveTo": {
                "!type": "fn(x, y) -> todo",
                "!doc": "This moves the offset to x and y"
              },
              "lineTo": {
                "!type": "fn(x, y) -> todo",
                "!doc": "This creates a line from the offset to X and Y and updates the offset to X and Y."
              },
              "quadraticCurveTo": {
                "!type": "fn(aCPx, aCPy, aX, aY) -> todo",
                "!doc": "This creates a quadratic curve from the offset to aX and aY with aCPx and aCPy as control point and updates the offset to aX and aY."
              },
              "bezierCurveTo": {
                "!type": "fn(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) -> todo",
                "!doc": "This creates a bezier curve from the offset to aX and aY with aCP1x, aCP1y and aCP1x, aCP1y  as control points and updates the offset to aX and aY."
              },
              "arc": {
                "!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
                "!doc": "todo"
              },
              "absarc": {
                "!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
                "!doc": "todo"
              },
              "ellipse": {
                "!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
                "!doc": "todo"
              },
              "absellipse": {
                "!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
                "!doc": "todo"
              },
              "toShapes": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "A 2d path representation, comprising of points, lines, and cubes,  similar to the html5 2d canvas api. It extends CurvePath.",
            "!type": "fn(points: todo)"
          },
          "Shape": {
            "!url": "http://threejs.org/docs/#Reference/extras/core/Shape",
            "prototype": {
              "!proto": "THREE.Path.prototype",
              "holes": {
                "!type": "array",
                "!doc": "todo"
              },
              "extractPoints": {
                "!type": "fn(divisions: todo) -> todo",
                "!doc": "todo"
              },
              "getPointsHoles": {
                "!type": "fn(divisions: todo) -> todo",
                "!doc": "Get points of holes"
              },
            },
            "!doc": "Defines a 2d shape plane using paths.",
            "!type": "fn()"
          },
          "ArcCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/ArcCurve",
            "prototype": {
              "!proto": "THREE.EllipseCurve.prototype"
            },
            "!doc": "Alias for [page:EllipseCurve]"
          },
          "CubicBezierCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/CubicBezierCurve",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v0": "+THREE.Vector2",
              "v1": "+THREE.Vector2",
              "v2": "+THREE.Vector2",
              "v3": "+THREE.Vector2"
            },
            "!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>."
          },
          "CubicBezierCurve3": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/CubicBezierCurve3",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v0": "+THREE.Vector3",
              "v1": "+THREE.Vector3",
              "v2": "+THREE.Vector3",
              "v3": "+THREE.Vector3"
            },
            "!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>.",
            "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3, v3: +THREE.Vector3)"
          },
          "EllipseCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/EllipseCurve",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "aX": "number",
              "aY": "number",
              "xRadius": "Radians",
              "yRadius": "Radians",
              "aStartAngle": "number",
              "aEndAngle": "number",
              "aClockwise": "bool"
            },
            "!doc": "Creates a 2d curve in the shape of an ellipse.",
            "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: Radians, aEndAngle: Radians, aClockwise: bool)"
          },
          "LineCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/LineCurve",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v1": "+THREE.Vector2",
              "v2": "+THREE.Vector2"
            },
            "!doc": "A curve representing a 2d line segment",
            "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2)"
          },
          "LineCurve3": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/LineCurve3",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v1": "+THREE.Vector3",
              "v2": "+THREE.Vector3"
            },
            "!doc": "A curve representing a 3d line segment",
            "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3)"
          },
          "QuadraticBezierCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/QuadraticBezierCurve",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v0": "+THREE.Vector2",
              "v1": "+THREE.Vector2",
              "v2": "+THREE.Vector2"
            },
            "!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
            "!type": "fn(v0: +THREE.Vector2, v1: +THREE.Vector2, v2: +THREE.Vector2)"
          },
          "QuadraticBezierCurve3": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/QuadraticBezierCurve3",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "v0": "+THREE.Vector3",
              "v1": "+THREE.Vector3",
              "v2": "+THREE.Vector3"
            },
            "!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
            "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3)"
          },
          "SplineCurve": {
            "!url": "http://threejs.org/docs/#Reference/extras/curves/SplineCurve",
            "prototype": {
              "!proto": "THREE.Curve.prototype",
              "points": "[]"
            },
            "!doc": "Create a smooth 2d spline curve from a series of points",
            "!type": "fn(points: [])"
          },
          "BoxGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/BoxGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided with the 'width', 'height', and 'depth' constructor arguments.",
            "!type": "fn(width: number, height: number, depth: number, widthSegments: number, heightSegments: number, depthSegments: number)"
          },
          "CircleGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/CircleGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "CircleGeometry is a simple shape of Euclidean geometry.  It is contructed from a number of triangular segments that are oriented around a central point and extend as far out as a given radius.  It is built counter-clockwise from a start angle and a given central angle.  It can also be used to create regular polygons, where the number of segments determines the number of sides.",
            "!type": "fn(radius: number, segments: number, thetaStart: number, thetaLength: number)"
          },
          "CubeGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/CubeGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "Renamed CubeGeometry to BoxGeometry. see [page:BoxGeometry]."
          },
          "CylinderGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/CylinderGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "A class for generating cylinder geometries",
            "!type": "fn(radiusTop: number, radiusBottom: number, height: number, radiusSegments: number, heightSegments: number, openEnded: bool, thetaStart: number, thetaLength: number)"
          },
          "DodecahedronGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/DodecahedronGeometry",
            "prototype": {
              "!proto": "THREE.PolyhedronGeometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              }
            },
            "!doc": "A class for generating a dodecahedron geometries.",
            "!type": "fn(radius: number, detail: number)"
          },
          "ExtrudeGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/ExtrudeGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype",
              "addShapeList": {
                "!type": "fn(shapes: [], options: object)",
                "!doc": "Adds the shapes to the list to extrude."
              },
              "addShape": {
                "!type": "fn(shape: +THREE.Shape, options: object)",
                "!doc": "Add the shape to the list to extrude."
              }
            },
            "!doc": "Creates extruded geometry from a path shape",
            "!type": "fn(shapes: [], options: object)"
          },
          "IcosahedronGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/IcosahedronGeometry",
            "prototype": {
              "!proto": "THREE.PolyhedronGeometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              }
            },
            "!doc": "A class for generating an icosahedron geometry.",
            "!type": "fn(radius: number, detail: number)"
          },
          "LatheGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/LatheGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "Class for generating meshes with axial symmetry. Possible uses include donuts, pipes, vases etc. The lathe rotate around the Y axis.",
            "!type": "fn(points: [], segments: number, phiStart: number, phiLength: number)"
          },
          "OctahedronGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/OctahedronGeometry",
            "prototype": {
              "!proto": "THREE.PolyhedronGeometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              }
            },
            "!doc": "A class for generating an octahedron geometry.",
            "!type": "fn(radius: number, detail: number)"
          },
          "ParametricGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/ParametricGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "Generate geometry representing a parametric surface.",
            "!type": "fn(func: function, slices: number, stacks: number)"
          },
          "PlaneGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/PlaneGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "A class for generating plane geometries",
            "!type": "fn(width: number, height: number, widthSegments: number, heightSegments: number)"
          },
          "PolyhedronGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/PolyhedronGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              }
            },
            "!doc": "A polyhedron is a solid in three dimensions with flat faces. This class will take an array of vertices,\n\t\t\tproject them onto a sphere, and then divide them up to the desired level of detail. This class is used\n\t\t\tby [page:DodecahedronGeometry], [page:IcosahedronGeometry], [page:OctahedronGeometry],\n\t\t\tand [page:TetrahedronGeometry] to generate their respective geometries.",
            "!type": "fn(vertices: [], faces: [], radius: number, detail: number)"
          },
          "RingGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/RingGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "A class for generating a two-dimensional ring geometry.",
            "!type": "fn(innerRadius: number, outerRadius: number, thetaSegments: number, phiSegments: number, thetaStart: number, thetaLength: number)"
          },
          "ShapeGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/ShapeGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype",
              "addShape": {
                "!type": "fn(shape: +THREE.Shape, options: object)",
                "!doc": "Adds a single shape to the geometry"
              }
            },
            "!doc": "Creates a one-sided polygonal geometry from one or more path shapes. Similar to [page:ExtrudeGeometry]",
            "!type": "fn(shapes: [], options: object)"
          },
          "SphereGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/SphereGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "A class for generating sphere geometries",
            "!type": "fn(radius: number, widthSegments: number, heightSegments: number, phiStart: number, phiLength: number, thetaStart: number, thetaLength: number)"
          },
          "TetrahedronGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/TetrahedronGeometry",
            "prototype": {
              "!proto": "THREE.PolyhedronGeometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              }
            },
            "!doc": "A class for generating a tetrahedron geometries.",
            "!type": "fn(radius: number, detail: number)"
          },
          "TextGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/TextGeometry",
            "prototype": {
              "!proto": "THREE.ExtrudeGeometry.prototype"
            },
            "!doc": "This object creates an 3D object of text as a single object.",
            "!type": "fn(text: string, parameters: object)"
          },
          "TorusGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/TorusGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "A class for generating torus geometries",
            "!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, arc: number)"
          },
          "TorusKnotGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/TorusKnotGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype"
            },
            "!doc": "Creates a torus knot, the particular shape of which is defined by a pair of coprime integers, p and q.  If p and q are not coprime, the result will be a torus link.",
            "!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, heightScale: number)"
          },
          "TubeGeometry": {
            "!url": "http://threejs.org/docs/#Reference/geometries/TubeGeometry",
            "prototype": {
              "!proto": "THREE.Geometry.prototype",
              "parameters": {
                "!type": "object",
                "!doc": "An object with all of the parameters that were used to generate the geometry."
              },
              "tangents": {
                "!type": "[]",
                "!doc": "An array of [page:Vector3] tangents"
              },
              "normals": {
                "!type": "[]",
                "!doc": "An array of [page:Vector3] normals"
              },
              "binormals": {
                "!type": "[]",
                "!doc": "An array of [page:Vector3] binormals"
              }
            },
            "!doc": "Creates a tube that extrudes along a 3d curve",
            "!type": "fn(path: +THREE.Curve, segments: number, radius: number, radiusSegments: number, closed: bool)"
          },
          "ArrowHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/ArrowHelper",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "line": {
                "!type": "+THREE.Line",
                "!doc": "Contains the line part of the arrowHelper."
              },
              "cone": {
                "!type": "+THREE.Mesh",
                "!doc": "Contains the cone part of the arrowHelper."
              },
              "setColor": {
                "!type": "fn(hex: number)",
                "!doc": "Sets the color of the arrowHelper."
              },
              "setLength": {
                "!type": "fn(length: number, headLength: number, headWidth: number)",
                "!doc": "Sets the length of the arrowhelper."
              },
              "setDirection": {
                "!type": "fn(dir: +THREE.Vector3)",
                "!doc": "Sets the direction of the arrowhelper."
              }
            },
            "!doc": "An 3D arrow Object.",
            "!type": "fn(dir: +THREE.Vector3, origin: +THREE.Vector3, length: number, hex: number, headLength: number, headWidth: number)"
          },
          "AxisHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/AxisHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype"
            },
            "!doc": "An axis object to visualize the the 3 axes in a simple way. <br>\n\t\t\tThe X axis is red. The Y axis is green. The Z axis is blue.",
            "!type": "fn(size: number)"
          },
          "BoundingBoxHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/BoundingBoxHelper",
            "prototype": {
              "!proto": "THREE.Mesh.prototype",
              "object": {
                "!type": "+THREE.Object3D",
                "!doc": "Contains the object3D to show the world-axis-aligned boundingbox."
              },
              "box": {
                "!type": "+THREE.Box3",
                "!doc": "Contains the bounding box of the object."
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the BoundingBoxHelper based on the object property."
              }
            },
            "!doc": "A helper object to show the world-axis-aligned bounding box for an object.",
            "!type": "fn(object: +THREE.Object3D, hex: number)"
          },
          "BoxHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/BoxHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype",
              "update": {
                "!type": "fn(object: +THREE.Object3D)",
                "!doc": "Updates the helper's geometry to match the dimensions of the [page:Geometry.boundingBox bounding box] of the passed object's geometry.\n\n\t\t<h2>Source</h2>\n\n\t\t[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]"
              }
            },
            "!doc": "Helper object to show a wireframe box (with no face diagonals) around an object",
            "!type": "fn(object: +THREE.Object3D)"
          },
          "CameraHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/CameraHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype",
              "pointMap": {
                "!type": "object",
                "!doc": "This contains the points to viualize the cameraHelper"
              },
              "camera": {
                "!type": "+THREE.Camera",
                "!doc": "The camera to visualize."
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the helper based on the projectionMatrix of the camera."
              }
            },
            "!doc": "The camera Helper is an Object3D which helps visualizing what a camera contains in its frustum.<br>\n\t\tIt visualizes the frustum with an line Geometry.",
            "!type": "fn(camera: +THREE.Camera)"
          },
          "DirectionalLightHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/DirectionalLightHelper",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "lightPlane": {
                "!type": "+THREE.Line",
                "!doc": "Contains the line mesh showing the location of the directional light."
              },
              "light": {
                "!type": "+THREE.DirectionalLight",
                "!doc": "Contains the directionalLight."
              },
              "targetLine": {
                "!type": "+THREE.Line",
                "!doc": "Contains the line mesh that shows the direction of the light."
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the helper to match the position and direction of the [page:.light]."
              }
            },
            "!doc": "Visualize a [page:DirectionalLight]'s effect on the scene",
            "!type": "fn(light: +THREE.DirectionalLight, size: number)"
          },
          "EdgesHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/EdgesHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype"
            },
            "!doc": "Creates a wireframe object that shows the \"hard\" edges of another object's geometry. To draw a full wireframe image of an object, see [page:WireframeHelper].",
            "!type": "fn(object: +THREE.Object3D, color: +THREE.Color, thresholdAngle: number)"
          },
          "FaceNormalsHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/FaceNormalsHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype",
              "object": {
                "!type": "+THREE.Object3D",
                "!doc": "The attached object"
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the face normal preview based on movement of the object."
              }
            },
            "!doc": "Renders [page:ArrowHelper arrows] to visualize an object's [page:Face3 face] normals. Requires that the object's geometry be an instance of [page:Geometry] (does not work with [page:BufferGeometry]), and that face normals have been specified on all [page:Face3 faces] or calculated with [page:Geometry.computeFaceNormals computeFaceNormals].",
            "!type": "fn(object: +THREE.Object3D, size: number, color: +THREE.Color, linewidth: number)"
          },
          "GridHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/GridHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype"
            },
            "!doc": "The GridHelper is an object to define grids. Grids are two-dimensional arrays of lines.",
            "!type": "fn(size: number, step: number)"
          },
          "HemisphereLightHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/HemisphereLightHelper",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "lightSphere": {
                "!type": "+THREE.Mesh",
                "!doc": "The sphere mesh that shows the location of the hemispherelight."
              },
              "light": {
                "!type": "+THREE.HemisphereLight",
                "!doc": "Contains the HemisphereLight."
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the helper to match the position and direction of the [page:.light]."
              }
            },
            "!doc": "Creates a visual aid for a [page:HemisphereLight HemisphereLight].",
            "!type": "fn(light: +THREE.HemisphereLight, sphereSize: number)"
          },
          "PointLightHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/PointLightHelper",
            "prototype": {
              "!proto": "THREE.Mesh.prototype",
              "lightSphere": {
                "!type": "+THREE.Mesh",
                "!doc": "todo"
              },
              "light": {
                "!type": "+THREE.PointLight",
                "!doc": "todo"
              },
              "update": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "This display a helper for a pointLight",
            "!type": "fn(light: todo, sphereSize: todo)"
          },
          "SpotLightHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/SpotLightHelper",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "lightSphere": {
                "!type": "+THREE.Mesh",
                "!doc": "todo"
              },
              "light": {
                "!type": "+THREE.SpotLight",
                "!doc": "todo"
              },
              "lightCone": {
                "!type": "+THREE.Mesh",
                "!doc": "todo"
              },
              "update": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "todo",
            "!type": "fn(light: todo, sphereSize: todo)"
          },
          "VertexNormalsHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/VertexNormalsHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype",
              "object": {
                "!type": "+THREE.Object3D",
                "!doc": "The attached object"
              },
              "update": {
                "!type": "fn()",
                "!doc": "Updates the vertex normal preview based on movement of the object."
              }
            },
            "!doc": "Renders [page:ArrowHelper arrows] to visualize an object's vertex normal vectors. Requires that normals have been specified in a [page:BufferAttribute custom attribute] or have been calculated using [page:Geometry.computeVertexNormals computeVertexNormals].",
            "!type": "fn(object: +THREE.Object3D, size: number, color: +THREE.Color, linewidth: number)"
          },
          "WireframeHelper": {
            "!url": "http://threejs.org/docs/#Reference/extras/helpers/WireframeHelper",
            "prototype": {
              "!proto": "THREE.Line.prototype"
            },
            "!doc": "Creates a wireframe object that shows the edges of another object's geometry. To draw a  wireframe image showing only \"hard\" edges (edges between non-coplanar faces), see [page:EdgesHelper].",
            "!type": "fn(object: +THREE.Object3D, color: +THREE.Color)"
          },
          "AmbientLight": {
            "!url": "http://threejs.org/docs/#Reference/lights/AmbientLight",
            "prototype": {
              "!proto": "THREE.Light.prototype"
            },
            "!doc": "This light's color gets applied to all the objects in the scene globally.",
            "!type": "fn(hex: number)"
          },
          "DirectionalLight": {
            "!url": "http://threejs.org/docs/#Reference/lights/DirectionalLight",
            "prototype": {
              "!proto": "THREE.Light.prototype",
              "target": {
                "!type": "+THREE.Object3D",
                "!doc": "Target used for shadow camera orientation."
              },
              "intensity": {
                "!type": "number",
                "!doc": "Light's intensity.<br>\n\t\t\tDefault — *1.0*."
              }
            },
            "!doc": "Affects objects using [page:MeshLambertMaterial] or [page:MeshPhongMaterial].",
            "!type": "fn(hex: number, intensity: number)"
          },
          "HemisphereLight": {
            "!url": "http://threejs.org/docs/#Reference/lights/HemisphereLight",
            "prototype": {
              "!proto": "THREE.Light.prototype",
              "groundColor": {
                "!type": "number",
                "!doc": "Light's ground color.<br>"
              },
              "intensity": {
                "!type": "number",
                "!doc": "Light's intensity.<br>\n\t\t\tDefault — *1.0*."
              }
            },
            "!doc": "A light source positioned directly above the scene.",
            "!type": "fn(skyColorHex: number, groundColorHex: number, intensity: number)"
          },
          "Light": {
            "!url": "http://threejs.org/docs/#Reference/lights/Light",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Color of the light.<br>"
              }
            },
            "!doc": "Abstract base class for lights.",
            "!type": "fn(hex: number)"
          },
          "PointLight": {
            "!url": "http://threejs.org/docs/#Reference/lights/PointLight",
            "prototype": {
              "!proto": "THREE.Light.prototype",
              "intensity": {
                "!type": "number",
                "!doc": "Light's intensity.<br>\n\t\t\tDefault - *1.0*."
              },
              "distance": {
                "!type": "number",
                "!doc": "If non-zero, light will attenuate linearly from maximum intensity at light *position* down to zero at *distance*.<br>\n\t\t\tDefault — *0.0*."
              }
            },
            "!doc": "Affects objects using [page:MeshLambertMaterial] or [page:MeshPhongMaterial].",
            "!type": "fn(hex: number, intensity: number, distance: number)"
          },
          "SpotLight": {
            "!url": "http://threejs.org/docs/#Reference/lights/SpotLight",
            "prototype": {
              "!proto": "THREE.Light.prototype",
              "target": {
                "!type": "+THREE.Object3D",
                "!doc": "Spotlight focus points at target.position.<br>\n\t\t\tDefault position — *(0,0,0)*."
              },
              "intensity": {
                "!type": "number",
                "!doc": "Light's intensity.<br>\n\t\t\tDefault — *1.0*."
              },
              "distance": {
                "!type": "number",
                "!doc": "If non-zero, light will attenuate linearly from maximum intensity at light *position* down to zero at *distance*.<br>\n\t\t\tDefault — *0.0*."
              },
              "angle": {
                "!type": "number",
                "!doc": "Maximum extent of the spotlight, in radians, from its direction. Should be no more than *Math.PI/2*.<br>\n\t\t\tDefault — *Math.PI/3*."
              },
              "exponent": {
                "!type": "number",
                "!doc": "Rapidity of the falloff of light from its target direction.<br>\n\t\t\tDefault — *10.0*."
              }
            },
            "!doc": "A point light that can cast shadow in one direction.",
            "!type": "fn(hex: number, intensity: number, distance: todo, angle: todo, exponent: todo)"
          },
          "BabylonLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/BabylonLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(json: object) -> +THREE.Object3D",
                "!doc": "Parse a <em>JSON</em> structure and return an [page:Object3D object] or a [page:Scene scene].<br>\n\t\tFound objects are converted to [page:Mesh] with a [page:BufferGeometry] and a default [page:MeshPhongMaterial].<br>\n\t\tLights are parsed accordingly."
              }
            },
            "!doc": "A loader for loading a <em>.babylon</em> resource.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "BufferGeometryLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/BufferGeometryLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(json: object) -> +THREE.BufferGeometry",
                "!doc": "Parse a <em>JSON</em> structure and return a [page:BufferGeometry]."
              }
            },
            "!doc": "A loader for loading a [page:BufferGeometry].",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "Cache": {
            "!url": "http://threejs.org/docs/#Reference/loaders/Cache",
            "prototype": {
              "files": {
                "!type": "object",
                "!doc": "An [page:Object object] that hold cached values."
              },
              "add": {
                "!type": "fn(key: string, value)",
                "!doc": "Adds a cache entry with that key to hold the value. If this key already holds a value, it is overwritten."
              },
              "get": {
                "!type": "fn(key: string)",
                "!doc": "Get the value of key. If the key does not exist the null value is returned."
              },
              "remove": {
                "!type": "fn(key: string)",
                "!doc": "Remove the cached value associated with the key."
              },
              "clear": {
                "!type": "fn()",
                "!doc": "Remove all values from the cache."
              }
            },
            "!doc": "A simple caching classe, used internaly by [page:FileLoader].",
            "!type": "fn()"
          },
          "ColladaLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/ColladaLoader",
            "prototype": {
              "options": {
                "!type": "[]",
                "!doc": "&nbsp;.[page:Boolean centerGeometry] — Force [page:Geometry] to always be centered at the local origin of the containing [page: Mesh].<br>\n\t\t&nbsp;.[page:Boolean convertUpAxis] — Axis conversion is done for geometries, animations, and controllers.<br>\n\t\t&nbsp;.[page:Boolean subdivideFaces] — Force subdivision into multiple [page: Face3].<br>\n\t\t&nbsp;.[page:String upAxis] — X, Y or Z<br>\n\t\t&nbsp;.[page:Boolean defaultEnvMap] — Cubemap to use for reflective or refractive materials.<br>"
              },
              "geometries": {
                "!type": "object",
                "!doc": "Parsed <em>.dae</em> geometries."
              },
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(doc: Document, callBack: function, url: string) -> object",
                "!doc": "Parse an <em>XML Document</em> and return an [page:Object object] that contain loaded parts: .[page:Scene scene], .[page:Array morphs], .[page:Array skins], .[page:Array animations], .[page:Object dae]"
              },
              "setPreferredShading": {
                "!type": "fn(shading: number)",
                "!doc": "Set the .[page:Integer shading] property on the resource's materials.<br>\n\t\tOptions are [page:Materials THREE.SmoothShading], [page:Materials THREE.FlatShading]."
              },
              "applySkin": {
                "!type": "fn(geometry: +THREE.Geometry, instanceCtrl: object, frame: number)",
                "!doc": "Apply a skin (vertices, animation, bones) from a <em>collada skin controller</em>, on the given [page:Geometry]."
              }
            },
            "!doc": "A loader for <em>Collada</em> files.",
            "!type": "fn()"
          },
          "ImageLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/ImageLoader",
            "prototype": {
              "crossOrigin": {
                "!type": "string",
                "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              },
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and return the [page:Image image] object that will contain the data."
              },
              "setCrossOrigin": {
                "!type": "fn(value: string)",
                "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              }
            },
            "!doc": "A loader for loading an [page:Image].",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "Loader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/Loader",
            "prototype": {
              "onLoadStart": {
                "!type": "function",
                "!doc": "The default is a function with empty body."
              },
              "onLoadProgress": {
                "!type": "function",
                "!doc": "The default is a function with empty body."
              },
              "onLoadComplete": {
                "!type": "function",
                "!doc": "The default is a function with empty body."
              },
              "crossOrigin": {
                "!type": "string",
                "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              },
              "updateProgress": {
                "!type": "fn(progress: object)",
                "!doc": "Updates the DOM object with the progress made."
              },
              "createMaterial": {
                "!type": "fn(m: object, texturePath: string) -> +THREE.Material",
                "!doc": "Creates the Material based on the parameters m."
              },
              "initMaterials": {
                "!type": "fn(materials: [], texturePath: string) -> []",
                "!doc": "Creates an array of [page:Material] based on the array of parameters m. The index of the parameters decide the correct index of the materials."
              }
            },
            "!doc": "Base class for implementing loaders.",
            "!type": "fn()"
          },
          "LoadingManager": {
            "!url": "http://threejs.org/docs/#Reference/loaders/LoadingManager",
            "prototype": {
              "onLoad": {
                "!type": "function",
                "!doc": "The function that needs to be called when all loaders are done."
              },
              "onProgress": {
                "!type": "function",
                "!doc": "The function that needs to be called when an item is complete. The arguments are url(The url of the item just loaded),<br>\n\t\tloaded(the amount of items already loaded), total( The total amount of items to be loaded.)"
              },
              "onError": {
                "!type": "function",
                "!doc": "The function that needs to be called when an item errors."
              },
              "itemStart": {
                "!type": "fn(url: string)",
                "!doc": "This should be called by any loader used by the manager when the loader starts loading an url. These shouldn't be called outside a loader."
              },
              "itemEnd": {
                "!type": "fn(url: string)",
                "!doc": "This should be called by any loader used by the manager when the loader ended loading an url.  These shouldn't be called outside a loader."
              }
            },
            "!doc": "Handles and keeps track of loaded and pending data.",
            "!type": "fn(onLoad: function, onProgress: function, onError: function)"
          },
          "MTLLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/MTLLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and return the loaded material."
              },
              "parse": {
                "!type": "fn(text: string) -> MTLLoaderMaterialCreator",
                "!doc": "Parse a <em>mtl</em> text structure and return a [page:MTLLoaderMaterialCreator] instance.<br>"
              }
            },
            "!doc": "A loader for loading an <em>.mtl</em> resource, used internaly by [page:OBJLoader].",
            "!type": "fn(baseUrl: string, options: object, crossOrigin: string)"
          },
          "MaterialLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/MaterialLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and return the [page:Material] object that will contain the data."
              },
              "setCrossOrigin": {
                "!type": "fn(value: string)",
                "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              },
              "parse": {
                "!type": "fn(json: object) -> +THREE.Material",
                "!doc": "Parse a <em>JSON</em> structure and create a new [page:Material] of the type [page:String json.type] with parameters defined in the json object."
              }
            },
            "!doc": "A loader for loading a [page:Material] in JSON format.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "OBJLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/OBJLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(text: string) -> +THREE.Object3D",
                "!doc": "Parse an <em>obj</em> text structure and return an [page:Object3D].<br>\n\t\tFound objects are converted to [page:Mesh] with a [page:BufferGeometry] and a default [page:MeshLambertMaterial]."
              }
            },
            "!doc": "A loader for loading an <em>.obj</em> resource.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "OBJMTLLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/OBJMTLLoader",
            "prototype": {
              "load": {
                "!type": "fn(objUrl: string, mtlUrl: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from urls and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(text: string, mtllibCallback: function) -> +THREE.Object3D",
                "!doc": "Parse an <em>obj</em> text structure and return an [page:Object3D].<br>\n\t\tFound objects are converted to a [page:Mesh] and materials are converted to [page:MeshLambertMaterial]."
              }
            },
            "!doc": "A loader for loading a <em>.obj</em> and its <em>.mtl</em> together.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "ObjectLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/ObjectLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parse": {
                "!type": "fn(json: object) -> +THREE.Object3D",
                "!doc": "Parse a <em>JSON</em> content and return a threejs object."
              },
              "setCrossOrigin": {
                "!type": "fn(value: string)",
                "!doc": "[page:String value] — The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              }
            },
            "!doc": "A loader for loading a JSON resource.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "PDBLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/PDBLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the parsed response content."
              },
              "parsePDB": {
                "!type": "fn(text: string) -> object",
                "!doc": "Parse a <em>pdb</em> text and return a <em>JSON</em> structure.<br>"
              },
              "createModel": {
                "!type": "fn(json: object, callback: function)",
                "!doc": "Parse a <em>(JSON) pdb</em> structure and return two [page:Geometry]: one for atoms, one for bonds.<br>"
              }
            },
            "!doc": "A loader for loading a <em>.pdb</em> resource.\n\t\t<br><br>\n\t\tThe <a href=\"http://en.wikipedia.org/wiki/Protein_Data_Bank_(file_format)\">Protein Data Bank file format</a> is a textual file format describing the three-dimensional structures of molecules.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "SVGLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/SVGLoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and call onLoad with the response content."
              }
            },
            "!doc": "A loader for loading an <em>.svg</em> resource.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "TGALoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/TGALoader",
            "prototype": {
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function) -> +THREE.DataTexture",
                "!doc": "Begin loading from url and pass the loaded [page:DataTexture texture] to onLoad. The [page:DataTexture texture] is also directly returned for immediate use (but may not be fully loaded)."
              }
            },
            "!doc": "Class for loading a <em>.tga</em> [page:DataTexture texture].",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "TextureLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/TextureLoader",
            "prototype": {
              "crossOrigin": {
                "!type": "string",
                "!doc": "default — *null*.<br>\n\t\tIf set, assigns the *crossOrigin* attribute of the image to the value of *crossOrigin*, prior to starting the load."
              },
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and pass the loaded [page:Texture texture] to onLoad."
              }
            },
            "!doc": "Class for loading a [page:Texture texture].",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "FileLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/FileLoader",
            "prototype": {
              "cache": {
                "!type": "+THREE.Cache",
                "!doc": "A [page:Cache cache] instance that hold the response from each request made through this loader, so each file is requested once."
              },
              "crossOrigin": {
                "!type": "string",
                "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              },
              "responseType": {
                "!type": "string",
                "!doc": "Can be set to change the response type."
              },
              "load": {
                "!type": "fn(url: string, onLoad: function, onProgress: function, onError: function)",
                "!doc": "Begin loading from url and return the [page:String text] response that will contain the data."
              },
              "setCrossOrigin": {
                "!type": "fn(value: string)",
                "!doc": "[page:String value] — The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
              },
              "setResponseType": {
                "!type": "fn(value: string)",
                "!doc": "[page:String value] — the empty string (default), \"arraybuffer\", \"blob\", \"document\", \"json\", or \"text\"."
              }
            },
            "!doc": "A low level class for loading resources with XMLHttpRequest, used internaly by most loaders.",
            "!type": "fn(manager: +THREE.LoadingManager)"
          },
          "GLTFLoader": {
            "!url": "http://threejs.org/docs/#Reference/loaders/GLTFLoader",
            "prototype": {
              "!proto": "THREE.Loader.prototype",
              "load": {
                "!type": "fn(url: string, callback: function) -> +THREE.Object3D",
                "!doc": "Begin loading from url and call the callback function with the parsed response content."
              }
            },
            "!doc": "A loader for loading a <em>.gltf</em> resource in <em>JSON</em> format.\n\t\t<br><br>\n\t\tThe <a href=\"https://www.khronos.org/gltf\">glTF file format</a> is a JSON file format to enable rapid delivery and loading of 3D content.",
            "!type": "fn()"
          },
          "LineBasicMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/LineBasicMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "number",
                "!doc": "Sets the color of the line. Default is 0xffffff."
              },
              "linewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "linecap": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "linejoin": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "vertexColors": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "fog": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              }
            },
            "!doc": "A material for drawing wireframe-style geometries.",
            "!type": "fn(parameters: object)"
          },
          "LineDashedMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/LineDashedMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Sets the color of the line. Default is 0xffffff."
              },
              "linewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "scale": {
                "!type": "number",
                "!doc": "The scale of the dashed part of a line."
              },
              "dashSize": {
                "!type": "number",
                "!doc": "The size of the dash. This is both the gap with the stroke. Default is 3."
              },
              "gapSize": {
                "!type": "number",
                "!doc": "The size of the gap. Default is 1."
              },
              "vertexColors": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "fog": {
                "!type": "boolean",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              }
            },
            "!doc": "A material for drawing wireframe-style geometries with dashed lines.",
            "!type": "fn(parameters: object)"
          },
          "Material": {
            "!url": "http://threejs.org/docs/#Reference/materials/Material",
            "prototype": {
              "id": {
                "!type": "number",
                "!doc": "Unique number for this material instance."
              },
              "name": {
                "!type": "string",
                "!doc": "Material name. Default is an empty string."
              },
              "opacity": {
                "!type": "number",
                "!doc": "Default is *1.0*."
              },
              "transparent": {
                "!type": "bool",
                "!doc": "Default is *false*."
              },
              "blendDst": {
                "!type": "number",
                "!doc": "Blending destination. It's one of the blending mode constants defined in [page:Three Three.js]. Default is [page:CustomBlendingEquation OneMinusSrcAlphaFactor]."
              },
              "blendEquation": {
                "!type": "number",
                "!doc": "Blending equation to use when applying blending. It's one of the constants defined in [page:Three Three.js]. Default is [page:CustomBlendingEquation AddEquation.]"
              },
              "depthTest": {
                "!type": "bool",
                "!doc": "Whether to have depth test enabled when rendering this material. Default is *true*."
              },
              "depthWrite": {
                "!type": "bool",
                "!doc": "When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
              },
              "polygonOffset": {
                "!type": "bool",
                "!doc": "Whether to use polygon offset. Default is *false*. This corresponds to the *POLYGON_OFFSET_FILL* WebGL feature."
              },
              "polygonOffsetFactor": {
                "!type": "number",
                "!doc": "Sets the polygon offset factor. Default is *0*."
              },
              "polygonOffsetUnits": {
                "!type": "number",
                "!doc": "Sets the polygon offset units. Default is *0*."
              },
              "alphaTest": {
                "!type": "number",
                "!doc": "Sets the alpha value to be used when running an alpha test. Default is *0*."
              },
              "overdraw": {
                "!type": "number",
                "!doc": "Amount of triangle expansion at draw time. This is a workaround for cases when gaps appear between triangles when using [page:CanvasRenderer]. *0.5* tends to give good results across browsers. Default is *0*."
              },
              "visible": {
                "!type": "bool",
                "!doc": "Defines whether this material is visible. Default is *true*."
              },
              "side": {
                "!type": "Enum",
                "!doc": "Default is [page:Materials THREE.FrontSide]. Other options are [page:Materials THREE.BackSide] and [page:Materials THREE.DoubleSide]."
              },
              "needsUpdate": {
                "!type": "bool",
                "!doc": "This property is automatically set to *true* when instancing a new material."
              },
              "clone": {
                "!type": "fn(material: material) -> +THREE.Material",
                "!doc": "This clones the material in the optional parameter and returns it."
              },
              "dispose": {
                "!type": "fn()",
                "!doc": "This disposes the material."
              },
              "setValues": {
                "!type": "fn(values: object)",
                "!doc": "Sets the properties based on the *values*."
              }
            },
            "!doc": "Materials describe the appearance of [page:Object objects]. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.",
            "!type": "fn()"
          },
          "MeshBasicMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MeshBasicMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "number",
                "!doc": "Sets the color of the geometry. Default is 0xffffff."
              },
              "lightMap": {
                "!type": "+THREE.Texture",
                "!doc": "Set light map. Default is null."
              },
              "specularMap": {
                "!type": "+THREE.Texture",
                "!doc": "Set specular map. Default is null."
              },
              "alphaMap": {
                "!type": "+THREE.Texture",
                "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
              },
              "envMap": {
                "!type": "TextureCube",
                "!doc": "Set env map. Default is null."
              },
              "fog": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              },
              "shading": {
                "!type": "string",
                "!doc": "Define shading type. Default is THREE.SmoothShading."
              },
              "wireframe": {
                "!type": "bool",
                "!doc": "Render geometry as wireframe. Default is false (i.e. render as flat polygons)."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "wireframeLinecap": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "wireframeLinejoin": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "vertexColors": {
                "!type": "boolean",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "morphTargets": {
                "!type": "bool",
                "!doc": "Define whether the material uses morphTargets. Default is false."
              },
              "map": {
                "!type": "+THREE.Texture",
                "!doc": "Sets the texture map. Default is  null."
              },
              "combine": {
                "!type": "number",
                "!doc": "How to combine the result of the surface's color with the environment map, if any."
              },
              "reflectivity": {
                "!type": "number",
                "!doc": "How much the environment map affects the surface; also see \"combine\"."
              },
              "refractionRatio": {
                "!type": "number",
                "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
              }
            },
            "!doc": "A material for drawing geometries in a simple shaded (flat or wireframe) way.",
            "!type": "fn(parameters: object)"
          },
          "MeshDepthMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MeshDepthMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "morphTargets": {
                "!type": "boolean",
                "!doc": "Define whether the material uses morphTargets. Default is false."
              },
              "wireframe": {
                "!type": "boolean",
                "!doc": "Render geometry as wireframe. Default is false (i.e. render as smooth shaded)."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Controls wireframe thickness. Default is 1.<br><br>\n\t\t\tDue to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value."
              }
            },
            "!doc": "A material for drawing geometry by depth. Depth is based off of the camera near and far plane. White is nearest, black is farthest.",
            "!type": "fn(parameters: object)"
          },
          "MultiMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MultiMaterial",
            "prototype": {
              "materials": {
                "!type": "[]",
                "!doc": "Get or set the materials for the geometry."
              }
            },
            "!doc": "A Material to define multiple materials for the same geometry. \n\t\tThe geometry decides which material is used for which faces by the [page:Face3 faces materialindex].\n\t\tThe materialindex corresponds with the index of the material in the materials array.",
            "!type": "fn(materials: [])"
          },
          "MeshLambertMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MeshLambertMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Diffuse color of the material. Default is white.<br>"
              },
              "emissive": {
                "!type": "+THREE.Color",
                "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting. Default is black.<br>"
              },
              "wrapAround": {
                "!type": "boolean",
                "!doc": "Define whether the diffuse lighting wraps around the model or not. This option adds a little more (tintable) light\n\t\t\tonto the side of the object in relation to a light."
              },
              "wrapRGB": {
                "!type": "+THREE.Vector3",
                "!doc": "Decide how much of the wrap around values get used if the wrapAround option is set. The x, y, z values correspond\n\t\t\tto the r, g, b values respectively. The typical range is of each is from 0 to 1. For example setting all of the\n\t\t\tvector values to 0.5 will add a moderate amount of light to the side of the model. Changing *b* to 1 will\n\t\t\ttint the light on the side to be more blue. Defaults to *(1,1,1)*."
              },
              "map": {
                "!type": "+THREE.Texture",
                "!doc": "Set color texture map. Default is null."
              },
              "lightMap": {
                "!type": "+THREE.Texture",
                "!doc": "Set light map. Default is null."
              },
              "specularMap": {
                "!type": "+THREE.Texture",
                "!doc": "Since this material does not have a specular component, the specular value affects only how much of the environment map affects the surface. Default is null."
              },
              "alphaMap": {
                "!type": "+THREE.Texture",
                "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
              },
              "envMap": {
                "!type": "TextureCube",
                "!doc": "Set env map. Default is null."
              },
              "combine": {
                "!type": "number",
                "!doc": "Options are [page:Textures THREE.Multiply] (default), [page:Textures THREE.MixOperation], [page:Textures THREE.AddOperation]. If mix is chosen, the reflectivity is used to blend between the two colors."
              },
              "reflectivity": {
                "!type": "number",
                "!doc": "How much the environment map affects the surface; also see \"combine\"."
              },
              "refractionRatio": {
                "!type": "number",
                "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
              },
              "fog": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              },
              "shading": {
                "!type": "number",
                "!doc": "Options are [page:Materials THREE.SmoothShading] (default), [page:Materials THREE.FlatShading]."
              },
              "wireframe": {
                "!type": "bool",
                "!doc": "Whether the triangles' edges are displayed instead of surfaces. Default is *false*."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "wireframeLinecap": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "wireframeLinejoin": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "vertexColors": {
                "!type": "boolean",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "morphTargets": {
                "!type": "bool",
                "!doc": "Define whether the material uses morphTargets. Default is *false*."
              },
              "morphNormals": {
                "!type": "boolean",
                "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
              }
            },
            "!doc": "A material for non-shiny (Lambertian) surfaces, evaluated per vertex.",
            "!type": "fn(parameters: object)"
          },
          "MeshNormalMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MeshNormalMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "wireframe": {
                "!type": "boolean",
                "!doc": "Render geometry as wireframe. Default is false (i.e. render as smooth shaded)."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Controls wireframe thickness. Default is 1.<br><br>\n\t\t\tDue to limitations in the ANGLE layer, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "morphTargets": {
                "!type": "boolean",
                "!doc": "Define whether the material uses morphTargets. Default is false."
              }
            },
            "!doc": "A material that maps the normal vectors to RGB colors.",
            "!type": "fn(parameters: object)"
          },
          "MeshPhongMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/MeshPhongMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Diffuse color of the material. Default is white.<br>"
              },
              "emissive": {
                "!type": "+THREE.Color",
                "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting. Default is black.<br>"
              },
              "specular": {
                "!type": "+THREE.Color",
                "!doc": "Specular color of the material, i.e., how shiny the material is and the color of its shine. Setting this the same color as the diffuse value (times some intensity) makes the material more metallic-looking; setting this to some gray makes the material look more plastic. Default is dark gray.<br>"
              },
              "shininess": {
                "!type": "number",
                "!doc": "How shiny the specular highlight is; a higher value gives a sharper highlight. Default is *30*. It should not be set to 0."
              },
              "metal": {
                "!type": "boolean",
                "!doc": "If set to true the shader multiplies the specular highlight by the underlying color of the object, making\n\t\t\tit appear to be more metal-like and darker. If set to false the specular highlight is added ontop of the\n\t\t\tunderlying colors."
              },
              "wrapAround": {
                "!type": "boolean",
                "!doc": "Define whether the diffuse lighting wraps around the model or not. This option adds a little more (tintable) light\n\t\t\tonto the side of the object in relation to a light."
              },
              "wrapRGB": {
                "!type": "+THREE.Vector3",
                "!doc": "Decide how much of the wrap around values get used if the wrapAround option is set. The x, y, z values correspond\n\t\t\tto the r, g, b values respectively. The typical range is of each is from 0 to 1. For example setting all of the\n\t\t\tvector values to 0.5 will add a moderate amount of light to the side of the model. Changing *b* to 1 will\n\t\t\ttint the light on the side to be more blue. Defaults to (1,1,1)."
              },
              "map": {
                "!type": "+THREE.Texture",
                "!doc": "Set color texture map. Default is null."
              },
              "lightMap": {
                "!type": "+THREE.Texture",
                "!doc": "Set light map. Default is null."
              },
              "bumpMap": {
                "!type": "+THREE.Texture",
                "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights.\n\t\t\tBump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will\n\t\t\tbe ignored."
              },
              "bumpScale": {
                "!type": "number",
                "!doc": "How much the bump map affects the material. Typical ranges are 0-1. Default is 1."
              },
              "normalMap": {
                "!type": "+THREE.Texture",
                "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change\n\t\t\tthe way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting."
              },
              "normalScale": {
                "!type": "+THREE.Vector2",
                "!doc": "How much the normal map affects the material. Typical ranges are 0-1. Default is (1,1)."
              },
              "specularMap": {
                "!type": "+THREE.Texture",
                "!doc": "The specular map value affects both how much the specular surface highlight contributes and how much of the environment map affects the surface. Default is null."
              },
              "alphaMap": {
                "!type": "+THREE.Texture",
                "!doc": "Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the [page:WebGLRenderer WebGL] renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
              },
              "envMap": {
                "!type": "TextureCube",
                "!doc": "Set env map. Default is null."
              },
              "combine": {
                "!type": "number",
                "!doc": "Options are [page:Textures THREE.MultiplyOperation] (default), [page:Textures THREE.MixOperation], [page:Textures THREE.AddOperation]. If mix is chosen, the reflectivity is used to blend between the two colors."
              },
              "reflectivity": {
                "!type": "number",
                "!doc": "How much the environment map affects the surface; also see \"combine\"."
              },
              "refractionRatio": {
                "!type": "number",
                "!doc": "The index of refraction for an environment map using [page:Textures THREE.CubeRefractionMapping]. Default is *0.98*."
              },
              "fog": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              },
              "shading": {
                "!type": "number",
                "!doc": "Options are [page:Materials THREE.SmoothShading] (default), [page:Materials THREE.FlatShading]."
              },
              "wireframe": {
                "!type": "bool",
                "!doc": "Whether the triangles' edges are displayed instead of surfaces. Default is *false*."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "wireframeLinecap": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "wireframeLinejoin": {
                "!type": "string",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:WebGLRenderer WebGL] renderer, but does work with the [page:CanvasRenderer Canvas] renderer."
              },
              "vertexColors": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "morphTargets": {
                "!type": "bool",
                "!doc": "Define whether the material uses morphTargets. Default is *false*."
              },
              "morphNormals": {
                "!type": "boolean",
                "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
              }
            },
            "!doc": "A material for shiny surfaces, evaluated per pixel.",
            "!type": "fn(parameters: object)"
          },
          "PointCloudMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/PointCloudMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "number",
                "!doc": "Sets the color of the particles. Default is 0xffffff."
              },
              "map": {
                "!type": "+THREE.Texture",
                "!doc": "Sets the color of the particles using data from a texture."
              },
              "size": {
                "!type": "number",
                "!doc": "Sets the size of the particles. Default is 1.0."
              },
              "sizeAttenuation": {
                "!type": "bool",
                "!doc": "Specify whether particles' size will get smaller with the distance. Default is true."
              },
              "vertexColors": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers."
              },
              "fog": {
                "!type": "bool",
                "!doc": "This setting might not have any effect when used with certain renderers. For example, it is ignored with the [page:CanvasRenderer Canvas] renderer, but does work with the [page:WebGLRenderer WebGL] renderer."
              }
            },
            "!doc": "The default material used by [page:PointCloud particle] systems.",
            "!type": "fn(parameters: object)"
          },
          "RawShaderMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/RawShaderMaterial",
            "prototype": {
              "!proto": "THREE.ShaderMaterial.prototype"
            },
            "!doc": "This class works just like [page:ShaderMaterial], except that definitions of built-in uniforms and attributes are not automatically prepended to the GLSL shader code."
          },
          "ShaderMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/ShaderMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "uniforms": {
                "!type": "object",
                "!doc": "Object specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form\n\t\t<code>\n\t\t{ type: 'f', value: 1.0 }\n\t\t</code>\n\t\twhere *type* is a <a href=\"#uniform-types\">uniform type string</a>, and *value* is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code."
              },
              "attributes": {
                "!type": "object",
                "!doc": "<p>\n\t\tObject specifying the custom attributes to be passed to the shader code; keys are attribute names, values are definitions of the form\n\t\t<code>\n\t\t{ type: 'f', value: [1.0, 0.5, 2.0, ...] }\n\t\t</code>\n\t\twhere *type* is an <a href=\"#attribute-types\">attribute type string</a>, and *value* is an array containing an attribute value for each vertex in the geometry (or *undefined* if using [page:BufferGeometry]). Names must match the name of the attribute, as defined in the GLSL code.\n\t\t</p>\n\t\t<p>\n\t\tNote that attribute buffers are <emph>not</emph> refreshed automatically when their values change; if using [page:Geometry], set <code>needsUpdate = true</code> on the attribute definition. If using [page:BufferGeometry], set <code>needsUpdate = true</code> on the [page:BufferAttribute].\n\t\t</p>"
              },
              "defines": {
                "!type": "object",
                "!doc": "Defines custom constants using *#define* directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive:\n\t\t<code>\n\t\tdefines: {\n\t\t\tFOO: 15,\n\t\t\tBAR: true\n\t\t}\n\t\t</code>\n\t\tyields the lines\n\t\t<code>\n\t\t#define FOO 15\n\t\t#define BAR true\n\t\t</code>\n\t\tin the GLSL code."
              },
              "vertexShader": {
                "!type": "string",
                "!doc": "Vertex shader GLSL code.  This is the actual code for the shader. In the example above, the *vertexShader* and *fragmentShader* code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead."
              },
              "fragmentShader": {
                "!type": "string",
                "!doc": "Fragment shader GLSL code.  This is the actual code for the shader. In the example above, the *vertexShader* and *fragmentShader* code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead."
              },
              "shading": {
                "!type": "number",
                "!doc": "Define shading type, which determines whether normals are smoothed between vertices; possible values are [page:Materials THREE.SmoothShading] or [page:Materials THREE.FlatShading]. Default is THREE.SmoothShading."
              },
              "linewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "wireframe": {
                "!type": "bool",
                "!doc": "Render geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false (i.e. render as flat polygons)."
              },
              "wireframeLinewidth": {
                "!type": "number",
                "!doc": "Due to limitations in the <a href=\"https://code.google.com/p/angleproject/\" target=\"_blank\">ANGLE layer</a>, on Windows platforms linewidth will always be 1 regardless of the set value."
              },
              "fog": {
                "!type": "bool",
                "!doc": "Define whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Default is false."
              },
              "lights": {
                "!type": "bool",
                "!doc": "Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader"
              },
              "vertexColors": {
                "!type": "bool",
                "!doc": "Define how the vertices are colored, by defining how the *colors* attribute gets populated. Default is false."
              },
              "morphTargets": {
                "!type": "bool",
                "!doc": "Defines whether the material uses morphTargets; true morphTarget attributes to this shader"
              },
              "morphNormals": {
                "!type": "boolean",
                "!doc": "Defines whether the material uses morphNormals. Set as true to pass morphNormal attributes from the [page:Geometry]\n\t\t\tto the shader. Default is *false*."
              },
              "program": {
                "!type": "+THREE.WebGLProgram",
                "!doc": "The compiled shader program associated with this material, generated by [page:WebGLRenderer]. You should not need to access this property."
              },
              "clone": {
                "!type": "fn() -> +THREE.ShaderMaterial",
                "!doc": "Generates a shallow copy of this material. Note that the vertexShader and fragmentShader are copied <emph>by reference</emph>, as are the definitions of the *attributes*; this means that clones of the material will share the same compiled [page:WebGLProgram]. However, the *uniforms* are copied <emph>by value</emph>, which allows you to have different sets of uniforms for different copies of the material."
              }
            },
            "!doc": "Material rendered with custom shaders. A shader is a small program written in [link:https://www.opengl.org/documentation/glsl/ GLSL] to run on the GPU. You may want to use a custom shader if you need to:\n\t\t<ul>\n\t\t\t<li>implement an effect not included with any of the built-in [page:Material materials]</li>\n\t\t\t<li>combine many objects into a single [page:Geometry] or [page:BufferGeometry] in order to improve performance</li>\n\t\t\t<li>associate custom data with individual vertices (\"custom attributes\")</li>\n\t\t</ul>\n\t\tNote that a ShaderMaterial will only be rendered properly by [page:WebGLRenderer], since the GLSL code in the vertexShader and fragmentShader properties must be compiled and run on the GPU using WebGL.",
            "!type": "fn(parameters: object)"
          },
          "SpriteCanvasMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/SpriteCanvasMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "The color of the sprite. The material will set up the color for the context before calling the material's program."
              },
              "program": {
                "!type": "fn(context: CanvasRenderingContext2D, color: +THREE.Color)",
                "!doc": "Define a program that will use the context to draw the sprite."
              }
            },
            "!doc": "Create a material that can draw custom sprites using a 2d canvas.",
            "!type": "fn(parameters: object)"
          },
          "SpriteMaterial": {
            "!url": "http://threejs.org/docs/#Reference/materials/SpriteMaterial",
            "prototype": {
              "!proto": "THREE.Material.prototype",
              "color": {
                "!type": "+THREE.Color",
                "!doc": "The texture is multiplied by this color. The default is 0xffffff"
              },
              "map": {
                "!type": "+THREE.Texture",
                "!doc": "The texture map. Default is null."
              },
              "rotation": {
                "!type": "Radians",
                "!doc": "The rotation of the sprite in radians. Default is 0."
              },
              "fog": {
                "!type": "boolean",
                "!doc": "Whether or not this material affected by the scene's fog. Default is false"
              }
            },
            "!doc": "A material for a [page:Sprite].",
            "!type": "fn(parameters: object)"
          },
          "Box2": {
            "!url": "http://threejs.org/docs/#Reference/math/Box2",
            "prototype": {
              "min": {
                "!type": "+THREE.Vector2",
                "!doc": "Lower (x, y) boundary of this box."
              },
              "max": {
                "!type": "+THREE.Vector2",
                "!doc": "Upper (x, y) boundary of this box."
              },
              "set": {
                "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Box2",
                "!doc": "Sets the lower and upper (x, y) boundaries of this box."
              },
              "expandByPoint": {
                "!type": "fn(point: +THREE.Vector2) -> +THREE.Box2",
                "!doc": "Expands the boundaries of this box to include *point*."
              },
              "clampPoint": {
                "!type": "fn(point: +THREE.Vector2, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Clamps *point* within the bounds of this box."
              },
              "isIntersectionBox": {
                "!type": "fn(box: +THREE.Box2) -> bool",
                "!doc": "Determines whether or not this box intersects *box*."
              },
              "setFromPoints": {
                "!type": "fn(points: []) -> +THREE.Box2",
                "!doc": "Sets the upper and lower bounds of this box to include all of the points in *points*."
              },
              "size": {
                "!type": "fn(optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Returns the width and height of this box."
              },
              "union": {
                "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
                "!doc": "Unions this box with *box* setting the upper bound of this box to the greater of the \n\t\ttwo boxes' upper bounds and the lower bound of this box to the lesser of the two boxes'\n\t\tlower bounds."
              },
              "getParameter": {
                "!type": "fn(point: +THREE.Vector2, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Returns a point as a proportion of this box's width and height."
              },
              "expandByScalar": {
                "!type": "fn(scalar: float) -> +THREE.Box2",
                "!doc": "Expands each dimension of the box by *scalar*. If negative, the dimensions of the box <br>\n\t\twill be contracted."
              },
              "intersect": {
                "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
                "!doc": "Returns the intersection of this and *box*, setting the upper bound of this box to the lesser <br>\n\t\tof the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' <br>\n\t\tlower bounds."
              },
              "containsBox": {
                "!type": "fn(box: +THREE.Box2) -> bool",
                "!doc": "Returns true if this box includes the entirety of *box*. If this and *box* overlap exactly,<br>\n\t\tthis function also returns true."
              },
              "translate": {
                "!type": "fn(offset: +THREE.Vector2) -> +THREE.Box2",
                "!doc": "Adds *offset* to both the upper and lower bounds of this box, effectively moving this box <br>\n\t\t*offset* units in 2D space."
              },
              "empty": {
                "!type": "fn() -> bool",
                "!doc": "Returns true if this box includes zero points within its bounds.<br>\n\t\tNote that a box with equal lower and upper bounds still includes one point, the\n\t\tone both bounds share."
              },
              "clone": {
                "!type": "fn() -> +THREE.Box2",
                "!doc": "Returns a copy of this box."
              },
              "equals": {
                "!type": "fn(box: +THREE.Box2) -> bool",
                "!doc": "Returns true if this box and *box* share the same lower and upper bounds."
              },
              "expandByVector": {
                "!type": "fn(vector: +THREE.Vector2) -> +THREE.Box2",
                "!doc": "Expands this box equilaterally by *vector*. The width of this box will be\n\t\texpanded by the x component of *vector* in both directions. The height of \n\t\tthis box will be expanded by the y component of *vector* in both directions."
              },
              "copy": {
                "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
                "!doc": "Copies the values of *box* to this box."
              },
              "makeEmpty": {
                "!type": "fn() -> +THREE.Box2",
                "!doc": "Makes this box empty."
              },
              "center": {
                "!type": "fn(optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Returns the center point of this box."
              },
              "distanceToPoint": {
                "!type": "fn(point: +THREE.Vector2) -> number",
                "!doc": "Returns the distance from any edge of this box to the specified point. <br>\n\t\tIf the point lies inside of this box, the distance will be 0."
              },
              "containsPoint": {
                "!type": "fn(point: +THREE.Vector2) -> bool",
                "!doc": "Returns true if the specified point lies within the boundaries of this box."
              },
              "setFromCenterAndSize": {
                "!type": "fn(center: +THREE.Vector2, size: +THREE.Vector2) -> +THREE.Box2",
                "!doc": "Centers this box on *center* and sets this box's width and height to the values specified\n\t\tin *size*."
              }
            },
            "!doc": "Represents a boundary box in 2D space.",
            "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2)"
          },
          "Box3": {
            "!url": "http://threejs.org/docs/#Reference/math/Box3",
            "prototype": {
              "min": {
                "!type": "+THREE.Vector3",
                "!doc": "Lower (x, y, z) boundary of this box."
              },
              "max": {
                "!type": "+THREE.Vector3",
                "!doc": "Upper (x, y, z) boundary of this box."
              },
              "set": {
                "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Box3",
                "!doc": "Sets the lower and upper (x, y, z) boundaries of this box."
              },
              "applyMatrix4": {
                "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Box3",
                "!doc": "Transforms this Box3 with the supplied matrix."
              },
              "clampPoint": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Clamps *point* within the bounds of this box."
              },
              "isIntersectionBox": {
                "!type": "fn(box: +THREE.Box3) -> bool",
                "!doc": "Determines whether or not this box intersects *box*."
              },
              "setFromPoints": {
                "!type": "fn(points: []) -> +THREE.Box3",
                "!doc": "Sets the upper and lower bounds of this box to include all of the points in *points*."
              },
              "setFromObject": {
                "!type": "fn(object: +THREE.Object3D) -> +THREE.Box3",
                "!doc": "Computes the world-axis-aligned bounding box of an object (including its children),\n\t\taccounting for both the object's, and childrens', world transforms"
              },
              "size": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns the width, height, and depth of this box."
              },
              "union": {
                "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
                "!doc": "Unions this box with *box* setting the upper bound of this box to the greater of the \n\t\ttwo boxes' upper bounds and the lower bound of this box to the lesser of the two boxes'\n\t\tlower bounds."
              },
              "getParameter": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns point as a proportion of this box's width and height."
              },
              "intersect": {
                "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
                "!doc": "Returns the intersection of this and *box*, setting the upper bound of this box to the lesser <br>\n\t\tof the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' <br>\n\t\tlower bounds."
              },
              "containsBox": {
                "!type": "fn(box: +THREE.Box3) -> bool",
                "!doc": "Returns true if this box includes the entirety of *box*. If this and *box* overlap exactly,<br>\n\t\tthis function also returns true."
              },
              "containsPoint": {
                "!type": "fn(point: +THREE.Vector3) -> bool",
                "!doc": "Returns true if the specified point lies within the boundaries of this box."
              },
              "translate": {
                "!type": "fn(offset: +THREE.Vector3) -> +THREE.Box3",
                "!doc": "Adds *offset* to both the upper and lower bounds of this box, effectively moving this box <br>\n\t\t*offset* units in 3D space."
              },
              "empty": {
                "!type": "fn() -> bool",
                "!doc": "Returns true if this box includes zero points within its bounds.<br>\n\t\tNote that a box with equal lower and upper bounds still includes one point, the\n\t\tone both bounds share."
              },
              "clone": {
                "!type": "fn() -> +THREE.Box3",
                "!doc": "Returns a copy of this box."
              },
              "equals": {
                "!type": "fn(box: +THREE.Box3) -> bool",
                "!doc": "Returns true if this box and *box* share the same lower and upper bounds."
              },
              "expandByPoint": {
                "!type": "fn(point: +THREE.Vector3) -> +THREE.Box3",
                "!doc": "Expands the boundaries of this box to include *point*."
              },
              "expandByScalar": {
                "!type": "fn(scalar: float) -> +THREE.Box3",
                "!doc": "Expands each dimension of the box by *scalar*. If negative, the dimensions of the box <br>\n\t\twill be contracted."
              },
              "expandByVector": {
                "!type": "fn(vector: +THREE.Vector3) -> +THREE.Box3",
                "!doc": "Expands this box equilaterally by *vector*. The width of this box will be\n\t\texpanded by the x component of *vector* in both directions. The height of \n\t\tthis box will be expanded by the y component of *vector* in both directions.\n\t\tThe depth of this box will be expanded by the z component of *vector* in\n\t\tboth directions."
              },
              "copy": {
                "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
                "!doc": "Copies the values of *box* to this box."
              },
              "makeEmpty": {
                "!type": "fn() -> +THREE.Box3",
                "!doc": "Makes this box empty."
              },
              "center": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns the center point of this box."
              },
              "getBoundingSphere": {
                "!type": "fn(optionalTarget: +THREE.Sphere) -> +THREE.Sphere",
                "!doc": "Gets a sphere that bounds the box."
              },
              "distanceToPoint": {
                "!type": "fn(point: +THREE.Vector3) -> number",
                "!doc": "Returns the distance from any edge of this box to the specified point. <br>\n\t\tIf the point lies inside of this box, the distance will be 0."
              },
              "setFromCenterAndSize": {
                "!type": "fn(center: +THREE.Vector3, size: +THREE.Vector3) -> +THREE.Box3",
                "!doc": "Centers this box on *center* and sets this box's width and height to the values specified\n\t\tin *size*."
              }
            },
            "!doc": "Represents a boundary box in 3d space.",
            "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3)"
          },
          "Color": {
            "!url": "http://threejs.org/docs/#Reference/math/Color",
            "prototype": {
              "r": {
                "!type": "number",
                "!doc": "Red channel value between 0 and 1. Default is 1."
              },
              "g": {
                "!type": "number",
                "!doc": "Green channel value between 0 and 1. Default is 1."
              },
              "b": {
                "!type": "number",
                "!doc": "Blue channel value between 0 and 1. Default is 1."
              },
              "copy": {
                "!type": "fn(color: +THREE.Color) -> +THREE.Color",
                "!doc": "Copies given color."
              },
              "copyGammaToLinear": {
                "!type": "fn(color: +THREE.Color) -> +THREE.Color",
                "!doc": "Copies given color making conversion from gamma to linear space."
              },
              "copyLinearToGamma": {
                "!type": "fn(color: +THREE.Color) -> +THREE.Color",
                "!doc": "Copies given color making conversion from linear to gamma space."
              },
              "convertGammaToLinear": {
                "!type": "fn() -> +THREE.Color",
                "!doc": "Converts this color from gamma to linear space."
              },
              "convertLinearToGamma": {
                "!type": "fn() -> +THREE.Color",
                "!doc": "Converts this color from linear to gamma space."
              },
              "setRGB": {
                "!type": "fn(r: number, g: number, b: number) -> +THREE.Color",
                "!doc": "Sets this color from RGB values."
              },
              "getHex": {
                "!type": "fn() -> number",
                "!doc": "Returns the hexadecimal value of this color."
              },
              "getHexString": {
                "!type": "fn() -> string",
                "!doc": "Returns the string formated hexadecimal value of this color."
              },
              "setHex": {
                "!type": "fn(hex: number) -> +THREE.Color",
                "!doc": "Sets this color from a hexadecimal value."
              },
              "setStyle": {
                "!type": "fn(style: string) -> +THREE.Color",
                "!doc": "Sets this color\tfrom a CSS-style string."
              },
              "getStyle": {
                "!type": "fn() -> string",
                "!doc": "Returns the value of this color as a CSS-style string. Example: rgb(255,0,0)"
              },
              "setHSL": {
                "!type": "fn(h: number, s: number, l: number) -> +THREE.Color",
                "!doc": "Sets color from hsl"
              },
              "offsetHSL": {
                "!type": "fn(h: number, s: number, l: number) -> +THREE.Color",
                "!doc": "Adds given h, s, and l to this color's existing h, s, and l values."
              },
              "add": {
                "!type": "fn(color: +THREE.Color) -> +THREE.Color",
                "!doc": "Adds rgb values of given color to rgb values of this color"
              },
              "addColors": {
                "!type": "fn(color1: +THREE.Color, color2: +THREE.Color) -> +THREE.Color",
                "!doc": "Sets this color to the sum of color1 and color2"
              },
              "addScalar": {
                "!type": "fn(s: number) -> +THREE.Color",
                "!doc": "Adds s to the rgb values of this color"
              },
              "multiply": {
                "!type": "fn(color: +THREE.Color) -> +THREE.Color",
                "!doc": "Multiplies this color's rgb values by given color's rgb values"
              },
              "multiplyScalar": {
                "!type": "fn(s: number) -> +THREE.Color",
                "!doc": "Multiplies this color's rgb values by s"
              },
              "lerp": {
                "!type": "fn(color: +THREE.Color, alpha) -> +THREE.Color",
                "!doc": "Linear interpolation of this colors rgb values and the rgb values of the first argument. The alpha argument can be thought of as the percent between the two colors, where 0 is this color and 1 is the first argument."
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Returns an array [r,g,b]"
              },
              "equals": {
                "!type": "fn(c: +THREE.Color) -> +THREE.Color",
                "!doc": "Compares this color and c and returns true if they are the same, false otherwise."
              },
              "clone": {
                "!type": "fn() -> +THREE.Color",
                "!doc": "Clones this color."
              },
              "set": {
                "!type": "fn(value) -> +THREE.Color",
                "!doc": "Delegates to .copy, .setStyle, or .setHex depending on input type."
              }
            },
            "!doc": "Represents a color.",
            "!type": "fn(value)"
          },
          "Euler": {
            "!url": "http://threejs.org/docs/#Reference/math/Euler",
            "prototype": {
              "x": "number",
              "y": "number",
              "z": "number",
              "order": "string",
              "set": {
                "!type": "fn(x: number, y: number, z: number, order: string) -> +THREE.Euler",
                "!doc": "Sets the angles of this euler transform."
              },
              "copy": {
                "!type": "fn(euler: +THREE.Euler) -> +THREE.Euler",
                "!doc": "Copies value of *euler* to this euler."
              },
              "setFromRotationMatrix": {
                "!type": "fn(m: +THREE.Matrix4, order: string) -> +THREE.Euler",
                "!doc": "Sets the angles of this euler transform from a pure rotation matrix based on the orientation specified by order."
              },
              "setFromQuaternion": {
                "!type": "fn(q: +THREE.Quaternion, order: string) -> +THREE.Euler",
                "!doc": "Sets the angles of this euler transform from a normalized quaternion based on the orientation specified by order."
              },
              "reorder": {
                "!type": "fn(newOrder: string) -> +THREE.Euler",
                "!doc": "Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order. <br>\n\t\tWARNING: this discards revolution information."
              },
              "setFromVector3": {
                "!type": "fn(vector: +THREE.Vector3, order: string) -> +THREE.Euler",
                "!doc": "Optionally Vector3 to the XYZ parameters of Euler, and order to the Euler's order property."
              },
              "toVector3": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Returns the Euler's XYZ properties as a Vector3."
              },
              "fromArray": {
                "!type": "fn(array: []) -> +THREE.Euler",
                "!doc": "Assigns this euler's x angle to array[0]. <br>\n\t\tAssigns this euler's y angle to array[1]. <br>\n\t\tAssigns this euler's z angle to array[2]. <br>\n\t\tOptionally assigns this euler's order to array[3]."
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Returns an array [x, y, z, order]"
              },
              "equals": {
                "!type": "fn(euler: +THREE.Euler) -> bool",
                "!doc": "Checks for strict equality of this euler and *euler*."
              },
              "clone": {
                "!type": "fn() -> +THREE.Euler",
                "!doc": "Returns a new euler created from this euler."
              }
            },
            "!doc": "Euler Angles. <br><br>\n\n\t\tEuler angles describe a rotation transformation by rotating an object on its various axes in specified amounts per axis, and a specified axis order.\n\t\t(More information on <a href=\"http://en.wikipedia.org/wiki/Euler_angles\" target=\"blank\">Wikipedia</a>)",
            "!type": "fn(x: number, y: number, z: number, order: string)"
          },
          "Frustum": {
            "!url": "http://threejs.org/docs/#Reference/math/Frustum",
            "prototype": {
              "planes": {
                "!type": "[]",
                "!doc": "Array of 6 [page:Plane planes]."
              },
              "setFromMatrix": {
                "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Frustum",
                "!doc": "Array of 6 [page:Plane planes]."
              },
              "intersectsObject": {
                "!type": "fn(object: +THREE.Object3D) -> bool",
                "!doc": "Checks whether the object's bounding sphere is intersecting the Frustum."
              },
              "clone": {
                "!type": "fn() -> +THREE.Frustum",
                "!doc": "Return a copy of this Frustum"
              },
              "set": {
                "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane) -> bool",
                "!doc": "Sets the current frustum from the passed planes. No plane order is implicitely implied."
              },
              "copy": {
                "!type": "fn(frustum: +THREE.Frustum) -> +THREE.Frustum",
                "!doc": "Copies the values of the passed frustum."
              },
              "containsPoint": {
                "!type": "fn(point: +THREE.Vector3) -> bool",
                "!doc": "Checks to see if the frustum contains the point."
              },
              "intersectsSphere": {
                "!type": "fn(sphere: +THREE.Sphere) -> bool",
                "!doc": "Check to see if the sphere intersects with the frustum."
              }
            },
            "!doc": "<a href=\"http://en.wikipedia.org/wiki/Frustum\">Frustums</a> are used to determine what is inside the camera's field of view. They help speed up the rendering process.",
            "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane)"
          },
          "Line3": {
            "!url": "http://threejs.org/docs/#Reference/math/Line3",
            "prototype": {
              "start": "+THREE.Vector3",
              "end": "+THREE.Vector3",
              "set": {
                "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3) -> +THREE.Line3",
                "!doc": "Sets the start and end values by copying the provided vectors."
              },
              "copy": {
                "!type": "fn(line: +THREE.Line3) -> +THREE.Line3",
                "!doc": "Copies the passed line's start and end vectors to this line."
              },
              "clone": {
                "!type": "fn() -> +THREE.Line3",
                "!doc": "Return a new copy of this [page:Line3]."
              },
              "equals": {
                "!type": "fn(line: +THREE.Line3) -> bool",
                "!doc": "<h3>[method:Float distance]()</h3>\n\t\t<div>\n\t\tReturns the length of the line segment.\n\t\t</div>\n\t\tReturns true if both line's start and end points are equal."
              },
              "distance": {
                "!type": "fn() -> number",
                "!doc": "Returns the length of the line segment."
              },
              "distanceSq": {
                "!type": "fn() -> number",
                "!doc": "Returns the line segment's length squared."
              },
              "applyMatrix4": {
                "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Line3",
                "!doc": "Apply a matrix transform to the line segment."
              },
              "at": {
                "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> Vector",
                "!doc": "Return a vector at a certain position along the line. When t = 0, it returns the start vector, and when t=1 it returns the end vector."
              },
              "center": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Return the center of the line segment."
              },
              "delta": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns the delta vector of the line segment, or the end vector minus the start vector."
              },
              "closestPointToPoint": {
                "!type": "fn(point: +THREE.Vector3, clampToLine: bool, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns the closets point on the line. If clamp to line is true, then the returned value will be clamped to the line segment."
              },
              "closestPointToPointParameter": {
                "!type": "fn(point: +THREE.Vector3, clampToLine: bool) -> number",
                "!doc": "Returns a point parameter based on the closest point as projected on the line segement. If clamp to line is true, then the returned value will be between 0 and 1."
              }
            },
            "!doc": "A geometric line segment represented by a start and end point.",
            "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3)"
          },
          "Math": {
            "!url": "http://threejs.org/docs/#Reference/math/Math",
            "prototype": {
              "clamp": {
                "!type": "fn(x: number, a: number, b: number) -> number",
                "!doc": "Clamps the *x* to be between *a* and *b*."
              },
              "clampBottom": {
                "!type": "fn(x: number, a: number) -> number",
                "!doc": "Clamps the *x* to be larger than *a*."
              },
              "mapLinear": {
                "!type": "fn(x: number, a1: number, a2: number, b1: number, b2: number) -> number",
                "!doc": "Linear mapping of *x* from range [*a1*, *a2*] to range [*b1*, *b2*]."
              },
              "random16": {
                "!type": "fn() -> number",
                "!doc": "Random float from 0 to 1 with 16 bits of randomness.<br>\n\t\tStandard Math.random() creates repetitive patterns when applied over larger space."
              },
              "randInt": {
                "!type": "fn(low: number, high: number) -> number",
                "!doc": "Random integer from *low* to *high* interval."
              },
              "randFloat": {
                "!type": "fn(low: number, high: number) -> number",
                "!doc": "Random float from *low* to *high* interval."
              },
              "randFloatSpread": {
                "!type": "fn(range: number) -> number",
                "!doc": "Random float from *- range / 2* to *range / 2* interval."
              },
              "sign": {
                "!type": "fn(x: number) -> number",
                "!doc": "Returns -1 if *x* is less than 0, 1 if *x* is greater than 0, and 0 if *x* is zero."
              },
              "degToRad": {
                "!type": "fn(degrees: number) -> number",
                "!doc": "Converts degrees to radians."
              },
              "radToDeg": {
                "!type": "fn(radians: number) -> number",
                "!doc": "Converts radians to degrees"
              },
              "smoothstep": {
                "!type": "fn(x: number, min: number, max: number) -> number",
                "!doc": "Returns a value between 0-1 that represents the percentage that x has moved between min and max, but smoothed or slowed down the closer X is to the min and max.<br><br>\n\t\t\n\t\t[link:http://en.wikipedia.org/wiki/Smoothstep Wikipedia]"
              },
              "smootherstep": {
                "!type": "fn(x: number, min: number, max: number) -> number",
                "!doc": "Returns a value between 0-1. It works the same as smoothstep, but more smooth."
              }
            },
            "!doc": "Math utility functions"
          },
          "Matrix3": {
            "!url": "http://threejs.org/docs/#Reference/math/Matrix3",
            "prototype": {
              "elements": {
                "!type": "Float32Array",
                "!doc": "Float32Array with column-major matrix values."
              },
              "transpose": {
                "!type": "fn() -> +THREE.Matrix3",
                "!doc": "Transposes this matrix in place."
              },
              "transposeIntoArray": {
                "!type": "fn(array: []) -> +THREE.Matrix3",
                "!doc": "Transposes this matrix into the supplied array, and returns itself."
              },
              "determinant": {
                "!type": "fn() -> number",
                "!doc": "Returns the matrix's determinant."
              },
              "set": {
                "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) -> +THREE.Matrix3",
                "!doc": "Set the 3x3 matrix values to the given row-major sequence of values."
              },
              "multiplyScalar": {
                "!type": "fn(scalar: number) -> +THREE.Matrix3",
                "!doc": "Multiply every component of the matrix by a scalar value."
              },
              "applyToBufferAttribute": {
                "!type": "fn(attribute: []) -> +THREE.BufferAttribute",
                "!doc": "Multiply (apply) this matrix to every vector3 in the attribute."
              },
              "getNormalMatrix": {
                "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Matrix3",
                "!doc": "Set this matrix as the normal matrix of the passed [page:Matrix4 matrix4]. The normal matrix is the inverse transpose of the matrix."
              },
              "getInverse": {
                "!type": "fn(matrix4: +THREE.Matrix4, throwOnInvertible: bool) -> +THREE.Matrix3",
                "!doc": "Set this matrix to the inverse of the passed matrix."
              },
              "copy": {
                "!type": "fn(matrix: +THREE.Matrix3) -> +THREE.Matrix3",
                "!doc": "Copy the values of the passed matrix."
              },
              "clone": {
                "!type": "fn() -> +THREE.Matrix3",
                "!doc": "Create a copy of the matrix."
              },
              "identity": {
                "!type": "fn() -> +THREE.Matrix3",
                "!doc": "Set as an identity matrix.<br><br>\n\t\t\n\t\t1, 0, 0<br>\n\t\t0, 1, 0<br>\n\t\t0, 0, 1<br>"
              }
            },
            "!doc": "A 3x3 matrix.",
            "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number)"
          },
          "Matrix4": {
            "!url": "http://threejs.org/docs/#Reference/math/Matrix4",
            "prototype": {
              "elements": {
                "!type": "Float32Array",
                "!doc": "A column-major list of matrix values."
              },
              "set": {
                "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) -> +THREE.Matrix4",
                "!doc": "Sets all fields of this matrix to the supplied row-major values n11..n44."
              },
              "identity": {
                "!type": "fn() -> +THREE.Matrix4",
                "!doc": "Resets this matrix to identity."
              },
              "copy": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Copies a matrix *m* into this matrix."
              },
              "copyPosition": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Copies the translation component of the supplied matrix *m* into this matrix translation component."
              },
              "makeBasis": {
                "!type": "fn(xAxis: +THREE.Vector3, zAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Creates the basis matrix consisting of the three provided axis vectors.  Returns the current matrix."
              },
              "extractBasis": {
                "!type": "fn(xAxis: +THREE.Vector3, zAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Extracts basis of into the three axis vectors provided.  Returns the current matrix."
              },
              "extractRotation": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Extracts the rotation of the supplied matrix *m* into this matrix rotation component."
              },
              "lookAt": {
                "!type": "fn(eye: +THREE.Vector3, center: +THREE.Vector3, up: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Constructs a rotation matrix, looking from *eye* towards *center* with defined *up* vector."
              },
              "multiply": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Multiplies this matrix by *m*."
              },
              "multiplyMatrices": {
                "!type": "fn(a: +THREE.Matrix4, b: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Sets this matrix to *a x b*."
              },
              "multiplyScalar": {
                "!type": "fn(s: number) -> +THREE.Matrix4",
                "!doc": "Multiplies this matrix by *s*."
              },
              "determinant": {
                "!type": "fn() -> number",
                "!doc": "Computes determinant of this matrix.<br>\n\t\tBased on [link:http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm]"
              },
              "transpose": {
                "!type": "fn() -> +THREE.Matrix4",
                "!doc": "Transposes this matrix."
              },
              "flattenToArrayOffset": {
                "!type": "fn(flat: [], offset: number) -> []",
                "!doc": "Flattens this matrix into supplied *flat* array starting from *offset* position in the array."
              },
              "setPosition": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Sets the position component for this matrix from vector *v*."
              },
              "getInverse": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
                "!doc": "Sets this matrix to the inverse of matrix *m*.<br>\n\t\tBased on [link:http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm]."
              },
              "makeRotationFromEuler": {
                "!type": "fn(euler: +THREE.Euler) -> +THREE.Matrix4",
                "!doc": "Sets the rotation submatrix of this matrix to the rotation specified by Euler angles, the rest of the matrix is identity.<br>\n\t\tDefault order is *\"XYZ\"*."
              },
              "makeRotationFromQuaternion": {
                "!type": "fn(q: +THREE.Quaternion) -> +THREE.Matrix4",
                "!doc": "Sets the rotation submatrix of this matrix to the rotation specified by *q*. The rest of the matrix is identity."
              },
              "scale": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Multiplies the columns of this matrix by vector *v*."
              },
              "compose": {
                "!type": "fn(translation: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> +THREE.Matrix4",
                "!doc": "Sets this matrix to the transformation composed of *translation*, *quaternion* and *scale*."
              },
              "decompose": {
                "!type": "fn(translation: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> []",
                "!doc": "Decomposes this matrix into the *translation*, *quaternion* and *scale* components."
              },
              "makeTranslation": {
                "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as translation transform."
              },
              "makeRotationX": {
                "!type": "fn(theta: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as rotation transform around x axis by *theta* radians."
              },
              "makeRotationY": {
                "!type": "fn(theta: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as rotation transform around y axis by *theta* radians."
              },
              "makeRotationZ": {
                "!type": "fn(theta: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as rotation transform around z axis by *theta* radians."
              },
              "makeRotationAxis": {
                "!type": "fn(axis: +THREE.Vector3, theta: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as rotation transform around *axis* by *angle* radians.<br>\n\t\tBased on [link:http://www.gamedev.net/reference/articles/article1199.asp]."
              },
              "makeScale": {
                "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
                "!doc": "Sets this matrix as scale transform."
              },
              "makePerspective": {
                "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number) -> +THREE.Matrix4",
                "!doc": "Creates a perspective projection matrix."
              },
              "makeOrthographic": {
                "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number) -> +THREE.Matrix4",
                "!doc": "Creates an orthographic projection matrix."
              },
              "clone": {
                "!type": "fn() -> +THREE.Matrix4",
                "!doc": "Clones this matrix."
              },
              "applyToBufferAttribute": {
                "!type": "fn(attribute: []) -> +THREE.BufferAttribute",
                "!doc": "Multiply (apply) this matrix to every vector3 in the attribute."
              },
              "getMaxScaleOnAxis": {
                "!type": "fn() -> number",
                "!doc": "Gets the max scale value of the 3 axes."
              }
            },
            "!doc": "A 4x4 Matrix.",
            "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number)"
          },
          "Plane": {
            "!url": "http://threejs.org/docs/#Reference/math/Plane",
            "prototype": {
              "normal": "+THREE.Vector3",
              "constant": "number",
              "normalize": {
                "!type": "fn() -> +THREE.Plane",
                "!doc": "Normalizes the normal vector, and adjusts the constant value accordingly."
              },
              "set": {
                "!type": "fn(normal: +THREE.Vector3, constant: number) -> +THREE.Plane",
                "!doc": "Sets the plane's values."
              },
              "copy": {
                "!type": "fn(plane: +THREE.Plane) -> +THREE.Plane",
                "!doc": "Copies the values of the passed plane to this plane."
              },
              "applyMatrix4": {
                "!type": "fn(matrix: +THREE.Matrix4, optionalNormalMatrix: +THREE.Matrix3) -> +THREE.Plane",
                "!doc": "Apply a Matrix4 to the plane. The second parameter is optional.\n\t\t\n\t\t<code>\n\t\tvar optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix ) \n\t\t</code>"
              },
              "orthoPoint": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns a vector in the same direction as the Plane's normal, but the magnitude is passed point's original distance to the plane."
              },
              "isIntersectionLine": {
                "!type": "fn(line: +THREE.Line3) -> bool",
                "!doc": "Tests whether a line segment intersects with the plane. (Do not mistake this for a collinear check.)"
              },
              "intersectLine": {
                "!type": "fn(line: +THREE.Line3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns the intersection point of the passed line and the plane. Returns undefined if the line does not intersect. Returns the line's starting point if the line is coplanar with the plane."
              },
              "setFromNormalAndCoplanarPoint": {
                "!type": "fn(normal: +THREE.Vector3, point: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets the plane's values as defined by a normal and arbitrary coplanar point."
              },
              "clone": {
                "!type": "fn() -> +THREE.Plane",
                "!doc": "Returns a new copy of this plane."
              },
              "distanceToPoint": {
                "!type": "fn(point: +THREE.Vector3) -> number",
                "!doc": "Returns the smallest distance from the point to the plane."
              },
              "equals": {
                "!type": "fn(plane: +THREE.Plane) -> bool",
                "!doc": "Checks to see if two planes are equal (their normals and constants match)"
              },
              "setComponents": {
                "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Plane",
                "!doc": "Set the individual components that make up the plane."
              },
              "distanceToSphere": {
                "!type": "fn(sphere: +THREE.Sphere) -> number",
                "!doc": "Returns the smallest distance from an edge of the sphere to the plane."
              },
              "setFromCoplanarPoints": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Plane",
                "!doc": "Defines the plane based on the 3 provided points. The winding order is counter clockwise, and determines which direction the normal will point."
              },
              "projectPoint": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Projects a point onto the plane. The projected point is the closest point on the plane to the passed point, so a line drawn from the projected point and the passed point would be orthogonal to the plane."
              },
              "negate": {
                "!type": "fn() -> +THREE.Plane",
                "!doc": "Negates both the normal vector and constant, effectively mirroring the plane across the origin."
              },
              "translate": {
                "!type": "fn(offset: +THREE.Vector3) -> +THREE.Plane",
                "!doc": "Translates the plane the distance defined by the vector. Note that this only affects the constant (distance from origin) and will not affect the normal vector."
              },
              "coplanarPoint": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Returns a coplanar point. (The projection of the normal vector at the origin onto the plane.)"
              }
            },
            "!doc": "A two dimensional surface that extends infinitely in 3d space.",
            "!type": "fn(normal: +THREE.Vector3, constant: number)"
          },
          "Quaternion": {
            "!url": "http://threejs.org/docs/#Reference/math/Quaternion",
            "prototype": {
              "x": "number",
              "y": "number",
              "z": "number",
              "w": "number",
              "set": {
                "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Quaternion",
                "!doc": "Sets values of this quaternion."
              },
              "copy": {
                "!type": "fn(q: +THREE.Quaternion) -> +THREE.Quaternion",
                "!doc": "Copies values of *q* to this quaternion."
              },
              "setFromEuler": {
                "!type": "fn(euler: +THREE.Euler) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion from rotation specified by Euler angle."
              },
              "setFromAxisAngle": {
                "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion from rotation specified by axis and angle.<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm].<br>\n\t\t*Axis* is asumed to be normalized, *angle* is in radians."
              },
              "setFromRotationMatrix": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion from rotation component of *m*.<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm]."
              },
              "setFromUnitVectors": {
                "!type": "fn(vFrom: +THREE.Vector3, vTo: +THREE.Vector3) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion to the rotation required to rotate direction vector *vFrom* to direction vector *vTo*.<br>\n\t\tAdapted from [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors].<br>\n\t\t*vFrom* and *vTo* are assumed to be normalized."
              },
              "inverse": {
                "!type": "fn() -> +THREE.Quaternion",
                "!doc": "Inverts this quaternion."
              },
              "length": {
                "!type": "fn() -> number",
                "!doc": "Computes length of this quaternion."
              },
              "normalize": {
                "!type": "fn() -> +THREE.Quaternion",
                "!doc": "Normalizes this quaternion."
              },
              "multiply": {
                "!type": "fn(b: +THREE.Quaternion) -> +THREE.Quaternion",
                "!doc": "Multiplies this quaternion by *b*."
              },
              "multiplyQuaternions": {
                "!type": "fn(a: +THREE.Quaternion, b: +THREE.Quaternion) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion to *a x b*<br>\n\t\tAdapted from [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm]."
              },
              "multiplyVector3": {
                "!type": "fn(vector: +THREE.Vector3, dest: +THREE.Vector3) -> +THREE.Quaternion",
                "!doc": "Rotates *vector* by this quaternion into *dest*.<br>\n\t\tIf *dest* is not specified, result goes to *vec*."
              },
              "clone": {
                "!type": "fn() -> +THREE.Quaternion",
                "!doc": "Clones this quaternion."
              },
              "slerp": {
                "!type": "fn(qb: +THREE.Quaternion, t: float) -> +THREE.Quaternion",
                "!doc": "Handles the spherical linear interpolation between this quaternion's configuration\n\t\tand that of *qb*. *t* represents how close to the current (0) or target (1) rotation the\n\t\tresult should be."
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Returns the numerical elements of this quaternion in an array of format (x, y, z, w)."
              },
              "equals": {
                "!type": "fn(v: +THREE.Quaternion) -> bool",
                "!doc": "Compares each component of *v* to each component of this quaternion to determine if they\n\t\trepresent the same rotation."
              },
              "lengthSq": {
                "!type": "fn() -> number",
                "!doc": "Calculates the squared length of the quaternion."
              },
              "fromArray": {
                "!type": "fn(array: []) -> +THREE.Quaternion",
                "!doc": "Sets this quaternion's component values from an array."
              },
              "conjugate": {
                "!type": "fn() -> +THREE.Quaternion",
                "!doc": "Returns the rotational conjugate of this quaternion. The conjugate of a quaternion\n\t\trepresents the same rotation in the opposite direction about the rotational axis."
              }
            },
            "!doc": "Implementation of a <a href=\"http://en.wikipedia.org/wiki/Quaternion\">quaternion</a>. This is used for rotating things without encountering the dreaded <a href=\"http://en.wikipedia.org/wiki/Gimbal_lock\">gimbal lock</a> issue, amongst other advantages.",
            "!type": "fn(x: number, y: number, z: number, w: number)"
          },
          "Ray": {
            "!url": "http://threejs.org/docs/#Reference/math/Ray",
            "prototype": {
              "origin": {
                "!type": "+THREE.Vector3",
                "!doc": "The origin of the [page:Ray]."
              },
              "direction": {
                "!type": "+THREE.Vector3",
                "!doc": "The direction of the [page:Ray]. This must be normalized (with [page:Vector3].normalize) for the methods to operate properly."
              },
              "applyMatrix4": {
                "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Ray",
                "!doc": "Transform this [page:Ray] by the [page:Matrix4]."
              },
              "clone": {
                "!type": "fn() -> +THREE.Ray",
                "!doc": "Create a clone of this [page:Ray]."
              },
              "closestPointToPoint": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Get the point along this [page:Ray] that is closest to the [page:Vector3] provided."
              },
              "copy": {
                "!type": "fn(ray: +THREE.Ray) -> +THREE.Ray",
                "!doc": "Copy the properties of the provided [page:Ray], then return this [page:Ray]."
              },
              "distanceToPlane": {
                "!type": "fn(plane: +THREE.Plane) -> number",
                "!doc": "Get the distance from the origin to the [page:Plane], or *null* if the [page:Ray] doesn't intersect the [page:Plane]."
              },
              "distanceToPoint": {
                "!type": "fn(point: +THREE.Vector3) -> number",
                "!doc": "Get the distance of the closest approach between the [page:Ray] and the [page:Vector3]."
              },
              "equals": {
                "!type": "fn(ray: +THREE.Ray) -> bool",
                "!doc": "Return whether this and the other [page:Ray] have equal offsets and directions."
              },
              "isIntersectionBox": {
                "!type": "fn(box: +THREE.Box3) -> bool",
                "!doc": "Return whether or not this [page:Ray] intersects with the [page:Box3]."
              },
              "isIntersectionPlane": {
                "!type": "fn(plane: +THREE.Plane) -> bool",
                "!doc": "Return whether or not this [page:Ray] intersects with the [page:Plane]."
              },
              "isIntersectionSphere": {
                "!type": "fn(sphere: +THREE.Sphere) -> bool",
                "!doc": "Return whether or not this [page:Ray] intersects with the [page:Sphere]."
              },
              "recast": {
                "!type": "fn(t: number) -> +THREE.Ray",
                "!doc": "Shift the origin of this [page:Ray] along its direction by the distance given."
              },
              "set": {
                "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3) -> +THREE.Ray",
                "!doc": "Copy the parameters to the origin and direction properties."
              }
            },
            "!doc": "A ray that emits from an origin in a certain direction.",
            "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)"
          },
          "Sphere": {
            "!url": "http://threejs.org/docs/#Reference/math/Sphere",
            "prototype": {
              "center": "+THREE.Vector3",
              "radius": "number",
              "applyMatrix4": {
                "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Sphere",
                "!doc": "Transforms this sphere with the provided [page:Matrix4]."
              },
              "clampPoint": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Clamps a point within the sphere. If the point is is outside the sphere, it will clamp it to the closets point on the edge of the sphere."
              },
              "translate": {
                "!type": "fn(offset: +THREE.Vector3) -> +THREE.Sphere",
                "!doc": "Translate the sphere's center by the provided offset vector."
              },
              "clone": {
                "!type": "fn() -> +THREE.Sphere",
                "!doc": "Provides a new copy of the sphere."
              },
              "equals": {
                "!type": "fn(sphere: +THREE.Sphere) -> bool",
                "!doc": "Checks to see if the two spheres' centers and radii are equal."
              },
              "setFromPoints": {
                "!type": "fn(points: [], optionalCenter: +THREE.Vector3) -> +THREE.Sphere",
                "!doc": "Computes the minimum bounding sphere for *points*. If *optionalCenter* is given, it is used as the sphere's center. Otherwise, the center of the axis-aligned bounding box encompassing *points* is calculated."
              },
              "distanceToPoint": {
                "!type": "fn(point: +THREE.Vector3) -> number",
                "!doc": "Returns the closest distance from the boundary of the sphere to the point. If the sphere contains the point, the distance will be negative."
              },
              "getBoundingBox": {
                "!type": "fn(optionalTarget: Box) -> Box",
                "!doc": "Returns a bounding box for the sphere, optionally setting a provided box target."
              },
              "containsPoint": {
                "!type": "fn(point: +THREE.Vector3) -> bool",
                "!doc": "Checks to see if the sphere contains the provided point inclusive of the edge of the sphere."
              },
              "copy": {
                "!type": "fn(sphere: +THREE.Sphere) -> +THREE.Sphere",
                "!doc": "Copies the values of the passed sphere to this sphere."
              },
              "intersectsSphere": {
                "!type": "fn(sphere: +THREE.Sphere) -> bool",
                "!doc": "Checks to see if two spheres intersect."
              },
              "empty": {
                "!type": "fn() -> bool",
                "!doc": "Checks to see if the sphere is empty (the radius set to 0)."
              }
            },
            "!doc": "A geometric sphere defined by a center position and radius.",
            "!type": "fn(center: +THREE.Vector3, radius: number)"
          },
          "Triangle": {
            "!url": "http://threejs.org/docs/#Reference/math/Triangle",
            "prototype": {
              "a": {
                "!type": "+THREE.Vector3",
                "!doc": "The first [page:Vector3] of the triangle."
              },
              "b": {
                "!type": "+THREE.Vector3",
                "!doc": "The second [page:Vector3] of the triangle."
              },
              "c": {
                "!type": "+THREE.Vector3",
                "!doc": "The third [page:Vector3] of the triangle."
              },
              "setFromPointsAndIndices": {
                "!type": "fn(points: [], i0: number, i1: number, i2: number) -> +THREE.Triangle",
                "!doc": "Sets the triangle's vectors to the vectors in the array."
              },
              "set": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Triangle",
                "!doc": "Sets the triangle's vectors to the passed vectors."
              },
              "getNormal": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Return the calculated normal of the triangle."
              },
              "getBarycoord": {
                "!type": "fn(point: +THREE.Vector3, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Return a barycentric coordinate from the given vector. <br><br>\n\t\t[link:http://commons.wikimedia.org/wiki/File:Barycentric_coordinates_1.png](Picture of barycentric coordinates)"
              },
              "clone": {
                "!type": "fn() -> +THREE.Triangle",
                "!doc": "Return a new copy of this triangle."
              },
              "getArea": {
                "!type": "fn() -> number",
                "!doc": "Return the area of the triangle."
              },
              "getMidpoint": {
                "!type": "fn(optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Return the midpoint of the triangle. Optionally sets a target vector."
              },
              "equals": {
                "!type": "fn(triangle: +THREE.Triangle) -> bool",
                "!doc": "Checks to see if two triangles are equal (share the same vectors)."
              },
              "getPlane": {
                "!type": "fn(optionalTarget: +THREE.Plane) -> +THREE.Plane",
                "!doc": "Return a [page:Plane plane] based on the triangle. Optionally sets a target plane."
              },
              "containsPoint": {
                "!type": "fn(point: +THREE.Vector3) -> bool",
                "!doc": "Checks to see if the passed vector is within the triangle."
              },
              "copy": {
                "!type": "fn(triangle: +THREE.Triangle) -> +THREE.Triangle",
                "!doc": "Copies the values of the vertices of the passed triangle to this triangle."
              }
            },
            "!doc": "A geometric triangle as defined by three vectors.",
            "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3)"
          },
          "Vector2": {
            "!url": "http://threejs.org/docs/#Reference/math/Vector2",
            "prototype": {
              "x": "number",
              "y": "number",
              "set": {
                "!type": "fn(x: number, y: number) -> +THREE.Vector2",
                "!doc": "Sets value of this vector."
              },
              "copy": {
                "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Copies value of *v* to this vector."
              },
              "add": {
                "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Adds *v* to this vector."
              },
              "addVectors": {
                "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Sets this vector to *a + b*."
              },
              "sub": {
                "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Subtracts *v* from this vector."
              },
              "subVectors": {
                "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "Sets this vector to *a - b*."
              },
              "multiplyScalar": {
                "!type": "fn(s: number) -> +THREE.Vector2",
                "!doc": "Multiplies this vector by scalar *s*."
              },
              "divideScalar": {
                "!type": "fn(s: number) -> +THREE.Vector2",
                "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0 )* if *s == 0*."
              },
              "negate": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "Inverts this vector."
              },
              "dot": {
                "!type": "fn(v: +THREE.Vector2) -> number",
                "!doc": "Computes dot product of this vector and *v*."
              },
              "lengthSq": {
                "!type": "fn() -> number",
                "!doc": "Computes squared length of this vector."
              },
              "length": {
                "!type": "fn() -> number",
                "!doc": "Computes length of this vector."
              },
              "normalize": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "Normalizes this vector."
              },
              "distanceTo": {
                "!type": "fn(v: +THREE.Vector2) -> number",
                "!doc": "Computes distance of this vector to *v*."
              },
              "distanceToSquared": {
                "!type": "fn(v: +THREE.Vector2) -> number",
                "!doc": "Computes squared distance of this vector to *v*."
              },
              "setLength": {
                "!type": "fn(l: number) -> +THREE.Vector2",
                "!doc": "Normalizes this vector and multiplies it by *l*."
              },
              "equals": {
                "!type": "fn(v: +THREE.Vector2) -> bool",
                "!doc": "Checks for strict equality of this vector and *v*."
              },
              "clone": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "Clones this vector."
              },
              "clamp": {
                "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value. <br>\tIf this vector's x or y value is less than the min vector's x or y value, it is replace by the corresponding value."
              },
              "clampScalar": {
                "!type": "fn(min: number, max: number) -> +THREE.Vector2",
                "!doc": "If this vector's x or y values are greater than the max value, they are replaced by the max value. <br>  If this vector's x or y values are less than the min value, they are replace by the min value."
              },
              "floor": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
              },
              "ceil": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
              },
              "round": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "The components of the vector are rounded towards the nearest integer value."
              },
              "roundToZero": {
                "!type": "fn() -> +THREE.Vector2",
                "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
              },
              "lerp": {
                "!type": "fn(v: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
                "!doc": "Linear interpolation between this vector and v, where alpha is the percent along the line."
              },
              "lerpVectors": {
                "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
                "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
              },
              "setComponent": {
                "!type": "fn(index: number, value: number) -> undefined",
                "!doc": "if index equals 0 method replaces this.x with value. <br>\n\t\tif index equals 1 method replaces this.y with value."
              },
              "addScalar": {
                "!type": "fn(s: number) -> +THREE.Vector2",
                "!doc": "Add the scalar value s to this vector's x and y values."
              },
              "getComponent": {
                "!type": "fn(index: number) -> number",
                "!doc": "if index equals 0 returns the x value. <br>\n\t\tif index equals 1 returns the y value."
              },
              "fromArray": {
                "!type": "fn(array: []) -> +THREE.Vector2",
                "!doc": "Sets this vector's x value to be array[0] and y value to be array[1]."
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Returns an array [x, y]."
              },
              "min": {
                "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "If this vector's x or y value is less than v's x or y value, replace that value with the corresponding min value."
              },
              "max": {
                "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
                "!doc": "If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding max value."
              },
              "setX": {
                "!type": "fn(x: number) -> +THREE.Vector2",
                "!doc": "replace this vector's x value with x."
              },
              "setY": {
                "!type": "fn(y: number) -> +THREE.Vector2",
                "!doc": "replace this vector's y value with y."
              }
            },
            "!doc": "2D vector.",
            "!type": "fn(x: number, y: number)"
          },
          "Vector3": {
            "!url": "http://threejs.org/docs/#Reference/math/Vector3",
            "prototype": {
              "x": "number",
              "y": "number",
              "z": "number",
              "set": {
                "!type": "fn(x: number, y: number, z: number) -> +THREE.Vector3",
                "!doc": "Sets value of this vector."
              },
              "setX": {
                "!type": "fn(x: number) -> +THREE.Vector3",
                "!doc": "Sets x value of this vector."
              },
              "setY": {
                "!type": "fn(y: number) -> +THREE.Vector3",
                "!doc": "Sets y value of this vector."
              },
              "setZ": {
                "!type": "fn(z: number) -> +THREE.Vector3",
                "!doc": "Sets z value of this vector."
              },
              "copy": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Copies value of *v* to this vector."
              },
              "add": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Adds *v* to this vector."
              },
              "addVectors": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets this vector to *a + b*."
              },
              "sub": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Subtracts *v* from this vector."
              },
              "subVectors": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets this vector to *a - b*."
              },
              "multiplyScalar": {
                "!type": "fn(s: number) -> +THREE.Vector3",
                "!doc": "Multiplies this vector by scalar *s*."
              },
              "divideScalar": {
                "!type": "fn(s: number) -> +THREE.Vector3",
                "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0, 0 )* if *s == 0*."
              },
              "negate": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Inverts this vector."
              },
              "dot": {
                "!type": "fn(v: +THREE.Vector3) -> number",
                "!doc": "Computes dot product of this vector and *v*."
              },
              "lengthSq": {
                "!type": "fn() -> number",
                "!doc": "Computes squared length of this vector."
              },
              "length": {
                "!type": "fn() -> number",
                "!doc": "Computes length of this vector."
              },
              "lengthManhattan": {
                "!type": "fn() -> number",
                "!doc": "Computes Manhattan length of this vector.<br>\n\t\t[link:http://en.wikipedia.org/wiki/Taxicab_geometry]"
              },
              "normalize": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Normalizes this vector. Transforms this Vector into a Unit vector by dividing the vector by it's length."
              },
              "distanceTo": {
                "!type": "fn(v: +THREE.Vector3) -> number",
                "!doc": "Computes distance of this vector to *v*."
              },
              "distanceToSquared": {
                "!type": "fn(v: +THREE.Vector3) -> number",
                "!doc": "Computes squared distance of this vector to *v*."
              },
              "setLength": {
                "!type": "fn(l: number) -> +THREE.Vector3",
                "!doc": "Normalizes this vector and multiplies it by *l*."
              },
              "cross": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets this vector to cross product of itself and *v*."
              },
              "crossVectors": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets this vector to cross product of *a* and *b*."
              },
              "setFromMatrixPosition": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
                "!doc": "Sets this vector extracting position from matrix transform."
              },
              "setFromMatrixScale": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
                "!doc": "Sets this vector extracting scale from matrix transform."
              },
              "equals": {
                "!type": "fn(v: +THREE.Vector3) -> bool",
                "!doc": "Checks for strict equality of this vector and *v*."
              },
              "clone": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Clones this vector."
              },
              "clamp": {
                "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "If this vector's x, y or z value is greater than the max vector's x, y or z value, it is replaced by the corresponding value. <br><br>\n\t\tIf this vector's x, y or z value is less than the min vector's x, y or z value, it is replace by the corresponding value."
              },
              "clampScalar": {
                "!type": "fn(min: number, max: number) -> +THREE.Vector3",
                "!doc": "If this vector's x, y or z values are greater than the max value, they are replaced by the max value. <br>  If this vector's x, y or z values are less than the min value, they are replace by the min value."
              },
              "floor": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
              },
              "ceil": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
              },
              "round": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "The components of the vector are rounded towards the nearest integer value."
              },
              "roundToZero": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
              },
              "applyMatrix3": {
                "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
                "!doc": "Multiplies this vector times a 3 x 3 matrix."
              },
              "applyMatrix4": {
                "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
                "!doc": "Multiplies this vector by 4 x 3 subset of a Matrix4."
              },
              "projectOnPlane": {
                "!type": "fn(planeNormal: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Projects this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector."
              },
              "projectOnVector": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Projects this vector onto another vector."
              },
              "addScalar": {
                "!type": "fn() -> +THREE.Vector3",
                "!doc": "Adds a s to this vector."
              },
              "divide": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Divides this vector by vector v."
              },
              "min": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "If this vector's x, y, or z value is less than vector v's x, y, or z value, that value is replaced by the corresponding vector v value."
              },
              "max": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "If this vector's x, y, or z value is greater than vector v's x, y, or z value, that value is replaced by the corresponding vector v value."
              },
              "setComponent": {
                "!type": "fn(index: number, value: number) -> +THREE.Vector3",
                "!doc": "If index equals 0 the method sets this vector's x value to value <br>\n\t\tIf index equals 1 the method sets this vector's y value to value <br>\n\t\tIf index equals 2 the method sets this vector's z value to value"
              },
              "transformDirection": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
                "!doc": "Transforms the direction of this vector by a matrix (a 3 x 3 subset of a Matrix4) and then normalizes the result."
              },
              "multiplyVectors": {
                "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Sets this vector equal to the result of multiplying vector a by vector b."
              },
              "getComponent": {
                "!type": "fn(index: number) -> number",
                "!doc": "Returns the value of the vector component x, y, or z by an index. <br><br>\n\n\t\tIndex 0: x <br>\n\t\tIndex 1: y <br>\n\t\tIndex 2: z <br>"
              },
              "applyAxisAngle": {
                "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Vector3",
                "!doc": "Applies a rotation specified by an axis and an angle to this vector."
              },
              "lerp": {
                "!type": "fn(v: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
                "!doc": "Linear Interpolation between this vector and vector v, where alpha is the percent along the line."
              },
              "lerpVectors": {
                "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
                "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
              },
              "angleTo": {
                "!type": "fn(v: +THREE.Vector3) -> number",
                "!doc": "Returns the angle between this vector and vector v in radians."
              },
              "setFromMatrixColumn": {
                "!type": "fn(index: number, matrix: +THREE.Matrix4) -> +THREE.Vector3",
                "!doc": "Sets this vector's x, y, and z equal to the column of the matrix specified by the index."
              },
              "reflect": {
                "!type": "fn(normal: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Reflect incident vector off of plane orthogonal to normal. Normal is assumed to have unit length."
              },
              "fromArray": {
                "!type": "fn(array: []) -> +THREE.Vector3",
                "!doc": "Sets the vector's components based on an array formatted like [x, y, z]"
              },
              "multiply": {
                "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
                "!doc": "Multiplies this vector by vector v."
              },
              "applyProjection": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
                "!doc": "Multiplies this vector and m, and divides by perspective."
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Assigns this vector's x value to array[0]. <br>\n\t\tAssigns this vector's y value to array[1]. <br>\n\t\tAssigns this vector's z value to array[2]. <br>\n\t\tReturns the created array."
              },
              "applyEuler": {
                "!type": "fn(euler: +THREE.Euler) -> +THREE.Vector3",
                "!doc": "Applies euler transform to this vector by converting the [page:Euler] object to a [page:Quaternion] and applying."
              },
              "applyQuaternion": {
                "!type": "fn(quaternion: +THREE.Quaternion) -> +THREE.Vector3",
                "!doc": "Applies a [page:Quaternion] transform to this vector."
              },
              "project": {
                "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
                "!doc": "Projects the vector with the camera."
              },
              "unproject": {
                "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
                "!doc": "Unprojects the vector with the camera."
              }
            },
            "!doc": "3D vector.",
            "!type": "fn(x: number, y: number, z: number)"
          },
          "Vector4": {
            "!url": "http://threejs.org/docs/#Reference/math/Vector4",
            "prototype": {
              "x": "number",
              "y": "number",
              "z": "number",
              "w": "number",
              "set": {
                "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Vector4",
                "!doc": "Sets value of this vector."
              },
              "copy": {
                "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "Copies value of *v* to this vector."
              },
              "add": {
                "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "Adds *v* to this vector."
              },
              "addVectors": {
                "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "Sets this vector to *a + b*."
              },
              "sub": {
                "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "Subtracts *v* from this vector."
              },
              "subVectors": {
                "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "Sets this vector to *a - b*."
              },
              "multiplyScalar": {
                "!type": "fn(s: number) -> +THREE.Vector4",
                "!doc": "Multiplies this vector by scalar *s*."
              },
              "divideScalar": {
                "!type": "fn(s: number) -> +THREE.Vector4",
                "!doc": "Divides this vector by scalar *s*.<br>\n\t\tSet vector to *( 0, 0, 0 )* if *s == 0*."
              },
              "negate": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "Inverts this vector."
              },
              "dot": {
                "!type": "fn(v: +THREE.Vector4) -> number",
                "!doc": "Computes dot product of this vector and *v*."
              },
              "lengthSq": {
                "!type": "fn() -> number",
                "!doc": "Computes squared length of this vector."
              },
              "length": {
                "!type": "fn() -> number",
                "!doc": "Computes length of this vector."
              },
              "normalize": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "Normalizes this vector."
              },
              "setLength": {
                "!type": "fn(l: number) -> +THREE.Vector4",
                "!doc": "Normalizes this vector and multiplies it by *l*."
              },
              "lerp": {
                "!type": "fn(v: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
                "!doc": "Linearly interpolate between this vector and *v* with *alpha* factor."
              },
              "lerpVectors": {
                "!type": "fn(v1: +THREE.Vector4, v2: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
                "!doc": "Sets this vector to be the vector linearly interpolated between *v1* and *v2* with *alpha* factor."
              },
              "clone": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "Clones this vector."
              },
              "clamp": {
                "!type": "fn(min: +THREE.Vector4, max: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "If this vector's x, y, z, or w value is greater than the max vector's x, y, z, or w value, it is replaced by the corresponding value.<br><br>\n\n\t\tIf this vector's x, y, z, or w value is less than the min vector's x, y, z, or w value, it is replace by the corresponding value."
              },
              "clampScalar": {
                "!type": "fn(min: number, max: number) -> +THREE.Vector4",
                "!doc": "If this vector's x, y, z or w values are greater than the max value, they are replaced by the max value. <br>\n\t\tIf this vector's x, y, z or w values are less than the min value, they are replace by the min value."
              },
              "floor": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "The components of the vector are rounded downwards (towards negative infinity) to an integer value."
              },
              "ceil": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "The components of the vector are rounded upwards (towards positive infinity) to an integer value."
              },
              "round": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "The components of the vector are rounded towards the nearest integer value."
              },
              "roundToZero": {
                "!type": "fn() -> +THREE.Vector4",
                "!doc": "The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value."
              },
              "applyMatrix4": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
                "!doc": "Transforms the vector by the matrix."
              },
              "min": {
                "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "If this vector's x, y, z, or w value is less than vector v's x, y, z, or w value, that value is replaced by the corresponding vector v value."
              },
              "max": {
                "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
                "!doc": "If this vector's x, y, z, or w value is greater than vector v's x, y, z, or w value, that value is replaced by the corresponding vector v value."
              },
              "addScalar": {
                "!type": "fn(s: number) -> +THREE.Vector4",
                "!doc": "Adds a scalar value to all of the vector's components."
              },
              "equals": {
                "!type": "fn(v: +THREE.Vector4) -> bool",
                "!doc": "Checks to see if this vector matches vector v."
              },
              "setAxisAngleFromRotationMatrix": {
                "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
                "!doc": "Sets this Vector4 to the computed <a href=\"http://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation\" target=\"_blank\">axis-angle representation</a> of the rotation defined by Matrix4 m. Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).<br><br>\n\n\t\tThe axis is stored in components (x, y, z) of the vector, and the rotation in radians is stored in component w"
              },
              "setAxisAngleFromQuaternion": {
                "!type": "fn(q: +THREE.Quaternion) -> +THREE.Vector4",
                "!doc": "Sets this Vector4 to the computed <a href=\"http://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation\" target=\"_blank\">axis-angle representation</a> of the rotation defined by Quaternion q.<br><br>\n\n\t\tThe axis is stored in components (x, y, z) of the vector, and the rotation in radians is stored in component w"
              },
              "getComponent": {
                "!type": "fn(index: number) -> number",
                "!doc": "Returns the value of the vector component x, y, or z by an index.<br><br>\n\n\t\tIndex 0: x<br>\n\t\tIndex 1: y<br>\n\t\tIndex 2: z<br>\n\t\tIndex 3: w<br>"
              },
              "setComponent": {
                "!type": "fn(index: number, value: number)",
                "!doc": "Sets the value of the vector component\tx, y, or z by an index.<br><br>\n\n\t\tIndex 0: x<br>\n\t\tIndex 1: y<br>\n\t\tIndex 2: z<br>\n\t\tIndex 3: w<br>"
              },
              "fromArray": {
                "!type": "fn(array: []) -> +THREE.Vector4",
                "!doc": "Sets the vector's components based on an array formatted like [x, y, z, w]"
              },
              "toArray": {
                "!type": "fn(array: []) -> []",
                "!doc": "Returns an array in the format [x, y, z, w]"
              },
              "lengthManhattan": {
                "!type": "fn() -> number",
                "!doc": "Computes Manhattan length of this vector.<br>\n\t\t[link:http://en.wikipedia.org/wiki/Taxicab_geometry]"
              },
              "setX": {
                "!type": "fn(x: number) -> +THREE.Vector4",
                "!doc": "Sets the x component of the vector."
              },
              "setY": {
                "!type": "fn(y: number) -> +THREE.Vector4",
                "!doc": "Sets the y component of the vector."
              },
              "setZ": {
                "!type": "fn(z: number) -> +THREE.Vector4",
                "!doc": "Sets the z component of the vector."
              },
              "setW": {
                "!type": "fn(w: number) -> +THREE.Vector4",
                "!doc": "Sets the w component of the vector."
              }
            },
            "!doc": "4D vector.",
            "!type": "fn(x: number, y: number, z: number, w: number)"
          },
          "Bone": {
            "!url": "http://threejs.org/docs/#Reference/objects/Bone",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "skinMatrix": {
                "!type": "+THREE.Matrix4",
                "!doc": "The matrix of the bone."
              },
              "skin": {
                "!type": "+THREE.SkinnedMesh",
                "!doc": "The skin that contains this bone."
              },
              "update": {
                "!type": "fn(parentSkinMatrix: +THREE.Matrix4, forceUpdate: boolean) -> todo",
                "!doc": "This updates the matrix of the bone and the matrices of its children."
              }
            },
            "!doc": "A bone which is part of a SkinnedMesh.",
            "!type": "fn(belongsToSkin: +THREE.SkinnedMesh)"
          },
          "LOD": {
            "!url": "http://threejs.org/docs/#Reference/objects/LOD",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "objects": {
                "!type": "array",
                "!doc": "todo"
              },
              "addLevel": {
                "!type": "fn(object: todo, distance: todo) -> todo",
                "!doc": "todo"
              },
              "getObjectForDistance": {
                "!type": "fn(distance: todo) -> todo",
                "!doc": "todo"
              },
              "update": {
                "!type": "fn(camera: todo) -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "todo",
            "!type": "fn()"
          },
          "Line": {
            "!url": "http://threejs.org/docs/#Reference/objects/Line",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "geometry": {
                "!type": "+THREE.Geometry",
                "!doc": "Vertices representing the line segment(s)."
              },
              "material": {
                "!type": "+THREE.Material",
                "!doc": "Material for the line."
              },
              "type": {
                "!type": "number",
                "!doc": "In OpenGL terms, LineStrip is the classic GL_LINE_STRIP and LinePieces is the equivalent to GL_LINES."
              },
              "raycast": {
                "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
                "!doc": "Get intersections between a casted ray and this Line. [page:Raycaster.intersectObject] will call this method."
              }
            },
            "!doc": "A line or a series of lines.",
            "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material, type: number)"
          },
          "Mesh": {
            "!url": "http://threejs.org/docs/#Reference/objects/Mesh",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "geometry": {
                "!type": "+THREE.Geometry",
                "!doc": "An instance of [page:Geometry], defining the object's structure."
              },
              "material": {
                "!type": "+THREE.Material",
                "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:MeshBasicMaterial] with wireframe mode enabled and randomised color."
              },
              "getMorphTargetIndexByName": {
                "!type": "fn(name: string) -> number",
                "!doc": "Returns the index of a morph target defined by name."
              },
              "updateMorphTargets": {
                "!type": "fn()",
                "!doc": "Updates the morphtargets to have no influence on the object."
              },
              "raycast": {
                "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
                "!doc": "Get intersections between a casted ray and this mesh. [page:Raycaster.intersectObject] will call this method."
              }
            },
            "!doc": "Base class for Mesh objects, such as [page:MorphAnimMesh] and [page:SkinnedMesh].",
            "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material)"
          },
          "MorphAnimMesh": {
            "!url": "http://threejs.org/docs/#Reference/objects/MorphAnimMesh",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "directionBackwards": {
                "!type": "boolean",
                "!doc": "todo"
              },
              "direction": {
                "!type": "number",
                "!doc": "todo"
              },
              "endKeyframe": {
                "!type": "number",
                "!doc": "todo"
              },
              "mirroredLoop": {
                "!type": "boolean",
                "!doc": "todo"
              },
              "startKeyframe": {
                "!type": "number",
                "!doc": "todo"
              },
              "lastKeyframe": {
                "!type": "number",
                "!doc": "todo"
              },
              "length": {
                "!type": "number",
                "!doc": "todo"
              },
              "time": {
                "!type": "number",
                "!doc": "todo"
              },
              "duration": {
                "!type": "number",
                "!doc": "todo"
              },
              "currentKeyframe": {
                "!type": "number",
                "!doc": "todo"
              },
              "setDirectionForward": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              },
              "playAnimation": {
                "!type": "fn(label: todo, fps: todo) -> todo",
                "!doc": "todo"
              },
              "setFrameRange": {
                "!type": "fn(start: todo, end: todo) -> todo",
                "!doc": "todo"
              },
              "setDirectionBackward": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              },
              "parseAnimations": {
                "!type": "fn() -> todo",
                "!doc": "todo"
              },
              "updateAnimation": {
                "!type": "fn(delta: todo) -> todo",
                "!doc": "todo"
              },
              "setAnimationLabel": {
                "!type": "fn(label: todo, start: todo, end: todo) -> todo",
                "!doc": "todo"
              }
            },
            "!doc": "todo",
            "!type": "fn(geometry: todo, material: todo)"
          },
          "PointCloud": {
            "!url": "http://threejs.org/docs/#Reference/objects/PointCloud",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "geometry": {
                "!type": "+THREE.Geometry",
                "!doc": "An instance of [page:Geometry], where each vertex designates the position of a particle in the system."
              },
              "material": {
                "!type": "+THREE.Material",
                "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:PointCloudMaterial] with randomised color."
              },
              "clone": {
                "!type": "fn() -> +THREE.PointCloud",
                "!doc": "This creates a clone of the particle system."
              },
              "raycast": {
                "!type": "fn(raycaster: +THREE.Raycaster, intersects: []) -> []",
                "!doc": "Get intersections between a casted ray and this PointCloud. [page:Raycaster.intersectObject] will call this method."
              }
            },
            "!doc": "A class for displaying particles in the form of variable size points. For example, if using the [page:WebGLRenderer], the particles are displayed using GL_POINTS.",
            "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material)"
          },
          "SkinnedMesh": {
            "!url": "http://threejs.org/docs/#Reference/objects/SkinnedMesh",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "bones": {
                "!type": "array",
                "!doc": "This contains the array of bones for this mesh. These should be set in the constructor."
              },
              "identityMatrix": {
                "!type": "+THREE.Matrix4",
                "!doc": "This is an identityMatrix to calculate the bones matrices from."
              },
              "useVertexTexture": {
                "!type": "boolean",
                "!doc": "The boolean defines whether a vertex texture is used to calculate the bones. This boolean shouldn't be changed after constructor."
              },
              "boneMatrices": {
                "!type": "array",
                "!doc": "This array of matrices contains the matrices of the bones. These get calculated in the constructor."
              },
              "pose": {
                "!type": "fn()",
                "!doc": "This method sets the skinnedmesh in the rest pose."
              },
              "addBone": {
                "!type": "fn(bone: +THREE.Bone) -> +THREE.Bone",
                "!doc": "This method adds the bone to the skinnedmesh when it is provided. It creates a new bone and adds that when no bone is given."
              }
            },
            "!doc": "An 3d object that has bones data. These Bones can then be used to animate the vertices of the object.",
            "!type": "fn(geometry: +THREE.Geometry, material: +THREE.Material, useVertexTexture: boolean)"
          },
          "Sprite": {
            "!url": "http://threejs.org/docs/#Reference/objects/Sprite",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "material": {
                "!type": "+THREE.SpriteMaterial",
                "!doc": "An instance of [page:Material], defining the object's appearance. Default is a [page:SpriteMaterial] which is a white plane."
              },
              "clone": {
                "!type": "fn() -> +THREE.Sprite",
                "!doc": "This creates a new clone of the sprite."
              }
            },
            "!doc": "A sprite is a plane in an 3d scene which faces always towards the camera.",
            "!type": "fn(material: +THREE.Material)"
          },
          "CanvasRenderer": {
            "!url": "http://threejs.org/docs/#Reference/renderers/CanvasRenderer",
            "prototype": {
              "info": {
                "!type": "object",
                "!doc": "An object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:"
              },
              "domElement": {
                "!type": "DOMElement",
                "!doc": "A [page:Canvas] where the renderer draws its output.<br>\n\t\t\tThis is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page."
              },
              "autoClear": {
                "!type": "bool",
                "!doc": "Defines whether the renderer should automatically clear its output before rendering."
              },
              "sortObjects": {
                "!type": "bool",
                "!doc": "Defines whether the renderer should sort objects. Default is true.<br>\n      Note: Sorting is used to attempt to properly render objects that have some degree of transparency.  By definition, sorting objects may not work in all cases.  Depending on the needs of application, it may be neccessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining the object rendering order."
              },
              "sortElements": {
                "!type": "boolean",
                "!doc": "Defines whether the renderer should sort the face of each object. Default is true."
              },
              "render": {
                "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
                "!doc": "Render a scene using a camera."
              },
              "clear": {
                "!type": "fn()",
                "!doc": "Tells the renderer to clear its color drawing buffer with the clearcolor."
              },
              "setClearColor": {
                "!type": "fn(color: +THREE.Color, alpha: number)",
                "!doc": "This set the clearColor and the clearAlpha."
              },
              "setSize": {
                "!type": "fn(width: number, height: number)",
                "!doc": "This set the size of the drawing canvas and if updateStyle is set, then the css of the canvas is updated too."
              },
              "setClearColorHex": {
                "!type": "fn(hex: number, alpha: number)",
                "!doc": "This set the clearColor and the clearAlpha."
              },
              "getClearColorHex": {
                "!type": "fn() -> number",
                "!doc": "Returns the [page:number hex] color."
              },
              "getClearAlpha": {
                "!type": "fn() -> number",
                "!doc": "Returns the alpha value."
              }
            },
            "!doc": "The Canvas renderer displays your beautifully crafted scenes <em>not</em> using WebGL, but draws it using the (slower) <a href=\"http://www.w3.org/html/wg/drafts/2dcontext/html5_canvas/\">Canvas 2D Context</a> API.<br><br>\n\t\t\tThis renderer can be a nice fallback from [page:WebGLRenderer] for simple scenes:\n\n\t\t\t<code>\n\t\t\tfunction webglAvailable() {\n\t\t\t\ttry {\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\n\t\t\t\t\treturn !!( window.WebGLRenderingContext &amp;&amp; (\n\t\t\t\t\t\tcanvas.getContext( 'webgl' ) ||\n\t\t\t\t\t\tcanvas.getContext( 'experimental-webgl' ) )\n\t\t\t\t\t);\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( webglAvailable() ) {\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t} else {\n\t\t\t\trenderer = new THREE.CanvasRenderer();\n\t\t\t}\n\t\t\t</code>\n\n\t\t\tNote: both WebGLRenderer and CanvasRenderer are embedded in the web page using an HTML5 &lt;canvas&gt; tag.\n\t\t\tThe \"Canvas\" in CanvasRenderer means it uses Canvas 2D instead of WebGL.<br><br>\n\n\t\t\tDon't confuse either CanvasRenderer with the SoftwareRenderer example, which simulates a screen buffer in a Javascript array.",
            "!type": "fn(parameters: object)"
          },
          "WebGLRenderTarget": {
            "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderTarget",
            "prototype": {
              "wrapS": {
                "!type": "number",
                "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
              },
              "wrapT": {
                "!type": "number",
                "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
              },
              "magFilter": {
                "!type": "number",
                "!doc": "How the texture is sampled when a texel covers more than one pixel. The default is THREE.LinearFilter, which takes the four closest texels and bilinearly interpolates among them. The other option is THREE.NearestFilter, which uses the value of the closest texel."
              },
              "minFilter": {
                "!type": "number",
                "!doc": "How the texture is sampled when a texel covers less than one pixel. The default is THREE.LinearMipMapLinearFilter, which uses mipmapping and a trilinear filter. Other choices are THREE.NearestFilter, THREE.NearestMipMapNearestFilter, THREE.NearestMipMapLinearFilter, THREE.LinearFilter, and THREE.LinearMipMapNearestFilter. These vary whether the nearest texel or nearest four texels are retrieved on the nearest mipmap or nearest two mipmaps. Interpolation occurs among the samples retrieved."
              },
              "anisotropy": {
                "!type": "number",
                "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used. Use renderer.getMaxAnisotropy() to find the maximum valid anisotropy value for the GPU; this value is usually a power of 2."
              },
              "repeat": {
                "!type": "+THREE.Vector2",
                "!doc": "How many times the texture is repeated across the surface, in each direction U and V."
              },
              "offset": {
                "!type": "+THREE.Vector2",
                "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
              },
              "format": {
                "!type": "number",
                "!doc": "The default is THREE.RGBAFormat for the texture. Other formats are: THREE.AlphaFormat, THREE.RGBFormat, THREE.LuminanceFormat, and THREE.LuminanceAlphaFormat. There are also compressed texture formats, if the S3TC extension is supported: THREE.RGB_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT3_Format, and THREE.RGBA_S3TC_DXT5_Format."
              },
              "type": {
                "!type": "number",
                "!doc": "The default is THREE.UnsignedByteType. Other valid types (as WebGL allows) are THREE.ByteType, THREE.ShortType, THREE.UnsignedShortType, THREE.IntType, THREE.UnsignedIntType, THREE.HalfFloatType, THREE.FloatType, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type, and THREE.UnsignedShort565Type."
              },
              "depthBuffer": {
                "!type": "boolean",
                "!doc": "Renders to the depth buffer. Default is true."
              },
              "stencilBuffer": {
                "!type": "boolean",
                "!doc": "Renders to the stencil buffer. Default is true."
              },
              "generateMipmaps": {
                "!type": "boolean",
                "!doc": "Whether to generate mipmaps (if possible) for a texture. True by default."
              },
              "setSize": {
                "!type": "fn(width: number, height: number)",
                "!doc": "Sets the size of the renderTarget."
              },
              "clone": {
                "!type": "fn() -> RenderTarget",
                "!doc": "Creates a copy of the render target."
              },
              "dispose": {
                "!type": "fn()",
                "!doc": "Dispatches a dispose event."
              }
            },
            "!doc": "A render target is a buffer where the video card draws pixels for a scene that is being rendered in the background. It is used in different effects.",
            "!type": "fn(width: number, height: number, options: object)"
          },
          "WebGLRenderTargetCube": {
            "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderTargetCube",
            "prototype": {
              "!proto": "THREE.WebGLRenderTarget.prototype"
            },
            "!doc": "[page:CubeCamera] uses this as its [page:WebGLRenderTarget]",
            "!type": "fn(width: number, height: number, options: object)"
          },
          "WebGLRenderer": {
            "!url": "http://threejs.org/docs/#Reference/renderers/WebGLRenderer",
            "prototype": {
              "domElement": {
                "!type": "DOMElement",
                "!doc": "A [page:Canvas] where the renderer draws its output.<br>\n\t\tThis is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page."
              },
              "context": {
                "!type": "WebGLRenderingContext",
                "!doc": "The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw."
              },
              "autoClear": {
                "!type": "bool",
                "!doc": "Defines whether the renderer should automatically clear its output before rendering."
              },
              "autoClearColor": {
                "!type": "bool",
                "!doc": "If autoClear is true, defines whether the renderer should clear the color buffer. Default is true."
              },
              "autoClearDepth": {
                "!type": "bool",
                "!doc": "If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true."
              },
              "autoClearStencil": {
                "!type": "bool",
                "!doc": "If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true."
              },
              "sortObjects": {
                "!type": "bool",
                "!doc": "Note: Sorting is used to attempt to properly render objects that have some degree of transparency.  By definition, sorting objects may not work in all cases.  Depending on the needs of application, it may be neccessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining the object rendering order."
              },
              "autoUpdateObjects": {
                "!type": "bool",
                "!doc": "Defines whether the renderer should auto update objects. Default is true."
              },
              "shadowMapEnabled": {
                "!type": "bool",
                "!doc": "Default is false. If set, use shadow maps in the scene."
              },
              "shadowMapType": {
                "!type": "number",
                "!doc": "Options are THREE.BasicShadowMap, THREE.PCFShadowMap, THREE.PCFSoftShadowMap. Default is THREE.PCFShadowMap."
              },
              "shadowMapCullFace": {
                "!type": "number",
                "!doc": "Default is THREE.CullFaceFront. The faces that needed to be culled. Possible values: THREE.CullFaceFront and THREE.CullFaceBack"
              },
              "shadowMapCascade": {
                "!type": "bool",
                "!doc": "Default is false. If Set, use cascaded shadowmaps. See [link:http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf cascaded shadowmaps] for more information."
              },
              "maxMorphTargets": {
                "!type": "number",
                "!doc": "Default is 8. The maximum number of MorphTargets allowed in a shader. Keep in mind that the standard materials only allow 8 MorphTargets."
              },
              "maxMorphNormals": {
                "!type": "number",
                "!doc": "Default is 4. The maximum number of MorphNormals allowed in a shader. Keep in mind that the standard materials only allow 4 MorphNormals."
              },
              "autoScaleCubemaps": {
                "!type": "bool",
                "!doc": "Default is true. If set, then Cubemaps are scaled, when they are bigger than the maximum size, to make sure that they aren't bigger than the maximum size."
              },
              "info": {
                "!type": "object",
                "!doc": "<ul>\n\t\t\t<li>memory:\n\t\t\t\t<ul>\n\t\t\t\t\t<li>programs</li>\n\t\t\t\t\t<li>geometries</li>\n\t\t\t\t\t<li>textures</li>\n\t\t\t\t</ul>\n\t\t\t</li>\n\t\t\t<li>render:\n\t\t\t\t<ul>\n\t\t\t\t\t<li>calls</li>\n\t\t\t\t\t<li>vertices</li>\n\t\t\t\t\t<li>faces</li>\n\t\t\t\t\t<li>points</li>\n\t\t\t\t</ul>\n\t\t\t</li>\n\t\t</ul>"
              },
              "shadowMapPlugin": {
                "!type": "+THREE.ShadowMapPlugin",
                "!doc": "This contains the reference to the shadowMapPlugin."
              },
              "getContext": {
                "!type": "fn() -> WebGLRenderingContext",
                "!doc": "Return the WebGL context."
              },
              "supportsVertexTextures": {
                "!type": "fn() -> bool",
                "!doc": "Return a [page:Boolean] true if the context supports vertex textures."
              },
              "setSize": {
                "!type": "fn(width: number, height: number)",
                "!doc": "Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0)."
              },
              "setViewport": {
                "!type": "fn(x: number, y: number, width: number, height: number)",
                "!doc": "Sets the viewport to render from (x, y) to (x + width, y + height)."
              },
              "setScissor": {
                "!type": "fn(x: number, y: number, width: number, height: number)",
                "!doc": "Sets the scissor area from (x, y) to (x + width, y + height)."
              },
              "enableScissorTest": {
                "!type": "fn(enable: bool)",
                "!doc": "Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions."
              },
              "setClearColor": {
                "!type": "fn(color: +THREE.Color, alpha: number)",
                "!doc": "Sets the clear color and opacity."
              },
              "getClearColor": {
                "!type": "fn() -> +THREE.Color",
                "!doc": "Returns a [page:Color THREE.Color] instance with the current clear color."
              },
              "getClearAlpha": {
                "!type": "fn() -> number",
                "!doc": "Returns a [page:Float float] with the current clear alpha. Ranges from 0 to 1."
              },
              "clear": {
                "!type": "fn(color: bool, depth: bool, stencil: bool)",
                "!doc": "Arguments default to true."
              },
              "renderBufferImmediate": {
                "!type": "fn(object: +THREE.Object3D, program: shaderprogram, shading: +THREE.Material)",
                "!doc": "Render an immediate buffer. Gets called by renderImmediateObject."
              },
              "renderBufferDirect": {
                "!type": "fn(camera: +THREE.Camera, lights: [], fog: +THREE.Fog, material: +THREE.Material, geometryGroup: object, object: +THREE.Object3D)",
                "!doc": "Render a buffer geometry group using the camera and with the correct material."
              },
              "renderBuffer": {
                "!type": "fn(camera: +THREE.Camera, lights: [], fog: +THREE.Fog, material: +THREE.Material, geometryGroup: object, object: +THREE.Object3D)",
                "!doc": "Render a geometry group using the camera and with the correct material."
              },
              "render": {
                "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera, renderTarget: +THREE.WebGLRenderTarget, forceClear: bool)",
                "!doc": "Even with forceClear set to true you can prevent certain buffers being cleared by setting either the .autoClearColor, .autoClearStencil or .autoClearDepth properties to false."
              },
              "renderImmediateObject": {
                "!type": "fn(camera, lights, fog, material, object)",
                "!doc": "Renders an immediate Object using a camera."
              },
              "setDepthTest": {
                "!type": "fn(depthTest: boolean)",
                "!doc": "This sets, based on depthTest, whether or not the depth data needs to be tested against the depth buffer."
              },
              "setDepthWrite": {
                "!type": "fn(depthWrite: boolean)",
                "!doc": "This sets, based on depthWrite, whether or not the depth data needs to be written in the depth buffer."
              },
              "setBlending": {
                "!type": "fn(blending: number, blendEquation: number, blendSrc: number, blendDst: number)",
                "!doc": "This method sets the correct blending."
              },
              "setTexture": {
                "!type": "fn(texture: +THREE.Texture, slot: number)",
                "!doc": "This method sets the correct texture to the correct slot for the wegl shader. The slot number can be found as a value of the uniform of the sampler."
              },
              "setRenderTarget": {
                "!type": "fn(renderTarget: +THREE.WebGLRenderTarget)",
                "!doc": "This method sets the active rendertarget."
              },
              "supportsCompressedTextureS3TC": {
                "!type": "fn() -> boolean",
                "!doc": "This method returns true if the webgl implementation supports compressed textures of the format S3TC."
              },
              "getMaxAnisotropy": {
                "!type": "fn() -> number",
                "!doc": "This returns the anisotropy level of the textures."
              },
              "getPrecision": {
                "!type": "fn() -> string",
                "!doc": "This gets the precision used by the shaders. It returns \"highp\",\"mediump\" or \"lowp\"."
              },
              "setMaterialFaces": {
                "!type": "fn(material: +THREE.Material)",
                "!doc": "This sets which side needs to be culled in the webgl renderer."
              },
              "supportsStandardDerivatives": {
                "!type": "fn() -> boolean",
                "!doc": "This method returns true if the webgl implementation supports standard derivatives."
              },
              "supportsFloatTextures": {
                "!type": "fn() -> boolean",
                "!doc": "This method returns true if the webgl implementation supports float textures."
              },
              "clearTarget": {
                "!type": "fn(renderTarget: +THREE.WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean)",
                "!doc": "This method clears a rendertarget. To do this, it activates the rendertarget."
              }
            },
            "!doc": "The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.",
            "!type": "fn(parameters: object)"
          },
          "ShaderChunk": {
            "!url": "http://threejs.org/docs/#Reference/renderers/shaders/ShaderChunk",
            "prototype": {},
            "!doc": "Shader chunks for WebLG Shader library"
          },
          "ShaderLib": {
            "!url": "http://threejs.org/docs/#Reference/renderers/shaders/ShaderLib",
            "prototype": {},
            "!doc": "Webgl Shader Library for three.js"
          },
          "UniformsLib": {
            "!url": "http://threejs.org/docs/#Reference/renderers/shaders/UniformsLib",
            "prototype": {},
            "!doc": "Uniforms library for shared webgl shaders"
          },
          "UniformsUtils": {
            "!url": "http://threejs.org/docs/#Reference/renderers/shaders/UniformsUtils",
            "prototype": {},
            "!doc": "Uniform Utilities. Support merging and cloning of uniform variables"
          },
          "WebGLProgram": {
            "!url": "http://threejs.org/docs/#Reference/renderers/webgl/WebGLProgram",
            "prototype": {
              "uniforms": "object",
              "attributes": "object",
              "id": "string",
              "code": "string",
              "usedTimes": "number",
              "program": "object",
              "vertexShader": "+THREE.WebGLShader",
              "fragmentShader": "+THREE.WebGLShader"
            },
            "!doc": "Constructor for the GLSL program sent to vertex and fragment shaders, including default uniforms and attributes.",
            "!type": "fn(renderer: +THREE.WebGLRenderer, code: object, material: +THREE.Material, parameters: object)"
          },
          "WebGLShader": {
            "!url": "http://threejs.org/docs/#Reference/renderers/webgl/WebGLShader",
            "prototype": {},
            "!doc": "todo"
          },
          "ShadowMapPlugin": {
            "!url": "http://threejs.org/docs/#Reference/renderers/webgl/plugins/ShadowMapPlugin",
            "prototype": {
              "render": {
                "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
                "!doc": "Prepares the shadowmaps to be rendered defined in the scene."
              }
            },
            "!doc": "The Webglrenderer plugin class that allows shadowmaps to be rendered in the WebglRenderer. This plugin is automatically loaded in the Webglrenderer.",
            "!type": "fn()"
          },
          "SpritePlugin": {
            "!url": "http://threejs.org/docs/#Reference/renderers/webgl/plugins/SpritePlugin",
            "prototype": {
              "render": {
                "!type": "fn(scene: +THREE.Scene, camera: +THREE.Camera)",
                "!doc": "Renders the sprites defined in the scene."
              }
            },
            "!doc": "The Webglrenderer plugin class that allows Sprites to be rendered in the WebglRenderer. This plugin is automatically loaded in the Webglrenderer.",
            "!type": "fn()"
          },
          "Fog": {
            "!url": "http://threejs.org/docs/#Reference/scenes/Fog",
            "prototype": {
              "name": {
                "!type": "string",
                "!doc": "Default is the empty string."
              },
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Fog color.  Example: If set to black, far away objects will be rendered black."
              },
              "near": {
                "!type": "number",
                "!doc": "Default is 1."
              },
              "far": {
                "!type": "number",
                "!doc": "Default is 1000."
              },
              "clone": {
                "!type": "fn() -> +THREE.Fog",
                "!doc": "Returns a copy of this."
              }
            },
            "!doc": "This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.",
            "!type": "fn(hex: number, near: number, far: number)"
          },
          "FogExp2": {
            "!url": "http://threejs.org/docs/#Reference/scenes/FogExp2",
            "prototype": {
              "name": {
                "!type": "string",
                "!doc": "Default is the empty string."
              },
              "color": {
                "!type": "+THREE.Color",
                "!doc": "Fog color. Example: If set to black, far away objects will be rendered black."
              },
              "density": {
                "!type": "number",
                "!doc": "Default is 0.00025."
              },
              "clone": {
                "!type": "fn() -> +THREE.FogExp2",
                "!doc": "Returns a copy of this."
              }
            },
            "!doc": "This class contains the parameters that define exponential fog, i.e., that grows exponentially denser with the distance.",
            "!type": "fn(hex: number, density: number)"
          },
          "Scene": {
            "!url": "http://threejs.org/docs/#Reference/scenes/Scene",
            "prototype": {
              "!proto": "THREE.Object3D.prototype",
              "fog": {
                "!type": "+THREE.Fog",
                "!doc": "A [page:Fog fog] instance defining the type of fog that affects everything rendered in the scene. Default is null."
              },
              "overrideMaterial": {
                "!type": "+THREE.Material",
                "!doc": "If not null, it will force everything in the scene to be rendered with that material. Default is null."
              },
              "autoUpdate": {
                "!type": "boolean",
                "!doc": "Default is true. If set, then the renderer checks every frame if the scene and its objects needs matrix updates. \n\t\tWhen it isn't, then you have to maintain all matrices in the scene yourself."
              }
            },
            "!doc": "Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.",
            "!type": "fn()"
          },
          "CompressedTexture": {
            "!url": "http://threejs.org/docs/#Reference/textures/CompressedTexture",
            "prototype": {
              "!proto": "THREE.Texture.prototype",
              "flipY": {
                "!type": "boolean",
                "!doc": "False by default. Flipping textures does not work for compressed textures."
              },
              "generateMipmaps": {
                "!type": "boolean",
                "!doc": "False by default. Mipmaps can't be generated for compressed textures"
              }
            },
            "!doc": "Creates a texture based on data in compressed form.",
            "!type": "fn(mipmaps: [], width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number)"
          },
          "DataTexture": {
            "!url": "http://threejs.org/docs/#Reference/textures/DataTexture",
            "prototype": {
              "!proto": "THREE.Texture.prototype"
            },
            "!doc": "Creates a texture directly from bitmapdata, width and height.",
            "!type": "fn(data: ArraybufferView, width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number)"
          },
          "Texture": {
            "!url": "http://threejs.org/docs/#Reference/textures/Texture",
            "prototype": {
              "id": {
                "!type": "number",
                "!doc": "Unique number for this texture instance."
              },
              "image": {
                "!type": "Image",
                "!doc": "An Image object, typically created using the [page:ImageLoader ImageLoader] class. The Image object can include an image (e.g., PNG, JPG, GIF, DDS), video (e.g., MP4, OGG/OGV), or set of six images for a cube map. To use video as a texture you need to have a playing HTML5 video element as a source for your texture image and continuously update this texture as long as video is playing."
              },
              "mapping": {
                "!type": "object",
                "!doc": "How the image is applied to the object. An object type of THREE.UVMapping is the default, where the U,V coordinates are used to apply the map, and a single texture is expected. The other types are THREE.CubeReflectionMapping, for cube maps used as a reflection map; THREE.CubeRefractionMapping, refraction mapping; and THREE.SphericalReflectionMapping, a spherical reflection map projection."
              },
              "wrapS": {
                "!type": "number",
                "!doc": "The default is THREE.ClampToEdgeWrapping, where the edge is clamped to the outer edge texels. The other two choices are THREE.RepeatWrapping and THREE.MirroredRepeatWrapping."
              },
              "wrapT": {
                "!type": "number",
                "!doc": "NOTE: tiling of images in textures only functions if image dimensions are powers of two (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels. Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL, not Three.js."
              },
              "magFilter": {
                "!type": "number",
                "!doc": "How the texture is sampled when a texel covers more than one pixel. The default is THREE.LinearFilter, which takes the four closest texels and bilinearly interpolates among them. The other option is THREE.NearestFilter, which uses the value of the closest texel."
              },
              "minFilter": {
                "!type": "number",
                "!doc": "How the texture is sampled when a texel covers less than one pixel. The default is THREE.LinearMipMapLinearFilter, which uses mipmapping and a trilinear filter. Other choices are THREE.NearestFilter, THREE.NearestMipMapNearestFilter, THREE.NearestMipMapLinearFilter, THREE.LinearFilter, and THREE.LinearMipMapNearestFilter. These vary whether the nearest texel or nearest four texels are retrieved on the nearest mipmap or nearest two mipmaps. Interpolation occurs among the samples retrieved."
              },
              "format": {
                "!type": "number",
                "!doc": "The default is THREE.RGBAFormat for the texture. Other formats are: THREE.AlphaFormat, THREE.RGBFormat, THREE.LuminanceFormat, and THREE.LuminanceAlphaFormat. There are also compressed texture formats, if the S3TC extension is supported: THREE.RGB_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT1_Format, THREE.RGBA_S3TC_DXT3_Format, and THREE.RGBA_S3TC_DXT5_Format."
              },
              "type": {
                "!type": "number",
                "!doc": "The default is THREE.UnsignedByteType. Other valid types (as WebGL allows) are THREE.ByteType, THREE.ShortType, THREE.UnsignedShortType, THREE.IntType, THREE.UnsignedIntType, THREE.FloatType, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type, and THREE.UnsignedShort565Type."
              },
              "anisotropy": {
                "!type": "number",
                "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used. Use renderer.getMaxAnisotropy() to find the maximum valid anisotropy value for the GPU; this value is usually a power of 2."
              },
              "needsUpdate": {
                "!type": "boolean",
                "!doc": "If a texture is changed after creation, set this flag to true so that the texture is properly set up. Particularly important for setting the wrap mode."
              },
              "repeat": {
                "!type": "+THREE.Vector2",
                "!doc": "How many times the texture is repeated across the surface, in each direction U and V."
              },
              "offset": {
                "!type": "+THREE.Vector2",
                "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
              },
              "name": {
                "!type": "string",
                "!doc": "Given name of the texture, empty string by default."
              },
              "generateMipmaps": {
                "!type": "boolean",
                "!doc": "Whether to generate mipmaps (if possible) for a texture. True by default."
              },
              "flipY": {
                "!type": "boolean",
                "!doc": "True by default. Flips the image's Y axis to match the WebGL texture coordinate space."
              },
              "mipmaps": {
                "!type": "array",
                "!doc": "Array of mipmaps generated."
              },
              "unpackAlignment": {
                "!type": "number",
                "!doc": "4 by default. Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries). See <a href=\"http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml\">glPixelStorei</a> for more information."
              },
              "premultiplyAlpha": {
                "!type": "boolean",
                "!doc": "False by default, which is the norm for PNG images. Set to true if the RGB values have been stored premultiplied by alpha."
              },
              "onUpdate": {
                "!type": "object",
                "!doc": "A callback function, called when the texture is updated (e.g., when needsUpdate has been set to true and then the texture is used)."
              }
            },
            "!doc": "Create a texture to apply to a surface or as a reflection or refraction map.",
            "!type": "fn(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)"
          }
        }
      }
    };
  });
});

/*

 JS Signals <http://millermedeiros.github.com/js-signals/>
 Released under the MIT license
 Author: Miller Medeiros
 Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
*/
(function (i) {
  function h(a, b, c, d, e) { this._listener = b; this._isOnce = c; this.context = d; this._signal = a; this._priority = e || 0 } function g(a, b) { if (typeof a !== "function") throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", b)); } function e() { this._bindings = []; this._prevParams = null; var a = this; this.dispatch = function () { e.prototype.dispatch.apply(a, arguments) } } h.prototype = {
    active: !0, params: null, execute: function (a) {
      var b; this.active && this._listener && (a = this.params ? this.params.concat(a) :
        a, b = this._listener.apply(this.context, a), this._isOnce && this.detach()); return b
    }, detach: function () { return this.isBound() ? this._signal.remove(this._listener, this.context) : null }, isBound: function () { return !!this._signal && !!this._listener }, isOnce: function () { return this._isOnce }, getListener: function () { return this._listener }, getSignal: function () { return this._signal }, _destroy: function () { delete this._signal; delete this._listener; delete this.context }, toString: function () {
      return "[SignalBinding isOnce:" + this._isOnce +
        ", isBound:" + this.isBound() + ", active:" + this.active + "]"
    }
  }; e.prototype = {
    VERSION: "1.0.0", memorize: !1, _shouldPropagate: !0, active: !0, _registerListener: function (a, b, c, d) { var e = this._indexOfListener(a, c); if (e !== -1) { if (a = this._bindings[e], a.isOnce() !== b) throw Error("You cannot add" + (b ? "" : "Once") + "() then add" + (!b ? "" : "Once") + "() the same listener without removing the relationship first."); } else a = new h(this, a, b, c, d), this._addBinding(a); this.memorize && this._prevParams && a.execute(this._prevParams); return a },
    _addBinding: function (a) { var b = this._bindings.length; do --b; while (this._bindings[b] && a._priority <= this._bindings[b]._priority); this._bindings.splice(b + 1, 0, a) }, _indexOfListener: function (a, b) { for (var c = this._bindings.length, d; c--;)if (d = this._bindings[c], d._listener === a && d.context === b) return c; return -1 }, has: function (a, b) { return this._indexOfListener(a, b) !== -1 }, add: function (a, b, c) { g(a, "add"); return this._registerListener(a, !1, b, c) }, addOnce: function (a, b, c) {
      g(a, "addOnce"); return this._registerListener(a,
        !0, b, c)
    }, remove: function (a, b) { g(a, "remove"); var c = this._indexOfListener(a, b); c !== -1 && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)); return a }, removeAll: function () { for (var a = this._bindings.length; a--;)this._bindings[a]._destroy(); this._bindings.length = 0 }, getNumListeners: function () { return this._bindings.length }, halt: function () { this._shouldPropagate = !1 }, dispatch: function (a) {
      if (this.active) {
        var b = Array.prototype.slice.call(arguments), c = this._bindings.length, d; if (this.memorize) this._prevParams =
          b; if (c) { d = this._bindings.slice(); this._shouldPropagate = !0; do c--; while (d[c] && this._shouldPropagate && d[c].execute(b) !== !1) }
      }
    }, forget: function () { this._prevParams = null }, dispose: function () { this.removeAll(); delete this._bindings; delete this._prevParams }, toString: function () { return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]" }
  }; var f = e; f.Signal = e; typeof define === "function" && define.amd ? define(function () { return f }) : typeof module !== "undefined" && module.exports ? module.exports = f : i.signals =
    f
})(this);
